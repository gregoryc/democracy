(function (global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof globalThis !== "undefined") {
    global_object = globalThis;
  } else if (typeof global !== "undefined") {
    global_object = global;
  } else if (typeof window !== "undefined") {
    global_object = window;
  }

  // Setup a dummy console object if missing
  if (typeof global_object.console === "object") {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!("log" in console)) {
    console.log = function () {};
  }
  if (!("warn" in console)) {
    console.warn = console.log;
  }

  if (typeof global_object.Opal !== "undefined") {
    console.warn(
      "Opal already loaded. Loading twice can cause troubles, please fix your setup."
    );
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = (global_object.Opal = {});

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: "error", // error, warning, ignore
    unsupported_features_severity: "warning", // error, warning, ignore
    experimental_features_severity: "warning", // warning, ignore
    enable_stack_trace: true, // true, false
  };

  // Minify common function calls
  var $has_own = Object.hasOwnProperty;
  var $bind = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice = Array.prototype.slice;
  var $splice = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function () {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function (obj) {
    if (obj.$$is_number) return obj * 2 + 1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $defineProperty(obj, "$$id", Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function (status) {
    if (Opal.gvars.DEBUG) console.log("Exited with status " + status);
  };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function () {
    var exception = Opal.exceptions.pop();
    if (exception) {
      Opal.gvars["!"] = exception;
      Opal.gvars["@"] = exception.$backtrace();
    } else {
      Opal.gvars["!"] = Opal.gvars["@"] = nil;
    }
  };

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function (obj) {
    if (obj === undefined) {
      return "undefined";
    } else if (obj === null) {
      return "null";
    } else if (!obj.$$class) {
      return obj.toString();
    } else {
      return obj.$inspect();
    }
  };

  function $defineProperty(object, name, initialValue) {
    if (typeof object === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true,
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;

  // Helpers
  // -----

  Opal.truthy = function (val) {
    return val !== nil && val != null && (!val.$$is_boolean || val == true);
  };

  Opal.falsy = function (val) {
    return val === nil || val == null || (val.$$is_boolean && val == false);
  };

  Opal.type_error = function (object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " +
          object +
          " into " +
          type +
          " (" +
          object +
          "#" +
          method +
          " gives " +
          coerced +
          ")"
      );
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      );
    }
  };

  Opal.coerce_to = function (object, type, method, args) {
    if (type["$==="](object)) return object;

    if (!object["$respond_to?"](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  };

  Opal.respond_to = function (obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj["$respond_to?"].$$pristine) {
      if (obj["$respond_to_missing?"].$$pristine) {
        return typeof body === "function" && !body.$$stub;
      } else {
        return Opal.send(obj, obj["$respond_to_missing?"], [
          jsid.substr(1),
          include_all,
        ]);
      }
    } else {
      return Opal.send(obj, obj["$respond_to?"], [jsid.substr(1), include_all]);
    }
  };

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for (i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  function handle_autoload(cref, name) {
    if (!cref.$$autoload[name].loaded) {
      cref.$$autoload[name].loaded = true;
      try {
        Opal.Kernel.$require(cref.$$autoload[name].path);
      } catch (e) {
        cref.$$autoload[name].exception = e;
        throw e;
      }
      cref.$$autoload[name].required = true;
      if (cref.$$const[name]) {
        cref.$$autoload[name].success = true;
        return cref.$$const[name];
      }
    } else if (
      cref.$$autoload[name].loaded &&
      !cref.$$autoload[name].required
    ) {
      if (cref.$$autoload[name].exception) {
        throw cref.$$autoload[name].exception;
      }
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on "Everything you ever wanted to know about constant lookup in Ruby" (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) {
      if (cref.$$const[name]) {
        return cref.$$const[name];
      }
      if (cref.$$autoload && cref.$$autoload[name]) {
        return handle_autoload(cref, name);
      }
    }
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) {
        return constant;
      } else if (nesting[i].$$autoload && nesting[i].$$autoload[name]) {
        return handle_autoload(nesting[i], name);
      }
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      } else if (ancestors[i].$$autoload && ancestors[i].$$autoload[name]) {
        return handle_autoload(ancestors[i], name);
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function (cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === "::") cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);
    if (result != null) return result;
    result = const_missing(cref, name, skip_missing);
    if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function (cref, name, skip_missing) {
    var result,
      cache,
      cached,
      current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === "::") cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, "$$const_cache", Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      (result = const_get_name(cref, name)) != null ||
        (result = const_lookup_ancestors(cref, name)) != null;
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function (nesting, name, skip_missing) {
    var cref = nesting[0],
      result,
      current_version = Opal.const_cache_version,
      cache,
      cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, "$$const_cache", Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      (result = const_get_name(cref, name)) != null ||
        (result = const_lookup_nesting(nesting, name)) != null ||
        (result = const_lookup_ancestors(cref, name)) != null ||
        (result = const_lookup_Object(cref, name)) != null;

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function (cref, name, value) {
    if (cref == null || cref === "::") cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = cref.$$const || Object.create(null);
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function (cref, inherit) {
    if (inherit == null) inherit = true;

    var module,
      modules = [cref],
      i,
      ii,
      constants = {},
      constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module)
      modules = modules
        .concat([Opal.Object])
        .concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
      if (module.$$autoload) {
        for (constant in module.$$autoload) {
          constants[constant] = true;
        }
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function (cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload && cref.$$autoload[name]) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new(
      "constant " + cref + "::" + cref.$name() + " not defined"
    );
  };

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;

  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function (name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function () {
        var args = $slice.call(arguments),
          self = new ($bind.apply(
            superclass.$$constructor,
            [null].concat(args)
          ))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      };
    } else {
      constructor = function () {};
    }

    if (name) {
      $defineProperty(constructor, "displayName", "::" + name);
    }

    klass = constructor;

    $defineProperty(klass, "$$name", name);
    $defineProperty(klass, "$$constructor", constructor);
    $defineProperty(klass, "$$prototype", constructor.prototype);
    $defineProperty(klass, "$$const", {});
    $defineProperty(klass, "$$is_class", true);
    $defineProperty(klass, "$$is_a_module", true);
    $defineProperty(klass, "$$super", superclass);
    $defineProperty(klass, "$$cvars", {});
    $defineProperty(klass, "$$own_included_modules", []);
    $defineProperty(klass, "$$own_prepended_modules", []);
    $defineProperty(klass, "$$ancestors", []);
    $defineProperty(klass, "$$ancestors_cache_version", null);

    $defineProperty(klass.$$prototype, "$$class", klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };

  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new(
        "superclass mismatch for class " + klass.$$name
      );
    }
  }

  Opal.klass = function (scope, superclass, name) {
    var bridged;

    if (scope == null || scope == "::") {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null &&
      (!superclass.hasOwnProperty ||
        (superclass.hasOwnProperty && !superclass.hasOwnProperty("$$is_class")))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new(
          "superclass must be a Class (" +
            ((superclass.constructor &&
              (superclass.constructor.name || superclass.constructor.$$name)) ||
              typeof superclass) +
            " given)"
        );
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }

      if (Opal.trace_class) {
        invoke_tracers_for_class(klass);
      }

      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    if (Opal.trace_class) {
      invoke_tracers_for_class(klass);
    }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function (name) {
    var constructor = function () {};
    if (name) {
      $defineProperty(constructor, "displayName", name + ".$$constructor");
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, "displayName", name + ".constructor");

    $defineProperty(module, "$$name", name);
    $defineProperty(module, "$$prototype", constructor.prototype);
    $defineProperty(module, "$$const", {});
    $defineProperty(module, "$$is_module", true);
    $defineProperty(module, "$$is_a_module", true);
    $defineProperty(module, "$$cvars", {});
    $defineProperty(module, "$$iclasses", []);
    $defineProperty(module, "$$own_included_modules", []);
    $defineProperty(module, "$$own_prepended_modules", []);
    $defineProperty(module, "$$ancestors", [module]);
    $defineProperty(module, "$$ancestors_cache_version", null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object)
      module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function (scope, name) {
    var module;

    if (scope == null || scope == "::") {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {
      if (Opal.trace_class) {
        invoke_tracers_for_class(module);
      }

      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    if (Opal.trace_class) {
      invoke_tracers_for_class(module);
    }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function (object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty("$$is_class")) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty("$$is_module")) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function (klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass =
      klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function () {});

    $defineProperty(meta, "$$is_singleton", true);
    $defineProperty(meta, "$$singleton_of", klass);
    $defineProperty(klass, "$$meta", meta);
    $set_proto(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, "$$class", Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function (mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function () {});

    $defineProperty(meta, "$$is_singleton", true);
    $defineProperty(meta, "$$singleton_of", mod);
    $defineProperty(mod, "$$meta", meta);
    $set_proto(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, "$$class", Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function (object) {
    var superclass = object.$$class,
      klass = Opal.allocate_class(nil, superclass, function () {});

    $defineProperty(klass, "$$is_singleton", true);
    $defineProperty(klass, "$$singleton_of", object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, "$$meta", klass);

    $set_proto(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function (prop) {
    return prop[0] === "$" && prop[1] !== "$";
  };

  Opal.instance_methods = function (mod) {
    var exclude = [],
      results = [],
      ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
        proto = ancestor.$$prototype;

      if (proto.hasOwnProperty("$$dummy")) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
            method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (
            !method.$$stub &&
            results.indexOf(method_name) === -1 &&
            exclude.indexOf(method_name) === -1
          ) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function (mod) {
    var results = [],
      proto = mod.$$prototype;

    if (proto.hasOwnProperty("$$dummy")) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function (obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.own_methods = function (obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.receiver_methods = function (obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function (module) {
    var ancestors = Opal.ancestors(module),
      i,
      length = ancestors.length,
      result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function (module, name, value) {
    var ancestors = Opal.ancestors(module),
      i,
      length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function (module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name)) return module.$$cvars[name];

    var ancestors = Opal.ancestors(module),
      i,
      length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new(
        "uninitialized class variable " + name + " in " + module.$name()
      );

    return nil;
  };

  function isRoot(proto) {
    return proto.hasOwnProperty("$$iclass") && proto.hasOwnProperty("$$root");
  }

  function own_included_modules(module) {
    var result = [],
      mod,
      proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty("$$class")) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [],
      mod,
      proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty("$$dummy")) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }

  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function (module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new("cyclic include detected");
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i],
        iclass = create_iclass(ancestor);
      $defineProperty(iclass, "$$included", true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
      chain = chain_iclasses(iclasses),
      start_chain_after,
      end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype,
        module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (
          next_ancestor.hasOwnProperty("$$iclass") &&
          !isRoot(next_ancestor)
        ) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function (module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new("cyclic prepend detected");
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i],
        iclass = create_iclass(ancestor);
      $defineProperty(iclass, "$$prepended", true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
      dummy_prepender = prepender.$$prototype,
      previous_parent = Object.getPrototypeOf(dummy_prepender),
      prepender_iclass,
      start_chain_after,
      end_chain_on;

    if (dummy_prepender.hasOwnProperty("$$dummy")) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, "$$dummy", true);
      $defineProperty(dummy_prepender, "$$define_methods_on", prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty("$$root") ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty("$$iclass")
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new(
        "Prepending a module multiple times is not supported"
      );
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
      props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
      proto = module.$$prototype;

    if (proto.hasOwnProperty("$$dummy")) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
      length = props.length,
      i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, "$$iclass", true);
    $defineProperty(iclass, "$$module", module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length,
      first = iclasses[0];

    $defineProperty(first, "$$root", true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }

    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function (native_klass, klass) {
    if (native_klass.hasOwnProperty("$$bridge")) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, "$$bridge", klass);
    $set_proto(
      native_klass.prototype,
      (klass.$$super || Opal.Object).$$prototype
    );
    $defineProperty(klass, "$$prototype", native_klass.prototype);

    $defineProperty(klass.$$prototype, "$$class", klass);
    $defineProperty(klass, "$$constructor", native_klass);
    $defineProperty(klass, "$$bridge", true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty("$$dummy")) {
      return;
    } else if (proto.hasOwnProperty("$$iclass")) {
      return proto.$$module;
    } else if (proto.hasOwnProperty("$$class")) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules
      .concat([module])
      .concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function (module) {
    if (!module) {
      return [];
    }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [],
      i,
      mods,
      length;

    for (
      i = 0, mods = own_ancestors(module), length = mods.length;
      i < length;
      i++
    ) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (
        i = 0, mods = Opal.ancestors(module.$$super), length = mods.length;
        i < length;
        i++
      ) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function (module) {
    var result = [],
      mod = null,
      proto = Object.getPrototypeOf(module.$$prototype);

    for (
      ;
      proto && Object.getPrototypeOf(proto);
      proto = Object.getPrototypeOf(proto)
    ) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };

  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function (stubs) {
    var proto = Opal.BasicObject.$$prototype;
    var stub, existing_method;

    for (var i = 0, length = stubs.length; i < length; i++) {
      (stub = stubs[i]), (existing_method = proto[stub]);

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function (prototype, stub) {
    // Opal.stub_for(stub) is the method_missing_stub
    $defineProperty(prototype, stub, Opal.stub_for(stub));
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function (method_name) {
    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for (var i = 0, l = args_ary.length; i < l; i++) {
        args_ary[i] = arguments[i];
      }

      return this.$method_missing.apply(
        this,
        [method_name.slice(1)].concat(args_ary)
      );
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };

  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function (actual, expected, object, meth) {
    var inspect = "";
    if (object.$$is_a_module) {
      inspect += object.$$name + ".";
    } else {
      inspect += object.$$class.$$name + "#";
    }
    inspect += meth;

    throw Opal.ArgumentError.$new(
      "[" +
        inspect +
        "] wrong number of arguments(" +
        actual +
        " for " +
        expected +
        ")"
    );
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function (actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(
      inspect +
        ": wrong number of arguments (" +
        actual +
        " for " +
        expected +
        ")"
    );
  };

  // Super dispatcher
  Opal.find_super = function (obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = "$" + mid,
      ancestors,
      super_method;

    if (obj.hasOwnProperty("$$meta")) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
        proto = ancestor.$$prototype;

      if (proto.hasOwnProperty("$$dummy")) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (
      !defcheck &&
      super_method &&
      super_method.$$stub &&
      obj.$method_missing.$$pristine
    ) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new(
        "super: no superclass method `" + mid + "' for " + obj,
        mid
      );
    }

    return super_method.$$stub && !allow_stubs ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_block_super = function (
    obj,
    jsid,
    current_func,
    defcheck,
    implicit
  ) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new(
        "implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly"
      );
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // @deprecated
  Opal.find_super_dispatcher = Opal.find_super;

  // @deprecated
  Opal.find_iter_super_dispatcher = Opal.find_block_super;

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function (val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function (val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function () {
    return new Error("unexpected break");
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function (block, arg) {
    if (typeof block !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
      has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (
      block.length > 1 ||
      ((has_mlhs || has_trailing_comma) && block.length === 1)
    ) {
      arg = Opal.to_ary(arg);
    }

    if (
      (block.length > 1 || (has_trailing_comma && block.length === 1)) &&
      arg.$$is_array
    ) {
      return block.apply(null, arg);
    } else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function (block, args) {
    if (typeof block !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for (var i = 0, l = args_ary.length; i < l; i++) {
        args_ary[i] = args[i];
      }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function (exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      } else if (candidate === Opal.JS.Error) {
        return candidate;
      } else if (candidate["$==="](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function (object, klass) {
    if (
      (klass != null && object.$$meta === klass) ||
      object.$$class === klass
    ) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return klass.$$is_integer_class ? object % 1 === 0 : true;
    }

    var i,
      length,
      ancestors = Opal.ancestors(
        object.$$is_class
          ? Opal.get_singleton_class(object)
          : object.$$meta || object.$$class
      );

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function (value) {
    if (value.$$is_hash) {
      return value;
    } else if (value["$respond_to?"]("to_hash", true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      } else {
        throw Opal.TypeError.$new(
          "Can't convert " +
            value.$$class +
            " to Hash (" +
            value.$$class +
            "#to_hash gives " +
            hash.$$class +
            ")"
        );
      }
    } else {
      throw Opal.TypeError.$new(
        "no implicit conversion of " + value.$$class + " into Hash"
      );
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function (value) {
    if (value.$$is_array) {
      return value;
    } else if (value["$respond_to?"]("to_ary", true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      } else if (ary.$$is_array) {
        return ary;
      } else {
        throw Opal.TypeError.$new(
          "Can't convert " +
            value.$$class +
            " to Array (" +
            value.$$class +
            "#to_ary gives " +
            ary.$$class +
            ")"
        );
      }
    } else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function (value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    } else if (value["$respond_to?"]("to_a", true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      } else if (ary.$$is_array) {
        return ary;
      } else {
        throw Opal.TypeError.$new(
          "Can't convert " +
            value.$$class +
            " to Array (" +
            value.$$class +
            "#to_a gives " +
            ary.$$class +
            ")"
        );
      }
    } else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function (parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, "$to_hash", true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    } else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function (given_args, used_args) {
    var keys = [],
      map = {},
      key,
      given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function (recv, method, args, block) {
    var body;

    if (typeof method === "function") {
      body = method;
      method = null;
    } else if (typeof method === "string") {
      body = recv["$" + method];
    } else {
      throw Opal.NameError.$new(
        "Passed method should be a string or a function"
      );
    }

    return Opal.send2(recv, body, method, args, block);
  };

  Opal.send2 = function (recv, body, method, args, block) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    if (typeof block === "function") body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function (refinement_groups, recv, method, args, block) {
    var i,
      j,
      k,
      ancestors,
      ancestor,
      refinements,
      refinement,
      refine_modules,
      refine_module,
      body;

    if (recv.hasOwnProperty("$$meta")) {
      ancestors = Opal.ancestors(recv.$$meta);
    } else {
      ancestors = Opal.ancestors(recv.$$class);
    }

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);
      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];
        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === "undefined") continue;
          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;
          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] !== "undefined") {
            refine_module = refine_modules[ancestor];
            // Does this module define a method we want to call?
            if (
              typeof refine_module.$$prototype["$" + method] !== "undefined"
            ) {
              body = refine_module.$$prototype["$" + method];
              return Opal.send2(recv, body, method, args, block);
            }
          }
        }
      }
    }

    return Opal.send(recv, method, args, block);
  };

  Opal.lambda = function (block) {
    block.$$is_lambda = true;
    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function (obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body);
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    } else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function (module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty("$$dummy")) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body);
      }

      for (
        var i = 0, iclasses = module.$$iclasses, length = iclasses.length;
        i < length;
        i++
      ) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    } else if (
      singleton_of &&
      singleton_of.$singleton_method_added &&
      !singleton_of.$singleton_method_added.$$stub
    ) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function (obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body);
  };

  // Called from #remove_method.
  Opal.rdef = function (obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new(
        "method '" + jsid.substr(1) + "' not defined in " + obj.$name()
      );
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (
        obj.$$prototype.$singleton_method_removed &&
        !obj.$$prototype.$singleton_method_removed.$$stub
      ) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    } else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function (obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new(
        "method '" + jsid.substr(1) + "' not defined in " + obj.$name()
      );
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (
        obj.$$prototype.$singleton_method_undefined &&
        !obj.$$prototype.$singleton_method_undefined.$$stub
      ) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    } else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return typeof body === "function" && !body.$$stub;
  }

  Opal.alias = function (obj, name, old) {
    var id = "$" + name,
      old_id = "$" + old,
      body,
      alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === "undefined") {
      obj = Opal.Object;
    }

    body = obj.$$prototype["$" + old];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof body !== "function" && ancestor) {
        body = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id];
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new(
          "undefined method `" + old + "' for class `" + obj.$name() + "'"
        );
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function () {
      var block = alias.$$p,
        args,
        i,
        ii;

      args = new Array(arguments.length);
      for (i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) {
        alias.$$p = null;
      }

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, "length", { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName = name;

    alias.$$arity = body.$$arity;
    alias.$$parameters = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of = body;
    alias.$$alias_name = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_gvar = function (new_name, old_name) {
    Object.defineProperty(Opal.gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function () {
        return Opal.gvars[old_name];
      },
      set: function (new_value) {
        Opal.gvars[old_name] = new_value;
      },
    });
    return nil;
  };

  Opal.alias_native = function (obj, name, native_name) {
    var id = "$" + name,
      body = obj.$$prototype[native_name];

    if (typeof body !== "function" || body.$$stub) {
      throw Opal.NameError.$new(
        "undefined native method `" +
          native_name +
          "' for class `" +
          obj.$name() +
          "'"
      );
    }

    Opal.defn(obj, id, body);

    return obj;
  };

  // Hashes
  // ------

  Opal.hash_init = function (hash) {
    hash.$$smap = Object.create(null);
    hash.$$map = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function (from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (
      var i = 0,
        keys = from_hash.$$keys,
        smap = from_hash.$$smap,
        len = keys.length,
        key,
        value;
      i < len;
      i++
    ) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function (hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = { key: key, key_hash: key_hash, value: value };
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key["$eql?"](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = { key: key, key_hash: key_hash, value: value };
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function (hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key["$eql?"](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function (hash, key) {
    var i,
      keys = hash.$$keys,
      length = keys.length,
      value,
      key_tmp;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        key_tmp = keys[i];

        if (key_tmp.$$is_string && typeof key_tmp !== "string") {
          key_tmp = key_tmp.valueOf();
        }

        if (key_tmp === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash],
      last_bucket;

    while (bucket) {
      if (key === bucket.key || key["$eql?"](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        } else if (last_bucket) {
          delete last_bucket.next;
        } else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        } else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function (hash) {
    for (
      var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket;
      i < length;
      i++
    ) {
      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          } else if (last_bucket) {
            delete last_bucket.next;
          } else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          } else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function () {
    var arguments_length = arguments.length,
      args,
      hash,
      i,
      length,
      key,
      value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new(
            "value not of length 2: " + args[i].$inspect()
          );
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($has_own.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function (keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function (first, last, exc) {
    var range = new Opal.Range();
    range.begin = first;
    range.end = last;
    range.excl = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function (name) {
    if (
      // properties
      name === "constructor" ||
      name === "displayName" ||
      name === "__count__" ||
      name === "__noSuchMethod__" ||
      name === "__parent__" ||
      name === "__proto__" ||
      // methods
      name === "hasOwnProperty" ||
      name === "valueOf"
    ) {
      return name + "$";
    }

    return name;
  };

  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function (str) {
    return str
      .replace(/([-[\]\/{}()*+?.^$\\| ])/g, "\\$1")
      .replace(/[\n]/g, "\\n")
      .replace(/[\r]/g, "\\r")
      .replace(/[\f]/g, "\\f")
      .replace(/[\t]/g, "\\t");
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function (pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(
        pattern.source,
        (pattern.multiline ? "gm" : "g") + (pattern.ignoreCase ? "i" : "")
      );
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function (pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(
          pattern.source,
          "gm" + (pattern.ignoreCase ? "i" : "")
        );
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(
        pattern.source,
        "gm" + (pattern.ignoreCase ? "i" : "")
      );
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function (parts, flags) {
    var part;
    var ignoreCase =
      typeof flags !== "undefined" && flags && flags.indexOf("i") >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({ uplevel: 1 })
          );

        part = part.source;
      }
      if (part === "") part = "(?:" + part + ")";
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(""), flags);
    } else {
      return new RegExp(parts.join(""));
    }
  };

  // Require system
  // --------------

  Opal.modules = {};
  Opal.loaded_features = ["corelib/runtime"];
  Opal.current_dir = ".";
  Opal.require_table = { "corelib/runtime": true };

  Opal.normalize = function (path) {
    var parts,
      part,
      new_parts = [],
      SEPARATOR = "/";

    if (Opal.current_dir !== ".") {
      path = Opal.current_dir.replace(/\/*$/, "/") + path;
    }

    path = path.replace(/^\.\//, "");
    path = path.replace(/\.(rb|opal|js)$/, "");
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === "") continue;
      part === ".." ? new_parts.pop() : new_parts.push(part);
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function (paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function (path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      var retval = module(Opal);
      if (typeof Promise !== "undefined" && retval instanceof Promise) {
        // A special case of require having an async top:
        // We will need to await it.
        return retval.then(function () {
          return true;
        });
      }
    } else {
      var severity = Opal.config.missing_require_severity;
      var message = "cannot load such file -- " + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message);
        } else {
          throw message;
        }
      } else if (severity === "warning") {
        console.warn("WARNING: LoadError: " + message);
      }
    }

    return true;
  };

  Opal.require = function (path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };

  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function (str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === "string" || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) {
      return str;
    }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function (name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding)
      throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  };

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function (str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup;
  };

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function (str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  };

  Opal.last_promise = null;
  Opal.promise_unhandled_exception = false;

  // Run a block of code, but if it returns a Promise, don't run the next
  // one, but queue it.
  Opal.queue = function (proc) {
    if (Opal.last_promise) {
      // The async path is taken only if anything before returned a
      // Promise(V2).
      Opal.last_promise = Opal.last_promise
        .then(function () {
          if (!Opal.promise_unhandled_exception) return proc(Opal);
        })
        ["catch"](function (error) {
          if (Opal.respond_to(error, "$full_message")) {
            error = error.$full_message();
          }
          console.error(error);
          // Abort further execution
          Opal.promise_unhandled_exception = true;
          Opal.exit(1);
        });
      return Opal.last_promise;
    } else {
      var ret = proc(Opal);
      if (
        typeof Promise === "function" &&
        typeof ret === "object" &&
        ret instanceof Promise
      ) {
        Opal.last_promise = ret;
      }
      return ret;
    }
  };

  // Initialization
  // --------------
  function $BasicObject() {}
  function $Object() {}
  function $Module() {}
  function $Class() {}

  Opal.BasicObject = BasicObject = Opal.allocate_class(
    "BasicObject",
    null,
    $BasicObject
  );
  Opal.Object = _Object = Opal.allocate_class(
    "Object",
    Opal.BasicObject,
    $Object
  );
  Opal.Module = Module = Opal.allocate_class("Module", Opal.Object, $Module);
  Opal.Class = Class = Opal.allocate_class("Class", Opal.Module, $Class);

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject", BasicObject);
  Opal.const_set(_Object, "Object", _Object);
  Opal.const_set(_Object, "Module", Module);
  Opal.const_set(_Object, "Class", Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class = Class;
  Module.$$class = Class;
  Class.$$class = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, "toString", function () {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof to_s === "object") {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, "$require", Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function () {
    return "main";
  };
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments, 0, arguments.length);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, "define_method", args, block);
  }

  // Nil
  function $NilClass() {}
  Opal.NilClass = Opal.allocate_class("NilClass", Opal.Object, $NilClass);
  Opal.const_set(_Object, "NilClass", Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function () {
    throw Opal.LocalJumpError.$new("no block given");
  };

  // Errors
  Opal.breaker = new Error("unexpected break (old)");
  Opal.returner = new Error("unexpected return");
  TypeError.$$super = Error;
}.call(this));
Opal.loaded(["corelib/runtime.js"]);
Opal.modules["corelib/helpers"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $type_error = Opal.type_error,
    $coerce_to = Opal.coerce_to,
    $module = Opal.module,
    $truthy = Opal.truthy;

  Opal.add_stubs([
    "$===",
    "$raise",
    "$respond_to?",
    "$nil?",
    "$__send__",
    "$<=>",
    "$class",
    "$coerce_to!",
    "$new",
    "$!=",
    "$[]",
    "$upcase",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Opal");

    var $nesting = [self].concat($parent_nesting),
      $Opal_bridge$1,
      $Opal_coerce_to$excl$2,
      $Opal_coerce_to$ques$3,
      $Opal_try_convert$4,
      $Opal_compare$5,
      $Opal_destructure$6,
      $Opal_respond_to$ques$7,
      $Opal_instance_variable_name$excl$8,
      $Opal_class_variable_name$excl$9,
      $Opal_const_name$ques$10,
      $Opal_const_name$excl$11,
      $Opal_pristine$12;

    Opal.defs(
      self,
      "$bridge",
      ($Opal_bridge$1 = function $$bridge(constructor, klass) {
        var self = this;

        return Opal.bridge(constructor, klass);
      }),
      ($Opal_bridge$1.$$arity = 2)
    );
    Opal.defs(
      self,
      "$coerce_to!",
      ($Opal_coerce_to$excl$2 = function (object, type, method, $a) {
        var $post_args,
          args,
          self = this,
          coerced = nil;

        $post_args = Opal.slice.call(arguments, 3, arguments.length);

        args = $post_args;
        coerced = $coerce_to(object, type, method, args);
        if ($truthy(type["$==="](coerced))) {
        } else {
          self.$raise($type_error(object, type, method, coerced));
        }
        return coerced;
      }),
      ($Opal_coerce_to$excl$2.$$arity = -4)
    );
    Opal.defs(
      self,
      "$coerce_to?",
      ($Opal_coerce_to$ques$3 = function (object, type, method, $a) {
        var $post_args,
          args,
          self = this,
          coerced = nil;

        $post_args = Opal.slice.call(arguments, 3, arguments.length);

        args = $post_args;
        if ($truthy(object["$respond_to?"](method))) {
        } else {
          return nil;
        }
        coerced = $coerce_to(object, type, method, args);
        if ($truthy(coerced["$nil?"]())) {
          return nil;
        }
        if ($truthy(type["$==="](coerced))) {
        } else {
          self.$raise($type_error(object, type, method, coerced));
        }
        return coerced;
      }),
      ($Opal_coerce_to$ques$3.$$arity = -4)
    );
    Opal.defs(
      self,
      "$try_convert",
      ($Opal_try_convert$4 = function $$try_convert(object, type, method) {
        var self = this;

        if ($truthy(type["$==="](object))) {
          return object;
        }
        if ($truthy(object["$respond_to?"](method))) {
          return object.$__send__(method);
        } else {
          return nil;
        }
      }),
      ($Opal_try_convert$4.$$arity = 3)
    );
    Opal.defs(
      self,
      "$compare",
      ($Opal_compare$5 = function $$compare(a, b) {
        var self = this,
          compare = nil;

        compare = a["$<=>"](b);
        if ($truthy(compare === nil)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" +
              "comparison of " +
              a.$class() +
              " with " +
              b.$class() +
              " failed"
          );
        }
        return compare;
      }),
      ($Opal_compare$5.$$arity = 2)
    );
    Opal.defs(
      self,
      "$destructure",
      ($Opal_destructure$6 = function $$destructure(args) {
        var self = this;

        if (args.length == 1) {
          return args[0];
        } else if (args.$$is_array) {
          return args;
        } else {
          var args_ary = new Array(args.length);
          for (var i = 0, l = args_ary.length; i < l; i++) {
            args_ary[i] = args[i];
          }

          return args_ary;
        }
      }),
      ($Opal_destructure$6.$$arity = 1)
    );
    Opal.defs(
      self,
      "$respond_to?",
      ($Opal_respond_to$ques$7 = function (obj, method, include_all) {
        var self = this;

        if (include_all == null) {
          include_all = false;
        }

        if (obj == null || !obj.$$class) {
          return false;
        }
        return obj["$respond_to?"](method, include_all);
      }),
      ($Opal_respond_to$ques$7.$$arity = -3)
    );
    Opal.defs(
      self,
      "$instance_variable_name!",
      ($Opal_instance_variable_name$excl$8 = function (name) {
        var self = this;

        name = $$($nesting, "Opal")["$coerce_to!"](
          name,
          $$($nesting, "String"),
          "to_str"
        );
        if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
        } else {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" + "'" + name + "' is not allowed as an instance variable name",
              name
            )
          );
        }
        return name;
      }),
      ($Opal_instance_variable_name$excl$8.$$arity = 1)
    );
    Opal.defs(
      self,
      "$class_variable_name!",
      ($Opal_class_variable_name$excl$9 = function (name) {
        var self = this;

        name = $$($nesting, "Opal")["$coerce_to!"](
          name,
          $$($nesting, "String"),
          "to_str"
        );
        if ($truthy(name.length < 3 || name.slice(0, 2) !== "@@")) {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" + "`" + name + "' is not allowed as a class variable name",
              name
            )
          );
        }
        return name;
      }),
      ($Opal_class_variable_name$excl$9.$$arity = 1)
    );
    Opal.defs(
      self,
      "$const_name?",
      ($Opal_const_name$ques$10 = function (const_name) {
        var self = this;

        if (typeof const_name !== "string") {
          const_name = $$($nesting, "Opal")["$coerce_to!"](
            const_name,
            $$($nesting, "String"),
            "to_str"
          );
        }

        return const_name[0] === const_name[0].toUpperCase();
      }),
      ($Opal_const_name$ques$10.$$arity = 1)
    );
    Opal.defs(
      self,
      "$const_name!",
      ($Opal_const_name$excl$11 = function (const_name) {
        var self = this;

        const_name = $$($nesting, "Opal")["$coerce_to!"](
          const_name,
          $$($nesting, "String"),
          "to_str"
        );
        if (
          $truthy(const_name["$[]"](0)["$!="](const_name["$[]"](0).$upcase()))
        ) {
          self.$raise(
            $$($nesting, "NameError"),
            "" + "wrong constant name " + const_name
          );
        }
        return const_name;
      }),
      ($Opal_const_name$excl$11.$$arity = 1)
    );
    return (
      (Opal.defs(
        self,
        "$pristine",
        ($Opal_pristine$12 = function $$pristine(owner_class, $a) {
          var $post_args,
            method_names,
            self = this;

          $post_args = Opal.slice.call(arguments, 1, arguments.length);

          method_names = $post_args;

          var method_name, method;
          for (var i = method_names.length - 1; i >= 0; i--) {
            method_name = method_names[i];
            method = owner_class.$$prototype["$" + method_name];

            if (method && !method.$$stub) {
              method.$$pristine = true;
            }
          }
          return nil;
        }),
        ($Opal_pristine$12.$$arity = -2)
      ),
      nil) && "pristine"
    );
  })($nesting[0], $nesting);
};

Opal.modules["corelib/module"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $truthy = Opal.truthy,
    $coerce_to = Opal.coerce_to,
    $klass = Opal.klass,
    $send = Opal.send,
    $hash2 = Opal.hash2,
    $lambda = Opal.lambda,
    $range = Opal.range,
    $alias = Opal.alias,
    $send2 = Opal.send2,
    $find_super = Opal.find_super;

  Opal.add_stubs([
    "$module_eval",
    "$to_proc",
    "$===",
    "$raise",
    "$equal?",
    "$<",
    "$>",
    "$nil?",
    "$attr_reader",
    "$attr_writer",
    "$warn",
    "$attr_accessor",
    "$const_name?",
    "$class_variable_name!",
    "$const_name!",
    "$=~",
    "$new",
    "$inject",
    "$split",
    "$const_get",
    "$==",
    "$!~",
    "$start_with?",
    "$bind",
    "$call",
    "$class",
    "$append_features",
    "$included",
    "$name",
    "$cover?",
    "$size",
    "$merge",
    "$compile",
    "$proc",
    "$any?",
    "$prepend_features",
    "$prepended",
    "$to_s",
    "$__id__",
    "$constants",
    "$include?",
    "$copy_class_variables",
    "$copy_constants",
    "$define_singleton_method",
    "$inspect",
    "$class_exec",
  ]);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Module");

    var $nesting = [self].concat($parent_nesting),
      $Module_allocate$1,
      $Module_initialize$2,
      $Module_$eq_eq_eq$3,
      $Module_$lt$4,
      $Module_$lt_eq$5,
      $Module_$gt$6,
      $Module_$gt_eq$7,
      $Module_$lt_eq_gt$8,
      $Module_alias_method$9,
      $Module_alias_native$10,
      $Module_ancestors$11,
      $Module_append_features$12,
      $Module_attr_accessor$13,
      $Module_attr$14,
      $Module_attr_reader$15,
      $Module_attr_writer$16,
      $Module_autoload$17,
      $Module_autoload$ques$18,
      $Module_class_variables$19,
      $Module_class_variable_get$20,
      $Module_class_variable_set$21,
      $Module_class_variable_defined$ques$22,
      $Module_remove_class_variable$23,
      $Module_constants$24,
      $Module_constants$25,
      $Module_nesting$26,
      $Module_const_defined$ques$27,
      $Module_const_get$28,
      $Module_const_missing$30,
      $Module_const_set$31,
      $Module_public_constant$32,
      $Module_define_method$33,
      $Module_remove_method$35,
      $Module_singleton_class$ques$36,
      $Module_include$37,
      $Module_included_modules$38,
      $Module_include$ques$39,
      $Module_instance_method$40,
      $Module_instance_methods$41,
      $Module_included$42,
      $Module_extended$43,
      $Module_extend_object$44,
      $Module_method_added$45,
      $Module_method_removed$46,
      $Module_method_undefined$47,
      $Module_module_eval$48,
      $Module_module_exec$50,
      $Module_method_defined$ques$51,
      $Module_module_function$52,
      $Module_name$53,
      $Module_prepend$54,
      $Module_prepend_features$55,
      $Module_prepended$56,
      $Module_remove_const$57,
      $Module_to_s$58,
      $Module_undef_method$59,
      $Module_instance_variables$60,
      $Module_dup$61,
      $Module_copy_class_variables$62,
      $Module_copy_constants$63,
      $Module_refine$64,
      $Module_using$66;

    Opal.defs(
      self,
      "$allocate",
      ($Module_allocate$1 = function $$allocate() {
        var self = this;

        var module = Opal.allocate_module(nil, function () {});
        // Link the prototype of Module subclasses
        if (self !== Opal.Module)
          Object.setPrototypeOf(module, self.$$prototype);
        return module;
      }),
      ($Module_allocate$1.$$arity = 0)
    );

    Opal.def(
      self,
      "$initialize",
      ($Module_initialize$2 = function $$initialize() {
        var $iter = $Module_initialize$2.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Module_initialize$2.$$p = null;

        if ($iter) $Module_initialize$2.$$p = null;
        if (block !== nil) {
          return $send(self, "module_eval", [], block.$to_proc());
        } else {
          return nil;
        }
      }),
      ($Module_initialize$2.$$arity = 0)
    );

    Opal.def(
      self,
      "$===",
      ($Module_$eq_eq_eq$3 = function (object) {
        var self = this;

        if ($truthy(object == null)) {
          return false;
        }
        return Opal.is_a(object, self);
      }),
      ($Module_$eq_eq_eq$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$<",
      ($Module_$lt$4 = function (other) {
        var self = this;

        if ($truthy($$($nesting, "Module")["$==="](other))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "compared with non class/module"
          );
        }

        var working = self,
          ancestors,
          i,
          length;

        if (working === other) {
          return false;
        }

        for (
          i = 0, ancestors = Opal.ancestors(self), length = ancestors.length;
          i < length;
          i++
        ) {
          if (ancestors[i] === other) {
            return true;
          }
        }

        for (
          i = 0, ancestors = Opal.ancestors(other), length = ancestors.length;
          i < length;
          i++
        ) {
          if (ancestors[i] === self) {
            return false;
          }
        }

        return nil;
      }),
      ($Module_$lt$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=",
      ($Module_$lt_eq$5 = function (other) {
        var self = this,
          $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self["$equal?"](other)))) {
          return $ret_or_1;
        } else {
          return $rb_lt(self, other);
        }
      }),
      ($Module_$lt_eq$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$>",
      ($Module_$gt$6 = function (other) {
        var self = this;

        if ($truthy($$($nesting, "Module")["$==="](other))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "compared with non class/module"
          );
        }
        return $rb_lt(other, self);
      }),
      ($Module_$gt$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$>=",
      ($Module_$gt_eq$7 = function (other) {
        var self = this,
          $ret_or_2 = nil;

        if ($truthy(($ret_or_2 = self["$equal?"](other)))) {
          return $ret_or_2;
        } else {
          return $rb_gt(self, other);
        }
      }),
      ($Module_$gt_eq$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=>",
      ($Module_$lt_eq_gt$8 = function (other) {
        var self = this,
          lt = nil;

        if (self === other) {
          return 0;
        }
        if ($truthy($$($nesting, "Module")["$==="](other))) {
        } else {
          return nil;
        }
        lt = $rb_lt(self, other);
        if ($truthy(lt["$nil?"]())) {
          return nil;
        }
        if ($truthy(lt)) {
          return -1;
        } else {
          return 1;
        }
      }),
      ($Module_$lt_eq_gt$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$alias_method",
      ($Module_alias_method$9 = function $$alias_method(newname, oldname) {
        var self = this;

        newname = $coerce_to(newname, $$($nesting, "String"), "to_str");
        oldname = $coerce_to(oldname, $$($nesting, "String"), "to_str");
        Opal.alias(self, newname, oldname);
        return self;
      }),
      ($Module_alias_method$9.$$arity = 2)
    );

    Opal.def(
      self,
      "$alias_native",
      ($Module_alias_native$10 = function $$alias_native(mid, jsid) {
        var self = this;

        if (jsid == null) {
          jsid = mid;
        }
        Opal.alias_native(self, mid, jsid);
        return self;
      }),
      ($Module_alias_native$10.$$arity = -2)
    );

    Opal.def(
      self,
      "$ancestors",
      ($Module_ancestors$11 = function $$ancestors() {
        var self = this;

        return Opal.ancestors(self);
      }),
      ($Module_ancestors$11.$$arity = 0)
    );

    Opal.def(
      self,
      "$append_features",
      ($Module_append_features$12 = function $$append_features(includer) {
        var self = this;

        Opal.append_features(self, includer);
        return self;
      }),
      ($Module_append_features$12.$$arity = 1)
    );

    Opal.def(
      self,
      "$attr_accessor",
      ($Module_attr_accessor$13 = function $$attr_accessor($a) {
        var $post_args,
          names,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        names = $post_args;
        $send(self, "attr_reader", Opal.to_a(names));
        return $send(self, "attr_writer", Opal.to_a(names));
      }),
      ($Module_attr_accessor$13.$$arity = -1)
    );

    Opal.def(
      self,
      "$attr",
      ($Module_attr$14 = function $$attr($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        if (args.length == 2 && (args[1] === true || args[1] === false)) {
          self.$warn(
            "optional boolean argument is obsoleted",
            $hash2(["uplevel"], { uplevel: 1 })
          );

          args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
          return nil;
        }
        return $send(self, "attr_reader", Opal.to_a(args));
      }),
      ($Module_attr$14.$$arity = -1)
    );

    Opal.def(
      self,
      "$attr_reader",
      ($Module_attr_reader$15 = function $$attr_reader($a) {
        var $post_args,
          names,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        names = $post_args;

        var proto = self.$$prototype;

        for (var i = names.length - 1; i >= 0; i--) {
          var name = names[i],
            id = "$" + name,
            ivar = Opal.ivar(name);

          // the closure here is needed because name will change at the next
          // cycle, I wish we could use let.
          var body = (function (ivar) {
            return function () {
              if (this[ivar] == null) {
                return nil;
              } else {
                return this[ivar];
              }
            };
          })(ivar);

          // initialize the instance variable as nil
          Opal.defineProperty(proto, ivar, nil);

          body.$$parameters = [];
          body.$$arity = 0;

          Opal.defn(self, id, body);
        }
        return nil;
      }),
      ($Module_attr_reader$15.$$arity = -1)
    );

    Opal.def(
      self,
      "$attr_writer",
      ($Module_attr_writer$16 = function $$attr_writer($a) {
        var $post_args,
          names,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        names = $post_args;

        var proto = self.$$prototype;

        for (var i = names.length - 1; i >= 0; i--) {
          var name = names[i],
            id = "$" + name + "=",
            ivar = Opal.ivar(name);

          // the closure here is needed because name will change at the next
          // cycle, I wish we could use let.
          var body = (function (ivar) {
            return function (value) {
              return (this[ivar] = value);
            };
          })(ivar);

          body.$$parameters = [["req"]];
          body.$$arity = 1;

          // initialize the instance variable as nil
          Opal.defineProperty(proto, ivar, nil);

          Opal.defn(self, id, body);
        }
        return nil;
      }),
      ($Module_attr_writer$16.$$arity = -1)
    );

    Opal.def(
      self,
      "$autoload",
      ($Module_autoload$17 = function $$autoload(const$, path) {
        var self = this;

        if (!$$($nesting, "Opal")["$const_name?"](const$)) {
          self.$raise(
            $$($nesting, "NameError"),
            "" + "autoload must be constant name: " + const$
          );
        }

        if (path == "") {
          self.$raise($$($nesting, "ArgumentError"), "empty file name");
        }

        if (!self.$$const.hasOwnProperty(const$)) {
          if (!self.$$autoload) {
            self.$$autoload = {};
          }
          Opal.const_cache_version++;
          self.$$autoload[const$] = {
            path: path,
            loaded: false,
            required: false,
            success: false,
            exception: false,
          };
        }
        return nil;
      }),
      ($Module_autoload$17.$$arity = 2)
    );

    Opal.def(
      self,
      "$autoload?",
      ($Module_autoload$ques$18 = function (const$) {
        var self = this;

        if (
          self.$$autoload &&
          self.$$autoload[const$] &&
          !self.$$autoload[const$].required &&
          !self.$$autoload[const$].success
        ) {
          return self.$$autoload[const$].path;
        }

        var ancestors = self.$ancestors();

        for (var i = 0, length = ancestors.length; i < length; i++) {
          if (
            ancestors[i].$$autoload &&
            ancestors[i].$$autoload[const$] &&
            !ancestors[i].$$autoload[const$].required &&
            !ancestors[i].$$autoload[const$].success
          ) {
            return ancestors[i].$$autoload[const$].path;
          }
        }
        return nil;
      }),
      ($Module_autoload$ques$18.$$arity = 1)
    );

    Opal.def(
      self,
      "$class_variables",
      ($Module_class_variables$19 = function $$class_variables() {
        var self = this;

        return Object.keys(Opal.class_variables(self));
      }),
      ($Module_class_variables$19.$$arity = 0)
    );

    Opal.def(
      self,
      "$class_variable_get",
      ($Module_class_variable_get$20 = function $$class_variable_get(name) {
        var self = this;

        name = $$($nesting, "Opal")["$class_variable_name!"](name);
        return Opal.class_variable_get(self, name, false);
      }),
      ($Module_class_variable_get$20.$$arity = 1)
    );

    Opal.def(
      self,
      "$class_variable_set",
      ($Module_class_variable_set$21 = function $$class_variable_set(
        name,
        value
      ) {
        var self = this;

        name = $$($nesting, "Opal")["$class_variable_name!"](name);
        return Opal.class_variable_set(self, name, value);
      }),
      ($Module_class_variable_set$21.$$arity = 2)
    );

    Opal.def(
      self,
      "$class_variable_defined?",
      ($Module_class_variable_defined$ques$22 = function (name) {
        var self = this;

        name = $$($nesting, "Opal")["$class_variable_name!"](name);
        return Opal.class_variables(self).hasOwnProperty(name);
      }),
      ($Module_class_variable_defined$ques$22.$$arity = 1)
    );

    Opal.def(
      self,
      "$remove_class_variable",
      ($Module_remove_class_variable$23 = function $$remove_class_variable(
        name
      ) {
        var self = this;

        name = $$($nesting, "Opal")["$class_variable_name!"](name);

        if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
          var value = self.$$cvars[name];
          delete self.$$cvars[name];
          return value;
        } else {
          self.$raise(
            $$($nesting, "NameError"),
            "" + "cannot remove " + name + " for " + self
          );
        }
      }),
      ($Module_remove_class_variable$23.$$arity = 1)
    );

    Opal.def(
      self,
      "$constants",
      ($Module_constants$24 = function $$constants(inherit) {
        var self = this;

        if (inherit == null) {
          inherit = true;
        }
        return Opal.constants(self, inherit);
      }),
      ($Module_constants$24.$$arity = -1)
    );
    Opal.defs(
      self,
      "$constants",
      ($Module_constants$25 = function $$constants(inherit) {
        var self = this;

        if (inherit == null) {
          var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant,
            constants = {},
            i,
            ii;

          for (i = 0, ii = nesting.length; i < ii; i++) {
            for (constant in nesting[i].$$const) {
              constants[constant] = true;
            }
          }
          return Object.keys(constants);
        } else {
          return Opal.constants(self, inherit);
        }
      }),
      ($Module_constants$25.$$arity = -1)
    );
    Opal.defs(
      self,
      "$nesting",
      ($Module_nesting$26 = function $$nesting() {
        var self = this;

        return self.$$nesting || [];
      }),
      ($Module_nesting$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$const_defined?",
      ($Module_const_defined$ques$27 = function (name, inherit) {
        var self = this;

        if (inherit == null) {
          inherit = true;
        }
        name = $$($nesting, "Opal")["$const_name!"](name);
        if (
          $truthy(name["$=~"]($$$($$($nesting, "Opal"), "CONST_NAME_REGEXP")))
        ) {
        } else {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" + "wrong constant name " + name,
              name
            )
          );
        }

        var module,
          modules = [self],
          module_constants,
          i,
          ii;

        // Add up ancestors if inherit is true
        if (inherit) {
          modules = modules.concat(Opal.ancestors(self));

          // Add Object's ancestors if it's a module – modules have no ancestors otherwise
          if (self.$$is_module) {
            modules = modules
              .concat([Opal.Object])
              .concat(Opal.ancestors(Opal.Object));
          }
        }

        for (i = 0, ii = modules.length; i < ii; i++) {
          module = modules[i];
          if (module.$$const[name] != null) {
            return true;
          }
          if (
            module.$$autoload &&
            module.$$autoload[name] &&
            !module.$$autoload[name].required &&
            !module.$$autoload[name].success
          ) {
            return true;
          }
        }

        return false;
      }),
      ($Module_const_defined$ques$27.$$arity = -2)
    );

    Opal.def(
      self,
      "$const_get",
      ($Module_const_get$28 = function $$const_get(name, inherit) {
        var $$29,
          self = this;

        if (inherit == null) {
          inherit = true;
        }
        name = $$($nesting, "Opal")["$const_name!"](name);

        if (name.indexOf("::") === 0 && name !== "::") {
          name = name.slice(2);
        }
        if ($truthy(name.indexOf("::") != -1 && name != "::")) {
          return $send(
            name.$split("::"),
            "inject",
            [self],
            (($$29 = function (o, c) {
              var self = $$29.$$s == null ? this : $$29.$$s;

              if (o == null) {
                o = nil;
              }

              if (c == null) {
                c = nil;
              }
              return o.$const_get(c);
            }),
            ($$29.$$s = self),
            ($$29.$$arity = 2),
            $$29)
          );
        }
        if (
          $truthy(name["$=~"]($$$($$($nesting, "Opal"), "CONST_NAME_REGEXP")))
        ) {
        } else {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" + "wrong constant name " + name,
              name
            )
          );
        }

        if (inherit) {
          return $$([self], name);
        } else {
          return Opal.const_get_local(self, name);
        }
      }),
      ($Module_const_get$28.$$arity = -2)
    );

    Opal.def(
      self,
      "$const_missing",
      ($Module_const_missing$30 = function $$const_missing(name) {
        var self = this,
          full_const_name = nil;

        full_const_name = (function () {
          if (self["$=="]($$($nesting, "Object"))) {
            return name;
          } else {
            return "" + self + "::" + name;
          }
          return nil;
        })();
        return self.$raise(
          $$($nesting, "NameError").$new(
            "" + "uninitialized constant " + full_const_name,
            name
          )
        );
      }),
      ($Module_const_missing$30.$$arity = 1)
    );

    Opal.def(
      self,
      "$const_set",
      ($Module_const_set$31 = function $$const_set(name, value) {
        var self = this,
          $ret_or_3 = nil;

        name = $$($nesting, "Opal")["$const_name!"](name);
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_3 = name["$!~"](
                    $$$($$($nesting, "Opal"), "CONST_NAME_REGEXP")
                  ))
                )
              ) {
                return $ret_or_3;
              } else {
                return name["$start_with?"]("::");
              }
              return nil;
            })()
          )
        ) {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" + "wrong constant name " + name,
              name
            )
          );
        }
        Opal.const_set(self, name, value);
        return value;
      }),
      ($Module_const_set$31.$$arity = 2)
    );

    Opal.def(
      self,
      "$public_constant",
      ($Module_public_constant$32 = function $$public_constant(const_name) {
        var self = this;

        return nil;
      }),
      ($Module_public_constant$32.$$arity = 1)
    );

    Opal.def(
      self,
      "$define_method",
      ($Module_define_method$33 = function $$define_method(name, method) {
        var $iter = $Module_define_method$33.$$p,
          block = $iter || nil,
          $$34,
          self = this,
          $ret_or_4 = nil,
          $case = nil;

        if ($iter) $Module_define_method$33.$$p = null;

        if ($iter) $Module_define_method$33.$$p = null;
        if ($truthy(method === undefined && block === nil)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "tried to create a Proc object without a block"
          );
        }
        block = (function () {
          if ($truthy(($ret_or_4 = block))) {
            return $ret_or_4;
          } else {
            return (function () {
              $case = method;
              if ($$($nesting, "Proc")["$==="]($case)) {
                return method;
              } else if ($$($nesting, "Method")["$==="]($case)) {
                return method.$to_proc().$$unbound;
              } else if ($$($nesting, "UnboundMethod")["$==="]($case)) {
                return $lambda(
                  (($$34 = function ($a) {
                    var self = $$34.$$s == null ? this : $$34.$$s,
                      $post_args,
                      args,
                      bound = nil;

                    $post_args = Opal.slice.call(
                      arguments,
                      0,
                      arguments.length
                    );

                    args = $post_args;
                    bound = method.$bind(self);
                    return $send(bound, "call", Opal.to_a(args));
                  }),
                  ($$34.$$s = self),
                  ($$34.$$arity = -1),
                  $$34)
                );
              } else {
                return self.$raise(
                  $$($nesting, "TypeError"),
                  "" +
                    "wrong argument type " +
                    block.$class() +
                    " (expected Proc/Method)"
                );
              }
            })();
          }
          return nil;
        })();

        var id = "$" + name;

        block.$$jsid = name;
        block.$$s = null;
        block.$$def = block;
        block.$$define_meth = true;

        Opal.defn(self, id, block);

        return name;
      }),
      ($Module_define_method$33.$$arity = -2)
    );

    Opal.def(
      self,
      "$remove_method",
      ($Module_remove_method$35 = function $$remove_method($a) {
        var $post_args,
          names,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        names = $post_args;

        for (var i = 0, length = names.length; i < length; i++) {
          Opal.rdef(self, "$" + names[i]);
        }
        return self;
      }),
      ($Module_remove_method$35.$$arity = -1)
    );

    Opal.def(
      self,
      "$singleton_class?",
      ($Module_singleton_class$ques$36 = function () {
        var self = this;

        return !!self.$$is_singleton;
      }),
      ($Module_singleton_class$ques$36.$$arity = 0)
    );

    Opal.def(
      self,
      "$include",
      ($Module_include$37 = function $$include($a) {
        var $post_args,
          mods,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        mods = $post_args;

        for (var i = mods.length - 1; i >= 0; i--) {
          var mod = mods[i];

          if (!mod.$$is_module) {
            self.$raise(
              $$($nesting, "TypeError"),
              "" + "wrong argument type " + mod.$class() + " (expected Module)"
            );
          }

          mod.$append_features(self);
          mod.$included(self);
        }
        return self;
      }),
      ($Module_include$37.$$arity = -1)
    );

    Opal.def(
      self,
      "$included_modules",
      ($Module_included_modules$38 = function $$included_modules() {
        var self = this;

        return Opal.included_modules(self);
      }),
      ($Module_included_modules$38.$$arity = 0)
    );

    Opal.def(
      self,
      "$include?",
      ($Module_include$ques$39 = function (mod) {
        var self = this;

        if (!mod.$$is_module) {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "wrong argument type " + mod.$class() + " (expected Module)"
          );
        }

        var i,
          ii,
          mod2,
          ancestors = Opal.ancestors(self);

        for (i = 0, ii = ancestors.length; i < ii; i++) {
          mod2 = ancestors[i];
          if (mod2 === mod && mod2 !== self) {
            return true;
          }
        }

        return false;
      }),
      ($Module_include$ques$39.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_method",
      ($Module_instance_method$40 = function $$instance_method(name) {
        var self = this;

        var meth = self.$$prototype["$" + name];

        if (!meth || meth.$$stub) {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" +
                "undefined method `" +
                name +
                "' for class `" +
                self.$name() +
                "'",
              name
            )
          );
        }

        return $$($nesting, "UnboundMethod").$new(
          self,
          meth.$$owner || self,
          meth,
          name
        );
      }),
      ($Module_instance_method$40.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_methods",
      ($Module_instance_methods$41 = function $$instance_methods(
        include_super
      ) {
        var self = this;

        if (include_super == null) {
          include_super = true;
        }

        if ($truthy(include_super)) {
          return Opal.instance_methods(self);
        } else {
          return Opal.own_instance_methods(self);
        }
      }),
      ($Module_instance_methods$41.$$arity = -1)
    );

    Opal.def(
      self,
      "$included",
      ($Module_included$42 = function $$included(mod) {
        var self = this;

        return nil;
      }),
      ($Module_included$42.$$arity = 1)
    );

    Opal.def(
      self,
      "$extended",
      ($Module_extended$43 = function $$extended(mod) {
        var self = this;

        return nil;
      }),
      ($Module_extended$43.$$arity = 1)
    );

    Opal.def(
      self,
      "$extend_object",
      ($Module_extend_object$44 = function $$extend_object(object) {
        var self = this;

        return nil;
      }),
      ($Module_extend_object$44.$$arity = 1)
    );

    Opal.def(
      self,
      "$method_added",
      ($Module_method_added$45 = function $$method_added($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return nil;
      }),
      ($Module_method_added$45.$$arity = -1)
    );

    Opal.def(
      self,
      "$method_removed",
      ($Module_method_removed$46 = function $$method_removed($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return nil;
      }),
      ($Module_method_removed$46.$$arity = -1)
    );

    Opal.def(
      self,
      "$method_undefined",
      ($Module_method_undefined$47 = function $$method_undefined($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return nil;
      }),
      ($Module_method_undefined$47.$$arity = -1)
    );

    Opal.def(
      self,
      "$module_eval",
      ($Module_module_eval$48 = function $$module_eval($a) {
        var $iter = $Module_module_eval$48.$$p,
          block = $iter || nil,
          $post_args,
          args,
          $b,
          $$49,
          self = this,
          $ret_or_5 = nil,
          string = nil,
          file = nil,
          _lineno = nil,
          default_eval_options = nil,
          $ret_or_6 = nil,
          compiling_options = nil,
          compiled = nil;

        if ($iter) $Module_module_eval$48.$$p = null;

        if ($iter) $Module_module_eval$48.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_5 = block["$nil?"]()))) {
                return !!Opal.compile;
              } else {
                return $ret_or_5;
              }
              return nil;
            })()
          )
        ) {
          if ($truthy($range(1, 3, false)["$cover?"](args.$size()))) {
          } else {
            $$($nesting, "Kernel").$raise(
              $$($nesting, "ArgumentError"),
              "wrong number of arguments (0 for 1..3)"
            );
          }
          ($b = [].concat(Opal.to_a(args))),
            (string = $b[0] == null ? nil : $b[0]),
            (file = $b[1] == null ? nil : $b[1]),
            (_lineno = $b[2] == null ? nil : $b[2]),
            $b;
          default_eval_options = $hash2(["file", "eval"], {
            file: (function () {
              if ($truthy(($ret_or_6 = file))) {
                return $ret_or_6;
              } else {
                return "(eval)";
              }
              return nil;
            })(),
            eval: true,
          });
          compiling_options = Opal.hash({ arity_check: false }).$merge(
            default_eval_options
          );
          compiled = $$($nesting, "Opal").$compile(string, compiling_options);
          block = $send(
            $$($nesting, "Kernel"),
            "proc",
            [],
            (($$49 = function () {
              var self = $$49.$$s == null ? this : $$49.$$s;

              return (function (self) {
                return eval(compiled);
              })(self);
            }),
            ($$49.$$s = self),
            ($$49.$$arity = 0),
            $$49)
          );
        } else if ($truthy(args["$any?"]())) {
          $$($nesting, "Kernel").$raise(
            $$($nesting, "ArgumentError"),
            "" +
              ("" + "wrong number of arguments (" + args.$size() + " for 0)") +
              "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n"
          );
        }

        var old = block.$$s,
          result;

        block.$$s = null;
        result = block.apply(self, [self]);
        block.$$s = old;

        return result;
      }),
      ($Module_module_eval$48.$$arity = -1)
    );
    $alias(self, "class_eval", "module_eval");

    Opal.def(
      self,
      "$module_exec",
      ($Module_module_exec$50 = function $$module_exec($a) {
        var $iter = $Module_module_exec$50.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Module_module_exec$50.$$p = null;

        if ($iter) $Module_module_exec$50.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        if (block === nil) {
          self.$raise($$($nesting, "LocalJumpError"), "no block given");
        }

        var block_self = block.$$s,
          result;

        block.$$s = null;
        result = block.apply(self, args);
        block.$$s = block_self;

        return result;
      }),
      ($Module_module_exec$50.$$arity = -1)
    );
    $alias(self, "class_exec", "module_exec");

    Opal.def(
      self,
      "$method_defined?",
      ($Module_method_defined$ques$51 = function (method) {
        var self = this;

        var body = self.$$prototype["$" + method];
        return !!body && !body.$$stub;
      }),
      ($Module_method_defined$ques$51.$$arity = 1)
    );

    Opal.def(
      self,
      "$module_function",
      ($Module_module_function$52 = function $$module_function($a) {
        var $post_args,
          methods,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        methods = $post_args;

        if (methods.length === 0) {
          self.$$module_function = true;
        } else {
          for (var i = 0, length = methods.length; i < length; i++) {
            var meth = methods[i],
              id = "$" + meth,
              func = self.$$prototype[id];

            Opal.defs(self, id, func);
          }
        }

        return self;
      }),
      ($Module_module_function$52.$$arity = -1)
    );

    Opal.def(
      self,
      "$name",
      ($Module_name$53 = function $$name() {
        var self = this;

        if (self.$$full_name) {
          return self.$$full_name;
        }

        var result = [],
          base = self;

        while (base) {
          // Give up if any of the ancestors is unnamed
          if (base.$$name === nil || base.$$name == null) return nil;

          result.unshift(base.$$name);

          base = base.$$base_module;

          if (base === Opal.Object) {
            break;
          }
        }

        if (result.length === 0) {
          return nil;
        }

        return (self.$$full_name = result.join("::"));
      }),
      ($Module_name$53.$$arity = 0)
    );

    Opal.def(
      self,
      "$prepend",
      ($Module_prepend$54 = function $$prepend($a) {
        var $post_args,
          mods,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        mods = $post_args;

        if (mods.length === 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "wrong number of arguments (given 0, expected 1+)"
          );
        }

        for (var i = mods.length - 1; i >= 0; i--) {
          var mod = mods[i];

          if (!mod.$$is_module) {
            self.$raise(
              $$($nesting, "TypeError"),
              "" + "wrong argument type " + mod.$class() + " (expected Module)"
            );
          }

          mod.$prepend_features(self);
          mod.$prepended(self);
        }
        return self;
      }),
      ($Module_prepend$54.$$arity = -1)
    );

    Opal.def(
      self,
      "$prepend_features",
      ($Module_prepend_features$55 = function $$prepend_features(prepender) {
        var self = this;

        if (!self.$$is_module) {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "wrong argument type " + self.$class() + " (expected Module)"
          );
        }

        Opal.prepend_features(self, prepender);
        return self;
      }),
      ($Module_prepend_features$55.$$arity = 1)
    );

    Opal.def(
      self,
      "$prepended",
      ($Module_prepended$56 = function $$prepended(mod) {
        var self = this;

        return nil;
      }),
      ($Module_prepended$56.$$arity = 1)
    );

    Opal.def(
      self,
      "$remove_const",
      ($Module_remove_const$57 = function $$remove_const(name) {
        var self = this;

        return Opal.const_remove(self, name);
      }),
      ($Module_remove_const$57.$$arity = 1)
    );

    Opal.def(
      self,
      "$to_s",
      ($Module_to_s$58 = function $$to_s() {
        var self = this,
          $ret_or_7 = nil;

        if ($truthy(($ret_or_7 = Opal.Module.$name.call(self)))) {
          return $ret_or_7;
        } else {
          return (
            "" +
            "#<" +
            (self.$$is_module ? "Module" : "Class") +
            ":0x" +
            self.$__id__().$to_s(16) +
            ">"
          );
        }
      }),
      ($Module_to_s$58.$$arity = 0)
    );
    $alias(self, "inspect", "to_s");

    Opal.def(
      self,
      "$undef_method",
      ($Module_undef_method$59 = function $$undef_method($a) {
        var $post_args,
          names,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        names = $post_args;

        for (var i = 0, length = names.length; i < length; i++) {
          Opal.udef(self, "$" + names[i]);
        }
        return self;
      }),
      ($Module_undef_method$59.$$arity = -1)
    );

    Opal.def(
      self,
      "$instance_variables",
      ($Module_instance_variables$60 = function $$instance_variables() {
        var self = this,
          consts = nil;

        consts = ((Opal.Module.$$nesting = $nesting), self.$constants());

        var result = [];

        for (var name in self) {
          if (
            self.hasOwnProperty(name) &&
            name.charAt(0) !== "$" &&
            name !== "constructor" &&
            !consts["$include?"](name)
          ) {
            result.push("@" + name);
          }
        }

        return result;
      }),
      ($Module_instance_variables$60.$$arity = 0)
    );

    Opal.def(
      self,
      "$dup",
      ($Module_dup$61 = function $$dup() {
        var $iter = $Module_dup$61.$$p,
          $yield = $iter || nil,
          self = this,
          copy = nil;

        if ($iter) $Module_dup$61.$$p = null;

        copy = $send2(
          self,
          $find_super(self, "dup", $Module_dup$61, false, true),
          "dup",
          [],
          $iter
        );
        copy.$copy_class_variables(self);
        copy.$copy_constants(self);
        return copy;
      }),
      ($Module_dup$61.$$arity = 0)
    );

    Opal.def(
      self,
      "$copy_class_variables",
      ($Module_copy_class_variables$62 = function $$copy_class_variables(
        other
      ) {
        var self = this;

        for (var name in other.$$cvars) {
          self.$$cvars[name] = other.$$cvars[name];
        }
      }),
      ($Module_copy_class_variables$62.$$arity = 1)
    );

    Opal.def(
      self,
      "$copy_constants",
      ($Module_copy_constants$63 = function $$copy_constants(other) {
        var self = this;

        var name,
          other_constants = other.$$const;

        for (name in other_constants) {
          Opal.const_set(self, name, other_constants[name]);
        }
      }),
      ($Module_copy_constants$63.$$arity = 1)
    );

    Opal.def(
      self,
      "$refine",
      ($Module_refine$64 = function $$refine(mod) {
        var $iter = $Module_refine$64.$$p,
          block = $iter || nil,
          $a,
          $$65,
          self = this,
          s = nil,
          m = nil,
          mod_id = nil;

        if ($iter) $Module_refine$64.$$p = null;

        if ($iter) $Module_refine$64.$$p = null;
        ($a = [self, nil, nil]), (s = $a[0]), (m = $a[1]), (mod_id = $a[2]), $a;

        mod_id = Opal.id(mod);
        if (typeof self.$$refine_modules === "undefined") {
          self.$$refine_modules = {};
        }
        if (typeof self.$$refine_modules[mod_id] === "undefined") {
          m = self.$$refine_modules[mod_id] = $$$("::", "Module").$new();
        } else {
          m = self.$$refine_modules[mod_id];
        }
        $send(
          m,
          "define_singleton_method",
          ["inspect"],
          (($$65 = function () {
            var self = $$65.$$s == null ? this : $$65.$$s;

            return (
              "" + "#<refinement:" + mod.$inspect() + "@" + s.$inspect() + ">"
            );
          }),
          ($$65.$$s = self),
          ($$65.$$arity = 0),
          $$65)
        );
        $send(m, "class_exec", [], block.$to_proc());
        return m;
      }),
      ($Module_refine$64.$$arity = 1)
    );
    return (
      (Opal.def(
        self,
        "$using",
        ($Module_using$66 = function $$using(mod) {
          var self = this;

          return self.$raise("Module#using is not permitted in methods");
        }),
        ($Module_using$66.$$arity = 1)
      ),
      nil) && "using"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/class"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $send = Opal.send,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$require",
    "$class_eval",
    "$to_proc",
    "$initialize_copy",
    "$allocate",
    "$name",
    "$to_s",
  ]);

  self.$require("corelib/module");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Class");

    var $nesting = [self].concat($parent_nesting),
      $Class_new$1,
      $Class_allocate$2,
      $Class_inherited$3,
      $Class_initialize_dup$4,
      $Class_new$5,
      $Class_superclass$6,
      $Class_to_s$7;

    Opal.defs(
      self,
      "$new",
      ($Class_new$1 = function (superclass) {
        var $iter = $Class_new$1.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Class_new$1.$$p = null;

        if ($iter) $Class_new$1.$$p = null;

        if (superclass == null) {
          superclass = $$($nesting, "Object");
        }

        if (!superclass.$$is_class) {
          throw Opal.TypeError.$new("superclass must be a Class");
        }

        var klass = Opal.allocate_class(nil, superclass);
        superclass.$inherited(klass);
        (function () {
          if (block !== nil) {
            return $send(klass, "class_eval", [], block.$to_proc());
          } else {
            return nil;
          }
          return nil;
        })();
        return klass;
      }),
      ($Class_new$1.$$arity = -1)
    );

    Opal.def(
      self,
      "$allocate",
      ($Class_allocate$2 = function $$allocate() {
        var self = this;

        var obj = new self.$$constructor();
        obj.$$id = Opal.uid();
        return obj;
      }),
      ($Class_allocate$2.$$arity = 0)
    );

    Opal.def(
      self,
      "$inherited",
      ($Class_inherited$3 = function $$inherited(cls) {
        var self = this;

        return nil;
      }),
      ($Class_inherited$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$initialize_dup",
      ($Class_initialize_dup$4 = function $$initialize_dup(original) {
        var self = this;

        self.$initialize_copy(original);

        self.$$name = null;
        self.$$full_name = null;
      }),
      ($Class_initialize_dup$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$new",
      ($Class_new$5 = function ($a) {
        var $iter = $Class_new$5.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Class_new$5.$$p = null;

        if ($iter) $Class_new$5.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        var object = self.$allocate();
        Opal.send(object, object.$initialize, args, block);
        return object;
      }),
      ($Class_new$5.$$arity = -1)
    );

    Opal.def(
      self,
      "$superclass",
      ($Class_superclass$6 = function $$superclass() {
        var self = this;

        return self.$$super || nil;
      }),
      ($Class_superclass$6.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Class_to_s$7 = function $$to_s() {
        var $iter = $Class_to_s$7.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Class_to_s$7.$$p = null;

        var singleton_of = self.$$singleton_of;

        if (singleton_of && singleton_of.$$is_a_module) {
          return "" + "#<Class:" + singleton_of.$name() + ">";
        } else if (singleton_of) {
          // a singleton class created from an object
          return (
            "" +
            "#<Class:#<" +
            singleton_of.$$class.$name() +
            ":0x" +
            Opal.id(singleton_of).$to_s(16) +
            ">>"
          );
        }

        return $send2(
          self,
          $find_super(self, "to_s", $Class_to_s$7, false, true),
          "to_s",
          [],
          null
        );
      }),
      ($Class_to_s$7.$$arity = 0)
    );
    return $alias(self, "inspect", "to_s");
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/basic_object"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $truthy = Opal.truthy,
    $range = Opal.range,
    $hash2 = Opal.hash2,
    $send = Opal.send;

  Opal.add_stubs([
    "$==",
    "$!",
    "$nil?",
    "$cover?",
    "$size",
    "$raise",
    "$merge",
    "$compile",
    "$proc",
    "$any?",
    "$inspect",
    "$new",
  ]);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "BasicObject");

    var $nesting = [self].concat($parent_nesting),
      $BasicObject_initialize$1,
      $BasicObject_$eq_eq$2,
      $BasicObject_eql$ques$3,
      $BasicObject___id__$4,
      $BasicObject___send__$5,
      $BasicObject_$excl$6,
      $BasicObject_$not_eq$7,
      $BasicObject_instance_eval$8,
      $BasicObject_instance_exec$10,
      $BasicObject_singleton_method_added$11,
      $BasicObject_singleton_method_removed$12,
      $BasicObject_singleton_method_undefined$13,
      $BasicObject_method_missing$14,
      $BasicObject_respond_to_missing$ques$15;

    Opal.def(
      self,
      "$initialize",
      ($BasicObject_initialize$1 = function $$initialize($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return nil;
      }),
      ($BasicObject_initialize$1.$$arity = -1)
    );

    Opal.def(
      self,
      "$==",
      ($BasicObject_$eq_eq$2 = function (other) {
        var self = this;

        return self === other;
      }),
      ($BasicObject_$eq_eq$2.$$arity = 1)
    );

    Opal.def(
      self,
      "$eql?",
      ($BasicObject_eql$ques$3 = function (other) {
        var self = this;

        return self["$=="](other);
      }),
      ($BasicObject_eql$ques$3.$$arity = 1)
    );
    $alias(self, "equal?", "==");

    Opal.def(
      self,
      "$__id__",
      ($BasicObject___id__$4 = function $$__id__() {
        var self = this;

        if (self.$$id != null) {
          return self.$$id;
        }
        Opal.defineProperty(self, "$$id", Opal.uid());
        return self.$$id;
      }),
      ($BasicObject___id__$4.$$arity = 0)
    );

    Opal.def(
      self,
      "$__send__",
      ($BasicObject___send__$5 = function $$__send__(symbol, $a) {
        var $iter = $BasicObject___send__$5.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $BasicObject___send__$5.$$p = null;

        if ($iter) $BasicObject___send__$5.$$p = null;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        args = $post_args;

        var func = self["$" + symbol];

        if (func) {
          if (block !== nil) {
            func.$$p = block;
          }

          return func.apply(self, args);
        }

        if (block !== nil) {
          self.$method_missing.$$p = block;
        }

        return self.$method_missing.apply(self, [symbol].concat(args));
      }),
      ($BasicObject___send__$5.$$arity = -2)
    );

    Opal.def(
      self,
      "$!",
      ($BasicObject_$excl$6 = function () {
        var self = this;

        return false;
      }),
      ($BasicObject_$excl$6.$$arity = 0)
    );

    Opal.def(
      self,
      "$!=",
      ($BasicObject_$not_eq$7 = function (other) {
        var self = this;

        return self["$=="](other)["$!"]();
      }),
      ($BasicObject_$not_eq$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_eval",
      ($BasicObject_instance_eval$8 = function $$instance_eval($a) {
        var $iter = $BasicObject_instance_eval$8.$$p,
          block = $iter || nil,
          $post_args,
          args,
          $b,
          $$9,
          self = this,
          $ret_or_1 = nil,
          string = nil,
          file = nil,
          _lineno = nil,
          default_eval_options = nil,
          $ret_or_2 = nil,
          compiling_options = nil,
          compiled = nil;

        if ($iter) $BasicObject_instance_eval$8.$$p = null;

        if ($iter) $BasicObject_instance_eval$8.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_1 = block["$nil?"]()))) {
                return !!Opal.compile;
              } else {
                return $ret_or_1;
              }
              return nil;
            })()
          )
        ) {
          if ($truthy($range(1, 3, false)["$cover?"](args.$size()))) {
          } else {
            $$$("::", "Kernel").$raise(
              $$$("::", "ArgumentError"),
              "wrong number of arguments (0 for 1..3)"
            );
          }
          ($b = [].concat(Opal.to_a(args))),
            (string = $b[0] == null ? nil : $b[0]),
            (file = $b[1] == null ? nil : $b[1]),
            (_lineno = $b[2] == null ? nil : $b[2]),
            $b;
          default_eval_options = $hash2(["file", "eval"], {
            file: (function () {
              if ($truthy(($ret_or_2 = file))) {
                return $ret_or_2;
              } else {
                return "(eval)";
              }
              return nil;
            })(),
            eval: true,
          });
          compiling_options = Opal.hash({ arity_check: false }).$merge(
            default_eval_options
          );
          compiled = $$$("::", "Opal").$compile(string, compiling_options);
          block = $send(
            $$$("::", "Kernel"),
            "proc",
            [],
            (($$9 = function () {
              var self = $$9.$$s == null ? this : $$9.$$s;

              return (function (self) {
                return eval(compiled);
              })(self);
            }),
            ($$9.$$s = self),
            ($$9.$$arity = 0),
            $$9)
          );
        } else if ($truthy(args["$any?"]())) {
          $$$("::", "Kernel").$raise(
            $$$("::", "ArgumentError"),
            "" + "wrong number of arguments (" + args.$size() + " for 0)"
          );
        }

        var old = block.$$s,
          result;

        block.$$s = null;

        // Need to pass $$eval so that method definitions know if this is
        // being done on a class/module. Cannot be compiler driven since
        // send(:instance_eval) needs to work.
        if (self.$$is_a_module) {
          self.$$eval = true;
          try {
            result = block.call(self, self);
          } finally {
            self.$$eval = false;
          }
        } else {
          result = block.call(self, self);
        }

        block.$$s = old;

        return result;
      }),
      ($BasicObject_instance_eval$8.$$arity = -1)
    );

    Opal.def(
      self,
      "$instance_exec",
      ($BasicObject_instance_exec$10 = function $$instance_exec($a) {
        var $iter = $BasicObject_instance_exec$10.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $BasicObject_instance_exec$10.$$p = null;

        if ($iter) $BasicObject_instance_exec$10.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if ($truthy(block)) {
        } else {
          $$$("::", "Kernel").$raise(
            $$$("::", "ArgumentError"),
            "no block given"
          );
        }

        var block_self = block.$$s,
          result;

        block.$$s = null;

        if (self.$$is_a_module) {
          self.$$eval = true;
          try {
            result = block.apply(self, args);
          } finally {
            self.$$eval = false;
          }
        } else {
          result = block.apply(self, args);
        }

        block.$$s = block_self;

        return result;
      }),
      ($BasicObject_instance_exec$10.$$arity = -1)
    );

    Opal.def(
      self,
      "$singleton_method_added",
      ($BasicObject_singleton_method_added$11 =
        function $$singleton_method_added($a) {
          var $post_args,
            $rest_arg,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          $rest_arg = $post_args;
          return nil;
        }),
      ($BasicObject_singleton_method_added$11.$$arity = -1)
    );

    Opal.def(
      self,
      "$singleton_method_removed",
      ($BasicObject_singleton_method_removed$12 =
        function $$singleton_method_removed($a) {
          var $post_args,
            $rest_arg,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          $rest_arg = $post_args;
          return nil;
        }),
      ($BasicObject_singleton_method_removed$12.$$arity = -1)
    );

    Opal.def(
      self,
      "$singleton_method_undefined",
      ($BasicObject_singleton_method_undefined$13 =
        function $$singleton_method_undefined($a) {
          var $post_args,
            $rest_arg,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          $rest_arg = $post_args;
          return nil;
        }),
      ($BasicObject_singleton_method_undefined$13.$$arity = -1)
    );

    Opal.def(
      self,
      "$method_missing",
      ($BasicObject_method_missing$14 = function $$method_missing(symbol, $a) {
        var $iter = $BasicObject_method_missing$14.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this,
          message = nil;

        if ($iter) $BasicObject_method_missing$14.$$p = null;

        if ($iter) $BasicObject_method_missing$14.$$p = null;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        args = $post_args;
        message = (function () {
          if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
            return (
              "" +
              "undefined method `" +
              symbol +
              "' for " +
              self.$inspect() +
              ":" +
              self.$$class
            );
          } else {
            return "" + "undefined method `" + symbol + "' for " + self.$$class;
          }
          return nil;
        })();
        return $$$("::", "Kernel").$raise(
          $$$("::", "NoMethodError").$new(message, symbol)
        );
      }),
      ($BasicObject_method_missing$14.$$arity = -2)
    );
    return (
      (Opal.def(
        self,
        "$respond_to_missing?",
        ($BasicObject_respond_to_missing$ques$15 = function (
          method_name,
          include_all
        ) {
          var self = this;

          if (include_all == null) {
            include_all = false;
          }
          return false;
        }),
        ($BasicObject_respond_to_missing$ques$15.$$arity = -2)
      ),
      nil) && "respond_to_missing?"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/kernel"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_le(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs <= rhs
      : lhs["$<="](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $truthy = Opal.truthy,
    $coerce_to = Opal.coerce_to,
    $respond_to = Opal.respond_to,
    $module = Opal.module,
    $gvars = Opal.gvars,
    $hash2 = Opal.hash2,
    $send = Opal.send,
    $alias = Opal.alias,
    $klass = Opal.klass;

  Opal.add_stubs([
    "$raise",
    "$new",
    "$inspect",
    "$caller",
    "$!",
    "$=~",
    "$==",
    "$object_id",
    "$class",
    "$coerce_to?",
    "$<<",
    "$allocate",
    "$copy_instance_variables",
    "$copy_singleton_methods",
    "$initialize_clone",
    "$initialize_copy",
    "$define_method",
    "$singleton_class",
    "$to_proc",
    "$initialize_dup",
    "$for",
    "$empty?",
    "$pop",
    "$call",
    "$append_features",
    "$extend_object",
    "$extended",
    "$gets",
    "$__id__",
    "$each",
    "$instance_variables",
    "$+",
    "$instance_variable_get",
    "$to_s",
    "$instance_variable_name!",
    "$respond_to?",
    "$to_int",
    "$coerce_to!",
    "$Integer",
    "$nil?",
    "$===",
    "$enum_for",
    "$result",
    "$any?",
    "$print",
    "$format",
    "$puts",
    "$<=",
    "$length",
    "$[]",
    "$readline",
    "$<",
    "$first",
    "$split",
    "$map",
    "$to_str",
    "$exception",
    "$backtrace",
    "$rand",
    "$respond_to_missing?",
    "$pristine",
    "$try_convert!",
    "$expand_path",
    "$join",
    "$start_with?",
    "$new_seed",
    "$srand",
    "$tag",
    "$value",
    "$open",
    "$include",
  ]);

  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_method_missing$1,
      $Kernel_$eq_tilde$2,
      $Kernel_$excl_tilde$3,
      $Kernel_$eq_eq_eq$4,
      $Kernel_$lt_eq_gt$5,
      $Kernel_method$6,
      $Kernel_methods$7,
      $Kernel_public_methods$8,
      $Kernel_Array$9,
      $Kernel_at_exit$10,
      $Kernel_caller$11,
      $Kernel_class$12,
      $Kernel_copy_instance_variables$13,
      $Kernel_copy_singleton_methods$14,
      $Kernel_clone$15,
      $Kernel_initialize_clone$16,
      $Kernel_define_singleton_method$17,
      $Kernel_dup$18,
      $Kernel_initialize_dup$19,
      $Kernel_enum_for$20,
      $Kernel_equal$ques$21,
      $Kernel_exit$22,
      $Kernel_extend$23,
      $Kernel_gets$24,
      $Kernel_hash$25,
      $Kernel_initialize_copy$26,
      $Kernel_inspect$27,
      $Kernel_instance_of$ques$29,
      $Kernel_instance_variable_defined$ques$30,
      $Kernel_instance_variable_get$31,
      $Kernel_instance_variable_set$32,
      $Kernel_remove_instance_variable$33,
      $Kernel_instance_variables$34,
      $Kernel_Integer$35,
      $Kernel_Float$36,
      $Kernel_Hash$37,
      $Kernel_is_a$ques$38,
      $Kernel_itself$39,
      $Kernel_lambda$40,
      $Kernel_load$41,
      $Kernel_loop$42,
      $Kernel_nil$ques$44,
      $Kernel_printf$45,
      $Kernel_proc$46,
      $Kernel_puts$47,
      $Kernel_p$48,
      $Kernel_print$50,
      $Kernel_readline$51,
      $Kernel_warn$52,
      $Kernel_raise$54,
      $Kernel_rand$55,
      $Kernel_respond_to$ques$56,
      $Kernel_respond_to_missing$ques$57,
      $Kernel_require$58,
      $Kernel_require_relative$59,
      $Kernel_require_tree$60,
      $Kernel_singleton_class$61,
      $Kernel_sleep$62,
      $Kernel_srand$63,
      $Kernel_String$64,
      $Kernel_tap$65,
      $Kernel_to_proc$66,
      $Kernel_to_s$67,
      $Kernel_catch$68,
      $Kernel_throw$69,
      $Kernel_open$70,
      $Kernel_yield_self$71;

    Opal.def(
      self,
      "$method_missing",
      ($Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
        var $iter = $Kernel_method_missing$1.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Kernel_method_missing$1.$$p = null;

        if ($iter) $Kernel_method_missing$1.$$p = null;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        args = $post_args;
        return self.$raise(
          $$($nesting, "NoMethodError").$new(
            "" + "undefined method `" + symbol + "' for " + self.$inspect(),
            symbol,
            args
          ),
          nil,
          self.$caller(1)
        );
      }),
      ($Kernel_method_missing$1.$$arity = -2)
    );

    Opal.def(
      self,
      "$=~",
      ($Kernel_$eq_tilde$2 = function (obj) {
        var self = this;

        return false;
      }),
      ($Kernel_$eq_tilde$2.$$arity = 1)
    );

    Opal.def(
      self,
      "$!~",
      ($Kernel_$excl_tilde$3 = function (obj) {
        var self = this;

        return self["$=~"](obj)["$!"]();
      }),
      ($Kernel_$excl_tilde$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$===",
      ($Kernel_$eq_eq_eq$4 = function (other) {
        var self = this,
          $ret_or_1 = nil;

        if (
          $truthy(($ret_or_1 = self.$object_id()["$=="](other.$object_id())))
        ) {
          return $ret_or_1;
        } else {
          return self["$=="](other);
        }
      }),
      ($Kernel_$eq_eq_eq$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=>",
      ($Kernel_$lt_eq_gt$5 = function (other) {
        var self = this;

        // set guard for infinite recursion
        self.$$comparable = true;

        var x = self["$=="](other);

        if (x && x !== nil) {
          return 0;
        }

        return nil;
      }),
      ($Kernel_$lt_eq_gt$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$method",
      ($Kernel_method$6 = function $$method(name) {
        var self = this;

        var meth = self["$" + name];

        if (!meth || meth.$$stub) {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" +
                "undefined method `" +
                name +
                "' for class `" +
                self.$class() +
                "'",
              name
            )
          );
        }

        return $$($nesting, "Method").$new(
          self,
          meth.$$owner || self.$class(),
          meth,
          name
        );
      }),
      ($Kernel_method$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$methods",
      ($Kernel_methods$7 = function $$methods(all) {
        var self = this;

        if (all == null) {
          all = true;
        }

        if ($truthy(all)) {
          return Opal.methods(self);
        } else {
          return Opal.own_methods(self);
        }
      }),
      ($Kernel_methods$7.$$arity = -1)
    );

    Opal.def(
      self,
      "$public_methods",
      ($Kernel_public_methods$8 = function $$public_methods(all) {
        var self = this;

        if (all == null) {
          all = true;
        }

        if ($truthy(all)) {
          return Opal.methods(self);
        } else {
          return Opal.receiver_methods(self);
        }
      }),
      ($Kernel_public_methods$8.$$arity = -1)
    );

    Opal.def(
      self,
      "$Array",
      ($Kernel_Array$9 = function $$Array(object) {
        var self = this;

        var coerced;

        if (object === nil) {
          return [];
        }

        if (object.$$is_array) {
          return object;
        }

        coerced = $$($nesting, "Opal")["$coerce_to?"](
          object,
          $$($nesting, "Array"),
          "to_ary"
        );
        if (coerced !== nil) {
          return coerced;
        }

        coerced = $$($nesting, "Opal")["$coerce_to?"](
          object,
          $$($nesting, "Array"),
          "to_a"
        );
        if (coerced !== nil) {
          return coerced;
        }

        return [object];
      }),
      ($Kernel_Array$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$at_exit",
      ($Kernel_at_exit$10 = function $$at_exit() {
        var $iter = $Kernel_at_exit$10.$$p,
          block = $iter || nil,
          self = this,
          $ret_or_2 = nil;
        if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

        if ($iter) $Kernel_at_exit$10.$$p = null;

        if ($iter) $Kernel_at_exit$10.$$p = null;
        $gvars.__at_exit__ = (function () {
          if ($truthy(($ret_or_2 = $gvars.__at_exit__))) {
            return $ret_or_2;
          } else {
            return [];
          }
          return nil;
        })();
        $gvars.__at_exit__["$<<"](block);
        return block;
      }),
      ($Kernel_at_exit$10.$$arity = 0)
    );

    Opal.def(
      self,
      "$caller",
      ($Kernel_caller$11 = function $$caller(start, length) {
        var self = this;

        if (start == null) {
          start = 1;
        }

        if (length == null) {
          length = nil;
        }

        var stack, result;

        stack = new Error().$backtrace();
        result = [];

        for (var i = start + 1, ii = stack.length; i < ii; i++) {
          if (!stack[i].match(/runtime\.js/)) {
            result.push(stack[i]);
          }
        }
        if (length != nil) result = result.slice(0, length);
        return result;
      }),
      ($Kernel_caller$11.$$arity = -1)
    );

    Opal.def(
      self,
      "$class",
      ($Kernel_class$12 = function () {
        var self = this;

        return self.$$class;
      }),
      ($Kernel_class$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$copy_instance_variables",
      ($Kernel_copy_instance_variables$13 = function $$copy_instance_variables(
        other
      ) {
        var self = this;

        var keys = Object.keys(other),
          i,
          ii,
          name;
        for (i = 0, ii = keys.length; i < ii; i++) {
          name = keys[i];
          if (name.charAt(0) !== "$" && other.hasOwnProperty(name)) {
            self[name] = other[name];
          }
        }
      }),
      ($Kernel_copy_instance_variables$13.$$arity = 1)
    );

    Opal.def(
      self,
      "$copy_singleton_methods",
      ($Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(
        other
      ) {
        var self = this;

        var i, name, names, length;

        if (other.hasOwnProperty("$$meta")) {
          var other_singleton_class = Opal.get_singleton_class(other);
          var self_singleton_class = Opal.get_singleton_class(self);
          names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

          for (i = 0, length = names.length; i < length; i++) {
            name = names[i];
            if (Opal.is_method(name)) {
              self_singleton_class.$$prototype[name] =
                other_singleton_class.$$prototype[name];
            }
          }

          self_singleton_class.$$const = Object.assign(
            {},
            other_singleton_class.$$const
          );
          Object.setPrototypeOf(
            self_singleton_class.$$prototype,
            Object.getPrototypeOf(other_singleton_class.$$prototype)
          );
        }

        for (
          i = 0,
            names = Object.getOwnPropertyNames(other),
            length = names.length;
          i < length;
          i++
        ) {
          name = names[i];
          if (
            name.charAt(0) === "$" &&
            name.charAt(1) !== "$" &&
            other.hasOwnProperty(name)
          ) {
            self[name] = other[name];
          }
        }
      }),
      ($Kernel_copy_singleton_methods$14.$$arity = 1)
    );

    Opal.def(
      self,
      "$clone",
      ($Kernel_clone$15 = function $$clone($kwargs) {
        var freeze,
          self = this,
          copy = nil;

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        freeze = $kwargs.$$smap["freeze"];
        if (freeze == null) {
          freeze = true;
        }
        copy = self.$class().$allocate();
        copy.$copy_instance_variables(self);
        copy.$copy_singleton_methods(self);
        copy.$initialize_clone(self);
        return copy;
      }),
      ($Kernel_clone$15.$$arity = -1)
    );

    Opal.def(
      self,
      "$initialize_clone",
      ($Kernel_initialize_clone$16 = function $$initialize_clone(other) {
        var self = this;

        return self.$initialize_copy(other);
      }),
      ($Kernel_initialize_clone$16.$$arity = 1)
    );

    Opal.def(
      self,
      "$define_singleton_method",
      ($Kernel_define_singleton_method$17 = function $$define_singleton_method(
        name,
        method
      ) {
        var $iter = $Kernel_define_singleton_method$17.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Kernel_define_singleton_method$17.$$p = null;

        if ($iter) $Kernel_define_singleton_method$17.$$p = null;
        return $send(
          self.$singleton_class(),
          "define_method",
          [name, method],
          block.$to_proc()
        );
      }),
      ($Kernel_define_singleton_method$17.$$arity = -2)
    );

    Opal.def(
      self,
      "$dup",
      ($Kernel_dup$18 = function $$dup() {
        var self = this,
          copy = nil;

        copy = self.$class().$allocate();
        copy.$copy_instance_variables(self);
        copy.$initialize_dup(self);
        return copy;
      }),
      ($Kernel_dup$18.$$arity = 0)
    );

    Opal.def(
      self,
      "$initialize_dup",
      ($Kernel_initialize_dup$19 = function $$initialize_dup(other) {
        var self = this;

        return self.$initialize_copy(other);
      }),
      ($Kernel_initialize_dup$19.$$arity = 1)
    );

    Opal.def(
      self,
      "$enum_for",
      ($Kernel_enum_for$20 = function $$enum_for($a, $b) {
        var $iter = $Kernel_enum_for$20.$$p,
          block = $iter || nil,
          $post_args,
          method,
          args,
          self = this;

        if ($iter) $Kernel_enum_for$20.$$p = null;

        if ($iter) $Kernel_enum_for$20.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        }

        args = $post_args;
        return $send(
          $$($nesting, "Enumerator"),
          "for",
          [self, method].concat(Opal.to_a(args)),
          block.$to_proc()
        );
      }),
      ($Kernel_enum_for$20.$$arity = -1)
    );
    $alias(self, "to_enum", "enum_for");

    Opal.def(
      self,
      "$equal?",
      ($Kernel_equal$ques$21 = function (other) {
        var self = this;

        return self === other;
      }),
      ($Kernel_equal$ques$21.$$arity = 1)
    );

    Opal.def(
      self,
      "$exit",
      ($Kernel_exit$22 = function $$exit(status) {
        var $a,
          self = this,
          $ret_or_3 = nil,
          block = nil;
        if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

        if (status == null) {
          status = true;
        }
        $gvars.__at_exit__ = (function () {
          if ($truthy(($ret_or_3 = $gvars.__at_exit__))) {
            return $ret_or_3;
          } else {
            return [];
          }
          return nil;
        })();
        while (!$truthy($gvars.__at_exit__["$empty?"]())) {
          block = $gvars.__at_exit__.$pop();
          block.$call();
        }

        if (status.$$is_boolean) {
          status = status ? 0 : 1;
        } else {
          status = $coerce_to(status, $$($nesting, "Integer"), "to_int");
        }

        Opal.exit(status);
        return nil;
      }),
      ($Kernel_exit$22.$$arity = -1)
    );

    Opal.def(
      self,
      "$extend",
      ($Kernel_extend$23 = function $$extend($a) {
        var $post_args,
          mods,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        mods = $post_args;

        var singleton = self.$singleton_class();

        for (var i = mods.length - 1; i >= 0; i--) {
          var mod = mods[i];

          if (!mod.$$is_module) {
            self.$raise(
              $$($nesting, "TypeError"),
              "" + "wrong argument type " + mod.$class() + " (expected Module)"
            );
          }

          mod.$append_features(singleton);
          mod.$extend_object(self);
          mod.$extended(self);
        }
        return self;
      }),
      ($Kernel_extend$23.$$arity = -1)
    );

    Opal.def(
      self,
      "$gets",
      ($Kernel_gets$24 = function $$gets($a) {
        var $post_args,
          args,
          self = this;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        return $send($gvars.stdin, "gets", Opal.to_a(args));
      }),
      ($Kernel_gets$24.$$arity = -1)
    );

    Opal.def(
      self,
      "$hash",
      ($Kernel_hash$25 = function $$hash() {
        var self = this;

        return self.$__id__();
      }),
      ($Kernel_hash$25.$$arity = 0)
    );

    Opal.def(
      self,
      "$initialize_copy",
      ($Kernel_initialize_copy$26 = function $$initialize_copy(other) {
        var self = this;

        return nil;
      }),
      ($Kernel_initialize_copy$26.$$arity = 1)
    );

    Opal.def(
      self,
      "$inspect",
      ($Kernel_inspect$27 = function $$inspect() {
        var $$28,
          self = this,
          ivs = nil;

        try {
          ivs = "";
          $send(
            self.$instance_variables(),
            "each",
            [],
            (($$28 = function (i) {
              var self = $$28.$$s == null ? this : $$28.$$s;

              if (i == null) {
                i = nil;
              }
              return (ivs = $rb_plus(
                ivs,
                "" + " " + i + "=" + self.$instance_variable_get(i).$inspect()
              ));
            }),
            ($$28.$$s = self),
            ($$28.$$arity = 1),
            $$28)
          );
          return (
            "" +
            "#<" +
            self.$class() +
            ":0x" +
            self.$__id__().$to_s(16) +
            ivs +
            ">"
          );
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, "StandardError")])) {
            try {
              return (
                "" +
                "#<" +
                self.$class() +
                ":0x" +
                self.$__id__().$to_s(16) +
                ">"
              );
            } finally {
              Opal.pop_exception();
            }
          } else {
            throw $err;
          }
        }
      }),
      ($Kernel_inspect$27.$$arity = 0)
    );

    Opal.def(
      self,
      "$instance_of?",
      ($Kernel_instance_of$ques$29 = function (klass) {
        var self = this;

        if (!klass.$$is_class && !klass.$$is_module) {
          self.$raise($$($nesting, "TypeError"), "class or module required");
        }

        return self.$$class === klass;
      }),
      ($Kernel_instance_of$ques$29.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_variable_defined?",
      ($Kernel_instance_variable_defined$ques$30 = function (name) {
        var self = this;

        name = $$($nesting, "Opal")["$instance_variable_name!"](name);
        return Opal.hasOwnProperty.call(self, name.substr(1));
      }),
      ($Kernel_instance_variable_defined$ques$30.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_variable_get",
      ($Kernel_instance_variable_get$31 = function $$instance_variable_get(
        name
      ) {
        var self = this;

        name = $$($nesting, "Opal")["$instance_variable_name!"](name);

        var ivar = self[Opal.ivar(name.substr(1))];

        return ivar == null ? nil : ivar;
      }),
      ($Kernel_instance_variable_get$31.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_variable_set",
      ($Kernel_instance_variable_set$32 = function $$instance_variable_set(
        name,
        value
      ) {
        var self = this;

        name = $$($nesting, "Opal")["$instance_variable_name!"](name);
        return (self[Opal.ivar(name.substr(1))] = value);
      }),
      ($Kernel_instance_variable_set$32.$$arity = 2)
    );

    Opal.def(
      self,
      "$remove_instance_variable",
      ($Kernel_remove_instance_variable$33 =
        function $$remove_instance_variable(name) {
          var self = this;

          name = $$($nesting, "Opal")["$instance_variable_name!"](name);

          var key = Opal.ivar(name.substr(1)),
            val;
          if (self.hasOwnProperty(key)) {
            val = self[key];
            delete self[key];
            return val;
          }
          return self.$raise(
            $$($nesting, "NameError"),
            "" + "instance variable " + name + " not defined"
          );
        }),
      ($Kernel_remove_instance_variable$33.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_variables",
      ($Kernel_instance_variables$34 = function $$instance_variables() {
        var self = this;

        var result = [],
          ivar;

        for (var name in self) {
          if (self.hasOwnProperty(name) && name.charAt(0) !== "$") {
            if (name.substr(-1) === "$") {
              ivar = name.slice(0, name.length - 1);
            } else {
              ivar = name;
            }
            result.push("@" + ivar);
          }
        }

        return result;
      }),
      ($Kernel_instance_variables$34.$$arity = 0)
    );

    Opal.def(
      self,
      "$Integer",
      ($Kernel_Integer$35 = function $$Integer(value, base) {
        var self = this;

        var i, str, base_digits;

        if (!value.$$is_string) {
          if (base !== undefined) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "base specified for non string value"
            );
          }
          if (value === nil) {
            self.$raise(
              $$($nesting, "TypeError"),
              "can't convert nil into Integer"
            );
          }
          if (value.$$is_number) {
            if (value === Infinity || value === -Infinity || isNaN(value)) {
              self.$raise($$($nesting, "FloatDomainError"), value);
            }
            return Math.floor(value);
          }
          if (value["$respond_to?"]("to_int")) {
            i = value.$to_int();
            if (i !== nil) {
              return i;
            }
          }
          return $$($nesting, "Opal")["$coerce_to!"](
            value,
            $$($nesting, "Integer"),
            "to_i"
          );
        }

        if (value === "0") {
          return 0;
        }

        if (base === undefined) {
          base = 0;
        } else {
          base = $coerce_to(base, $$($nesting, "Integer"), "to_int");
          if (base === 1 || base < 0 || base > 36) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "invalid radix " + base
            );
          }
        }

        str = value.toLowerCase();

        str = str.replace(/(\d)_(?=\d)/g, "$1");

        str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
          switch (flag) {
            case "0b":
              if (base === 0 || base === 2) {
                base = 2;
                return head;
              }
            // no-break
            case "0":
            case "0o":
              if (base === 0 || base === 8) {
                base = 8;
                return head;
              }
            // no-break
            case "0d":
              if (base === 0 || base === 10) {
                base = 10;
                return head;
              }
            // no-break
            case "0x":
              if (base === 0 || base === 16) {
                base = 16;
                return head;
              }
            // no-break
          }
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + 'invalid value for Integer(): "' + value + '"'
          );
        });

        base = base === 0 ? 10 : base;

        base_digits =
          "0-" +
          (base <= 10
            ? base - 1
            : "9a-" + String.fromCharCode(97 + (base - 11)));

        if (!new RegExp("^\\s*[+-]?[" + base_digits + "]+\\s*$").test(str)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + 'invalid value for Integer(): "' + value + '"'
          );
        }

        i = parseInt(str, base);

        if (isNaN(i)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + 'invalid value for Integer(): "' + value + '"'
          );
        }

        return i;
      }),
      ($Kernel_Integer$35.$$arity = -2)
    );

    Opal.def(
      self,
      "$Float",
      ($Kernel_Float$36 = function $$Float(value) {
        var self = this;

        var str;

        if (value === nil) {
          self.$raise(
            $$($nesting, "TypeError"),
            "can't convert nil into Float"
          );
        }

        if (value.$$is_string) {
          str = value.toString();

          str = str.replace(/(\d)_(?=\d)/g, "$1");

          //Special case for hex strings only:
          if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
            return self.$Integer(str);
          }

          if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + 'invalid value for Float(): "' + value + '"'
            );
          }

          return parseFloat(str);
        }

        return $$($nesting, "Opal")["$coerce_to!"](
          value,
          $$($nesting, "Float"),
          "to_f"
        );
      }),
      ($Kernel_Float$36.$$arity = 1)
    );

    Opal.def(
      self,
      "$Hash",
      ($Kernel_Hash$37 = function $$Hash(arg) {
        var self = this,
          $ret_or_4 = nil;

        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_4 = arg["$nil?"]()))) {
                return $ret_or_4;
              } else {
                return arg["$=="]([]);
              }
              return nil;
            })()
          )
        ) {
          return $hash2([], {});
        }
        if ($truthy($$($nesting, "Hash")["$==="](arg))) {
          return arg;
        }
        return $$($nesting, "Opal")["$coerce_to!"](
          arg,
          $$($nesting, "Hash"),
          "to_hash"
        );
      }),
      ($Kernel_Hash$37.$$arity = 1)
    );

    Opal.def(
      self,
      "$is_a?",
      ($Kernel_is_a$ques$38 = function (klass) {
        var self = this;

        if (!klass.$$is_class && !klass.$$is_module) {
          self.$raise($$($nesting, "TypeError"), "class or module required");
        }

        return Opal.is_a(self, klass);
      }),
      ($Kernel_is_a$ques$38.$$arity = 1)
    );

    Opal.def(
      self,
      "$itself",
      ($Kernel_itself$39 = function $$itself() {
        var self = this;

        return self;
      }),
      ($Kernel_itself$39.$$arity = 0)
    );
    $alias(self, "kind_of?", "is_a?");

    Opal.def(
      self,
      "$lambda",
      ($Kernel_lambda$40 = function $$lambda() {
        var $iter = $Kernel_lambda$40.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Kernel_lambda$40.$$p = null;

        if ($iter) $Kernel_lambda$40.$$p = null;
        return Opal.lambda(block);
      }),
      ($Kernel_lambda$40.$$arity = 0)
    );

    Opal.def(
      self,
      "$load",
      ($Kernel_load$41 = function $$load(file) {
        var self = this;

        file = $$($nesting, "Opal")["$coerce_to!"](
          file,
          $$($nesting, "String"),
          "to_str"
        );
        return Opal.load(file);
      }),
      ($Kernel_load$41.$$arity = 1)
    );

    Opal.def(
      self,
      "$loop",
      ($Kernel_loop$42 = function $$loop() {
        var $$43,
          $a,
          $iter = $Kernel_loop$42.$$p,
          $yield = $iter || nil,
          self = this,
          e = nil;

        if ($iter) $Kernel_loop$42.$$p = null;

        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["loop"],
            (($$43 = function () {
              var self = $$43.$$s == null ? this : $$43.$$s;

              return $$$($$($nesting, "Float"), "INFINITY");
            }),
            ($$43.$$s = self),
            ($$43.$$arity = 0),
            $$43)
          );
        }
        while ($truthy(true)) {
          try {
            Opal.yieldX($yield, []);
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, "StopIteration")])) {
              e = $err;
              try {
                return e.$result();
              } finally {
                Opal.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        }
        return self;
      }),
      ($Kernel_loop$42.$$arity = 0)
    );

    Opal.def(
      self,
      "$nil?",
      ($Kernel_nil$ques$44 = function () {
        var self = this;

        return false;
      }),
      ($Kernel_nil$ques$44.$$arity = 0)
    );
    $alias(self, "object_id", "__id__");

    Opal.def(
      self,
      "$printf",
      ($Kernel_printf$45 = function $$printf($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if ($truthy(args["$any?"]())) {
          self.$print($send(self, "format", Opal.to_a(args)));
        }
        return nil;
      }),
      ($Kernel_printf$45.$$arity = -1)
    );

    Opal.def(
      self,
      "$proc",
      ($Kernel_proc$46 = function $$proc() {
        var $iter = $Kernel_proc$46.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Kernel_proc$46.$$p = null;

        if ($iter) $Kernel_proc$46.$$p = null;
        if ($truthy(block)) {
        } else {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "tried to create Proc object without a block"
          );
        }
        block.$$is_lambda = false;
        return block;
      }),
      ($Kernel_proc$46.$$arity = 0)
    );

    Opal.def(
      self,
      "$puts",
      ($Kernel_puts$47 = function $$puts($a) {
        var $post_args,
          strs,
          self = this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        strs = $post_args;
        return $send($gvars.stdout, "puts", Opal.to_a(strs));
      }),
      ($Kernel_puts$47.$$arity = -1)
    );

    Opal.def(
      self,
      "$p",
      ($Kernel_p$48 = function $$p($a) {
        var $post_args,
          args,
          $$49,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        $send(
          args,
          "each",
          [],
          (($$49 = function (obj) {
            var self = $$49.$$s == null ? this : $$49.$$s;
            if ($gvars.stdout == null) $gvars.stdout = nil;

            if (obj == null) {
              obj = nil;
            }
            return $gvars.stdout.$puts(obj.$inspect());
          }),
          ($$49.$$s = self),
          ($$49.$$arity = 1),
          $$49)
        );
        if ($truthy($rb_le(args.$length(), 1))) {
          return args["$[]"](0);
        } else {
          return args;
        }
      }),
      ($Kernel_p$48.$$arity = -1)
    );

    Opal.def(
      self,
      "$print",
      ($Kernel_print$50 = function $$print($a) {
        var $post_args,
          strs,
          self = this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        strs = $post_args;
        return $send($gvars.stdout, "print", Opal.to_a(strs));
      }),
      ($Kernel_print$50.$$arity = -1)
    );

    Opal.def(
      self,
      "$readline",
      ($Kernel_readline$51 = function $$readline($a) {
        var $post_args,
          args,
          self = this;
        if ($gvars.stdin == null) $gvars.stdin = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        return $send($gvars.stdin, "readline", Opal.to_a(args));
      }),
      ($Kernel_readline$51.$$arity = -1)
    );

    Opal.def(
      self,
      "$warn",
      ($Kernel_warn$52 = function $$warn($a, $b) {
        var $post_args,
          $kwargs,
          strs,
          uplevel,
          $c,
          $d,
          $$53,
          self = this,
          location = nil,
          $ret_or_5 = nil;
        if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $kwargs = Opal.extract_kwargs($post_args);

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        strs = $post_args;

        uplevel = $kwargs.$$smap["uplevel"];
        if (uplevel == null) {
          uplevel = nil;
        }
        if ($truthy(uplevel)) {
          uplevel = $$($nesting, "Opal")["$coerce_to!"](
            uplevel,
            $$($nesting, "Integer"),
            "to_str"
          );
          if ($truthy($rb_lt(uplevel, 0))) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "negative level (" + uplevel + ")"
            );
          }
          location =
            (($d =
              (($c = self.$caller($rb_plus(uplevel, 1), 1).$first()),
              $c === nil || $c == null ? nil : $send($c, "split", [":in `"]))),
            $d === nil || $d == null ? nil : $send($d, "first", []));
          if ($truthy(location)) {
            location = "" + location + ": ";
          }
          strs = $send(
            strs,
            "map",
            [],
            (($$53 = function (s) {
              var self = $$53.$$s == null ? this : $$53.$$s;

              if (s == null) {
                s = nil;
              }
              return "" + location + "warning: " + s;
            }),
            ($$53.$$s = self),
            ($$53.$$arity = 1),
            $$53)
          );
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_5 = $gvars.VERBOSE["$nil?"]()))) {
                return $ret_or_5;
              } else {
                return strs["$empty?"]();
              }
              return nil;
            })()
          )
        ) {
          return nil;
        } else {
          return $send($gvars.stderr, "puts", Opal.to_a(strs));
        }
      }),
      ($Kernel_warn$52.$$arity = -1)
    );

    Opal.def(
      self,
      "$raise",
      ($Kernel_raise$54 = function $$raise(exception, string, backtrace) {
        var self = this;
        if ($gvars["!"] == null) $gvars["!"] = nil;
        if ($gvars["@"] == null) $gvars["@"] = nil;

        if (string == null) {
          string = nil;
        }

        if (backtrace == null) {
          backtrace = nil;
        }

        if (exception == null && $gvars["!"] !== nil) {
          throw $gvars["!"];
        }
        if (exception == null) {
          exception = $$($nesting, "RuntimeError").$new("");
        } else if ($respond_to(exception, "$to_str")) {
          exception = $$($nesting, "RuntimeError").$new(exception.$to_str());
        }
        // using respond_to? and not an undefined check to avoid method_missing matching as true
        else if (exception.$$is_class && $respond_to(exception, "$exception")) {
          exception = exception.$exception(string);
        } else if (exception.$$is_exception) {
          // exception is fine
        } else {
          exception = $$($nesting, "TypeError").$new(
            "exception class/object expected"
          );
        }

        if (backtrace !== nil) {
          exception.$set_backtrace(backtrace);
        }

        if ($gvars["!"] !== nil) {
          Opal.exceptions.push($gvars["!"]);
        }

        $gvars["!"] = exception;
        $gvars["@"] = exception.$backtrace();

        throw exception;
      }),
      ($Kernel_raise$54.$$arity = -1)
    );
    $alias(self, "fail", "raise");

    Opal.def(
      self,
      "$rand",
      ($Kernel_rand$55 = function $$rand(max) {
        var self = this;

        if (max === undefined) {
          return $$$($$($nesting, "Random"), "DEFAULT").$rand();
        }

        if (max.$$is_number) {
          if (max < 0) {
            max = Math.abs(max);
          }

          if (max % 1 !== 0) {
            max = max.$to_i();
          }

          if (max === 0) {
            max = undefined;
          }
        }
        return $$$($$($nesting, "Random"), "DEFAULT").$rand(max);
      }),
      ($Kernel_rand$55.$$arity = -1)
    );

    Opal.def(
      self,
      "$respond_to?",
      ($Kernel_respond_to$ques$56 = function (name, include_all) {
        var self = this;

        if (include_all == null) {
          include_all = false;
        }

        var body = self["$" + name];

        if (typeof body === "function" && !body.$$stub) {
          return true;
        }

        if (self["$respond_to_missing?"].$$pristine === true) {
          return false;
        } else {
          return self["$respond_to_missing?"](name, include_all);
        }
      }),
      ($Kernel_respond_to$ques$56.$$arity = -2)
    );

    Opal.def(
      self,
      "$respond_to_missing?",
      ($Kernel_respond_to_missing$ques$57 = function (
        method_name,
        include_all
      ) {
        var self = this;

        if (include_all == null) {
          include_all = false;
        }
        return false;
      }),
      ($Kernel_respond_to_missing$ques$57.$$arity = -2)
    );
    $$($nesting, "Opal").$pristine(self, "respond_to?", "respond_to_missing?");

    Opal.def(
      self,
      "$require",
      ($Kernel_require$58 = function $$require(file) {
        var self = this;

        // As Object.require refers to Kernel.require once Kernel has been loaded the String
        // class may not be available yet, the coercion requires both  String and Array to be loaded.
        if (typeof file !== "string" && Opal.String && Opal.Array) {
          file = $$($nesting, "Opal")["$coerce_to!"](
            file,
            $$($nesting, "String"),
            "to_str"
          );
        }
        return Opal.require(file);
      }),
      ($Kernel_require$58.$$arity = 1)
    );

    Opal.def(
      self,
      "$require_relative",
      ($Kernel_require_relative$59 = function $$require_relative(file) {
        var self = this;

        $$($nesting, "Opal")["$try_convert!"](
          file,
          $$($nesting, "String"),
          "to_str"
        );
        file = $$($nesting, "File").$expand_path(
          $$($nesting, "File").$join(Opal.current_file, "..", file)
        );
        return Opal.require(file);
      }),
      ($Kernel_require_relative$59.$$arity = 1)
    );

    Opal.def(
      self,
      "$require_tree",
      ($Kernel_require_tree$60 = function $$require_tree(path, $kwargs) {
        var autoload,
          self = this;

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        autoload = $kwargs.$$smap["autoload"];
        if (autoload == null) {
          autoload = false;
        }

        var result = [];

        path = $$($nesting, "File").$expand_path(path);
        path = Opal.normalize(path);
        if (path === ".") path = "";
        for (var name in Opal.modules) {
          if (name["$start_with?"](path)) {
            if (!autoload) {
              result.push([name, Opal.require(name)]);
            } else {
              result.push([name, true]); // do nothing, delegated to a autoloading
            }
          }
        }

        return result;
      }),
      ($Kernel_require_tree$60.$$arity = -2)
    );
    $alias(self, "send", "__send__");
    $alias(self, "public_send", "__send__");

    Opal.def(
      self,
      "$singleton_class",
      ($Kernel_singleton_class$61 = function $$singleton_class() {
        var self = this;

        return Opal.get_singleton_class(self);
      }),
      ($Kernel_singleton_class$61.$$arity = 0)
    );

    Opal.def(
      self,
      "$sleep",
      ($Kernel_sleep$62 = function $$sleep(seconds) {
        var self = this;

        if (seconds == null) {
          seconds = nil;
        }

        if (seconds === nil) {
          self.$raise(
            $$($nesting, "TypeError"),
            "can't convert NilClass into time interval"
          );
        }
        if (!seconds.$$is_number) {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "can't convert " + seconds.$class() + " into time interval"
          );
        }
        if (seconds < 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "time interval must be positive"
          );
        }
        var get_time = Opal.global.performance
          ? function () {
              return performance.now();
            }
          : function () {
              return new Date();
            };

        var t = get_time();
        while (get_time() - t <= seconds * 1000);
        return Math.round(seconds);
      }),
      ($Kernel_sleep$62.$$arity = -1)
    );

    Opal.def(
      self,
      "$srand",
      ($Kernel_srand$63 = function $$srand(seed) {
        var self = this;

        if (seed == null) {
          seed = $$($nesting, "Random").$new_seed();
        }
        return $$($nesting, "Random").$srand(seed);
      }),
      ($Kernel_srand$63.$$arity = -1)
    );

    Opal.def(
      self,
      "$String",
      ($Kernel_String$64 = function $$String(str) {
        var self = this,
          $ret_or_6 = nil;

        if (
          $truthy(
            ($ret_or_6 = $$($nesting, "Opal")["$coerce_to?"](
              str,
              $$($nesting, "String"),
              "to_str"
            ))
          )
        ) {
          return $ret_or_6;
        } else {
          return $$($nesting, "Opal")["$coerce_to!"](
            str,
            $$($nesting, "String"),
            "to_s"
          );
        }
      }),
      ($Kernel_String$64.$$arity = 1)
    );

    Opal.def(
      self,
      "$tap",
      ($Kernel_tap$65 = function $$tap() {
        var $iter = $Kernel_tap$65.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Kernel_tap$65.$$p = null;

        if ($iter) $Kernel_tap$65.$$p = null;
        Opal.yield1(block, self);
        return self;
      }),
      ($Kernel_tap$65.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_proc",
      ($Kernel_to_proc$66 = function $$to_proc() {
        var self = this;

        return self;
      }),
      ($Kernel_to_proc$66.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Kernel_to_s$67 = function $$to_s() {
        var self = this;

        return (
          "" + "#<" + self.$class() + ":0x" + self.$__id__().$to_s(16) + ">"
        );
      }),
      ($Kernel_to_s$67.$$arity = 0)
    );

    Opal.def(
      self,
      "$catch",
      ($Kernel_catch$68 = function (tag) {
        var $iter = $Kernel_catch$68.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_7 = nil,
          e = nil;

        if ($iter) $Kernel_catch$68.$$p = null;

        if (tag == null) {
          tag = nil;
        }
        try {
          tag = (function () {
            if ($truthy(($ret_or_7 = tag))) {
              return $ret_or_7;
            } else {
              return $$($nesting, "Object").$new();
            }
            return nil;
          })();
          return Opal.yield1($yield, tag);
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, "UncaughtThrowError")])) {
            e = $err;
            try {
              if (e.$tag()["$=="](tag)) {
                return e.$value();
              }
              return self.$raise();
            } finally {
              Opal.pop_exception();
            }
          } else {
            throw $err;
          }
        }
      }),
      ($Kernel_catch$68.$$arity = -1)
    );

    Opal.def(
      self,
      "$throw",
      ($Kernel_throw$69 = function (tag, obj) {
        var self = this;

        if (obj == null) {
          obj = nil;
        }
        return self.$raise($$($nesting, "UncaughtThrowError").$new(tag, obj));
      }),
      ($Kernel_throw$69.$$arity = -2)
    );

    Opal.def(
      self,
      "$open",
      ($Kernel_open$70 = function $$open($a) {
        var $iter = $Kernel_open$70.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Kernel_open$70.$$p = null;

        if ($iter) $Kernel_open$70.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        return $send(
          $$($nesting, "File"),
          "open",
          Opal.to_a(args),
          block.$to_proc()
        );
      }),
      ($Kernel_open$70.$$arity = -1)
    );

    Opal.def(
      self,
      "$yield_self",
      ($Kernel_yield_self$71 = function $$yield_self() {
        var $$72,
          $iter = $Kernel_yield_self$71.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Kernel_yield_self$71.$$p = null;

        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["yield_self"],
            (($$72 = function () {
              var self = $$72.$$s == null ? this : $$72.$$s;

              return 1;
            }),
            ($$72.$$s = self),
            ($$72.$$arity = 0),
            $$72)
          );
        }
        return Opal.yield1($yield, self);
      }),
      ($Kernel_yield_self$71.$$arity = 0)
    );
    $alias(self, "then", "yield_self");
    return $$($nesting, "Opal").$pristine(self, "method_missing");
  })($nesting[0], $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Object");

    var $nesting = [self].concat($parent_nesting);

    delete Opal.Object.$$prototype.$require;
    return self.$include($$($nesting, "Kernel"));
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/error"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $gvars = Opal.gvars,
    $send = Opal.send,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $module = Opal.module,
    $send2 = Opal.send2,
    $find_super = Opal.find_super;

  Opal.add_stubs([
    "$new",
    "$map",
    "$backtrace",
    "$clone",
    "$to_s",
    "$tty?",
    "$include?",
    "$raise",
    "$dup",
    "$!",
    "$empty?",
    "$caller",
    "$shift",
    "$+",
    "$class",
    "$join",
    "$cause",
    "$full_message",
    "$==",
    "$reverse",
    "$split",
    "$attr_reader",
    "$inspect",
  ]);

  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Exception");

    var $nesting = [self].concat($parent_nesting),
      $Exception_new$1,
      $Exception_exception$2,
      $Exception_initialize$3,
      $Exception_backtrace$4,
      $Exception_backtrace_locations$5,
      $Exception_cause$7,
      $Exception_exception$8,
      $Exception_message$9,
      $Exception_full_message$10,
      $Exception_inspect$12,
      $Exception_set_backtrace$13,
      $Exception_to_s$15;

    self.$$prototype.message = nil;

    Opal.defineProperty(self.$$prototype, "$$is_exception", true);
    var stack_trace_limit;
    Opal.defs(
      self,
      "$new",
      ($Exception_new$1 = function ($a) {
        var $post_args,
          args,
          self = this;
        if ($gvars["!"] == null) $gvars["!"] = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        var message = args.length > 0 ? args[0] : nil;
        var error = new self.$$constructor(message);
        error.name = self.$$name;
        error.message = message;
        error.cause = $gvars["!"];
        Opal.send(error, error.$initialize, args);

        // Error.captureStackTrace() will use .name and .toString to build the
        // first line of the stack trace so it must be called after the error
        // has been initialized.
        // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
        if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
          // Passing Kernel.raise will cut the stack trace from that point above
          Error.captureStackTrace(error, stack_trace_limit);
        }

        return error;
      }),
      ($Exception_new$1.$$arity = -1)
    );
    stack_trace_limit = self.$new;
    Opal.defs(
      self,
      "$exception",
      ($Exception_exception$2 = function $$exception($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        return $send(self, "new", Opal.to_a(args));
      }),
      ($Exception_exception$2.$$arity = -1)
    );

    Opal.def(
      self,
      "$initialize",
      ($Exception_initialize$3 = function $$initialize($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        return (self.message = args.length > 0 ? args[0] : nil);
      }),
      ($Exception_initialize$3.$$arity = -1)
    );

    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [],
        m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        } else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          /* Chromium format */
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        } else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        } else if ((m = loc.match(/^  from (.*?)$/))) {
          /* Node format */
          new_bt.push(m[1]);
        } else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          /* Mozilla/Apple format */
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
      }

      return new_bt;
    }
    Opal.def(
      self,
      "$backtrace",
      ($Exception_backtrace$4 = function $$backtrace() {
        var self = this;

        if (self.backtrace) {
          // nil is a valid backtrace
          return self.backtrace;
        }

        var backtrace = self.stack;

        if (typeof backtrace !== "undefined" && backtrace.$$is_string) {
          return (self.backtrace = correct_backtrace(
            backtrace.split("\n").slice(0, 15)
          ));
        } else if (backtrace) {
          return (self.backtrace = correct_backtrace(backtrace.slice(0, 15)));
        }

        return [];
      }),
      ($Exception_backtrace$4.$$arity = 0)
    );

    Opal.def(
      self,
      "$backtrace_locations",
      ($Exception_backtrace_locations$5 = function $$backtrace_locations() {
        var $a,
          $$6,
          self = this;

        if (self.backtrace_locations) return self.backtrace_locations;
        self.backtrace_locations =
          (($a = self.$backtrace()),
          $a === nil || $a == null
            ? nil
            : $send(
                $a,
                "map",
                [],
                (($$6 = function (loc) {
                  var self = $$6.$$s == null ? this : $$6.$$s;

                  if (loc == null) {
                    loc = nil;
                  }
                  return $$$(
                    $$$($$$("::", "Thread"), "Backtrace"),
                    "Location"
                  ).$new(loc);
                }),
                ($$6.$$s = self),
                ($$6.$$arity = 1),
                $$6)
              ));
        return self.backtrace_locations;
      }),
      ($Exception_backtrace_locations$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$cause",
      ($Exception_cause$7 = function $$cause() {
        var self = this;

        return self.cause || nil;
      }),
      ($Exception_cause$7.$$arity = 0)
    );

    Opal.def(
      self,
      "$exception",
      ($Exception_exception$8 = function $$exception(str) {
        var self = this;

        if (str == null) {
          str = nil;
        }

        if (str === nil || self === str) {
          return self;
        }

        var cloned = self.$clone();
        cloned.message = str;
        if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
        cloned.stack = self.stack;
        cloned.cause = self.cause;
        return cloned;
      }),
      ($Exception_exception$8.$$arity = -1)
    );

    Opal.def(
      self,
      "$message",
      ($Exception_message$9 = function $$message() {
        var self = this;

        return self.$to_s();
      }),
      ($Exception_message$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$full_message",
      ($Exception_full_message$10 = function $$full_message($kwargs) {
        var highlight,
          order,
          $$11,
          self = this,
          bold_underline = nil,
          bold = nil,
          reset = nil,
          bt = nil,
          $ret_or_1 = nil,
          first = nil,
          msg = nil;
        if ($gvars.stderr == null) $gvars.stderr = nil;

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        highlight = $kwargs.$$smap["highlight"];
        if (highlight == null) {
          highlight = $gvars.stderr["$tty?"]();
        }

        order = $kwargs.$$smap["order"];
        if (order == null) {
          order = "top";
        }
        if ($truthy([true, false]["$include?"](highlight))) {
        } else {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "expected true or false as highlight: " + highlight
          );
        }
        if ($truthy(["top", "bottom"]["$include?"](order))) {
        } else {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "expected :top or :bottom as order: " + order
          );
        }
        if ($truthy(highlight)) {
          bold_underline = "\u001b[1;4m";
          bold = "\u001b[1m";
          reset = "\u001b[m";
        } else {
          bold_underline = bold = reset = "";
        }
        bt = self.$backtrace().$dup();
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_1 = bt["$!"]()))) {
                return $ret_or_1;
              } else {
                return bt["$empty?"]();
              }
              return nil;
            })()
          )
        ) {
          bt = self.$caller();
        }
        first = bt.$shift();
        msg = "" + first + ": ";
        msg = $rb_plus(
          msg,
          "" +
            bold +
            self.$to_s() +
            " (" +
            bold_underline +
            self.$class() +
            reset +
            bold +
            ")" +
            reset +
            "\n"
        );
        msg = $rb_plus(
          msg,
          $send(
            bt,
            "map",
            [],
            (($$11 = function (loc) {
              var self = $$11.$$s == null ? this : $$11.$$s;

              if (loc == null) {
                loc = nil;
              }
              return "" + "\tfrom " + loc + "\n";
            }),
            ($$11.$$s = self),
            ($$11.$$arity = 1),
            $$11)
          ).$join()
        );
        if ($truthy(self.$cause())) {
          msg = $rb_plus(
            msg,
            self
              .$cause()
              .$full_message($hash2(["highlight"], { highlight: highlight }))
          );
        }
        if (order["$=="]("bottom")) {
          msg = msg.$split("\n").$reverse().$join("\n");
          msg = $rb_plus(
            "" + bold + "Traceback" + reset + " (most recent call last):\n",
            msg
          );
        }
        return msg;
      }),
      ($Exception_full_message$10.$$arity = -1)
    );

    Opal.def(
      self,
      "$inspect",
      ($Exception_inspect$12 = function $$inspect() {
        var self = this,
          as_str = nil;

        as_str = self.$to_s();
        if ($truthy(as_str["$empty?"]())) {
          return self.$class().$to_s();
        } else {
          return "" + "#<" + self.$class().$to_s() + ": " + self.$to_s() + ">";
        }
      }),
      ($Exception_inspect$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$set_backtrace",
      ($Exception_set_backtrace$13 = function $$set_backtrace(backtrace) {
        var $$14,
          self = this;

        var valid = true,
          i,
          ii;

        if (backtrace === nil) {
          self.backtrace = nil;
          self.stack = "";
        } else if (backtrace.$$is_string) {
          self.backtrace = [backtrace];
          self.stack = "  from " + backtrace;
        } else {
          if (backtrace.$$is_array) {
            for (i = 0, ii = backtrace.length; i < ii; i++) {
              if (!backtrace[i].$$is_string) {
                valid = false;
                break;
              }
            }
          } else {
            valid = false;
          }

          if (valid === false) {
            self.$raise(
              $$($nesting, "TypeError"),
              "backtrace must be Array of String"
            );
          }

          self.backtrace = backtrace;
          self.stack = $send(
            backtrace,
            "map",
            [],
            (($$14 = function (i) {
              var self = $$14.$$s == null ? this : $$14.$$s;

              if (i == null) {
                i = nil;
              }
              return $rb_plus("  from ", i);
            }),
            ($$14.$$s = self),
            ($$14.$$arity = 1),
            $$14)
          ).join("\n");
        }

        return backtrace;
      }),
      ($Exception_set_backtrace$13.$$arity = 1)
    );
    return (
      (Opal.def(
        self,
        "$to_s",
        ($Exception_to_s$15 = function $$to_s() {
          var self = this,
            $ret_or_2 = nil,
            $ret_or_3 = nil;

          if (
            $truthy(
              ($ret_or_2 = (function () {
                if ($truthy(($ret_or_3 = self.message))) {
                  return self.message.$to_s();
                } else {
                  return $ret_or_3;
                }
                return nil;
              })())
            )
          ) {
            return $ret_or_2;
          } else {
            return self.$class().$to_s();
          }
        }),
        ($Exception_to_s$15.$$arity = 0)
      ),
      nil) && "to_s"
    );
  })($nesting[0], Error, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "ScriptError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Exception"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "SyntaxError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "ScriptError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "LoadError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "ScriptError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NotImplementedError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "ScriptError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "SystemExit");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Exception"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NoMemoryError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Exception"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "SignalException");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Exception"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Interrupt");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "SignalException"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "SecurityError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Exception"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "SystemStackError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Exception"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "StandardError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Exception"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "EncodingError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "ZeroDivisionError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NameError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NoMethodError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "NameError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "RuntimeError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "FrozenError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "RuntimeError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "LocalJumpError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "TypeError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "ArgumentError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "UncaughtThrowError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "ArgumentError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "IndexError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "StopIteration");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "IndexError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "ClosedQueueError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StopIteration"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "KeyError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "IndexError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "RangeError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "FloatDomainError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "RangeError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "IOError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "EOFError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "IOError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "SystemCallError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "RegexpError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "ThreadError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "FiberError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $parent_nesting) {
    var self = $module($base, "Errno");

    var $nesting = [self].concat($parent_nesting);

    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "EINVAL");

      var $nesting = [self].concat($parent_nesting),
        $EINVAL_new$16;

      return (
        (Opal.defs(
          self,
          "$new",
          ($EINVAL_new$16 = function (name) {
            var $iter = $EINVAL_new$16.$$p,
              $yield = $iter || nil,
              self = this,
              message = nil;

            if ($iter) $EINVAL_new$16.$$p = null;

            if (name == null) {
              name = nil;
            }
            message = "Invalid argument";
            if ($truthy(name)) {
              message = $rb_plus(message, "" + " - " + name);
            }
            return $send2(
              self,
              $find_super(self, "new", $EINVAL_new$16, false, true),
              "new",
              [message],
              null
            );
          }),
          ($EINVAL_new$16.$$arity = -1)
        ),
        nil) && "new"
      );
    })($nesting[0], $$($nesting, "SystemCallError"), $nesting);
  })($nesting[0], $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "UncaughtThrowError");

    var $nesting = [self].concat($parent_nesting),
      $UncaughtThrowError_initialize$17;

    self.$$prototype.tag = nil;

    self.$attr_reader("tag", "value");
    return (
      (Opal.def(
        self,
        "$initialize",
        ($UncaughtThrowError_initialize$17 = function $$initialize(tag, value) {
          var $iter = $UncaughtThrowError_initialize$17.$$p,
            $yield = $iter || nil,
            self = this;

          if ($iter) $UncaughtThrowError_initialize$17.$$p = null;

          if (value == null) {
            value = nil;
          }
          self.tag = tag;
          self.value = value;
          return $send2(
            self,
            $find_super(
              self,
              "initialize",
              $UncaughtThrowError_initialize$17,
              false,
              true
            ),
            "initialize",
            ["" + "uncaught throw " + self.tag.$inspect()],
            null
          );
        }),
        ($UncaughtThrowError_initialize$17.$$arity = -2)
      ),
      nil) && "initialize"
    );
  })($nesting[0], $$($nesting, "ArgumentError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NameError");

    var $nesting = [self].concat($parent_nesting),
      $NameError_initialize$18;

    self.$attr_reader("name");
    return (
      (Opal.def(
        self,
        "$initialize",
        ($NameError_initialize$18 = function $$initialize(message, name) {
          var $iter = $NameError_initialize$18.$$p,
            $yield = $iter || nil,
            self = this;

          if ($iter) $NameError_initialize$18.$$p = null;

          if (name == null) {
            name = nil;
          }
          $send2(
            self,
            $find_super(
              self,
              "initialize",
              $NameError_initialize$18,
              false,
              true
            ),
            "initialize",
            [message],
            null
          );
          return (self.name = name);
        }),
        ($NameError_initialize$18.$$arity = -2)
      ),
      nil) && "initialize"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NoMethodError");

    var $nesting = [self].concat($parent_nesting),
      $NoMethodError_initialize$19;

    self.$attr_reader("args");
    return (
      (Opal.def(
        self,
        "$initialize",
        ($NoMethodError_initialize$19 = function $$initialize(
          message,
          name,
          args
        ) {
          var $iter = $NoMethodError_initialize$19.$$p,
            $yield = $iter || nil,
            self = this;

          if ($iter) $NoMethodError_initialize$19.$$p = null;

          if (name == null) {
            name = nil;
          }

          if (args == null) {
            args = [];
          }
          $send2(
            self,
            $find_super(
              self,
              "initialize",
              $NoMethodError_initialize$19,
              false,
              true
            ),
            "initialize",
            [message, name],
            null
          );
          return (self.args = args);
        }),
        ($NoMethodError_initialize$19.$$arity = -2)
      ),
      nil) && "initialize"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "StopIteration");

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result");
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "KeyError");

    var $nesting = [self].concat($parent_nesting),
      $KeyError_initialize$20,
      $KeyError_receiver$21,
      $KeyError_key$22;

    self.$$prototype.receiver = self.$$prototype.key = nil;

    Opal.def(
      self,
      "$initialize",
      ($KeyError_initialize$20 = function $$initialize(message, $kwargs) {
        var receiver,
          key,
          $iter = $KeyError_initialize$20.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $KeyError_initialize$20.$$p = null;

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        receiver = $kwargs.$$smap["receiver"];
        if (receiver == null) {
          receiver = nil;
        }

        key = $kwargs.$$smap["key"];
        if (key == null) {
          key = nil;
        }
        $send2(
          self,
          $find_super(self, "initialize", $KeyError_initialize$20, false, true),
          "initialize",
          [message],
          null
        );
        self.receiver = receiver;
        return (self.key = key);
      }),
      ($KeyError_initialize$20.$$arity = -2)
    );

    Opal.def(
      self,
      "$receiver",
      ($KeyError_receiver$21 = function $$receiver() {
        var self = this,
          $ret_or_4 = nil;

        if ($truthy(($ret_or_4 = self.receiver))) {
          return $ret_or_4;
        } else {
          return self.$raise(
            $$($nesting, "ArgumentError"),
            "no receiver is available"
          );
        }
      }),
      ($KeyError_receiver$21.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$key",
        ($KeyError_key$22 = function $$key() {
          var self = this,
            $ret_or_5 = nil;

          if ($truthy(($ret_or_5 = self.key))) {
            return $ret_or_5;
          } else {
            return self.$raise(
              $$($nesting, "ArgumentError"),
              "no key is available"
            );
          }
        }),
        ($KeyError_key$22.$$arity = 0)
      ),
      nil) && "key"
    );
  })($nesting[0], null, $nesting);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "JS");

    var $nesting = [self].concat($parent_nesting);

    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Error");

      var $nesting = [self].concat($parent_nesting);

      return nil;
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["corelib/constants"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.const_set($nesting[0], "RUBY_PLATFORM", "opal");
  Opal.const_set($nesting[0], "RUBY_ENGINE", "opal");
  Opal.const_set($nesting[0], "RUBY_VERSION", "3.0.2");
  Opal.const_set($nesting[0], "RUBY_ENGINE_VERSION", "1.3.1");
  Opal.const_set($nesting[0], "RUBY_RELEASE_DATE", "2021-11-03");
  Opal.const_set($nesting[0], "RUBY_PATCHLEVEL", 0);
  Opal.const_set($nesting[0], "RUBY_REVISION", "0");
  Opal.const_set(
    $nesting[0],
    "RUBY_COPYRIGHT",
    "opal - Copyright (C) 2013-2021 Adam Beynon and the Opal contributors"
  );
  return Opal.const_set(
    $nesting[0],
    "RUBY_DESCRIPTION",
    "" +
      "opal " +
      $$($nesting, "RUBY_ENGINE_VERSION") +
      " (" +
      $$($nesting, "RUBY_RELEASE_DATE") +
      " revision " +
      $$($nesting, "RUBY_REVISION") +
      ")"
  );
};

Opal.modules["opal/base"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.add_stubs(["$require"]);

  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

Opal.modules["corelib/nil"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $hash2 = Opal.hash2,
    $alias = Opal.alias,
    $truthy = Opal.truthy;

  Opal.add_stubs(["$raise", "$name", "$new", "$>", "$length", "$Rational"]);

  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NilClass");

    var $nesting = [self].concat($parent_nesting),
      $NilClass_$excl$2,
      $NilClass_$$3,
      $NilClass_$$4,
      $NilClass_$$5,
      $NilClass_$eq_eq$6,
      $NilClass_dup$7,
      $NilClass_clone$8,
      $NilClass_inspect$9,
      $NilClass_nil$ques$10,
      $NilClass_singleton_class$11,
      $NilClass_to_a$12,
      $NilClass_to_h$13,
      $NilClass_to_i$14,
      $NilClass_to_s$15,
      $NilClass_to_c$16,
      $NilClass_rationalize$17,
      $NilClass_to_r$18,
      $NilClass_instance_variables$19;

    self.$$prototype.$$meta = self;
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $allocate$1;

      Opal.def(
        self,
        "$allocate",
        ($allocate$1 = function $$allocate() {
          var self = this;

          return self.$raise(
            $$($nesting, "TypeError"),
            "" + "allocator undefined for " + self.$name()
          );
        }),
        ($allocate$1.$$arity = 0)
      );

      Opal.udef(self, "$" + "new");
      return nil;
    })(Opal.get_singleton_class(self), $nesting);

    Opal.def(
      self,
      "$!",
      ($NilClass_$excl$2 = function () {
        var self = this;

        return true;
      }),
      ($NilClass_$excl$2.$$arity = 0)
    );

    Opal.def(
      self,
      "$&",
      ($NilClass_$$3 = function (other) {
        var self = this;

        return false;
      }),
      ($NilClass_$$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$|",
      ($NilClass_$$4 = function (other) {
        var self = this;

        return other !== false && other !== nil;
      }),
      ($NilClass_$$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$^",
      ($NilClass_$$5 = function (other) {
        var self = this;

        return other !== false && other !== nil;
      }),
      ($NilClass_$$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($NilClass_$eq_eq$6 = function (other) {
        var self = this;

        return other === nil;
      }),
      ($NilClass_$eq_eq$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$dup",
      ($NilClass_dup$7 = function $$dup() {
        var self = this;

        return nil;
      }),
      ($NilClass_dup$7.$$arity = 0)
    );

    Opal.def(
      self,
      "$clone",
      ($NilClass_clone$8 = function $$clone($kwargs) {
        var freeze,
          self = this;

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        freeze = $kwargs.$$smap["freeze"];
        if (freeze == null) {
          freeze = true;
        }
        return nil;
      }),
      ($NilClass_clone$8.$$arity = -1)
    );

    Opal.def(
      self,
      "$inspect",
      ($NilClass_inspect$9 = function $$inspect() {
        var self = this;

        return "nil";
      }),
      ($NilClass_inspect$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$nil?",
      ($NilClass_nil$ques$10 = function () {
        var self = this;

        return true;
      }),
      ($NilClass_nil$ques$10.$$arity = 0)
    );

    Opal.def(
      self,
      "$singleton_class",
      ($NilClass_singleton_class$11 = function $$singleton_class() {
        var self = this;

        return $$($nesting, "NilClass");
      }),
      ($NilClass_singleton_class$11.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_a",
      ($NilClass_to_a$12 = function $$to_a() {
        var self = this;

        return [];
      }),
      ($NilClass_to_a$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_h",
      ($NilClass_to_h$13 = function $$to_h() {
        var self = this;

        return Opal.hash();
      }),
      ($NilClass_to_h$13.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_i",
      ($NilClass_to_i$14 = function $$to_i() {
        var self = this;

        return 0;
      }),
      ($NilClass_to_i$14.$$arity = 0)
    );
    $alias(self, "to_f", "to_i");

    Opal.def(
      self,
      "$to_s",
      ($NilClass_to_s$15 = function $$to_s() {
        var self = this;

        return "";
      }),
      ($NilClass_to_s$15.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_c",
      ($NilClass_to_c$16 = function $$to_c() {
        var self = this;

        return $$($nesting, "Complex").$new(0, 0);
      }),
      ($NilClass_to_c$16.$$arity = 0)
    );

    Opal.def(
      self,
      "$rationalize",
      ($NilClass_rationalize$17 = function $$rationalize($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if ($truthy($rb_gt(args.$length(), 1))) {
          self.$raise($$($nesting, "ArgumentError"));
        }
        return self.$Rational(0, 1);
      }),
      ($NilClass_rationalize$17.$$arity = -1)
    );

    Opal.def(
      self,
      "$to_r",
      ($NilClass_to_r$18 = function $$to_r() {
        var self = this;

        return self.$Rational(0, 1);
      }),
      ($NilClass_to_r$18.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$instance_variables",
        ($NilClass_instance_variables$19 = function $$instance_variables() {
          var self = this;

          return [];
        }),
        ($NilClass_instance_variables$19.$$arity = 0)
      ),
      nil) && "instance_variables"
    );
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], "NIL", nil);
};

Opal.modules["corelib/boolean"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $send2 = Opal.send2,
    $find_super = Opal.find_super;

  Opal.add_stubs(["$raise", "$name"]);

  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Boolean");

    var $nesting = [self].concat($parent_nesting),
      $Boolean___id__$2,
      $Boolean_$excl$3,
      $Boolean_$$4,
      $Boolean_$$5,
      $Boolean_$$6,
      $Boolean_$eq_eq$7,
      $Boolean_singleton_class$8,
      $Boolean_to_s$9,
      $Boolean_dup$10,
      $Boolean_clone$11,
      $Boolean_method_missing$12,
      $Boolean_respond_to_missing$ques$13;

    Opal.defineProperty(self.$$prototype, "$$is_boolean", true);

    var properties = ["$$class", "$$meta"];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function () {
          return this == true
            ? Opal.TrueClass
            : this == false
            ? Opal.FalseClass
            : Opal.Boolean;
        },
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function () {
        return this == true ? 2 : this == false ? 0 : nil;
      },
    });
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $allocate$1;

      Opal.def(
        self,
        "$allocate",
        ($allocate$1 = function $$allocate() {
          var self = this;

          return self.$raise(
            $$($nesting, "TypeError"),
            "" + "allocator undefined for " + self.$name()
          );
        }),
        ($allocate$1.$$arity = 0)
      );

      Opal.udef(self, "$" + "new");
      return nil;
    })(Opal.get_singleton_class(self), $nesting);

    Opal.def(
      self,
      "$__id__",
      ($Boolean___id__$2 = function $$__id__() {
        var self = this;

        return self.valueOf() ? 2 : 0;
      }),
      ($Boolean___id__$2.$$arity = 0)
    );
    $alias(self, "object_id", "__id__");

    Opal.def(
      self,
      "$!",
      ($Boolean_$excl$3 = function () {
        var self = this;

        return self != true;
      }),
      ($Boolean_$excl$3.$$arity = 0)
    );

    Opal.def(
      self,
      "$&",
      ($Boolean_$$4 = function (other) {
        var self = this;

        return self == true ? other !== false && other !== nil : false;
      }),
      ($Boolean_$$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$|",
      ($Boolean_$$5 = function (other) {
        var self = this;

        return self == true ? true : other !== false && other !== nil;
      }),
      ($Boolean_$$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$^",
      ($Boolean_$$6 = function (other) {
        var self = this;

        return self == true
          ? other === false || other === nil
          : other !== false && other !== nil;
      }),
      ($Boolean_$$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($Boolean_$eq_eq$7 = function (other) {
        var self = this;

        return (self == true) === other.valueOf();
      }),
      ($Boolean_$eq_eq$7.$$arity = 1)
    );
    $alias(self, "equal?", "==");
    $alias(self, "eql?", "==");

    Opal.def(
      self,
      "$singleton_class",
      ($Boolean_singleton_class$8 = function $$singleton_class() {
        var self = this;

        return self.$$meta;
      }),
      ($Boolean_singleton_class$8.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Boolean_to_s$9 = function $$to_s() {
        var self = this;

        return self == true ? "true" : "false";
      }),
      ($Boolean_to_s$9.$$arity = 0)
    );
    $alias(self, "inspect", "to_s");

    Opal.def(
      self,
      "$dup",
      ($Boolean_dup$10 = function $$dup() {
        var self = this;

        return self;
      }),
      ($Boolean_dup$10.$$arity = 0)
    );

    Opal.def(
      self,
      "$clone",
      ($Boolean_clone$11 = function $$clone($kwargs) {
        var freeze,
          self = this;

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        freeze = $kwargs.$$smap["freeze"];
        if (freeze == null) {
          freeze = true;
        }
        return self;
      }),
      ($Boolean_clone$11.$$arity = -1)
    );

    Opal.def(
      self,
      "$method_missing",
      ($Boolean_method_missing$12 = function $$method_missing(method, $a) {
        var $iter = $Boolean_method_missing$12.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Boolean_method_missing$12.$$p = null;

        if ($iter) $Boolean_method_missing$12.$$p = null;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        args = $post_args;
        var body = self.$$class.$$prototype["$" + method];
        if ($truthy(typeof body !== "undefined" && !body.$$stub)) {
        } else {
          $send2(
            self,
            $find_super(
              self,
              "method_missing",
              $Boolean_method_missing$12,
              false,
              true
            ),
            "method_missing",
            [method].concat(Opal.to_a(args)),
            $iter
          );
        }
        return Opal.send(self, body, args, block);
      }),
      ($Boolean_method_missing$12.$$arity = -2)
    );
    return (
      (Opal.def(
        self,
        "$respond_to_missing?",
        ($Boolean_respond_to_missing$ques$13 = function (method, _include_all) {
          var self = this;

          if (_include_all == null) {
            _include_all = false;
          }
          var body = self.$$class.$$prototype["$" + method];
          return typeof body !== "undefined" && !body.$$stub;
        }),
        ($Boolean_respond_to_missing$ques$13.$$arity = -2)
      ),
      nil) && "respond_to_missing?"
    );
  })($nesting[0], Boolean, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "TrueClass");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Boolean"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "FalseClass");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "Boolean"), $nesting);
  Opal.const_set($nesting[0], "TRUE", true);
  return Opal.const_set($nesting[0], "FALSE", false);
};

Opal.modules["corelib/comparable"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $falsy = Opal.falsy,
    $module = Opal.module,
    $truthy = Opal.truthy;

  Opal.add_stubs(["$>", "$<", "$===", "$raise", "$class", "$<=>", "$equal?"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Comparable");

    var $nesting = [self].concat($parent_nesting),
      $Comparable_$eq_eq$1,
      $Comparable_$gt$2,
      $Comparable_$gt_eq$3,
      $Comparable_$lt$4,
      $Comparable_$lt_eq$5,
      $Comparable_between$ques$6,
      $Comparable_clamp$7,
      $case = nil;

    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) {
        return what;
      }

      if ($rb_gt(what, 0)) {
        return 1;
      }
      if ($rb_lt(what, 0)) {
        return -1;
      }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function () {
        $case = rhs;
        if (
          nil["$==="]($case) ||
          true["$==="]($case) ||
          false["$==="]($case) ||
          $$($nesting, "Integer")["$==="]($case) ||
          $$($nesting, "Float")["$==="]($case)
        ) {
          return (class_name = rhs.$inspect());
        } else {
          return (class_name = rhs.$$class);
        }
      })();
      self.$raise(
        $$($nesting, "ArgumentError"),
        "" + "comparison of " + lhs.$class() + " with " + class_name + " failed"
      );
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = lhs["$<=>"](rhs);
      if ($falsy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
    Opal.def(
      self,
      "$==",
      ($Comparable_$eq_eq$1 = function (other) {
        var self = this,
          cmp = nil;

        if ($truthy(self["$equal?"](other))) {
          return true;
        }

        if (self["$<=>"] == Opal.Kernel["$<=>"]) {
          return false;
        }

        // check for infinite recursion
        if (self.$$comparable) {
          delete self.$$comparable;
          return false;
        }
        if ($truthy((cmp = self["$<=>"](other)))) {
        } else {
          return false;
        }
        return normalize(cmp) == 0;
      }),
      ($Comparable_$eq_eq$1.$$arity = 1)
    );

    Opal.def(
      self,
      "$>",
      ($Comparable_$gt$2 = function (other) {
        var self = this;

        return cmp_or_fail(self, other) > 0;
      }),
      ($Comparable_$gt$2.$$arity = 1)
    );

    Opal.def(
      self,
      "$>=",
      ($Comparable_$gt_eq$3 = function (other) {
        var self = this;

        return cmp_or_fail(self, other) >= 0;
      }),
      ($Comparable_$gt_eq$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$<",
      ($Comparable_$lt$4 = function (other) {
        var self = this;

        return cmp_or_fail(self, other) < 0;
      }),
      ($Comparable_$lt$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=",
      ($Comparable_$lt_eq$5 = function (other) {
        var self = this;

        return cmp_or_fail(self, other) <= 0;
      }),
      ($Comparable_$lt_eq$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$between?",
      ($Comparable_between$ques$6 = function (min, max) {
        var self = this;

        if ($rb_lt(self, min)) {
          return false;
        }
        if ($rb_gt(self, max)) {
          return false;
        }
        return true;
      }),
      ($Comparable_between$ques$6.$$arity = 2)
    );
    return (
      (Opal.def(
        self,
        "$clamp",
        ($Comparable_clamp$7 = function $$clamp(min, max) {
          var self = this;

          if (max == null) {
            max = nil;
          }

          var c, excl;

          if (max === nil) {
            // We are dealing with a new Ruby 2.7 behaviour that we are able to
            // provide a single Range argument instead of 2 Comparables.

            if (!Opal.is_a(min, Opal.Range)) {
              self.$raise(
                $$($nesting, "TypeError"),
                "" + "wrong argument type " + min.$class() + " (expected Range)"
              );
            }

            excl = min.excl;
            max = min.end;
            min = min.begin;

            if (max !== nil && excl) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "cannot clamp with an exclusive range"
              );
            }
          }

          if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "min argument must be smaller than max argument"
            );
          }

          if (min !== nil) {
            c = cmp_or_fail(self, min);

            if (c == 0) return self;
            if (c < 0) return min;
          }

          if (max !== nil) {
            c = cmp_or_fail(self, max);

            if (c > 0) return max;
          }

          return self;
        }),
        ($Comparable_clamp$7.$$arity = -2)
      ),
      nil) && "clamp"
    );
  })($nesting[0], $nesting);
};

Opal.modules["corelib/regexp"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $coerce_to = Opal.coerce_to,
    $klass = Opal.klass,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $truthy = Opal.truthy,
    $gvars = Opal.gvars,
    $alias = Opal.alias,
    $send = Opal.send;

  Opal.add_stubs([
    "$nil?",
    "$[]",
    "$raise",
    "$escape",
    "$options",
    "$to_str",
    "$new",
    "$join",
    "$coerce_to!",
    "$!",
    "$match",
    "$coerce_to?",
    "$begin",
    "$uniq",
    "$map",
    "$scan",
    "$source",
    "$to_proc",
    "$transform_values",
    "$group_by",
    "$each_with_index",
    "$+",
    "$last",
    "$=~",
    "$attr_reader",
    "$include?",
    "$names",
    "$regexp",
    "$named_captures",
    "$===",
    "$captures",
    "$-",
    "$inspect",
    "$empty?",
    "$each",
    "$to_a",
  ]);

  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "RegexpError");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $$($nesting, "StandardError"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Regexp");

    var $nesting = [self].concat($parent_nesting),
      $Regexp_$eq_eq$6,
      $Regexp_$eq_eq_eq$7,
      $Regexp_$eq_tilde$8,
      $Regexp_inspect$9,
      $Regexp_match$10,
      $Regexp_match$ques$11,
      $Regexp_names$12,
      $Regexp_named_captures$13,
      $Regexp_$$16,
      $Regexp_source$17,
      $Regexp_options$18,
      $Regexp_casefold$ques$19;

    Opal.const_set($nesting[0], "IGNORECASE", 1);
    Opal.const_set($nesting[0], "EXTENDED", 2);
    Opal.const_set($nesting[0], "MULTILINE", 4);
    Opal.defineProperty(self.$$prototype, "$$is_regexp", true);
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $allocate$1,
        $escape$2,
        $last_match$3,
        $union$4,
        $new$5;

      Opal.def(
        self,
        "$allocate",
        ($allocate$1 = function $$allocate() {
          var $iter = $allocate$1.$$p,
            $yield = $iter || nil,
            self = this,
            allocated = nil;

          if ($iter) $allocate$1.$$p = null;

          allocated = $send2(
            self,
            $find_super(self, "allocate", $allocate$1, false, true),
            "allocate",
            [],
            $iter
          );
          allocated.uninitialized = true;
          return allocated;
        }),
        ($allocate$1.$$arity = 0)
      );

      Opal.def(
        self,
        "$escape",
        ($escape$2 = function $$escape(string) {
          var self = this;

          return Opal.escape_regexp(string);
        }),
        ($escape$2.$$arity = 1)
      );

      Opal.def(
        self,
        "$last_match",
        ($last_match$3 = function $$last_match(n) {
          var self = this;
          if ($gvars["~"] == null) $gvars["~"] = nil;

          if (n == null) {
            n = nil;
          }
          if ($truthy(n["$nil?"]())) {
            return $gvars["~"];
          } else if ($truthy($gvars["~"])) {
            return $gvars["~"]["$[]"](n);
          } else {
            return nil;
          }
        }),
        ($last_match$3.$$arity = -1)
      );
      $alias(self, "quote", "escape");

      Opal.def(
        self,
        "$union",
        ($union$4 = function $$union($a) {
          var $post_args,
            parts,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          parts = $post_args;

          var is_first_part_array,
            quoted_validated,
            part,
            options,
            each_part_options;
          if (parts.length == 0) {
            return /(?!)/;
          }
          // return fast if there's only one element
          if (parts.length == 1 && parts[0].$$is_regexp) {
            return parts[0];
          }
          // cover the 2 arrays passed as arguments case
          is_first_part_array = parts[0].$$is_array;
          if (parts.length > 1 && is_first_part_array) {
            self.$raise(
              $$($nesting, "TypeError"),
              "no implicit conversion of Array into String"
            );
          }
          // deal with splat issues (related to https://github.com/opal/opal/issues/858)
          if (is_first_part_array) {
            parts = parts[0];
          }
          options = undefined;
          quoted_validated = [];
          for (var i = 0; i < parts.length; i++) {
            part = parts[i];
            if (part.$$is_string) {
              quoted_validated.push(self.$escape(part));
            } else if (part.$$is_regexp) {
              each_part_options = part.$options();
              if (options != undefined && options != each_part_options) {
                self.$raise(
                  $$($nesting, "TypeError"),
                  "All expressions must use the same options"
                );
              }
              options = each_part_options;
              quoted_validated.push("(" + part.source + ")");
            } else {
              quoted_validated.push(self.$escape(part.$to_str()));
            }
          }
          return self.$new(quoted_validated.$join("|"), options);
        }),
        ($union$4.$$arity = -1)
      );

      Opal.def(
        self,
        "$new",
        ($new$5 = function (regexp, options) {
          var self = this;

          if (regexp.$$is_regexp) {
            return new RegExp(regexp);
          }

          regexp = $$($nesting, "Opal")["$coerce_to!"](
            regexp,
            $$($nesting, "String"),
            "to_str"
          );

          if (
            regexp.charAt(regexp.length - 1) === "\\" &&
            regexp.charAt(regexp.length - 2) !== "\\"
          ) {
            self.$raise(
              $$($nesting, "RegexpError"),
              "" + "too short escape sequence: /" + regexp + "/"
            );
          }

          if (options === undefined || options["$!"]()) {
            return new RegExp(regexp);
          }

          if (options.$$is_number) {
            var temp = "";
            if ($$($nesting, "IGNORECASE") & options) {
              temp += "i";
            }
            if ($$($nesting, "MULTILINE") & options) {
              temp += "m";
            }
            options = temp;
          } else {
            options = "i";
          }

          return new RegExp(regexp, options);
        }),
        ($new$5.$$arity = -2)
      );
      return $alias(self, "compile", "new");
    })(Opal.get_singleton_class(self), $nesting);

    Opal.def(
      self,
      "$==",
      ($Regexp_$eq_eq$6 = function (other) {
        var self = this;

        return other instanceof RegExp && self.toString() === other.toString();
      }),
      ($Regexp_$eq_eq$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$===",
      ($Regexp_$eq_eq_eq$7 = function (string) {
        var self = this;

        return (
          self.$match(
            $$($nesting, "Opal")["$coerce_to?"](
              string,
              $$($nesting, "String"),
              "to_str"
            )
          ) !== nil
        );
      }),
      ($Regexp_$eq_eq_eq$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$=~",
      ($Regexp_$eq_tilde$8 = function (string) {
        var self = this,
          $ret_or_1 = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        if ($truthy(($ret_or_1 = self.$match(string)))) {
          return $gvars["~"].$begin(0);
        } else {
          return $ret_or_1;
        }
      }),
      ($Regexp_$eq_tilde$8.$$arity = 1)
    );
    $alias(self, "eql?", "==");

    Opal.def(
      self,
      "$inspect",
      ($Regexp_inspect$9 = function $$inspect() {
        var self = this;

        var regexp_format = /^\/(.*)\/([^\/]*)$/;
        var value = self.toString();
        var matches = regexp_format.exec(value);
        if (matches) {
          var regexp_pattern = matches[1];
          var regexp_flags = matches[2];
          var chars = regexp_pattern.split("");
          var chars_length = chars.length;
          var char_escaped = false;
          var regexp_pattern_escaped = "";
          for (var i = 0; i < chars_length; i++) {
            var current_char = chars[i];
            if (!char_escaped && current_char == "/") {
              regexp_pattern_escaped = regexp_pattern_escaped.concat("\\");
            }
            regexp_pattern_escaped =
              regexp_pattern_escaped.concat(current_char);
            if (current_char == "\\") {
              if (char_escaped) {
                // does not over escape
                char_escaped = false;
              } else {
                char_escaped = true;
              }
            } else {
              char_escaped = false;
            }
          }
          return "/" + regexp_pattern_escaped + "/" + regexp_flags;
        } else {
          return value;
        }
      }),
      ($Regexp_inspect$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$match",
      ($Regexp_match$10 = function $$match(string, pos) {
        var $iter = $Regexp_match$10.$$p,
          block = $iter || nil,
          self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        if ($iter) $Regexp_match$10.$$p = null;

        if ($iter) $Regexp_match$10.$$p = null;
        if (self.uninitialized) {
          self.$raise($$($nesting, "TypeError"), "uninitialized Regexp");
        }

        if (pos === undefined) {
          if (string === nil) return ($gvars["~"] = nil);
          var m = self.exec(
            $coerce_to(string, $$($nesting, "String"), "to_str")
          );
          if (m) {
            $gvars["~"] = $$($nesting, "MatchData").$new(self, m);
            return block === nil
              ? $gvars["~"]
              : Opal.yield1(block, $gvars["~"]);
          } else {
            return ($gvars["~"] = nil);
          }
        }

        pos = $coerce_to(pos, $$($nesting, "Integer"), "to_int");

        if (string === nil) {
          return ($gvars["~"] = nil);
        }

        string = $coerce_to(string, $$($nesting, "String"), "to_str");

        if (pos < 0) {
          pos += string.length;
          if (pos < 0) {
            return ($gvars["~"] = nil);
          }
        }

        // global RegExp maintains state, so not using self/this
        var md,
          re = Opal.global_regexp(self);

        while (true) {
          md = re.exec(string);
          if (md === null) {
            return ($gvars["~"] = nil);
          }
          if (md.index >= pos) {
            $gvars["~"] = $$($nesting, "MatchData").$new(re, md);
            return block === nil
              ? $gvars["~"]
              : Opal.yield1(block, $gvars["~"]);
          }
          re.lastIndex = md.index + 1;
        }
      }),
      ($Regexp_match$10.$$arity = -2)
    );

    Opal.def(
      self,
      "$match?",
      ($Regexp_match$ques$11 = function (string, pos) {
        var self = this;

        if (self.uninitialized) {
          self.$raise($$($nesting, "TypeError"), "uninitialized Regexp");
        }

        if (pos === undefined) {
          return string === nil
            ? false
            : self.test($coerce_to(string, $$($nesting, "String"), "to_str"));
        }

        pos = $coerce_to(pos, $$($nesting, "Integer"), "to_int");

        if (string === nil) {
          return false;
        }

        string = $coerce_to(string, $$($nesting, "String"), "to_str");

        if (pos < 0) {
          pos += string.length;
          if (pos < 0) {
            return false;
          }
        }

        // global RegExp maintains state, so not using self/this
        var md,
          re = Opal.global_regexp(self);

        md = re.exec(string);
        if (md === null || md.index < pos) {
          return false;
        } else {
          return true;
        }
      }),
      ($Regexp_match$ques$11.$$arity = -2)
    );

    Opal.def(
      self,
      "$names",
      ($Regexp_names$12 = function $$names() {
        var self = this;

        return $send(
          self.$source().$scan(/\(?<(\w+)>/),
          "map",
          [],
          "first".$to_proc()
        ).$uniq();
      }),
      ($Regexp_names$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$named_captures",
      ($Regexp_named_captures$13 = function $$named_captures() {
        var $$14,
          self = this;

        return $send(
          $send(
            $send(
              self.$source().$scan(/\(?<(\w+)>/),
              "map",
              [],
              "first".$to_proc()
            ).$each_with_index(),
            "group_by",
            [],
            "first".$to_proc()
          ),
          "transform_values",
          [],
          (($$14 = function (i) {
            var self = $$14.$$s == null ? this : $$14.$$s,
              $$15;

            if (i == null) {
              i = nil;
            }
            return $send(
              i,
              "map",
              [],
              (($$15 = function (j) {
                var self = $$15.$$s == null ? this : $$15.$$s;

                if (j == null) {
                  j = nil;
                }
                return $rb_plus(j.$last(), 1);
              }),
              ($$15.$$s = self),
              ($$15.$$arity = 1),
              $$15)
            );
          }),
          ($$14.$$s = self),
          ($$14.$$arity = 1),
          $$14)
        );
      }),
      ($Regexp_named_captures$13.$$arity = 0)
    );

    Opal.def(
      self,
      "$~",
      ($Regexp_$$16 = function () {
        var self = this;
        if ($gvars._ == null) $gvars._ = nil;

        return self["$=~"]($gvars._);
      }),
      ($Regexp_$$16.$$arity = 0)
    );

    Opal.def(
      self,
      "$source",
      ($Regexp_source$17 = function $$source() {
        var self = this;

        return self.source;
      }),
      ($Regexp_source$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$options",
      ($Regexp_options$18 = function $$options() {
        var self = this;

        if (self.uninitialized) {
          self.$raise($$($nesting, "TypeError"), "uninitialized Regexp");
        }
        var result = 0;
        // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
        if (self.multiline) {
          result |= $$($nesting, "MULTILINE");
        }
        if (self.ignoreCase) {
          result |= $$($nesting, "IGNORECASE");
        }
        return result;
      }),
      ($Regexp_options$18.$$arity = 0)
    );

    Opal.def(
      self,
      "$casefold?",
      ($Regexp_casefold$ques$19 = function () {
        var self = this;

        return self.ignoreCase;
      }),
      ($Regexp_casefold$ques$19.$$arity = 0)
    );
    return $alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "MatchData");

    var $nesting = [self].concat($parent_nesting),
      $MatchData_initialize$20,
      $MatchData_$$$21,
      $MatchData_offset$22,
      $MatchData_$eq_eq$23,
      $MatchData_begin$24,
      $MatchData_end$25,
      $MatchData_captures$26,
      $MatchData_named_captures$27,
      $MatchData_names$29,
      $MatchData_inspect$30,
      $MatchData_length$32,
      $MatchData_to_a$33,
      $MatchData_to_s$34,
      $MatchData_values_at$35;

    self.$$prototype.matches = nil;

    self.$attr_reader("post_match", "pre_match", "regexp", "string");

    Opal.def(
      self,
      "$initialize",
      ($MatchData_initialize$20 = function $$initialize(regexp, match_groups) {
        var self = this;

        $gvars["~"] = self;
        self.regexp = regexp;
        self.begin = match_groups.index;
        self.string = match_groups.input;
        self.pre_match = match_groups.input.slice(0, match_groups.index);
        self.post_match = match_groups.input.slice(
          match_groups.index + match_groups[0].length
        );
        self.matches = [];

        for (var i = 0, length = match_groups.length; i < length; i++) {
          var group = match_groups[i];

          if (group == null) {
            self.matches.push(nil);
          } else {
            self.matches.push(group);
          }
        }
      }),
      ($MatchData_initialize$20.$$arity = 2)
    );

    Opal.def(
      self,
      "$[]",
      ($MatchData_$$$21 = function ($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        if (args[0].$$is_string) {
          if (self.$regexp().$names()["$include?"](args["$[]"](0))["$!"]()) {
            self.$raise(
              $$($nesting, "IndexError"),
              "" + "undefined group name reference: " + args["$[]"](0)
            );
          }
          return self.$named_captures()["$[]"](args["$[]"](0));
        } else {
          return $send(self.matches, "[]", Opal.to_a(args));
        }
      }),
      ($MatchData_$$$21.$$arity = -1)
    );

    Opal.def(
      self,
      "$offset",
      ($MatchData_offset$22 = function $$offset(n) {
        var self = this;

        if (n !== 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "MatchData#offset only supports 0th element"
          );
        }
        return [self.begin, self.begin + self.matches[n].length];
      }),
      ($MatchData_offset$22.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($MatchData_$eq_eq$23 = function (other) {
        var self = this,
          $ret_or_2 = nil,
          $ret_or_3 = nil,
          $ret_or_4 = nil,
          $ret_or_5 = nil;

        if ($truthy($$($nesting, "MatchData")["$==="](other))) {
        } else {
          return false;
        }
        if (
          $truthy(
            ($ret_or_2 = (function () {
              if (
                $truthy(
                  ($ret_or_3 = (function () {
                    if (
                      $truthy(
                        ($ret_or_4 = (function () {
                          if (
                            $truthy(($ret_or_5 = self.string == other.string))
                          ) {
                            return (
                              self.regexp.toString() == other.regexp.toString()
                            );
                          } else {
                            return $ret_or_5;
                          }
                          return nil;
                        })())
                      )
                    ) {
                      return self.pre_match == other.pre_match;
                    } else {
                      return $ret_or_4;
                    }
                    return nil;
                  })())
                )
              ) {
                return self.post_match == other.post_match;
              } else {
                return $ret_or_3;
              }
              return nil;
            })())
          )
        ) {
          return self.begin == other.begin;
        } else {
          return $ret_or_2;
        }
      }),
      ($MatchData_$eq_eq$23.$$arity = 1)
    );
    $alias(self, "eql?", "==");

    Opal.def(
      self,
      "$begin",
      ($MatchData_begin$24 = function $$begin(n) {
        var self = this;

        if (n !== 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "MatchData#begin only supports 0th element"
          );
        }
        return self.begin;
      }),
      ($MatchData_begin$24.$$arity = 1)
    );

    Opal.def(
      self,
      "$end",
      ($MatchData_end$25 = function $$end(n) {
        var self = this;

        if (n !== 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "MatchData#end only supports 0th element"
          );
        }
        return self.begin + self.matches[n].length;
      }),
      ($MatchData_end$25.$$arity = 1)
    );

    Opal.def(
      self,
      "$captures",
      ($MatchData_captures$26 = function $$captures() {
        var self = this;

        return self.matches.slice(1);
      }),
      ($MatchData_captures$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$named_captures",
      ($MatchData_named_captures$27 = function $$named_captures() {
        var $$28,
          self = this,
          matches = nil;

        matches = self.$captures();
        return $send(
          self.$regexp().$named_captures(),
          "transform_values",
          [],
          (($$28 = function (i) {
            var self = $$28.$$s == null ? this : $$28.$$s;

            if (i == null) {
              i = nil;
            }
            return matches["$[]"]($rb_minus(i.$last(), 1));
          }),
          ($$28.$$s = self),
          ($$28.$$arity = 1),
          $$28)
        );
      }),
      ($MatchData_named_captures$27.$$arity = 0)
    );

    Opal.def(
      self,
      "$names",
      ($MatchData_names$29 = function $$names() {
        var self = this;

        return self.$regexp().$names();
      }),
      ($MatchData_names$29.$$arity = 0)
    );

    Opal.def(
      self,
      "$inspect",
      ($MatchData_inspect$30 = function $$inspect() {
        var $$31,
          self = this;

        var str = "#<MatchData " + self.matches[0].$inspect();

        if (self.$regexp().$names()["$empty?"]()) {
          for (var i = 1, length = self.matches.length; i < length; i++) {
            str += " " + i + ":" + self.matches[i].$inspect();
          }
        } else {
          $send(
            self.$named_captures(),
            "each",
            [],
            (($$31 = function (k, v) {
              var self = $$31.$$s == null ? this : $$31.$$s;

              if (k == null) {
                k = nil;
              }

              if (v == null) {
                v = nil;
              }
              return (str += " " + k + ":" + v.$inspect());
            }),
            ($$31.$$s = self),
            ($$31.$$arity = 2),
            $$31)
          );
        }

        return str + ">";
      }),
      ($MatchData_inspect$30.$$arity = 0)
    );

    Opal.def(
      self,
      "$length",
      ($MatchData_length$32 = function $$length() {
        var self = this;

        return self.matches.length;
      }),
      ($MatchData_length$32.$$arity = 0)
    );
    $alias(self, "size", "length");

    Opal.def(
      self,
      "$to_a",
      ($MatchData_to_a$33 = function $$to_a() {
        var self = this;

        return self.matches;
      }),
      ($MatchData_to_a$33.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($MatchData_to_s$34 = function $$to_s() {
        var self = this;

        return self.matches[0];
      }),
      ($MatchData_to_s$34.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$values_at",
        ($MatchData_values_at$35 = function $$values_at($a) {
          var $post_args,
            args,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          args = $post_args;

          var i,
            a,
            index,
            values = [];

          for (i = 0; i < args.length; i++) {
            if (args[i].$$is_range) {
              a = args[i].$to_a();
              a.unshift(i, 1);
              Array.prototype.splice.apply(args, a);
            }

            index = $$($nesting, "Opal")["$coerce_to!"](
              args[i],
              $$($nesting, "Integer"),
              "to_int"
            );

            if (index < 0) {
              index += self.matches.length;
              if (index < 0) {
                values.push(nil);
                continue;
              }
            }

            values.push(self.matches[index]);
          }

          return values;
        }),
        ($MatchData_values_at$35.$$arity = -1)
      ),
      nil) && "values_at"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/string"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $coerce_to = Opal.coerce_to,
    $respond_to = Opal.respond_to,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $send = Opal.send,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $gvars = Opal.gvars;

  Opal.add_stubs([
    "$require",
    "$include",
    "$coerce_to?",
    "$initialize",
    "$===",
    "$format",
    "$raise",
    "$respond_to?",
    "$to_s",
    "$to_str",
    "$<=>",
    "$==",
    "$=~",
    "$new",
    "$force_encoding",
    "$casecmp",
    "$empty?",
    "$ljust",
    "$ceil",
    "$/",
    "$+",
    "$rjust",
    "$floor",
    "$coerce_to!",
    "$copy_singleton_methods",
    "$initialize_clone",
    "$initialize_dup",
    "$enum_for",
    "$chomp",
    "$[]",
    "$to_i",
    "$each_line",
    "$to_proc",
    "$to_a",
    "$class",
    "$match",
    "$match?",
    "$captures",
    "$proc",
    "$succ",
    "$escape",
    "$include?",
    "$upcase",
    "$unicode_normalize",
    "$pristine",
  ]);

  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String___id__$1,
      $String_try_convert$2,
      $String_new$3,
      $String_initialize$4,
      $String_$percent$5,
      $String_$$6,
      $String_$plus$7,
      $String_$lt_eq_gt$8,
      $String_$eq_eq$9,
      $String_$eq_tilde$10,
      $String_$$$11,
      $String_b$12,
      $String_capitalize$13,
      $String_casecmp$14,
      $String_casecmp$ques$15,
      $String_center$16,
      $String_chomp$17,
      $String_chop$18,
      $String_chr$19,
      $String_clone$20,
      $String_dup$21,
      $String_count$22,
      $String_delete$23,
      $String_delete_prefix$24,
      $String_delete_suffix$25,
      $String_downcase$26,
      $String_each_line$27,
      $String_empty$ques$28,
      $String_end_with$ques$29,
      $String_gsub$30,
      $String_hash$31,
      $String_hex$32,
      $String_include$ques$33,
      $String_index$34,
      $String_inspect$35,
      $String_intern$36,
      $String_lines$37,
      $String_ljust$38,
      $String_lstrip$39,
      $String_ascii_only$ques$40,
      $String_match$41,
      $String_match$ques$42,
      $String_next$43,
      $String_oct$44,
      $String_ord$45,
      $String_partition$46,
      $String_reverse$47,
      $String_rindex$48,
      $String_rjust$49,
      $String_rpartition$50,
      $String_rstrip$51,
      $String_scan$52,
      $String_split$53,
      $String_squeeze$54,
      $String_start_with$ques$55,
      $String_strip$56,
      $String_sub$57,
      $String_sum$58,
      $String_swapcase$59,
      $String_to_f$60,
      $String_to_i$61,
      $String_to_proc$62,
      $String_to_s$64,
      $String_tr$65,
      $String_tr_s$66,
      $String_upcase$67,
      $String_upto$68,
      $String_instance_variables$69,
      $String__load$70,
      $String_unicode_normalize$71,
      $String_unicode_normalized$ques$72,
      $String_unpack$73,
      $String_unpack1$74,
      $String_freeze$75,
      $String_$minus$$76,
      $String_frozen$ques$77;

    self.$include($$($nesting, "Comparable"));

    Opal.defineProperty(self.$$prototype, "$$is_string", true);

    Opal.defineProperty(self.$$prototype, "$$cast", function (string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
    Opal.def(
      self,
      "$__id__",
      ($String___id__$1 = function $$__id__() {
        var self = this;

        return self.toString();
      }),
      ($String___id__$1.$$arity = 0)
    );
    $alias(self, "object_id", "__id__");
    Opal.defs(
      self,
      "$try_convert",
      ($String_try_convert$2 = function $$try_convert(what) {
        var self = this;

        return $$($nesting, "Opal")["$coerce_to?"](
          what,
          $$($nesting, "String"),
          "to_str"
        );
      }),
      ($String_try_convert$2.$$arity = 1)
    );
    Opal.defs(
      self,
      "$new",
      ($String_new$3 = function ($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        var str = args[0] || "";
        var opts = args[args.length - 1];
        str = $coerce_to(str, $$($nesting, "String"), "to_str");
        if (opts && opts.$$is_hash) {
          if (opts.$$smap.encoding)
            str = str.$force_encoding(opts.$$smap.encoding);
        }
        str = new self.$$constructor(str);
        if (!str.$initialize.$$pristine)
          $send(str, "initialize", Opal.to_a(args));
        return str;
      }),
      ($String_new$3.$$arity = -1)
    );

    Opal.def(
      self,
      "$initialize",
      ($String_initialize$4 = function $$initialize($a, $b) {
        var $post_args,
          $kwargs,
          str,
          encoding,
          capacity,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $kwargs = Opal.extract_kwargs($post_args);

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        if ($post_args.length > 0) {
          str = $post_args[0];
          $post_args.splice(0, 1);
        }

        encoding = $kwargs.$$smap["encoding"];
        if (encoding == null) {
          encoding = nil;
        }

        capacity = $kwargs.$$smap["capacity"];
        if (capacity == null) {
          capacity = nil;
        }
        return nil;
      }),
      ($String_initialize$4.$$arity = -1)
    );

    Opal.def(
      self,
      "$%",
      ($String_$percent$5 = function (data) {
        var self = this;

        if ($truthy($$($nesting, "Array")["$==="](data))) {
          return $send(self, "format", [self].concat(Opal.to_a(data)));
        } else {
          return self.$format(self, data);
        }
      }),
      ($String_$percent$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$*",
      ($String_$$6 = function (count) {
        var self = this;

        count = $coerce_to(count, $$($nesting, "Integer"), "to_int");

        if (count < 0) {
          self.$raise($$($nesting, "ArgumentError"), "negative argument");
        }

        if (count === 0) {
          return self.$$cast("");
        }

        var result = "",
          string = self.toString();

        // All credit for the bit-twiddling magic code below goes to Mozilla
        // polyfill implementation of String.prototype.repeat() posted here:
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

        if (string.length * count >= 1 << 28) {
          self.$raise(
            $$($nesting, "RangeError"),
            "multiply count must not overflow maximum string size"
          );
        }

        for (;;) {
          if ((count & 1) === 1) {
            result += string;
          }
          count >>>= 1;
          if (count === 0) {
            break;
          }
          string += string;
        }

        return self.$$cast(result);
      }),
      ($String_$$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$+",
      ($String_$plus$7 = function (other) {
        var self = this;

        other = $coerce_to(other, $$($nesting, "String"), "to_str");

        if (other == "" && self.$$class === Opal.String) return self;
        if (self == "" && other.$$class === Opal.String) return other;
        var out = self + other;
        if (self.encoding === out.encoding && other.encoding === out.encoding)
          return out;
        if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8")
          return out;
        return Opal.enc(out, self.encoding);
      }),
      ($String_$plus$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=>",
      ($String_$lt_eq_gt$8 = function (other) {
        var self = this;

        if ($truthy(other["$respond_to?"]("to_str"))) {
          other = other.$to_str().$to_s();
          return self > other ? 1 : self < other ? -1 : 0;
        } else {
          var cmp = other["$<=>"](self);

          if (cmp === nil) {
            return nil;
          } else {
            return cmp > 0 ? -1 : cmp < 0 ? 1 : 0;
          }
        }
      }),
      ($String_$lt_eq_gt$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($String_$eq_eq$9 = function (other) {
        var self = this;

        if (other.$$is_string) {
          return self.toString() === other.toString();
        }
        if ($respond_to(other, "$to_str")) {
          return other["$=="](self);
        }
        return false;
      }),
      ($String_$eq_eq$9.$$arity = 1)
    );
    $alias(self, "eql?", "==");
    $alias(self, "===", "==");

    Opal.def(
      self,
      "$=~",
      ($String_$eq_tilde$10 = function (other) {
        var self = this;

        if (other.$$is_string) {
          self.$raise($$($nesting, "TypeError"), "type mismatch: String given");
        }

        return other["$=~"](self);
      }),
      ($String_$eq_tilde$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$[]",
      ($String_$$$11 = function (index, length) {
        var self = this;

        var size = self.length,
          exclude;

        if (index.$$is_range) {
          exclude = index.excl;
          length = $coerce_to(index.end, $$($nesting, "Integer"), "to_int");
          index = $coerce_to(index.begin, $$($nesting, "Integer"), "to_int");

          if (Math.abs(index) > size) {
            return nil;
          }

          if (index < 0) {
            index += size;
          }

          if (length < 0) {
            length += size;
          }

          if (!exclude) {
            length += 1;
          }

          length = length - index;

          if (length < 0) {
            length = 0;
          }

          return self.$$cast(self.substr(index, length));
        }

        if (index.$$is_string) {
          if (length != null) {
            self.$raise($$($nesting, "TypeError"));
          }
          return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
        }

        if (index.$$is_regexp) {
          var match = self.match(index);

          if (match === null) {
            $gvars["~"] = nil;
            return nil;
          }

          $gvars["~"] = $$($nesting, "MatchData").$new(index, match);

          if (length == null) {
            return self.$$cast(match[0]);
          }

          length = $coerce_to(length, $$($nesting, "Integer"), "to_int");

          if (length < 0 && -length < match.length) {
            return self.$$cast(match[(length += match.length)]);
          }

          if (length >= 0 && length < match.length) {
            return self.$$cast(match[length]);
          }

          return nil;
        }

        index = $coerce_to(index, $$($nesting, "Integer"), "to_int");

        if (index < 0) {
          index += size;
        }

        if (length == null) {
          if (index >= size || index < 0) {
            return nil;
          }
          return self.$$cast(self.substr(index, 1));
        }

        length = $coerce_to(length, $$($nesting, "Integer"), "to_int");

        if (length < 0) {
          return nil;
        }

        if (index > size || index < 0) {
          return nil;
        }

        return self.$$cast(self.substr(index, length));
      }),
      ($String_$$$11.$$arity = -2)
    );
    $alias(self, "byteslice", "[]");

    Opal.def(
      self,
      "$b",
      ($String_b$12 = function $$b() {
        var self = this;

        return new String(self).$force_encoding("binary");
      }),
      ($String_b$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$capitalize",
      ($String_capitalize$13 = function $$capitalize() {
        var self = this;

        return self.$$cast(
          self.charAt(0).toUpperCase() + self.substr(1).toLowerCase()
        );
      }),
      ($String_capitalize$13.$$arity = 0)
    );

    Opal.def(
      self,
      "$casecmp",
      ($String_casecmp$14 = function $$casecmp(other) {
        var self = this;

        if ($truthy(other["$respond_to?"]("to_str"))) {
        } else {
          return nil;
        }
        other = $coerce_to(other, $$($nesting, "String"), "to_str").$to_s();

        var ascii_only = /^[\x00-\x7F]*$/;
        if (ascii_only.test(self) && ascii_only.test(other)) {
          self = self.toLowerCase();
          other = other.toLowerCase();
        }
        return self["$<=>"](other);
      }),
      ($String_casecmp$14.$$arity = 1)
    );

    Opal.def(
      self,
      "$casecmp?",
      ($String_casecmp$ques$15 = function (other) {
        var self = this;

        var cmp = self.$casecmp(other);
        if (cmp === nil) {
          return nil;
        } else {
          return cmp === 0;
        }
      }),
      ($String_casecmp$ques$15.$$arity = 1)
    );

    Opal.def(
      self,
      "$center",
      ($String_center$16 = function $$center(width, padstr) {
        var self = this;

        if (padstr == null) {
          padstr = " ";
        }
        width = $coerce_to(width, $$($nesting, "Integer"), "to_int");
        padstr = $coerce_to(padstr, $$($nesting, "String"), "to_str").$to_s();
        if ($truthy(padstr["$empty?"]())) {
          self.$raise($$($nesting, "ArgumentError"), "zero width padding");
        }
        if ($truthy(width <= self.length)) {
          return self;
        }

        var ljustified = self.$ljust(
            $rb_divide($rb_plus(width, self.length), 2).$ceil(),
            padstr
          ),
          rjustified = self.$rjust(
            $rb_divide($rb_plus(width, self.length), 2).$floor(),
            padstr
          );

        return self.$$cast(rjustified + ljustified.slice(self.length));
      }),
      ($String_center$16.$$arity = -2)
    );

    Opal.def(
      self,
      "$chomp",
      ($String_chomp$17 = function $$chomp(separator) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        if (separator == null) {
          separator = $gvars["/"];
        }
        if ($truthy(separator === nil || self.length === 0)) {
          return self;
        }
        separator = $$($nesting, "Opal")
          ["$coerce_to!"](separator, $$($nesting, "String"), "to_str")
          .$to_s();

        var result;

        if (separator === "\n") {
          result = self.replace(/\r?\n?$/, "");
        } else if (separator === "") {
          result = self.replace(/(\r?\n)+$/, "");
        } else if (self.length >= separator.length) {
          var tail = self.substr(
            self.length - separator.length,
            separator.length
          );

          if (tail === separator) {
            result = self.substr(0, self.length - separator.length);
          }
        }

        if (result != null) {
          return self.$$cast(result);
        }
        return self;
      }),
      ($String_chomp$17.$$arity = -1)
    );

    Opal.def(
      self,
      "$chop",
      ($String_chop$18 = function $$chop() {
        var self = this;

        var length = self.length,
          result;

        if (length <= 1) {
          result = "";
        } else if (
          self.charAt(length - 1) === "\n" &&
          self.charAt(length - 2) === "\r"
        ) {
          result = self.substr(0, length - 2);
        } else {
          result = self.substr(0, length - 1);
        }

        return self.$$cast(result);
      }),
      ($String_chop$18.$$arity = 0)
    );

    Opal.def(
      self,
      "$chr",
      ($String_chr$19 = function $$chr() {
        var self = this;

        return self.charAt(0);
      }),
      ($String_chr$19.$$arity = 0)
    );

    Opal.def(
      self,
      "$clone",
      ($String_clone$20 = function $$clone() {
        var self = this,
          copy = nil;

        copy = new String(self);
        copy.$copy_singleton_methods(self);
        copy.$initialize_clone(self);
        return copy;
      }),
      ($String_clone$20.$$arity = 0)
    );

    Opal.def(
      self,
      "$dup",
      ($String_dup$21 = function $$dup() {
        var self = this,
          copy = nil;

        copy = new String(self);
        copy.$initialize_dup(self);
        return copy;
      }),
      ($String_dup$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$count",
      ($String_count$22 = function $$count($a) {
        var $post_args,
          sets,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        sets = $post_args;

        if (sets.length === 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "ArgumentError: wrong number of arguments (0 for 1+)"
          );
        }
        var char_class = char_class_from_char_sets(sets);
        if (char_class === null) {
          return 0;
        }
        return (
          self.length - self.replace(new RegExp(char_class, "g"), "").length
        );
      }),
      ($String_count$22.$$arity = -1)
    );

    Opal.def(
      self,
      "$delete",
      ($String_delete$23 = function ($a) {
        var $post_args,
          sets,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        sets = $post_args;

        if (sets.length === 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "ArgumentError: wrong number of arguments (0 for 1+)"
          );
        }
        var char_class = char_class_from_char_sets(sets);
        if (char_class === null) {
          return self;
        }
        return self.$$cast(self.replace(new RegExp(char_class, "g"), ""));
      }),
      ($String_delete$23.$$arity = -1)
    );

    Opal.def(
      self,
      "$delete_prefix",
      ($String_delete_prefix$24 = function $$delete_prefix(prefix) {
        var self = this;

        if (!prefix.$$is_string) {
          prefix = $coerce_to(prefix, $$($nesting, "String"), "to_str");
        }

        if (self.slice(0, prefix.length) === prefix) {
          return self.$$cast(self.slice(prefix.length));
        } else {
          return self;
        }
      }),
      ($String_delete_prefix$24.$$arity = 1)
    );

    Opal.def(
      self,
      "$delete_suffix",
      ($String_delete_suffix$25 = function $$delete_suffix(suffix) {
        var self = this;

        if (!suffix.$$is_string) {
          suffix = $coerce_to(suffix, $$($nesting, "String"), "to_str");
        }

        if (self.slice(self.length - suffix.length) === suffix) {
          return self.$$cast(self.slice(0, self.length - suffix.length));
        } else {
          return self;
        }
      }),
      ($String_delete_suffix$25.$$arity = 1)
    );

    Opal.def(
      self,
      "$downcase",
      ($String_downcase$26 = function $$downcase() {
        var self = this;

        return self.$$cast(self.toLowerCase());
      }),
      ($String_downcase$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_line",
      ($String_each_line$27 = function $$each_line(separator) {
        var $iter = $String_each_line$27.$$p,
          block = $iter || nil,
          self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        if ($iter) $String_each_line$27.$$p = null;

        if ($iter) $String_each_line$27.$$p = null;

        if (separator == null) {
          separator = $gvars["/"];
        }
        if (block !== nil) {
        } else {
          return self.$enum_for("each_line", separator);
        }

        if (separator === nil) {
          Opal.yield1(block, self);

          return self;
        }

        separator = $coerce_to(separator, $$($nesting, "String"), "to_str");

        var a, i, n, length, chomped, trailing, splitted;

        if (separator.length === 0) {
          for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
            if (a[i] || a[i + 1]) {
              var value = (a[i] || "") + (a[i + 1] || "");
              Opal.yield1(block, self.$$cast(value));
            }
          }

          return self;
        }

        chomped = self.$chomp(separator);
        trailing = self.length != chomped.length;
        splitted = chomped.split(separator);

        for (i = 0, length = splitted.length; i < length; i++) {
          if (i < length - 1 || trailing) {
            Opal.yield1(block, self.$$cast(splitted[i] + separator));
          } else {
            Opal.yield1(block, self.$$cast(splitted[i]));
          }
        }
        return self;
      }),
      ($String_each_line$27.$$arity = -1)
    );

    Opal.def(
      self,
      "$empty?",
      ($String_empty$ques$28 = function () {
        var self = this;

        return self.length === 0;
      }),
      ($String_empty$ques$28.$$arity = 0)
    );

    Opal.def(
      self,
      "$end_with?",
      ($String_end_with$ques$29 = function ($a) {
        var $post_args,
          suffixes,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        suffixes = $post_args;

        for (var i = 0, length = suffixes.length; i < length; i++) {
          var suffix = $coerce_to(
            suffixes[i],
            $$($nesting, "String"),
            "to_str"
          ).$to_s();

          if (
            self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix
          ) {
            return true;
          }
        }
        return false;
      }),
      ($String_end_with$ques$29.$$arity = -1)
    );
    $alias(self, "equal?", "===");

    Opal.def(
      self,
      "$gsub",
      ($String_gsub$30 = function $$gsub(pattern, replacement) {
        var $iter = $String_gsub$30.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $String_gsub$30.$$p = null;

        if ($iter) $String_gsub$30.$$p = null;
        if (replacement === undefined && block === nil) {
          return self.$enum_for("gsub", pattern);
        }

        var result = "",
          match_data = nil,
          index = 0,
          match,
          _replacement;

        if (pattern.$$is_regexp) {
          pattern = Opal.global_multiline_regexp(pattern);
        } else {
          pattern = $coerce_to(pattern, $$($nesting, "String"), "to_str");
          pattern = new RegExp(
            pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
            "gm"
          );
        }

        var lastIndex;
        while (true) {
          match = pattern.exec(self);

          if (match === null) {
            $gvars["~"] = nil;
            result += self.slice(index);
            break;
          }

          match_data = $$($nesting, "MatchData").$new(pattern, match);

          if (replacement === undefined) {
            lastIndex = pattern.lastIndex;
            _replacement = block(match[0]);
            pattern.lastIndex = lastIndex; // save and restore lastIndex
          } else if (replacement.$$is_hash) {
            _replacement = replacement["$[]"](match[0]).$to_s();
          } else {
            if (!replacement.$$is_string) {
              replacement = $coerce_to(
                replacement,
                $$($nesting, "String"),
                "to_str"
              );
            }
            _replacement = replacement
              .replace(
                /([\\]+)([0-9+&`'])/g,
                function (original, slashes, command) {
                  if (slashes.length % 2 === 0) {
                    return original;
                  }
                  switch (command) {
                    case "+":
                      for (var i = match.length - 1; i > 0; i--) {
                        if (match[i] !== undefined) {
                          return slashes.slice(1) + match[i];
                        }
                      }
                      return "";
                    case "&":
                      return slashes.slice(1) + match[0];
                    case "`":
                      return slashes.slice(1) + self.slice(0, match.index);
                    case "'":
                      return (
                        slashes.slice(1) +
                        self.slice(match.index + match[0].length)
                      );
                    default:
                      return slashes.slice(1) + (match[command] || "");
                  }
                }
              )
              .replace(/\\\\/g, "\\");
          }

          if (pattern.lastIndex === match.index) {
            result +=
              self.slice(index, match.index) +
              _replacement +
              (self[match.index] || "");
            pattern.lastIndex += 1;
          } else {
            result += self.slice(index, match.index) + _replacement;
          }
          index = pattern.lastIndex;
        }

        $gvars["~"] = match_data;
        return self.$$cast(result);
      }),
      ($String_gsub$30.$$arity = -2)
    );

    Opal.def(
      self,
      "$hash",
      ($String_hash$31 = function $$hash() {
        var self = this;

        return self.toString();
      }),
      ($String_hash$31.$$arity = 0)
    );

    Opal.def(
      self,
      "$hex",
      ($String_hex$32 = function $$hex() {
        var self = this;

        return self.$to_i(16);
      }),
      ($String_hex$32.$$arity = 0)
    );

    Opal.def(
      self,
      "$include?",
      ($String_include$ques$33 = function (other) {
        var self = this;

        if (!other.$$is_string) {
          other = $coerce_to(other, $$($nesting, "String"), "to_str");
        }
        return self.indexOf(other) !== -1;
      }),
      ($String_include$ques$33.$$arity = 1)
    );

    Opal.def(
      self,
      "$index",
      ($String_index$34 = function $$index(search, offset) {
        var self = this;

        var index, match, regex;

        if (offset === undefined) {
          offset = 0;
        } else {
          offset = $coerce_to(offset, $$($nesting, "Integer"), "to_int");
          if (offset < 0) {
            offset += self.length;
            if (offset < 0) {
              return nil;
            }
          }
        }

        if (search.$$is_regexp) {
          regex = Opal.global_multiline_regexp(search);
          while (true) {
            match = regex.exec(self);
            if (match === null) {
              $gvars["~"] = nil;
              index = -1;
              break;
            }
            if (match.index >= offset) {
              $gvars["~"] = $$($nesting, "MatchData").$new(regex, match);
              index = match.index;
              break;
            }
            regex.lastIndex = match.index + 1;
          }
        } else {
          search = $coerce_to(search, $$($nesting, "String"), "to_str");
          if (search.length === 0 && offset > self.length) {
            index = -1;
          } else {
            index = self.indexOf(search, offset);
          }
        }

        return index === -1 ? nil : index;
      }),
      ($String_index$34.$$arity = -2)
    );

    Opal.def(
      self,
      "$inspect",
      ($String_inspect$35 = function $$inspect() {
        var self = this;

        /* eslint-disable no-misleading-character-class */
        var escapable =
            /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            "\u0007": "\\a",
            "\u001b": "\\e",
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\v": "\\v",
            '"': '\\"',
            "\\": "\\\\",
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (
              chr <= 0xff &&
              (self.encoding["$binary?"]() ||
                self.internal_encoding["$binary?"]())
            ) {
              return "\\x" + ("00" + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return (
                "\\u" + ("0000" + chr.toString(16).toUpperCase()).slice(-4)
              );
            }
          });
        return '"' + escaped.replace(/\#[\$\@\{]/g, "\\$&") + '"';
        /* eslint-enable no-misleading-character-class */
      }),
      ($String_inspect$35.$$arity = 0)
    );

    Opal.def(
      self,
      "$intern",
      ($String_intern$36 = function $$intern() {
        var self = this;

        return self.toString();
      }),
      ($String_intern$36.$$arity = 0)
    );

    Opal.def(
      self,
      "$lines",
      ($String_lines$37 = function $$lines(separator) {
        var $iter = $String_lines$37.$$p,
          block = $iter || nil,
          self = this,
          e = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        if ($iter) $String_lines$37.$$p = null;

        if ($iter) $String_lines$37.$$p = null;

        if (separator == null) {
          separator = $gvars["/"];
        }
        e = $send(self, "each_line", [separator], block.$to_proc());
        if ($truthy(block)) {
          return self;
        } else {
          return e.$to_a();
        }
      }),
      ($String_lines$37.$$arity = -1)
    );

    Opal.def(
      self,
      "$ljust",
      ($String_ljust$38 = function $$ljust(width, padstr) {
        var self = this;

        if (padstr == null) {
          padstr = " ";
        }
        width = $coerce_to(width, $$($nesting, "Integer"), "to_int");
        padstr = $coerce_to(padstr, $$($nesting, "String"), "to_str").$to_s();
        if ($truthy(padstr["$empty?"]())) {
          self.$raise($$($nesting, "ArgumentError"), "zero width padding");
        }
        if ($truthy(width <= self.length)) {
          return self;
        }

        var index = -1,
          result = "";

        width -= self.length;

        while (++index < width) {
          result += padstr;
        }

        return self.$$cast(self + result.slice(0, width));
      }),
      ($String_ljust$38.$$arity = -2)
    );

    Opal.def(
      self,
      "$lstrip",
      ($String_lstrip$39 = function $$lstrip() {
        var self = this;

        return self.replace(/^\s*/, "");
      }),
      ($String_lstrip$39.$$arity = 0)
    );

    Opal.def(
      self,
      "$ascii_only?",
      ($String_ascii_only$ques$40 = function () {
        var self = this;

        if (!self.encoding.ascii) return false;
        return /^[\x00-\x7F]*$/.test(self);
      }),
      ($String_ascii_only$ques$40.$$arity = 0)
    );

    Opal.def(
      self,
      "$match",
      ($String_match$41 = function $$match(pattern, pos) {
        var $iter = $String_match$41.$$p,
          block = $iter || nil,
          self = this,
          $ret_or_1 = nil;

        if ($iter) $String_match$41.$$p = null;

        if ($iter) $String_match$41.$$p = null;
        if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_1 = $$($nesting, "String")["$==="](pattern)))
              ) {
                return $ret_or_1;
              } else {
                return pattern["$respond_to?"]("to_str");
              }
              return nil;
            })()
          )
        ) {
          pattern = $$($nesting, "Regexp").$new(pattern.$to_str());
        }
        if ($truthy($$($nesting, "Regexp")["$==="](pattern))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" +
              "wrong argument type " +
              pattern.$class() +
              " (expected Regexp)"
          );
        }
        return $send(pattern, "match", [self, pos], block.$to_proc());
      }),
      ($String_match$41.$$arity = -2)
    );

    Opal.def(
      self,
      "$match?",
      ($String_match$ques$42 = function (pattern, pos) {
        var self = this,
          $ret_or_2 = nil;

        if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_2 = $$($nesting, "String")["$==="](pattern)))
              ) {
                return $ret_or_2;
              } else {
                return pattern["$respond_to?"]("to_str");
              }
              return nil;
            })()
          )
        ) {
          pattern = $$($nesting, "Regexp").$new(pattern.$to_str());
        }
        if ($truthy($$($nesting, "Regexp")["$==="](pattern))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" +
              "wrong argument type " +
              pattern.$class() +
              " (expected Regexp)"
          );
        }
        return pattern["$match?"](self, pos);
      }),
      ($String_match$ques$42.$$arity = -2)
    );

    Opal.def(
      self,
      "$next",
      ($String_next$43 = function $$next() {
        var self = this;

        var i = self.length;
        if (i === 0) {
          return self.$$cast("");
        }
        var result = self;
        var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
        var carry = false;
        var code;
        while (i--) {
          code = self.charCodeAt(i);
          if (
            (code >= 48 && code <= 57) ||
            (code >= 65 && code <= 90) ||
            (code >= 97 && code <= 122)
          ) {
            switch (code) {
              case 57:
                carry = true;
                code = 48;
                break;
              case 90:
                carry = true;
                code = 65;
                break;
              case 122:
                carry = true;
                code = 97;
                break;
              default:
                carry = false;
                code += 1;
            }
          } else {
            if (first_alphanum_char_index === -1) {
              if (code === 255) {
                carry = true;
                code = 0;
              } else {
                carry = false;
                code += 1;
              }
            } else {
              carry = true;
            }
          }
          result =
            result.slice(0, i) +
            String.fromCharCode(code) +
            result.slice(i + 1);
          if (carry && (i === 0 || i === first_alphanum_char_index)) {
            switch (code) {
              case 65:
                break;
              case 97:
                break;
              default:
                code += 1;
            }
            if (i === 0) {
              result = String.fromCharCode(code) + result;
            } else {
              result =
                result.slice(0, i) +
                String.fromCharCode(code) +
                result.slice(i);
            }
            carry = false;
          }
          if (!carry) {
            break;
          }
        }
        return self.$$cast(result);
      }),
      ($String_next$43.$$arity = 0)
    );

    Opal.def(
      self,
      "$oct",
      ($String_oct$44 = function $$oct() {
        var self = this;

        var result,
          string = self,
          radix = 8;

        if (/^\s*_/.test(string)) {
          return 0;
        }

        string = string.replace(
          /^(\s*[+-]?)(0[bodx]?)(.+)$/i,
          function (original, head, flag, tail) {
            switch (tail.charAt(0)) {
              case "+":
              case "-":
                return original;
              case "0":
                if (tail.charAt(1) === "x" && flag === "0x") {
                  return original;
                }
            }
            switch (flag) {
              case "0b":
                radix = 2;
                break;
              case "0":
              case "0o":
                radix = 8;
                break;
              case "0d":
                radix = 10;
                break;
              case "0x":
                radix = 16;
                break;
            }
            return head + tail;
          }
        );

        result = parseInt(string.replace(/_(?!_)/g, ""), radix);
        return isNaN(result) ? 0 : result;
      }),
      ($String_oct$44.$$arity = 0)
    );

    Opal.def(
      self,
      "$ord",
      ($String_ord$45 = function $$ord() {
        var self = this;

        if (typeof self.codePointAt === "function") {
          return self.codePointAt(0);
        } else {
          return self.charCodeAt(0);
        }
      }),
      ($String_ord$45.$$arity = 0)
    );

    Opal.def(
      self,
      "$partition",
      ($String_partition$46 = function $$partition(sep) {
        var self = this;

        var i, m;

        if (sep.$$is_regexp) {
          m = sep.exec(self);
          if (m === null) {
            i = -1;
          } else {
            $$($nesting, "MatchData").$new(sep, m);
            sep = m[0];
            i = m.index;
          }
        } else {
          sep = $coerce_to(sep, $$($nesting, "String"), "to_str");
          i = self.indexOf(sep);
        }

        if (i === -1) {
          return [self, "", ""];
        }

        return [
          self.slice(0, i),
          self.slice(i, i + sep.length),
          self.slice(i + sep.length),
        ];
      }),
      ($String_partition$46.$$arity = 1)
    );

    Opal.def(
      self,
      "$reverse",
      ($String_reverse$47 = function $$reverse() {
        var self = this;

        return self.split("").reverse().join("");
      }),
      ($String_reverse$47.$$arity = 0)
    );

    Opal.def(
      self,
      "$rindex",
      ($String_rindex$48 = function $$rindex(search, offset) {
        var self = this;

        var i, m, r, _m;

        if (offset === undefined) {
          offset = self.length;
        } else {
          offset = $coerce_to(offset, $$($nesting, "Integer"), "to_int");
          if (offset < 0) {
            offset += self.length;
            if (offset < 0) {
              return nil;
            }
          }
        }

        if (search.$$is_regexp) {
          m = null;
          r = Opal.global_multiline_regexp(search);
          while (true) {
            _m = r.exec(self);
            if (_m === null || _m.index > offset) {
              break;
            }
            m = _m;
            r.lastIndex = m.index + 1;
          }
          if (m === null) {
            $gvars["~"] = nil;
            i = -1;
          } else {
            $$($nesting, "MatchData").$new(r, m);
            i = m.index;
          }
        } else {
          search = $coerce_to(search, $$($nesting, "String"), "to_str");
          i = self.lastIndexOf(search, offset);
        }

        return i === -1 ? nil : i;
      }),
      ($String_rindex$48.$$arity = -2)
    );

    Opal.def(
      self,
      "$rjust",
      ($String_rjust$49 = function $$rjust(width, padstr) {
        var self = this;

        if (padstr == null) {
          padstr = " ";
        }
        width = $coerce_to(width, $$($nesting, "Integer"), "to_int");
        padstr = $coerce_to(padstr, $$($nesting, "String"), "to_str").$to_s();
        if ($truthy(padstr["$empty?"]())) {
          self.$raise($$($nesting, "ArgumentError"), "zero width padding");
        }
        if ($truthy(width <= self.length)) {
          return self;
        }

        var chars = Math.floor(width - self.length),
          patterns = Math.floor(chars / padstr.length),
          result = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

        return self.$$cast(result + padstr.slice(0, remaining) + self);
      }),
      ($String_rjust$49.$$arity = -2)
    );

    Opal.def(
      self,
      "$rpartition",
      ($String_rpartition$50 = function $$rpartition(sep) {
        var self = this;

        var i, m, r, _m;

        if (sep.$$is_regexp) {
          m = null;
          r = Opal.global_multiline_regexp(sep);

          while (true) {
            _m = r.exec(self);
            if (_m === null) {
              break;
            }
            m = _m;
            r.lastIndex = m.index + 1;
          }

          if (m === null) {
            i = -1;
          } else {
            $$($nesting, "MatchData").$new(r, m);
            sep = m[0];
            i = m.index;
          }
        } else {
          sep = $coerce_to(sep, $$($nesting, "String"), "to_str");
          i = self.lastIndexOf(sep);
        }

        if (i === -1) {
          return ["", "", self];
        }

        return [
          self.slice(0, i),
          self.slice(i, i + sep.length),
          self.slice(i + sep.length),
        ];
      }),
      ($String_rpartition$50.$$arity = 1)
    );

    Opal.def(
      self,
      "$rstrip",
      ($String_rstrip$51 = function $$rstrip() {
        var self = this;

        return self.replace(/[\s\u0000]*$/, "");
      }),
      ($String_rstrip$51.$$arity = 0)
    );

    Opal.def(
      self,
      "$scan",
      ($String_scan$52 = function $$scan(pattern) {
        var $iter = $String_scan$52.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $String_scan$52.$$p = null;

        if ($iter) $String_scan$52.$$p = null;

        var result = [],
          match_data = nil,
          match;

        if (pattern.$$is_regexp) {
          pattern = Opal.global_multiline_regexp(pattern);
        } else {
          pattern = $coerce_to(pattern, $$($nesting, "String"), "to_str");
          pattern = new RegExp(
            pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
            "gm"
          );
        }

        while ((match = pattern.exec(self)) != null) {
          match_data = $$($nesting, "MatchData").$new(pattern, match);
          if (block === nil) {
            match.length == 1
              ? result.push(match[0])
              : result.push(match_data.$captures());
          } else {
            match.length == 1
              ? Opal.yield1(block, match[0])
              : Opal.yield1(block, match_data.$captures());
          }
          if (pattern.lastIndex === match.index) {
            pattern.lastIndex += 1;
          }
        }

        $gvars["~"] = match_data;

        return block !== nil ? self : result;
      }),
      ($String_scan$52.$$arity = 1)
    );
    $alias(self, "slice", "[]");

    Opal.def(
      self,
      "$split",
      ($String_split$53 = function $$split(pattern, limit) {
        var self = this,
          $ret_or_3 = nil;
        if ($gvars[";"] == null) $gvars[";"] = nil;

        if (self.length === 0) {
          return [];
        }

        if (limit === undefined) {
          limit = 0;
        } else {
          limit = $$($nesting, "Opal")["$coerce_to!"](
            limit,
            $$($nesting, "Integer"),
            "to_int"
          );
          if (limit === 1) {
            return [self];
          }
        }

        if (pattern === undefined || pattern === nil) {
          pattern = (function () {
            if ($truthy(($ret_or_3 = $gvars[";"]))) {
              return $ret_or_3;
            } else {
              return " ";
            }
            return nil;
          })();
        }

        var result = [],
          string = self.toString(),
          index = 0,
          match,
          i,
          ii;

        if (pattern.$$is_regexp) {
          pattern = Opal.global_multiline_regexp(pattern);
        } else {
          pattern = $coerce_to(
            pattern,
            $$($nesting, "String"),
            "to_str"
          ).$to_s();
          if (pattern === " ") {
            pattern = /\s+/gm;
            string = string.replace(/^\s+/, "");
          } else {
            pattern = new RegExp(
              pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
              "gm"
            );
          }
        }

        result = string.split(pattern);

        if (result.length === 1 && result[0] === string) {
          return [self.$$cast(result[0])];
        }

        while ((i = result.indexOf(undefined)) !== -1) {
          result.splice(i, 1);
        }

        function castResult() {
          for (i = 0; i < result.length; i++) {
            result[i] = self.$$cast(result[i]);
          }
        }

        if (limit === 0) {
          while (result[result.length - 1] === "") {
            result.length -= 1;
          }
          castResult();
          return result;
        }

        match = pattern.exec(string);

        if (limit < 0) {
          if (
            match !== null &&
            match[0] === "" &&
            pattern.source.indexOf("(?=") === -1
          ) {
            for (i = 0, ii = match.length; i < ii; i++) {
              result.push("");
            }
          }
          castResult();
          return result;
        }

        if (match !== null && match[0] === "") {
          result.splice(
            limit - 1,
            result.length - 1,
            result.slice(limit - 1).join("")
          );
          castResult();
          return result;
        }

        if (limit >= result.length) {
          castResult();
          return result;
        }

        i = 0;
        while (match !== null) {
          i++;
          index = pattern.lastIndex;
          if (i + 1 === limit) {
            break;
          }
          match = pattern.exec(string);
        }
        result.splice(limit - 1, result.length - 1, string.slice(index));
        castResult();
        return result;
      }),
      ($String_split$53.$$arity = -1)
    );

    Opal.def(
      self,
      "$squeeze",
      ($String_squeeze$54 = function $$squeeze($a) {
        var $post_args,
          sets,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        sets = $post_args;

        if (sets.length === 0) {
          return self.$$cast(self.replace(/(.)\1+/g, "$1"));
        }
        var char_class = char_class_from_char_sets(sets);
        if (char_class === null) {
          return self;
        }
        return self.$$cast(
          self.replace(new RegExp("(" + char_class + ")\\1+", "g"), "$1")
        );
      }),
      ($String_squeeze$54.$$arity = -1)
    );

    Opal.def(
      self,
      "$start_with?",
      ($String_start_with$ques$55 = function ($a) {
        var $post_args,
          prefixes,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        prefixes = $post_args;

        for (var i = 0, length = prefixes.length; i < length; i++) {
          if (prefixes[i].$$is_regexp) {
            var regexp = prefixes[i];
            var match = regexp.exec(self);

            if (match != null && match.index === 0) {
              $gvars["~"] = $$($nesting, "MatchData").$new(regexp, match);
              return true;
            } else {
              $gvars["~"] = nil;
            }
          } else {
            var prefix = $coerce_to(
              prefixes[i],
              $$($nesting, "String"),
              "to_str"
            ).$to_s();

            if (self.indexOf(prefix) === 0) {
              return true;
            }
          }
        }

        return false;
      }),
      ($String_start_with$ques$55.$$arity = -1)
    );

    Opal.def(
      self,
      "$strip",
      ($String_strip$56 = function $$strip() {
        var self = this;

        return self.replace(/^\s*/, "").replace(/[\s\u0000]*$/, "");
      }),
      ($String_strip$56.$$arity = 0)
    );

    Opal.def(
      self,
      "$sub",
      ($String_sub$57 = function $$sub(pattern, replacement) {
        var $iter = $String_sub$57.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $String_sub$57.$$p = null;

        if ($iter) $String_sub$57.$$p = null;
        if (!pattern.$$is_regexp) {
          pattern = $coerce_to(pattern, $$($nesting, "String"), "to_str");
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
        }

        var result,
          match = pattern.exec(self);

        if (match === null) {
          $gvars["~"] = nil;
          result = self.toString();
        } else {
          $$($nesting, "MatchData").$new(pattern, match);

          if (replacement === undefined) {
            if (block === nil) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "wrong number of arguments (1 for 2)"
              );
            }
            result =
              self.slice(0, match.index) +
              block(match[0]) +
              self.slice(match.index + match[0].length);
          } else if (replacement.$$is_hash) {
            result =
              self.slice(0, match.index) +
              replacement["$[]"](match[0]).$to_s() +
              self.slice(match.index + match[0].length);
          } else {
            replacement = $coerce_to(
              replacement,
              $$($nesting, "String"),
              "to_str"
            );

            replacement = replacement
              .replace(
                /([\\]+)([0-9+&`'])/g,
                function (original, slashes, command) {
                  if (slashes.length % 2 === 0) {
                    return original;
                  }
                  switch (command) {
                    case "+":
                      for (var i = match.length - 1; i > 0; i--) {
                        if (match[i] !== undefined) {
                          return slashes.slice(1) + match[i];
                        }
                      }
                      return "";
                    case "&":
                      return slashes.slice(1) + match[0];
                    case "`":
                      return slashes.slice(1) + self.slice(0, match.index);
                    case "'":
                      return (
                        slashes.slice(1) +
                        self.slice(match.index + match[0].length)
                      );
                    default:
                      return slashes.slice(1) + (match[command] || "");
                  }
                }
              )
              .replace(/\\\\/g, "\\");

            result =
              self.slice(0, match.index) +
              replacement +
              self.slice(match.index + match[0].length);
          }
        }

        return self.$$cast(result);
      }),
      ($String_sub$57.$$arity = -2)
    );
    $alias(self, "succ", "next");

    Opal.def(
      self,
      "$sum",
      ($String_sum$58 = function $$sum(n) {
        var self = this;

        if (n == null) {
          n = 16;
        }

        n = $coerce_to(n, $$($nesting, "Integer"), "to_int");

        var result = 0,
          length = self.length,
          i = 0;

        for (; i < length; i++) {
          result += self.charCodeAt(i);
        }

        if (n <= 0) {
          return result;
        }

        return result & (Math.pow(2, n) - 1);
      }),
      ($String_sum$58.$$arity = -1)
    );

    Opal.def(
      self,
      "$swapcase",
      ($String_swapcase$59 = function $$swapcase() {
        var self = this;

        var str = self.replace(/([a-z]+)|([A-Z]+)/g, function ($0, $1, $2) {
          return $1 ? $0.toUpperCase() : $0.toLowerCase();
        });

        if (self.constructor === String) {
          return str;
        }

        return self.$class().$new(str);
      }),
      ($String_swapcase$59.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_f",
      ($String_to_f$60 = function $$to_f() {
        var self = this;

        if (self.charAt(0) === "_") {
          return 0;
        }

        var result = parseFloat(self.replace(/_/g, ""));

        if (isNaN(result) || result == Infinity || result == -Infinity) {
          return 0;
        } else {
          return result;
        }
      }),
      ($String_to_f$60.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_i",
      ($String_to_i$61 = function $$to_i(base) {
        var self = this;

        if (base == null) {
          base = 10;
        }

        var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$($nesting, "Integer"), "to_int");

        if (radix === 1 || radix < 0 || radix > 36) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "invalid radix " + radix
          );
        }

        if (/^\s*_/.test(string)) {
          return 0;
        }

        string = string.replace(
          /^(\s*[+-]?)(0[bodx]?)(.+)$/,
          function (original, head, flag, tail) {
            switch (tail.charAt(0)) {
              case "+":
              case "-":
                return original;
              case "0":
                if (
                  tail.charAt(1) === "x" &&
                  flag === "0x" &&
                  (radix === 0 || radix === 16)
                ) {
                  return original;
                }
            }
            switch (flag) {
              case "0b":
                if (radix === 0 || radix === 2) {
                  radix = 2;
                  return head + tail;
                }
                break;
              case "0":
              case "0o":
                if (radix === 0 || radix === 8) {
                  radix = 8;
                  return head + tail;
                }
                break;
              case "0d":
                if (radix === 0 || radix === 10) {
                  radix = 10;
                  return head + tail;
                }
                break;
              case "0x":
                if (radix === 0 || radix === 16) {
                  radix = 16;
                  return head + tail;
                }
                break;
            }
            return original;
          }
        );

        result = parseInt(string.replace(/_(?!_)/g, ""), radix);
        return isNaN(result) ? 0 : result;
      }),
      ($String_to_i$61.$$arity = -1)
    );

    Opal.def(
      self,
      "$to_proc",
      ($String_to_proc$62 = function $$to_proc() {
        var $$63,
          $iter = $String_to_proc$62.$$p,
          $yield = $iter || nil,
          self = this,
          method_name = nil;

        if ($iter) $String_to_proc$62.$$p = null;

        method_name = $rb_plus("$", self.valueOf());
        return $send(
          self,
          "proc",
          [],
          (($$63 = function ($a) {
            var self = $$63.$$s == null ? this : $$63.$$s,
              $iter = $$63.$$p,
              block = $iter || nil,
              $post_args,
              args;

            if ($iter) $$63.$$p = null;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;

            if (args.length === 0) {
              self.$raise($$($nesting, "ArgumentError"), "no receiver given");
            }

            var recv = args[0];

            if (recv == null) recv = nil;

            var body = recv[method_name];

            if (!body) {
              return recv.$method_missing.apply(recv, args);
            }

            if (typeof block === "function") {
              body.$$p = block;
            }

            if (args.length === 1) {
              return body.call(recv);
            } else {
              return body.apply(recv, args.slice(1));
            }
          }),
          ($$63.$$s = self),
          ($$63.$$arity = -1),
          $$63)
        );
      }),
      ($String_to_proc$62.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($String_to_s$64 = function $$to_s() {
        var self = this;

        return self.toString();
      }),
      ($String_to_s$64.$$arity = 0)
    );
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");

    Opal.def(
      self,
      "$tr",
      ($String_tr$65 = function $$tr(from, to) {
        var self = this;

        from = $coerce_to(from, $$($nesting, "String"), "to_str").$to_s();
        to = $coerce_to(to, $$($nesting, "String"), "to_str").$to_s();

        if (from.length == 0 || from === to) {
          return self;
        }

        var i, in_range, c, ch, start, end, length;
        var subs = {};
        var from_chars = from.split("");
        var from_length = from_chars.length;
        var to_chars = to.split("");
        var to_length = to_chars.length;

        var inverse = false;
        var global_sub = null;
        if (from_chars[0] === "^" && from_chars.length > 1) {
          inverse = true;
          from_chars.shift();
          global_sub = to_chars[to_length - 1];
          from_length -= 1;
        }

        var from_chars_expanded = [];
        var last_from = null;
        in_range = false;
        for (i = 0; i < from_length; i++) {
          ch = from_chars[i];
          if (last_from == null) {
            last_from = ch;
            from_chars_expanded.push(ch);
          } else if (ch === "-") {
            if (last_from === "-") {
              from_chars_expanded.push("-");
              from_chars_expanded.push("-");
            } else if (i == from_length - 1) {
              from_chars_expanded.push("-");
            } else {
              in_range = true;
            }
          } else if (in_range) {
            start = last_from.charCodeAt(0);
            end = ch.charCodeAt(0);
            if (start > end) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" +
                  'invalid range "' +
                  String.fromCharCode(start) +
                  "-" +
                  String.fromCharCode(end) +
                  '" in string transliteration'
              );
            }
            for (c = start + 1; c < end; c++) {
              from_chars_expanded.push(String.fromCharCode(c));
            }
            from_chars_expanded.push(ch);
            in_range = null;
            last_from = null;
          } else {
            from_chars_expanded.push(ch);
          }
        }

        from_chars = from_chars_expanded;
        from_length = from_chars.length;

        if (inverse) {
          for (i = 0; i < from_length; i++) {
            subs[from_chars[i]] = true;
          }
        } else {
          if (to_length > 0) {
            var to_chars_expanded = [];
            var last_to = null;
            in_range = false;
            for (i = 0; i < to_length; i++) {
              ch = to_chars[i];
              if (last_to == null) {
                last_to = ch;
                to_chars_expanded.push(ch);
              } else if (ch === "-") {
                if (last_to === "-") {
                  to_chars_expanded.push("-");
                  to_chars_expanded.push("-");
                } else if (i == to_length - 1) {
                  to_chars_expanded.push("-");
                } else {
                  in_range = true;
                }
              } else if (in_range) {
                start = last_to.charCodeAt(0);
                end = ch.charCodeAt(0);
                if (start > end) {
                  self.$raise(
                    $$($nesting, "ArgumentError"),
                    "" +
                      'invalid range "' +
                      String.fromCharCode(start) +
                      "-" +
                      String.fromCharCode(end) +
                      '" in string transliteration'
                  );
                }
                for (c = start + 1; c < end; c++) {
                  to_chars_expanded.push(String.fromCharCode(c));
                }
                to_chars_expanded.push(ch);
                in_range = null;
                last_to = null;
              } else {
                to_chars_expanded.push(ch);
              }
            }

            to_chars = to_chars_expanded;
            to_length = to_chars.length;
          }

          var length_diff = from_length - to_length;
          if (length_diff > 0) {
            var pad_char = to_length > 0 ? to_chars[to_length - 1] : "";
            for (i = 0; i < length_diff; i++) {
              to_chars.push(pad_char);
            }
          }

          for (i = 0; i < from_length; i++) {
            subs[from_chars[i]] = to_chars[i];
          }
        }

        var new_str = "";
        for (i = 0, length = self.length; i < length; i++) {
          ch = self.charAt(i);
          var sub = subs[ch];
          if (inverse) {
            new_str += sub == null ? global_sub : ch;
          } else {
            new_str += sub != null ? sub : ch;
          }
        }
        return self.$$cast(new_str);
      }),
      ($String_tr$65.$$arity = 2)
    );

    Opal.def(
      self,
      "$tr_s",
      ($String_tr_s$66 = function $$tr_s(from, to) {
        var self = this;

        from = $coerce_to(from, $$($nesting, "String"), "to_str").$to_s();
        to = $coerce_to(to, $$($nesting, "String"), "to_str").$to_s();

        if (from.length == 0) {
          return self;
        }

        var i, in_range, c, ch, start, end, length;
        var subs = {};
        var from_chars = from.split("");
        var from_length = from_chars.length;
        var to_chars = to.split("");
        var to_length = to_chars.length;

        var inverse = false;
        var global_sub = null;
        if (from_chars[0] === "^" && from_chars.length > 1) {
          inverse = true;
          from_chars.shift();
          global_sub = to_chars[to_length - 1];
          from_length -= 1;
        }

        var from_chars_expanded = [];
        var last_from = null;
        in_range = false;
        for (i = 0; i < from_length; i++) {
          ch = from_chars[i];
          if (last_from == null) {
            last_from = ch;
            from_chars_expanded.push(ch);
          } else if (ch === "-") {
            if (last_from === "-") {
              from_chars_expanded.push("-");
              from_chars_expanded.push("-");
            } else if (i == from_length - 1) {
              from_chars_expanded.push("-");
            } else {
              in_range = true;
            }
          } else if (in_range) {
            start = last_from.charCodeAt(0);
            end = ch.charCodeAt(0);
            if (start > end) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" +
                  'invalid range "' +
                  String.fromCharCode(start) +
                  "-" +
                  String.fromCharCode(end) +
                  '" in string transliteration'
              );
            }
            for (c = start + 1; c < end; c++) {
              from_chars_expanded.push(String.fromCharCode(c));
            }
            from_chars_expanded.push(ch);
            in_range = null;
            last_from = null;
          } else {
            from_chars_expanded.push(ch);
          }
        }

        from_chars = from_chars_expanded;
        from_length = from_chars.length;

        if (inverse) {
          for (i = 0; i < from_length; i++) {
            subs[from_chars[i]] = true;
          }
        } else {
          if (to_length > 0) {
            var to_chars_expanded = [];
            var last_to = null;
            in_range = false;
            for (i = 0; i < to_length; i++) {
              ch = to_chars[i];
              if (last_from == null) {
                last_from = ch;
                to_chars_expanded.push(ch);
              } else if (ch === "-") {
                if (last_to === "-") {
                  to_chars_expanded.push("-");
                  to_chars_expanded.push("-");
                } else if (i == to_length - 1) {
                  to_chars_expanded.push("-");
                } else {
                  in_range = true;
                }
              } else if (in_range) {
                start = last_from.charCodeAt(0);
                end = ch.charCodeAt(0);
                if (start > end) {
                  self.$raise(
                    $$($nesting, "ArgumentError"),
                    "" +
                      'invalid range "' +
                      String.fromCharCode(start) +
                      "-" +
                      String.fromCharCode(end) +
                      '" in string transliteration'
                  );
                }
                for (c = start + 1; c < end; c++) {
                  to_chars_expanded.push(String.fromCharCode(c));
                }
                to_chars_expanded.push(ch);
                in_range = null;
                last_from = null;
              } else {
                to_chars_expanded.push(ch);
              }
            }

            to_chars = to_chars_expanded;
            to_length = to_chars.length;
          }

          var length_diff = from_length - to_length;
          if (length_diff > 0) {
            var pad_char = to_length > 0 ? to_chars[to_length - 1] : "";
            for (i = 0; i < length_diff; i++) {
              to_chars.push(pad_char);
            }
          }

          for (i = 0; i < from_length; i++) {
            subs[from_chars[i]] = to_chars[i];
          }
        }
        var new_str = "";
        var last_substitute = null;
        for (i = 0, length = self.length; i < length; i++) {
          ch = self.charAt(i);
          var sub = subs[ch];
          if (inverse) {
            if (sub == null) {
              if (last_substitute == null) {
                new_str += global_sub;
                last_substitute = true;
              }
            } else {
              new_str += ch;
              last_substitute = null;
            }
          } else {
            if (sub != null) {
              if (last_substitute == null || last_substitute !== sub) {
                new_str += sub;
                last_substitute = sub;
              }
            } else {
              new_str += ch;
              last_substitute = null;
            }
          }
        }
        return self.$$cast(new_str);
      }),
      ($String_tr_s$66.$$arity = 2)
    );

    Opal.def(
      self,
      "$upcase",
      ($String_upcase$67 = function $$upcase() {
        var self = this;

        return self.$$cast(self.toUpperCase());
      }),
      ($String_upcase$67.$$arity = 0)
    );

    Opal.def(
      self,
      "$upto",
      ($String_upto$68 = function $$upto(stop, excl) {
        var $iter = $String_upto$68.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $String_upto$68.$$p = null;

        if ($iter) $String_upto$68.$$p = null;

        if (excl == null) {
          excl = false;
        }
        if (block !== nil) {
        } else {
          return self.$enum_for("upto", stop, excl);
        }

        var a,
          b,
          s = self.toString();

        stop = $coerce_to(stop, $$($nesting, "String"), "to_str");

        if (s.length === 1 && stop.length === 1) {
          a = s.charCodeAt(0);
          b = stop.charCodeAt(0);

          while (a <= b) {
            if (excl && a === b) {
              break;
            }

            block(String.fromCharCode(a));

            a += 1;
          }
        } else if (
          parseInt(s, 10).toString() === s &&
          parseInt(stop, 10).toString() === stop
        ) {
          a = parseInt(s, 10);
          b = parseInt(stop, 10);

          while (a <= b) {
            if (excl && a === b) {
              break;
            }

            block(a.toString());

            a += 1;
          }
        } else {
          while (s.length <= stop.length && s <= stop) {
            if (excl && s === stop) {
              break;
            }

            block(s);

            s = s.$succ();
          }
        }
        return self;
      }),
      ($String_upto$68.$$arity = -2)
    );

    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = "",
          i,
          len = set.length,
          curr_char,
          skip_next_dash,
          char_code_from,
          char_code_upto,
          char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === "-" && i > 0 && i < len - 1 && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" +
                  'invalid range "' +
                  char_code_from +
                  "-" +
                  char_code_upto +
                  '" in string transliteration'
              );
            }
            for (
              char_code = char_code_from + 1;
              char_code < char_code_upto + 1;
              char_code++
            ) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = curr_char === "\\";
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = "",
          i,
          len = setA.length,
          chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i,
        len,
        set,
        neg,
        chr,
        tmp,
        pos_intersection = "",
        neg_intersection = "";

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$($nesting, "String"), "to_str");
        neg = set.charAt(0) === "^" && set.length > 1;
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = "";
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = "";
      }

      if (pos_intersection.length > 0) {
        return "[" + $$($nesting, "Regexp").$escape(pos_intersection) + "]";
      }

      if (neg_intersection.length > 0) {
        return "[^" + $$($nesting, "Regexp").$escape(neg_intersection) + "]";
      }

      return null;
    }
    Opal.def(
      self,
      "$instance_variables",
      ($String_instance_variables$69 = function $$instance_variables() {
        var self = this;

        return [];
      }),
      ($String_instance_variables$69.$$arity = 0)
    );
    Opal.defs(
      self,
      "$_load",
      ($String__load$70 = function $$_load($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        return $send(self, "new", Opal.to_a(args));
      }),
      ($String__load$70.$$arity = -1)
    );

    Opal.def(
      self,
      "$unicode_normalize",
      ($String_unicode_normalize$71 = function $$unicode_normalize(form) {
        var self = this;

        if (form == null) {
          form = "nfc";
        }
        if ($truthy(["nfc", "nfd", "nfkc", "nfkd"]["$include?"](form))) {
        } else {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "Invalid normalization form " + form
          );
        }
        return self.normalize(form.$upcase());
      }),
      ($String_unicode_normalize$71.$$arity = -1)
    );

    Opal.def(
      self,
      "$unicode_normalized?",
      ($String_unicode_normalized$ques$72 = function (form) {
        var self = this;

        if (form == null) {
          form = "nfc";
        }
        return self.$unicode_normalize(form)["$=="](self);
      }),
      ($String_unicode_normalized$ques$72.$$arity = -1)
    );

    Opal.def(
      self,
      "$unpack",
      ($String_unpack$73 = function $$unpack(format) {
        var self = this;

        return self.$raise(
          "To use String#unpack, you must first require 'corelib/string/unpack'."
        );
      }),
      ($String_unpack$73.$$arity = 1)
    );

    Opal.def(
      self,
      "$unpack1",
      ($String_unpack1$74 = function $$unpack1(format) {
        var self = this;

        return self.$raise(
          "To use String#unpack1, you must first require 'corelib/string/unpack'."
        );
      }),
      ($String_unpack1$74.$$arity = 1)
    );

    Opal.def(
      self,
      "$freeze",
      ($String_freeze$75 = function $$freeze() {
        var self = this;

        if (typeof self === "string") return self;
        self.$$frozen = true;
        return self;
      }),
      ($String_freeze$75.$$arity = 0)
    );
    $alias(self, "+@", "dup");

    Opal.def(
      self,
      "$-@",
      ($String_$minus$$76 = function () {
        var self = this;

        if (typeof self === "string") return self;
        if (self.$$frozen === true) return self;
        if (
          self.encoding.name == "UTF-8" &&
          self.internal_encoding.name == "UTF-8"
        )
          return self.toString();
        return self.$dup().$freeze();
      }),
      ($String_$minus$$76.$$arity = 0)
    );

    Opal.def(
      self,
      "$frozen?",
      ($String_frozen$ques$77 = function () {
        var self = this;

        return typeof self === "string" || self.$$frozen === true;
      }),
      ($String_frozen$ques$77.$$arity = 0)
    );
    return $$($nesting, "Opal").$pristine(self, "initialize");
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], "Symbol", $$($nesting, "String"));
};

Opal.modules["corelib/enumerable"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_le(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs <= rhs
      : lhs["$<="](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $falsy = Opal.falsy,
    $truthy = Opal.truthy,
    $coerce_to = Opal.coerce_to,
    $module = Opal.module,
    $send = Opal.send,
    $alias = Opal.alias,
    $hash2 = Opal.hash2,
    $lambda = Opal.lambda;

  Opal.add_stubs([
    "$each",
    "$public_send",
    "$destructure",
    "$to_enum",
    "$enumerator_size",
    "$new",
    "$yield",
    "$raise",
    "$slice_when",
    "$!",
    "$enum_for",
    "$flatten",
    "$map",
    "$warn",
    "$proc",
    "$==",
    "$nil?",
    "$respond_to?",
    "$coerce_to!",
    "$>",
    "$*",
    "$try_convert",
    "$<",
    "$+",
    "$-",
    "$ceil",
    "$/",
    "$size",
    "$select",
    "$to_proc",
    "$__send__",
    "$length",
    "$<=",
    "$[]",
    "$push",
    "$<<",
    "$[]=",
    "$===",
    "$inspect",
    "$<=>",
    "$first",
    "$reverse",
    "$sort",
    "$take",
    "$sort_by",
    "$compare",
    "$call",
    "$dup",
    "$to_a",
    "$sort!",
    "$map!",
    "$key?",
    "$values",
    "$transform_values",
    "$group_by",
    "$to_h",
    "$coerce_to?",
    "$class",
    "$zip",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Enumerable");

    var $nesting = [self].concat($parent_nesting),
      $Enumerable_all$ques$1,
      $Enumerable_any$ques$5,
      $Enumerable_chunk$9,
      $Enumerable_chunk_while$12,
      $Enumerable_collect$14,
      $Enumerable_collect_concat$16,
      $Enumerable_count$19,
      $Enumerable_cycle$23,
      $Enumerable_detect$25,
      $Enumerable_drop$27,
      $Enumerable_drop_while$28,
      $Enumerable_each_cons$29,
      $Enumerable_each_entry$31,
      $Enumerable_each_slice$33,
      $Enumerable_each_with_index$35,
      $Enumerable_each_with_object$37,
      $Enumerable_entries$39,
      $Enumerable_filter_map$40,
      $Enumerable_find_all$42,
      $Enumerable_find_index$44,
      $Enumerable_first$47,
      $Enumerable_grep$50,
      $Enumerable_grep_v$52,
      $Enumerable_group_by$54,
      $Enumerable_include$ques$56,
      $Enumerable_inject$58,
      $Enumerable_lazy$59,
      $Enumerable_enumerator_size$61,
      $Enumerable_max$62,
      $Enumerable_max_by$63,
      $Enumerable_min$65,
      $Enumerable_min_by$67,
      $Enumerable_minmax$69,
      $Enumerable_minmax_by$71,
      $Enumerable_none$ques$73,
      $Enumerable_one$ques$77,
      $Enumerable_partition$81,
      $Enumerable_reject$83,
      $Enumerable_reverse_each$85,
      $Enumerable_slice_before$87,
      $Enumerable_slice_after$89,
      $Enumerable_slice_when$92,
      $Enumerable_sort$94,
      $Enumerable_sort_by$96,
      $Enumerable_sum$101,
      $Enumerable_take$103,
      $Enumerable_take_while$104,
      $Enumerable_uniq$106,
      $Enumerable_tally$108,
      $Enumerable_to_h$109,
      $Enumerable_zip$110;

    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
    Opal.def(
      self,
      "$all?",
      ($Enumerable_all$ques$1 = function (pattern) {
        try {
          var $iter = $Enumerable_all$ques$1.$$p,
            block = $iter || nil,
            $$2,
            $$3,
            $$4,
            self = this;

          if ($iter) $Enumerable_all$ques$1.$$p = null;

          if ($iter) $Enumerable_all$ques$1.$$p = null;
          if ($truthy(pattern !== undefined)) {
            $send(
              self,
              "each",
              [],
              (($$2 = function ($a) {
                var self = $$2.$$s == null ? this : $$2.$$s,
                  $post_args,
                  value,
                  comparable = nil;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                comparable = comparableForPattern(value);
                if (
                  $truthy(
                    $send(
                      pattern,
                      "public_send",
                      ["==="].concat(Opal.to_a(comparable))
                    )
                  )
                ) {
                  return nil;
                } else {
                  Opal.ret(false);
                }
              }),
              ($$2.$$s = self),
              ($$2.$$arity = -1),
              $$2)
            );
          } else if (block !== nil) {
            $send(
              self,
              "each",
              [],
              (($$3 = function ($a) {
                var self = $$3.$$s == null ? this : $$3.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                  return nil;
                } else {
                  Opal.ret(false);
                }
              }),
              ($$3.$$s = self),
              ($$3.$$arity = -1),
              $$3)
            );
          } else {
            $send(
              self,
              "each",
              [],
              (($$4 = function ($a) {
                var self = $$4.$$s == null ? this : $$4.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy($$($nesting, "Opal").$destructure(value))) {
                  return nil;
                } else {
                  Opal.ret(false);
                }
              }),
              ($$4.$$s = self),
              ($$4.$$arity = -1),
              $$4)
            );
          }
          return true;
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_all$ques$1.$$arity = -1)
    );

    Opal.def(
      self,
      "$any?",
      ($Enumerable_any$ques$5 = function (pattern) {
        try {
          var $iter = $Enumerable_any$ques$5.$$p,
            block = $iter || nil,
            $$6,
            $$7,
            $$8,
            self = this;

          if ($iter) $Enumerable_any$ques$5.$$p = null;

          if ($iter) $Enumerable_any$ques$5.$$p = null;
          if ($truthy(pattern !== undefined)) {
            $send(
              self,
              "each",
              [],
              (($$6 = function ($a) {
                var self = $$6.$$s == null ? this : $$6.$$s,
                  $post_args,
                  value,
                  comparable = nil;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                comparable = comparableForPattern(value);
                if (
                  $truthy(
                    $send(
                      pattern,
                      "public_send",
                      ["==="].concat(Opal.to_a(comparable))
                    )
                  )
                ) {
                  Opal.ret(true);
                } else {
                  return nil;
                }
              }),
              ($$6.$$s = self),
              ($$6.$$arity = -1),
              $$6)
            );
          } else if (block !== nil) {
            $send(
              self,
              "each",
              [],
              (($$7 = function ($a) {
                var self = $$7.$$s == null ? this : $$7.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                  Opal.ret(true);
                } else {
                  return nil;
                }
              }),
              ($$7.$$s = self),
              ($$7.$$arity = -1),
              $$7)
            );
          } else {
            $send(
              self,
              "each",
              [],
              (($$8 = function ($a) {
                var self = $$8.$$s == null ? this : $$8.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy($$($nesting, "Opal").$destructure(value))) {
                  Opal.ret(true);
                } else {
                  return nil;
                }
              }),
              ($$8.$$s = self),
              ($$8.$$arity = -1),
              $$8)
            );
          }
          return false;
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_any$ques$5.$$arity = -1)
    );

    Opal.def(
      self,
      "$chunk",
      ($Enumerable_chunk$9 = function $$chunk() {
        var $iter = $Enumerable_chunk$9.$$p,
          block = $iter || nil,
          $$10,
          $$11,
          self = this;

        if ($iter) $Enumerable_chunk$9.$$p = null;

        if ($iter) $Enumerable_chunk$9.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "to_enum",
            ["chunk"],
            (($$10 = function () {
              var self = $$10.$$s == null ? this : $$10.$$s;

              return self.$enumerator_size();
            }),
            ($$10.$$s = self),
            ($$10.$$arity = 0),
            $$10)
          );
        }
        return $send(
          $$$("::", "Enumerator"),
          "new",
          [],
          (($$11 = function (yielder) {
            var self = $$11.$$s == null ? this : $$11.$$s;

            if (yielder == null) {
              yielder = nil;
            }

            var previous = nil,
              accumulate = [];

            function releaseAccumulate() {
              if (accumulate.length > 0) {
                yielder.$yield(previous, accumulate);
              }
            }

            self.$each.$$p = function (value) {
              var key = Opal.yield1(block, value);

              if (key === nil) {
                releaseAccumulate();
                accumulate = [];
                previous = nil;
              } else {
                if (previous === nil || previous === key) {
                  accumulate.push(value);
                } else {
                  releaseAccumulate();
                  accumulate = [value];
                }

                previous = key;
              }
            };

            self.$each();

            releaseAccumulate();
          }),
          ($$11.$$s = self),
          ($$11.$$arity = 1),
          $$11)
        );
      }),
      ($Enumerable_chunk$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$chunk_while",
      ($Enumerable_chunk_while$12 = function $$chunk_while() {
        var $iter = $Enumerable_chunk_while$12.$$p,
          block = $iter || nil,
          $$13,
          self = this;

        if ($iter) $Enumerable_chunk_while$12.$$p = null;

        if ($iter) $Enumerable_chunk_while$12.$$p = null;
        if (block !== nil) {
        } else {
          self.$raise($$($nesting, "ArgumentError"), "no block given");
        }
        return $send(
          self,
          "slice_when",
          [],
          (($$13 = function (before, after) {
            var self = $$13.$$s == null ? this : $$13.$$s;

            if (before == null) {
              before = nil;
            }

            if (after == null) {
              after = nil;
            }
            return Opal.yieldX(block, [before, after])["$!"]();
          }),
          ($$13.$$s = self),
          ($$13.$$arity = 2),
          $$13)
        );
      }),
      ($Enumerable_chunk_while$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$collect",
      ($Enumerable_collect$14 = function $$collect() {
        var $iter = $Enumerable_collect$14.$$p,
          block = $iter || nil,
          $$15,
          self = this;

        if ($iter) $Enumerable_collect$14.$$p = null;

        if ($iter) $Enumerable_collect$14.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["collect"],
            (($$15 = function () {
              var self = $$15.$$s == null ? this : $$15.$$s;

              return self.$enumerator_size();
            }),
            ($$15.$$s = self),
            ($$15.$$arity = 0),
            $$15)
          );
        }

        var result = [];

        self.$each.$$p = function () {
          var value = Opal.yieldX(block, arguments);

          result.push(value);
        };

        self.$each();

        return result;
      }),
      ($Enumerable_collect$14.$$arity = 0)
    );

    Opal.def(
      self,
      "$collect_concat",
      ($Enumerable_collect_concat$16 = function $$collect_concat() {
        var $iter = $Enumerable_collect_concat$16.$$p,
          block = $iter || nil,
          $$17,
          $$18,
          self = this;

        if ($iter) $Enumerable_collect_concat$16.$$p = null;

        if ($iter) $Enumerable_collect_concat$16.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["collect_concat"],
            (($$17 = function () {
              var self = $$17.$$s == null ? this : $$17.$$s;

              return self.$enumerator_size();
            }),
            ($$17.$$s = self),
            ($$17.$$arity = 0),
            $$17)
          );
        }
        return $send(
          self,
          "map",
          [],
          (($$18 = function (item) {
            var self = $$18.$$s == null ? this : $$18.$$s;

            if (item == null) {
              item = nil;
            }
            return Opal.yield1(block, item);
          }),
          ($$18.$$s = self),
          ($$18.$$arity = 1),
          $$18)
        ).$flatten(1);
      }),
      ($Enumerable_collect_concat$16.$$arity = 0)
    );

    Opal.def(
      self,
      "$count",
      ($Enumerable_count$19 = function $$count(object) {
        var $iter = $Enumerable_count$19.$$p,
          block = $iter || nil,
          $$20,
          $$21,
          $$22,
          self = this,
          result = nil;

        if ($iter) $Enumerable_count$19.$$p = null;

        if ($iter) $Enumerable_count$19.$$p = null;
        result = 0;

        if (object != null && block !== nil) {
          self.$warn("warning: given block not used");
        }
        if ($truthy(object != null)) {
          block = $send(
            self,
            "proc",
            [],
            (($$20 = function ($a) {
              var self = $$20.$$s == null ? this : $$20.$$s,
                $post_args,
                args;

              $post_args = Opal.slice.call(arguments, 0, arguments.length);

              args = $post_args;
              return $$($nesting, "Opal").$destructure(args)["$=="](object);
            }),
            ($$20.$$s = self),
            ($$20.$$arity = -1),
            $$20)
          );
        } else if ($truthy(block["$nil?"]())) {
          block = $send(
            self,
            "proc",
            [],
            (($$21 = function () {
              var self = $$21.$$s == null ? this : $$21.$$s;

              return true;
            }),
            ($$21.$$s = self),
            ($$21.$$arity = 0),
            $$21)
          );
        }
        $send(
          self,
          "each",
          [],
          (($$22 = function ($a) {
            var self = $$22.$$s == null ? this : $$22.$$s,
              $post_args,
              args;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;
            if ($truthy(Opal.yieldX(block, args))) {
              return result++;
            } else {
              return nil;
            }
          }),
          ($$22.$$s = self),
          ($$22.$$arity = -1),
          $$22)
        );
        return result;
      }),
      ($Enumerable_count$19.$$arity = -1)
    );

    Opal.def(
      self,
      "$cycle",
      ($Enumerable_cycle$23 = function $$cycle(n) {
        var $iter = $Enumerable_cycle$23.$$p,
          block = $iter || nil,
          $$24,
          self = this;

        if ($iter) $Enumerable_cycle$23.$$p = null;

        if ($iter) $Enumerable_cycle$23.$$p = null;

        if (n == null) {
          n = nil;
        }
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["cycle", n],
            (($$24 = function () {
              var self = $$24.$$s == null ? this : $$24.$$s;

              if ($truthy(n["$nil?"]())) {
                if ($truthy(self["$respond_to?"]("size"))) {
                  return $$$($$($nesting, "Float"), "INFINITY");
                } else {
                  return nil;
                }
              } else {
                n = $$($nesting, "Opal")["$coerce_to!"](
                  n,
                  $$($nesting, "Integer"),
                  "to_int"
                );
                if ($truthy($rb_gt(n, 0))) {
                  return $rb_times(self.$enumerator_size(), n);
                } else {
                  return 0;
                }
              }
            }),
            ($$24.$$s = self),
            ($$24.$$arity = 0),
            $$24)
          );
        }
        if ($truthy(n["$nil?"]())) {
        } else {
          n = $$($nesting, "Opal")["$coerce_to!"](
            n,
            $$($nesting, "Integer"),
            "to_int"
          );
          if ($truthy(n <= 0)) {
            return nil;
          }
        }

        var all = [],
          i,
          length,
          value;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          all.push(param);
        };

        self.$each();

        if (all.length === 0) {
          return nil;
        }

        if (n === nil) {
          while (true) {
            for (i = 0, length = all.length; i < length; i++) {
              value = Opal.yield1(block, all[i]);
            }
          }
        } else {
          while (n > 1) {
            for (i = 0, length = all.length; i < length; i++) {
              value = Opal.yield1(block, all[i]);
            }

            n--;
          }
        }
      }),
      ($Enumerable_cycle$23.$$arity = -1)
    );

    Opal.def(
      self,
      "$detect",
      ($Enumerable_detect$25 = function $$detect(ifnone) {
        try {
          var $iter = $Enumerable_detect$25.$$p,
            block = $iter || nil,
            $$26,
            self = this;

          if ($iter) $Enumerable_detect$25.$$p = null;

          if ($iter) $Enumerable_detect$25.$$p = null;
          if (block !== nil) {
          } else {
            return self.$enum_for("detect", ifnone);
          }
          $send(
            self,
            "each",
            [],
            (($$26 = function ($a) {
              var self = $$26.$$s == null ? this : $$26.$$s,
                $post_args,
                args,
                value = nil;

              $post_args = Opal.slice.call(arguments, 0, arguments.length);

              args = $post_args;
              value = $$($nesting, "Opal").$destructure(args);
              if ($truthy(Opal.yield1(block, value))) {
                Opal.ret(value);
              } else {
                return nil;
              }
            }),
            ($$26.$$s = self),
            ($$26.$$arity = -1),
            $$26)
          );

          if (ifnone !== undefined) {
            if (typeof ifnone === "function") {
              return ifnone();
            } else {
              return ifnone;
            }
          }
          return nil;
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_detect$25.$$arity = -1)
    );

    Opal.def(
      self,
      "$drop",
      ($Enumerable_drop$27 = function $$drop(number) {
        var self = this;

        number = $coerce_to(number, $$($nesting, "Integer"), "to_int");
        if ($truthy(number < 0)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "attempt to drop negative size"
          );
        }

        var result = [],
          current = 0;

        self.$each.$$p = function () {
          if (number <= current) {
            result.push($$($nesting, "Opal").$destructure(arguments));
          }

          current++;
        };

        self.$each();

        return result;
      }),
      ($Enumerable_drop$27.$$arity = 1)
    );

    Opal.def(
      self,
      "$drop_while",
      ($Enumerable_drop_while$28 = function $$drop_while() {
        var $iter = $Enumerable_drop_while$28.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Enumerable_drop_while$28.$$p = null;

        if ($iter) $Enumerable_drop_while$28.$$p = null;
        if (block !== nil) {
        } else {
          return self.$enum_for("drop_while");
        }

        var result = [],
          dropping = true;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments);

          if (dropping) {
            var value = Opal.yield1(block, param);

            if ($falsy(value)) {
              dropping = false;
              result.push(param);
            }
          } else {
            result.push(param);
          }
        };

        self.$each();

        return result;
      }),
      ($Enumerable_drop_while$28.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_cons",
      ($Enumerable_each_cons$29 = function $$each_cons(n) {
        var $iter = $Enumerable_each_cons$29.$$p,
          block = $iter || nil,
          $$30,
          self = this;

        if ($iter) $Enumerable_each_cons$29.$$p = null;

        if ($iter) $Enumerable_each_cons$29.$$p = null;
        if ($truthy(arguments.length != 1)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "wrong number of arguments (" + arguments.length + " for 1)"
          );
        }
        n = $$($nesting, "Opal").$try_convert(
          n,
          $$($nesting, "Integer"),
          "to_int"
        );
        if ($truthy(n <= 0)) {
          self.$raise($$($nesting, "ArgumentError"), "invalid size");
        }
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_cons", n],
            (($$30 = function () {
              var self = $$30.$$s == null ? this : $$30.$$s,
                enum_size = nil,
                $ret_or_1 = nil;

              enum_size = self.$enumerator_size();
              if ($truthy(enum_size["$nil?"]())) {
                return nil;
              } else if (
                $truthy(
                  (function () {
                    if ($truthy(($ret_or_1 = enum_size["$=="](0)))) {
                      return $ret_or_1;
                    } else {
                      return $rb_lt(enum_size, n);
                    }
                    return nil;
                  })()
                )
              ) {
                return 0;
              } else {
                return $rb_plus($rb_minus(enum_size, n), 1);
              }
            }),
            ($$30.$$s = self),
            ($$30.$$arity = 0),
            $$30)
          );
        }

        var buffer = [];

        self.$each.$$p = function () {
          var element = $$($nesting, "Opal").$destructure(arguments);
          buffer.push(element);
          if (buffer.length > n) {
            buffer.shift();
          }
          if (buffer.length == n) {
            Opal.yield1(block, buffer.slice(0, n));
          }
        };

        self.$each();

        return nil;
      }),
      ($Enumerable_each_cons$29.$$arity = 1)
    );

    Opal.def(
      self,
      "$each_entry",
      ($Enumerable_each_entry$31 = function $$each_entry($a) {
        var $iter = $Enumerable_each_entry$31.$$p,
          block = $iter || nil,
          $post_args,
          data,
          $$32,
          self = this;

        if ($iter) $Enumerable_each_entry$31.$$p = null;

        if ($iter) $Enumerable_each_entry$31.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        data = $post_args;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "to_enum",
            ["each_entry"].concat(Opal.to_a(data)),
            (($$32 = function () {
              var self = $$32.$$s == null ? this : $$32.$$s;

              return self.$enumerator_size();
            }),
            ($$32.$$s = self),
            ($$32.$$arity = 0),
            $$32)
          );
        }

        self.$each.$$p = function () {
          var item = $$($nesting, "Opal").$destructure(arguments);

          Opal.yield1(block, item);
        };

        self.$each.apply(self, data);

        return self;
      }),
      ($Enumerable_each_entry$31.$$arity = -1)
    );

    Opal.def(
      self,
      "$each_slice",
      ($Enumerable_each_slice$33 = function $$each_slice(n) {
        var $iter = $Enumerable_each_slice$33.$$p,
          block = $iter || nil,
          $$34,
          self = this;

        if ($iter) $Enumerable_each_slice$33.$$p = null;

        if ($iter) $Enumerable_each_slice$33.$$p = null;
        n = $coerce_to(n, $$($nesting, "Integer"), "to_int");
        if ($truthy(n <= 0)) {
          self.$raise($$($nesting, "ArgumentError"), "invalid slice size");
        }
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_slice", n],
            (($$34 = function () {
              var self = $$34.$$s == null ? this : $$34.$$s;

              if ($truthy(self["$respond_to?"]("size"))) {
                return $rb_divide(self.$size(), n).$ceil();
              } else {
                return nil;
              }
            }),
            ($$34.$$s = self),
            ($$34.$$arity = 0),
            $$34)
          );
        }

        var slice = [];

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments);

          slice.push(param);

          if (slice.length === n) {
            Opal.yield1(block, slice);
            slice = [];
          }
        };

        self.$each();

        // our "last" group, if smaller than n then won't have been yielded
        if (slice.length > 0) {
          Opal.yield1(block, slice);
        }
        return nil;
      }),
      ($Enumerable_each_slice$33.$$arity = 1)
    );

    Opal.def(
      self,
      "$each_with_index",
      ($Enumerable_each_with_index$35 = function $$each_with_index($a) {
        var $iter = $Enumerable_each_with_index$35.$$p,
          block = $iter || nil,
          $post_args,
          args,
          $$36,
          self = this;

        if ($iter) $Enumerable_each_with_index$35.$$p = null;

        if ($iter) $Enumerable_each_with_index$35.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_with_index"].concat(Opal.to_a(args)),
            (($$36 = function () {
              var self = $$36.$$s == null ? this : $$36.$$s;

              return self.$enumerator_size();
            }),
            ($$36.$$s = self),
            ($$36.$$arity = 0),
            $$36)
          );
        }

        var index = 0;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments);

          block(param, index);

          index++;
        };

        self.$each.apply(self, args);
        return self;
      }),
      ($Enumerable_each_with_index$35.$$arity = -1)
    );

    Opal.def(
      self,
      "$each_with_object",
      ($Enumerable_each_with_object$37 = function $$each_with_object(object) {
        var $iter = $Enumerable_each_with_object$37.$$p,
          block = $iter || nil,
          $$38,
          self = this;

        if ($iter) $Enumerable_each_with_object$37.$$p = null;

        if ($iter) $Enumerable_each_with_object$37.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_with_object", object],
            (($$38 = function () {
              var self = $$38.$$s == null ? this : $$38.$$s;

              return self.$enumerator_size();
            }),
            ($$38.$$s = self),
            ($$38.$$arity = 0),
            $$38)
          );
        }

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments);

          block(param, object);
        };

        self.$each();
        return object;
      }),
      ($Enumerable_each_with_object$37.$$arity = 1)
    );

    Opal.def(
      self,
      "$entries",
      ($Enumerable_entries$39 = function $$entries($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        var result = [];

        self.$each.$$p = function () {
          result.push($$($nesting, "Opal").$destructure(arguments));
        };

        self.$each.apply(self, args);

        return result;
      }),
      ($Enumerable_entries$39.$$arity = -1)
    );

    Opal.def(
      self,
      "$filter_map",
      ($Enumerable_filter_map$40 = function $$filter_map() {
        var $iter = $Enumerable_filter_map$40.$$p,
          block = $iter || nil,
          $$41,
          self = this;

        if ($iter) $Enumerable_filter_map$40.$$p = null;

        if ($iter) $Enumerable_filter_map$40.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["filter_map"],
            (($$41 = function () {
              var self = $$41.$$s == null ? this : $$41.$$s;

              return self.$enumerator_size();
            }),
            ($$41.$$s = self),
            ($$41.$$arity = 0),
            $$41)
          );
        }
        return $send(
          $send(self, "map", [], block.$to_proc()),
          "select",
          [],
          "itself".$to_proc()
        );
      }),
      ($Enumerable_filter_map$40.$$arity = 0)
    );
    $alias(self, "find", "detect");

    Opal.def(
      self,
      "$find_all",
      ($Enumerable_find_all$42 = function $$find_all() {
        var $iter = $Enumerable_find_all$42.$$p,
          block = $iter || nil,
          $$43,
          self = this;

        if ($iter) $Enumerable_find_all$42.$$p = null;

        if ($iter) $Enumerable_find_all$42.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["find_all"],
            (($$43 = function () {
              var self = $$43.$$s == null ? this : $$43.$$s;

              return self.$enumerator_size();
            }),
            ($$43.$$s = self),
            ($$43.$$arity = 0),
            $$43)
          );
        }

        var result = [];

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          if ($truthy(value)) {
            result.push(param);
          }
        };

        self.$each();

        return result;
      }),
      ($Enumerable_find_all$42.$$arity = 0)
    );
    $alias(self, "filter", "find_all");

    Opal.def(
      self,
      "$find_index",
      ($Enumerable_find_index$44 = function $$find_index(object) {
        try {
          var $iter = $Enumerable_find_index$44.$$p,
            block = $iter || nil,
            $$45,
            $$46,
            self = this,
            index = nil;

          if ($iter) $Enumerable_find_index$44.$$p = null;

          if ($iter) $Enumerable_find_index$44.$$p = null;
          if ($truthy(object === undefined && block === nil)) {
            return self.$enum_for("find_index");
          }

          if (object != null && block !== nil) {
            self.$warn("warning: given block not used");
          }
          index = 0;
          if ($truthy(object != null)) {
            $send(
              self,
              "each",
              [],
              (($$45 = function ($a) {
                var self = $$45.$$s == null ? this : $$45.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($$($nesting, "Opal").$destructure(value)["$=="](object)) {
                  Opal.ret(index);
                }
                return (index += 1);
              }),
              ($$45.$$s = self),
              ($$45.$$arity = -1),
              $$45)
            );
          } else {
            $send(
              self,
              "each",
              [],
              (($$46 = function ($a) {
                var self = $$46.$$s == null ? this : $$46.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                  Opal.ret(index);
                }
                return (index += 1);
              }),
              ($$46.$$s = self),
              ($$46.$$arity = -1),
              $$46)
            );
          }
          return nil;
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_find_index$44.$$arity = -1)
    );

    Opal.def(
      self,
      "$first",
      ($Enumerable_first$47 = function $$first(number) {
        try {
          var $$48,
            $$49,
            self = this,
            result = nil,
            current = nil;

          if ($truthy(number === undefined)) {
            return $send(
              self,
              "each",
              [],
              (($$48 = function (value) {
                var self = $$48.$$s == null ? this : $$48.$$s;

                if (value == null) {
                  value = nil;
                }
                Opal.ret(value);
              }),
              ($$48.$$s = self),
              ($$48.$$arity = 1),
              $$48)
            );
          } else {
            result = [];
            number = $coerce_to(number, $$($nesting, "Integer"), "to_int");
            if ($truthy(number < 0)) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "attempt to take negative size"
              );
            }
            if ($truthy(number == 0)) {
              return [];
            }
            current = 0;
            $send(
              self,
              "each",
              [],
              (($$49 = function ($a) {
                var self = $$49.$$s == null ? this : $$49.$$s,
                  $post_args,
                  args;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                args = $post_args;
                result.push($$($nesting, "Opal").$destructure(args));
                if ($truthy(number <= ++current)) {
                  Opal.ret(result);
                } else {
                  return nil;
                }
              }),
              ($$49.$$s = self),
              ($$49.$$arity = -1),
              $$49)
            );
            return result;
          }
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_first$47.$$arity = -1)
    );
    $alias(self, "flat_map", "collect_concat");

    Opal.def(
      self,
      "$grep",
      ($Enumerable_grep$50 = function $$grep(pattern) {
        var $iter = $Enumerable_grep$50.$$p,
          block = $iter || nil,
          $$51,
          self = this,
          result = nil;

        if ($iter) $Enumerable_grep$50.$$p = null;

        if ($iter) $Enumerable_grep$50.$$p = null;
        result = [];
        $send(
          self,
          "each",
          [],
          (($$51 = function ($a) {
            var self = $$51.$$s == null ? this : $$51.$$s,
              $post_args,
              value,
              cmp = nil;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            value = $post_args;
            cmp = comparableForPattern(value);
            if (
              $truthy(
                $send(pattern, "__send__", ["==="].concat(Opal.to_a(cmp)))
              )
            ) {
            } else {
              return nil;
            }
            if (block !== nil) {
              if ($truthy($rb_gt(value.$length(), 1))) {
                value = [value];
              }
              value = Opal.yieldX(block, Opal.to_a(value));
            } else if ($truthy($rb_le(value.$length(), 1))) {
              value = value["$[]"](0);
            }
            return result.$push(value);
          }),
          ($$51.$$s = self),
          ($$51.$$arity = -1),
          $$51)
        );
        return result;
      }),
      ($Enumerable_grep$50.$$arity = 1)
    );

    Opal.def(
      self,
      "$grep_v",
      ($Enumerable_grep_v$52 = function $$grep_v(pattern) {
        var $iter = $Enumerable_grep_v$52.$$p,
          block = $iter || nil,
          $$53,
          self = this,
          result = nil;

        if ($iter) $Enumerable_grep_v$52.$$p = null;

        if ($iter) $Enumerable_grep_v$52.$$p = null;
        result = [];
        $send(
          self,
          "each",
          [],
          (($$53 = function ($a) {
            var self = $$53.$$s == null ? this : $$53.$$s,
              $post_args,
              value,
              cmp = nil;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            value = $post_args;
            cmp = comparableForPattern(value);
            if (
              $truthy(
                $send(pattern, "__send__", ["==="].concat(Opal.to_a(cmp)))
              )
            ) {
              return nil;
            }
            if (block !== nil) {
              if ($truthy($rb_gt(value.$length(), 1))) {
                value = [value];
              }
              value = Opal.yieldX(block, Opal.to_a(value));
            } else if ($truthy($rb_le(value.$length(), 1))) {
              value = value["$[]"](0);
            }
            return result.$push(value);
          }),
          ($$53.$$s = self),
          ($$53.$$arity = -1),
          $$53)
        );
        return result;
      }),
      ($Enumerable_grep_v$52.$$arity = 1)
    );

    Opal.def(
      self,
      "$group_by",
      ($Enumerable_group_by$54 = function $$group_by() {
        var $iter = $Enumerable_group_by$54.$$p,
          block = $iter || nil,
          $$55,
          self = this,
          hash = nil,
          $ret_or_2 = nil,
          $writer = nil;

        if ($iter) $Enumerable_group_by$54.$$p = null;

        if ($iter) $Enumerable_group_by$54.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["group_by"],
            (($$55 = function () {
              var self = $$55.$$s == null ? this : $$55.$$s;

              return self.$enumerator_size();
            }),
            ($$55.$$s = self),
            ($$55.$$arity = 0),
            $$55)
          );
        }
        hash = $hash2([], {});

        var result;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          (function () {
            if ($truthy(($ret_or_2 = hash["$[]"](value)))) {
              return $ret_or_2;
            } else {
              $writer = [value, []];
              $send(hash, "[]=", Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            }
            return nil;
          })()["$<<"](param);
        };

        self.$each();

        if (result !== undefined) {
          return result;
        }
        return hash;
      }),
      ($Enumerable_group_by$54.$$arity = 0)
    );

    Opal.def(
      self,
      "$include?",
      ($Enumerable_include$ques$56 = function (obj) {
        try {
          var $$57,
            self = this;

          $send(
            self,
            "each",
            [],
            (($$57 = function ($a) {
              var self = $$57.$$s == null ? this : $$57.$$s,
                $post_args,
                args;

              $post_args = Opal.slice.call(arguments, 0, arguments.length);

              args = $post_args;
              if ($$($nesting, "Opal").$destructure(args)["$=="](obj)) {
                Opal.ret(true);
              } else {
                return nil;
              }
            }),
            ($$57.$$s = self),
            ($$57.$$arity = -1),
            $$57)
          );
          return false;
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_include$ques$56.$$arity = 1)
    );

    Opal.def(
      self,
      "$inject",
      ($Enumerable_inject$58 = function $$inject(object, sym) {
        var $iter = $Enumerable_inject$58.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Enumerable_inject$58.$$p = null;

        if ($iter) $Enumerable_inject$58.$$p = null;
        var result = object;

        if (block !== nil && sym === undefined) {
          self.$each.$$p = function () {
            var value = $$($nesting, "Opal").$destructure(arguments);

            if (result === undefined) {
              result = value;
              return;
            }

            value = Opal.yieldX(block, [result, value]);

            result = value;
          };
        } else {
          if (sym === undefined) {
            if (!$$($nesting, "Symbol")["$==="](object)) {
              self.$raise(
                $$($nesting, "TypeError"),
                "" + object.$inspect() + " is not a Symbol"
              );
            }

            sym = object;
            result = undefined;
          }

          self.$each.$$p = function () {
            var value = $$($nesting, "Opal").$destructure(arguments);

            if (result === undefined) {
              result = value;
              return;
            }

            result = result.$__send__(sym, value);
          };
        }

        self.$each();

        return result == undefined ? nil : result;
      }),
      ($Enumerable_inject$58.$$arity = -1)
    );

    Opal.def(
      self,
      "$lazy",
      ($Enumerable_lazy$59 = function $$lazy() {
        var $$60,
          self = this;

        return $send(
          $$$($$($nesting, "Enumerator"), "Lazy"),
          "new",
          [self, self.$enumerator_size()],
          (($$60 = function (enum$, $a) {
            var self = $$60.$$s == null ? this : $$60.$$s,
              $post_args,
              args;

            if (enum$ == null) {
              enum$ = nil;
            }

            $post_args = Opal.slice.call(arguments, 1, arguments.length);

            args = $post_args;
            return $send(enum$, "yield", Opal.to_a(args));
          }),
          ($$60.$$s = self),
          ($$60.$$arity = -2),
          $$60)
        );
      }),
      ($Enumerable_lazy$59.$$arity = 0)
    );

    Opal.def(
      self,
      "$enumerator_size",
      ($Enumerable_enumerator_size$61 = function $$enumerator_size() {
        var self = this;

        if ($truthy(self["$respond_to?"]("size"))) {
          return self.$size();
        } else {
          return nil;
        }
      }),
      ($Enumerable_enumerator_size$61.$$arity = 0)
    );
    $alias(self, "map", "collect");

    Opal.def(
      self,
      "$max",
      ($Enumerable_max$62 = function $$max(n) {
        var $iter = $Enumerable_max$62.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Enumerable_max$62.$$p = null;

        if ($iter) $Enumerable_max$62.$$p = null;
        if (n === undefined || n === nil) {
          var result, value;

          self.$each.$$p = function () {
            var item = $$($nesting, "Opal").$destructure(arguments);

            if (result === undefined) {
              result = item;
              return;
            }

            if (block !== nil) {
              value = Opal.yieldX(block, [item, result]);
            } else {
              value = item["$<=>"](result);
            }

            if (value === nil) {
              self.$raise($$($nesting, "ArgumentError"), "comparison failed");
            }

            if (value > 0) {
              result = item;
            }
          };

          self.$each();

          if (result === undefined) {
            return nil;
          } else {
            return result;
          }
        }

        n = $coerce_to(n, $$($nesting, "Integer"), "to_int");
        return $send(self, "sort", [], block.$to_proc()).$reverse().$first(n);
      }),
      ($Enumerable_max$62.$$arity = -1)
    );

    Opal.def(
      self,
      "$max_by",
      ($Enumerable_max_by$63 = function $$max_by(n) {
        var $iter = $Enumerable_max_by$63.$$p,
          block = $iter || nil,
          $$64,
          self = this;

        if ($iter) $Enumerable_max_by$63.$$p = null;

        if ($iter) $Enumerable_max_by$63.$$p = null;

        if (n == null) {
          n = nil;
        }
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["max_by", n],
            (($$64 = function () {
              var self = $$64.$$s == null ? this : $$64.$$s;

              return self.$enumerator_size();
            }),
            ($$64.$$s = self),
            ($$64.$$arity = 0),
            $$64)
          );
        }
        if ($truthy(n["$nil?"]())) {
        } else {
          return $send(self, "sort_by", [], block.$to_proc())
            .$reverse()
            .$take(n);
        }

        var result, by;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          if (result === undefined) {
            result = param;
            by = value;
            return;
          }

          if (value["$<=>"](by) > 0) {
            result = param;
            by = value;
          }
        };

        self.$each();

        return result === undefined ? nil : result;
      }),
      ($Enumerable_max_by$63.$$arity = -1)
    );
    $alias(self, "member?", "include?");

    Opal.def(
      self,
      "$min",
      ($Enumerable_min$65 = function $$min(n) {
        var $iter = $Enumerable_min$65.$$p,
          block = $iter || nil,
          $$66,
          self = this;

        if ($iter) $Enumerable_min$65.$$p = null;

        if ($iter) $Enumerable_min$65.$$p = null;

        if (n == null) {
          n = nil;
        }
        if ($truthy(n["$nil?"]())) {
        } else if (block !== nil) {
          return $send(
            self,
            "sort",
            [],
            (($$66 = function (a, b) {
              var self = $$66.$$s == null ? this : $$66.$$s;

              if (a == null) {
                a = nil;
              }

              if (b == null) {
                b = nil;
              }
              return Opal.yieldX(block, [a, b]);
            }),
            ($$66.$$s = self),
            ($$66.$$arity = 2),
            $$66)
          ).$take(n);
        } else {
          return self.$sort().$take(n);
        }

        var result;

        if (block !== nil) {
          self.$each.$$p = function () {
            var param = $$($nesting, "Opal").$destructure(arguments);

            if (result === undefined) {
              result = param;
              return;
            }

            var value = block(param, result);

            if (value === nil) {
              self.$raise($$($nesting, "ArgumentError"), "comparison failed");
            }

            if (value < 0) {
              result = param;
            }
          };
        } else {
          self.$each.$$p = function () {
            var param = $$($nesting, "Opal").$destructure(arguments);

            if (result === undefined) {
              result = param;
              return;
            }

            if ($$($nesting, "Opal").$compare(param, result) < 0) {
              result = param;
            }
          };
        }

        self.$each();

        return result === undefined ? nil : result;
      }),
      ($Enumerable_min$65.$$arity = -1)
    );

    Opal.def(
      self,
      "$min_by",
      ($Enumerable_min_by$67 = function $$min_by(n) {
        var $iter = $Enumerable_min_by$67.$$p,
          block = $iter || nil,
          $$68,
          self = this;

        if ($iter) $Enumerable_min_by$67.$$p = null;

        if ($iter) $Enumerable_min_by$67.$$p = null;

        if (n == null) {
          n = nil;
        }
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["min_by", n],
            (($$68 = function () {
              var self = $$68.$$s == null ? this : $$68.$$s;

              return self.$enumerator_size();
            }),
            ($$68.$$s = self),
            ($$68.$$arity = 0),
            $$68)
          );
        }
        if ($truthy(n["$nil?"]())) {
        } else {
          return $send(self, "sort_by", [], block.$to_proc()).$take(n);
        }

        var result, by;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          if (result === undefined) {
            result = param;
            by = value;
            return;
          }

          if (value["$<=>"](by) < 0) {
            result = param;
            by = value;
          }
        };

        self.$each();

        return result === undefined ? nil : result;
      }),
      ($Enumerable_min_by$67.$$arity = -1)
    );

    Opal.def(
      self,
      "$minmax",
      ($Enumerable_minmax$69 = function $$minmax() {
        var $iter = $Enumerable_minmax$69.$$p,
          block = $iter || nil,
          $$70,
          self = this,
          $ret_or_3 = nil;

        if ($iter) $Enumerable_minmax$69.$$p = null;

        if ($iter) $Enumerable_minmax$69.$$p = null;
        block = (function () {
          if ($truthy(($ret_or_3 = block))) {
            return $ret_or_3;
          } else {
            return $send(
              self,
              "proc",
              [],
              (($$70 = function (a, b) {
                var self = $$70.$$s == null ? this : $$70.$$s;

                if (a == null) {
                  a = nil;
                }

                if (b == null) {
                  b = nil;
                }
                return a["$<=>"](b);
              }),
              ($$70.$$s = self),
              ($$70.$$arity = 2),
              $$70)
            );
          }
          return nil;
        })();

        var min = nil,
          max = nil,
          first_time = true;

        self.$each.$$p = function () {
          var element = $$($nesting, "Opal").$destructure(arguments);
          if (first_time) {
            min = max = element;
            first_time = false;
          } else {
            var min_cmp = block.$call(min, element);

            if (min_cmp === nil) {
              self.$raise($$($nesting, "ArgumentError"), "comparison failed");
            } else if (min_cmp > 0) {
              min = element;
            }

            var max_cmp = block.$call(max, element);

            if (max_cmp === nil) {
              self.$raise($$($nesting, "ArgumentError"), "comparison failed");
            } else if (max_cmp < 0) {
              max = element;
            }
          }
        };

        self.$each();

        return [min, max];
      }),
      ($Enumerable_minmax$69.$$arity = 0)
    );

    Opal.def(
      self,
      "$minmax_by",
      ($Enumerable_minmax_by$71 = function $$minmax_by() {
        var $iter = $Enumerable_minmax_by$71.$$p,
          block = $iter || nil,
          $$72,
          self = this;

        if ($iter) $Enumerable_minmax_by$71.$$p = null;

        if ($iter) $Enumerable_minmax_by$71.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["minmax_by"],
            (($$72 = function () {
              var self = $$72.$$s == null ? this : $$72.$$s;

              return self.$enumerator_size();
            }),
            ($$72.$$s = self),
            ($$72.$$arity = 0),
            $$72)
          );
        }

        var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          if (min_by === undefined || value["$<=>"](min_by) < 0) {
            min_result = param;
            min_by = value;
          }

          if (max_by === undefined || value["$<=>"](max_by) > 0) {
            max_result = param;
            max_by = value;
          }
        };

        self.$each();

        return [min_result, max_result];
      }),
      ($Enumerable_minmax_by$71.$$arity = 0)
    );

    Opal.def(
      self,
      "$none?",
      ($Enumerable_none$ques$73 = function (pattern) {
        try {
          var $iter = $Enumerable_none$ques$73.$$p,
            block = $iter || nil,
            $$74,
            $$75,
            $$76,
            self = this;

          if ($iter) $Enumerable_none$ques$73.$$p = null;

          if ($iter) $Enumerable_none$ques$73.$$p = null;
          if ($truthy(pattern !== undefined)) {
            $send(
              self,
              "each",
              [],
              (($$74 = function ($a) {
                var self = $$74.$$s == null ? this : $$74.$$s,
                  $post_args,
                  value,
                  comparable = nil;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                comparable = comparableForPattern(value);
                if (
                  $truthy(
                    $send(
                      pattern,
                      "public_send",
                      ["==="].concat(Opal.to_a(comparable))
                    )
                  )
                ) {
                  Opal.ret(false);
                } else {
                  return nil;
                }
              }),
              ($$74.$$s = self),
              ($$74.$$arity = -1),
              $$74)
            );
          } else if (block !== nil) {
            $send(
              self,
              "each",
              [],
              (($$75 = function ($a) {
                var self = $$75.$$s == null ? this : $$75.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                  Opal.ret(false);
                } else {
                  return nil;
                }
              }),
              ($$75.$$s = self),
              ($$75.$$arity = -1),
              $$75)
            );
          } else {
            $send(
              self,
              "each",
              [],
              (($$76 = function ($a) {
                var self = $$76.$$s == null ? this : $$76.$$s,
                  $post_args,
                  value,
                  item = nil;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                item = $$($nesting, "Opal").$destructure(value);
                if ($truthy(item)) {
                  Opal.ret(false);
                } else {
                  return nil;
                }
              }),
              ($$76.$$s = self),
              ($$76.$$arity = -1),
              $$76)
            );
          }
          return true;
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_none$ques$73.$$arity = -1)
    );

    Opal.def(
      self,
      "$one?",
      ($Enumerable_one$ques$77 = function (pattern) {
        try {
          var $iter = $Enumerable_one$ques$77.$$p,
            block = $iter || nil,
            $$78,
            $$79,
            $$80,
            self = this,
            count = nil;

          if ($iter) $Enumerable_one$ques$77.$$p = null;

          if ($iter) $Enumerable_one$ques$77.$$p = null;
          count = 0;
          if ($truthy(pattern !== undefined)) {
            $send(
              self,
              "each",
              [],
              (($$78 = function ($a) {
                var self = $$78.$$s == null ? this : $$78.$$s,
                  $post_args,
                  value,
                  comparable = nil;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                comparable = comparableForPattern(value);
                if (
                  $truthy(
                    $send(
                      pattern,
                      "public_send",
                      ["==="].concat(Opal.to_a(comparable))
                    )
                  )
                ) {
                  count = $rb_plus(count, 1);
                  if ($truthy($rb_gt(count, 1))) {
                    Opal.ret(false);
                  } else {
                    return nil;
                  }
                } else {
                  return nil;
                }
              }),
              ($$78.$$s = self),
              ($$78.$$arity = -1),
              $$78)
            );
          } else if (block !== nil) {
            $send(
              self,
              "each",
              [],
              (($$79 = function ($a) {
                var self = $$79.$$s == null ? this : $$79.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
                } else {
                  return nil;
                }
                count = $rb_plus(count, 1);
                if ($truthy($rb_gt(count, 1))) {
                  Opal.ret(false);
                } else {
                  return nil;
                }
              }),
              ($$79.$$s = self),
              ($$79.$$arity = -1),
              $$79)
            );
          } else {
            $send(
              self,
              "each",
              [],
              (($$80 = function ($a) {
                var self = $$80.$$s == null ? this : $$80.$$s,
                  $post_args,
                  value;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                value = $post_args;
                if ($truthy($$($nesting, "Opal").$destructure(value))) {
                } else {
                  return nil;
                }
                count = $rb_plus(count, 1);
                if ($truthy($rb_gt(count, 1))) {
                  Opal.ret(false);
                } else {
                  return nil;
                }
              }),
              ($$80.$$s = self),
              ($$80.$$arity = -1),
              $$80)
            );
          }
          return count["$=="](1);
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_one$ques$77.$$arity = -1)
    );

    Opal.def(
      self,
      "$partition",
      ($Enumerable_partition$81 = function $$partition() {
        var $iter = $Enumerable_partition$81.$$p,
          block = $iter || nil,
          $$82,
          self = this;

        if ($iter) $Enumerable_partition$81.$$p = null;

        if ($iter) $Enumerable_partition$81.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["partition"],
            (($$82 = function () {
              var self = $$82.$$s == null ? this : $$82.$$s;

              return self.$enumerator_size();
            }),
            ($$82.$$s = self),
            ($$82.$$arity = 0),
            $$82)
          );
        }

        var truthy = [],
          falsy = [],
          result;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          if ($truthy(value)) {
            truthy.push(param);
          } else {
            falsy.push(param);
          }
        };

        self.$each();

        return [truthy, falsy];
      }),
      ($Enumerable_partition$81.$$arity = 0)
    );
    $alias(self, "reduce", "inject");

    Opal.def(
      self,
      "$reject",
      ($Enumerable_reject$83 = function $$reject() {
        var $iter = $Enumerable_reject$83.$$p,
          block = $iter || nil,
          $$84,
          self = this;

        if ($iter) $Enumerable_reject$83.$$p = null;

        if ($iter) $Enumerable_reject$83.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["reject"],
            (($$84 = function () {
              var self = $$84.$$s == null ? this : $$84.$$s;

              return self.$enumerator_size();
            }),
            ($$84.$$s = self),
            ($$84.$$arity = 0),
            $$84)
          );
        }

        var result = [];

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = Opal.yield1(block, param);

          if ($falsy(value)) {
            result.push(param);
          }
        };

        self.$each();

        return result;
      }),
      ($Enumerable_reject$83.$$arity = 0)
    );

    Opal.def(
      self,
      "$reverse_each",
      ($Enumerable_reverse_each$85 = function $$reverse_each() {
        var $iter = $Enumerable_reverse_each$85.$$p,
          block = $iter || nil,
          $$86,
          self = this;

        if ($iter) $Enumerable_reverse_each$85.$$p = null;

        if ($iter) $Enumerable_reverse_each$85.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["reverse_each"],
            (($$86 = function () {
              var self = $$86.$$s == null ? this : $$86.$$s;

              return self.$enumerator_size();
            }),
            ($$86.$$s = self),
            ($$86.$$arity = 0),
            $$86)
          );
        }

        var result = [];

        self.$each.$$p = function () {
          result.push(arguments);
        };

        self.$each();

        for (var i = result.length - 1; i >= 0; i--) {
          Opal.yieldX(block, result[i]);
        }

        return result;
      }),
      ($Enumerable_reverse_each$85.$$arity = 0)
    );
    $alias(self, "select", "find_all");

    Opal.def(
      self,
      "$slice_before",
      ($Enumerable_slice_before$87 = function $$slice_before(pattern) {
        var $iter = $Enumerable_slice_before$87.$$p,
          block = $iter || nil,
          $$88,
          self = this;

        if ($iter) $Enumerable_slice_before$87.$$p = null;

        if ($iter) $Enumerable_slice_before$87.$$p = null;
        if ($truthy(pattern === undefined && block === nil)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "both pattern and block are given"
          );
        }
        if (
          $truthy(
            (pattern !== undefined && block !== nil) || arguments.length > 1
          )
        ) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" +
              "wrong number of arguments (" +
              arguments.length +
              " expected 1)"
          );
        }
        return $send(
          $$($nesting, "Enumerator"),
          "new",
          [],
          (($$88 = function (e) {
            var self = $$88.$$s == null ? this : $$88.$$s;

            if (e == null) {
              e = nil;
            }

            var slice = [];

            if (block !== nil) {
              if (pattern === undefined) {
                self.$each.$$p = function () {
                  var param = $$($nesting, "Opal").$destructure(arguments),
                    value = Opal.yield1(block, param);

                  if ($truthy(value) && slice.length > 0) {
                    e["$<<"](slice);
                    slice = [];
                  }

                  slice.push(param);
                };
              } else {
                self.$each.$$p = function () {
                  var param = $$($nesting, "Opal").$destructure(arguments),
                    value = block(param, pattern.$dup());

                  if ($truthy(value) && slice.length > 0) {
                    e["$<<"](slice);
                    slice = [];
                  }

                  slice.push(param);
                };
              }
            } else {
              self.$each.$$p = function () {
                var param = $$($nesting, "Opal").$destructure(arguments),
                  value = pattern["$==="](param);

                if ($truthy(value) && slice.length > 0) {
                  e["$<<"](slice);
                  slice = [];
                }

                slice.push(param);
              };
            }

            self.$each();

            if (slice.length > 0) {
              e["$<<"](slice);
            }
          }),
          ($$88.$$s = self),
          ($$88.$$arity = 1),
          $$88)
        );
      }),
      ($Enumerable_slice_before$87.$$arity = -1)
    );

    Opal.def(
      self,
      "$slice_after",
      ($Enumerable_slice_after$89 = function $$slice_after(pattern) {
        var $iter = $Enumerable_slice_after$89.$$p,
          block = $iter || nil,
          $$90,
          $$91,
          self = this;

        if ($iter) $Enumerable_slice_after$89.$$p = null;

        if ($iter) $Enumerable_slice_after$89.$$p = null;
        if ($truthy(pattern === undefined && block === nil)) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "both pattern and block are given"
          );
        }
        if (
          $truthy(
            (pattern !== undefined && block !== nil) || arguments.length > 1
          )
        ) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" +
              "wrong number of arguments (" +
              arguments.length +
              " expected 1)"
          );
        }
        if ($truthy(pattern !== undefined)) {
          block = $send(
            self,
            "proc",
            [],
            (($$90 = function (e) {
              var self = $$90.$$s == null ? this : $$90.$$s;

              if (e == null) {
                e = nil;
              }
              return pattern["$==="](e);
            }),
            ($$90.$$s = self),
            ($$90.$$arity = 1),
            $$90)
          );
        }
        return $send(
          $$($nesting, "Enumerator"),
          "new",
          [],
          (($$91 = function (yielder) {
            var self = $$91.$$s == null ? this : $$91.$$s;

            if (yielder == null) {
              yielder = nil;
            }

            var accumulate;

            self.$each.$$p = function () {
              var element = $$($nesting, "Opal").$destructure(arguments),
                end_chunk = Opal.yield1(block, element);

              if (accumulate == null) {
                accumulate = [];
              }

              if ($truthy(end_chunk)) {
                accumulate.push(element);
                yielder.$yield(accumulate);
                accumulate = null;
              } else {
                accumulate.push(element);
              }
            };

            self.$each();

            if (accumulate != null) {
              yielder.$yield(accumulate);
            }
          }),
          ($$91.$$s = self),
          ($$91.$$arity = 1),
          $$91)
        );
      }),
      ($Enumerable_slice_after$89.$$arity = -1)
    );

    Opal.def(
      self,
      "$slice_when",
      ($Enumerable_slice_when$92 = function $$slice_when() {
        var $iter = $Enumerable_slice_when$92.$$p,
          block = $iter || nil,
          $$93,
          self = this;

        if ($iter) $Enumerable_slice_when$92.$$p = null;

        if ($iter) $Enumerable_slice_when$92.$$p = null;
        if (block !== nil) {
        } else {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "wrong number of arguments (0 for 1)"
          );
        }
        return $send(
          $$($nesting, "Enumerator"),
          "new",
          [],
          (($$93 = function (yielder) {
            var self = $$93.$$s == null ? this : $$93.$$s;

            if (yielder == null) {
              yielder = nil;
            }

            var slice = nil,
              last_after = nil;

            self.$each_cons.$$p = function () {
              var params = $$($nesting, "Opal").$destructure(arguments),
                before = params[0],
                after = params[1],
                match = Opal.yieldX(block, [before, after]);

              last_after = after;

              if (slice === nil) {
                slice = [];
              }

              if ($truthy(match)) {
                slice.push(before);
                yielder.$yield(slice);
                slice = [];
              } else {
                slice.push(before);
              }
            };

            self.$each_cons(2);

            if (slice !== nil) {
              slice.push(last_after);
              yielder.$yield(slice);
            }
          }),
          ($$93.$$s = self),
          ($$93.$$arity = 1),
          $$93)
        );
      }),
      ($Enumerable_slice_when$92.$$arity = 0)
    );

    Opal.def(
      self,
      "$sort",
      ($Enumerable_sort$94 = function $$sort() {
        var $iter = $Enumerable_sort$94.$$p,
          block = $iter || nil,
          $$95,
          self = this,
          ary = nil;

        if ($iter) $Enumerable_sort$94.$$p = null;

        if ($iter) $Enumerable_sort$94.$$p = null;
        ary = self.$to_a();
        if (block !== nil) {
        } else {
          block = $lambda(
            (($$95 = function (a, b) {
              var self = $$95.$$s == null ? this : $$95.$$s;

              if (a == null) {
                a = nil;
              }

              if (b == null) {
                b = nil;
              }
              return a["$<=>"](b);
            }),
            ($$95.$$s = self),
            ($$95.$$arity = 2),
            $$95)
          );
        }
        return $send(ary, "sort", [], block.$to_proc());
      }),
      ($Enumerable_sort$94.$$arity = 0)
    );

    Opal.def(
      self,
      "$sort_by",
      ($Enumerable_sort_by$96 = function $$sort_by() {
        var $iter = $Enumerable_sort_by$96.$$p,
          block = $iter || nil,
          $$97,
          $$98,
          $$99,
          $$100,
          self = this,
          dup = nil;

        if ($iter) $Enumerable_sort_by$96.$$p = null;

        if ($iter) $Enumerable_sort_by$96.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["sort_by"],
            (($$97 = function () {
              var self = $$97.$$s == null ? this : $$97.$$s;

              return self.$enumerator_size();
            }),
            ($$97.$$s = self),
            ($$97.$$arity = 0),
            $$97)
          );
        }
        dup = $send(
          self,
          "map",
          [],
          (($$98 = function () {
            var self = $$98.$$s == null ? this : $$98.$$s,
              arg = nil;

            arg = $$($nesting, "Opal").$destructure(arguments);
            return [Opal.yield1(block, arg), arg];
          }),
          ($$98.$$s = self),
          ($$98.$$arity = 0),
          $$98)
        );
        $send(
          dup,
          "sort!",
          [],
          (($$99 = function (a, b) {
            var self = $$99.$$s == null ? this : $$99.$$s;

            if (a == null) {
              a = nil;
            }

            if (b == null) {
              b = nil;
            }
            return a[0]["$<=>"](b[0]);
          }),
          ($$99.$$s = self),
          ($$99.$$arity = 2),
          $$99)
        );
        return $send(
          dup,
          "map!",
          [],
          (($$100 = function (i) {
            var self = $$100.$$s == null ? this : $$100.$$s;

            if (i == null) {
              i = nil;
            }
            return i[1];
          }),
          ($$100.$$s = self),
          ($$100.$$arity = 1),
          $$100)
        );
      }),
      ($Enumerable_sort_by$96.$$arity = 0)
    );

    Opal.def(
      self,
      "$sum",
      ($Enumerable_sum$101 = function $$sum(initial) {
        var $$102,
          $iter = $Enumerable_sum$101.$$p,
          $yield = $iter || nil,
          self = this,
          result = nil;

        if ($iter) $Enumerable_sum$101.$$p = null;

        if (initial == null) {
          initial = 0;
        }
        result = initial;
        $send(
          self,
          "each",
          [],
          (($$102 = function ($a) {
            var self = $$102.$$s == null ? this : $$102.$$s,
              $post_args,
              args,
              item = nil;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;
            item = (function () {
              if ($yield !== nil) {
                return Opal.yieldX($yield, Opal.to_a(args));
              } else {
                return $$($nesting, "Opal").$destructure(args);
              }
              return nil;
            })();
            return (result = $rb_plus(result, item));
          }),
          ($$102.$$s = self),
          ($$102.$$arity = -1),
          $$102)
        );
        return result;
      }),
      ($Enumerable_sum$101.$$arity = -1)
    );

    Opal.def(
      self,
      "$take",
      ($Enumerable_take$103 = function $$take(num) {
        var self = this;

        return self.$first(num);
      }),
      ($Enumerable_take$103.$$arity = 1)
    );

    Opal.def(
      self,
      "$take_while",
      ($Enumerable_take_while$104 = function $$take_while() {
        try {
          var $iter = $Enumerable_take_while$104.$$p,
            block = $iter || nil,
            $$105,
            self = this,
            result = nil;

          if ($iter) $Enumerable_take_while$104.$$p = null;

          if ($iter) $Enumerable_take_while$104.$$p = null;
          if ($truthy(block)) {
          } else {
            return self.$enum_for("take_while");
          }
          result = [];
          return $send(
            self,
            "each",
            [],
            (($$105 = function ($a) {
              var self = $$105.$$s == null ? this : $$105.$$s,
                $post_args,
                args,
                value = nil;

              $post_args = Opal.slice.call(arguments, 0, arguments.length);

              args = $post_args;
              value = $$($nesting, "Opal").$destructure(args);
              if ($truthy(Opal.yield1(block, value))) {
              } else {
                Opal.ret(result);
              }
              return result.push(value);
            }),
            ($$105.$$s = self),
            ($$105.$$arity = -1),
            $$105)
          );
        } catch ($returner) {
          if ($returner === Opal.returner) {
            return $returner.$v;
          }
          throw $returner;
        }
      }),
      ($Enumerable_take_while$104.$$arity = 0)
    );

    Opal.def(
      self,
      "$uniq",
      ($Enumerable_uniq$106 = function $$uniq() {
        var $iter = $Enumerable_uniq$106.$$p,
          block = $iter || nil,
          $$107,
          self = this,
          hash = nil;

        if ($iter) $Enumerable_uniq$106.$$p = null;

        if ($iter) $Enumerable_uniq$106.$$p = null;
        hash = $hash2([], {});
        $send(
          self,
          "each",
          [],
          (($$107 = function ($a) {
            var self = $$107.$$s == null ? this : $$107.$$s,
              $post_args,
              args,
              value = nil,
              produced = nil,
              $writer = nil;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;
            value = $$($nesting, "Opal").$destructure(args);
            produced = (function () {
              if (block !== nil) {
                return Opal.yield1(block, value);
              } else {
                return value;
              }
              return nil;
            })();
            if ($truthy(hash["$key?"](produced))) {
              return nil;
            } else {
              $writer = [produced, value];
              $send(hash, "[]=", Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            }
          }),
          ($$107.$$s = self),
          ($$107.$$arity = -1),
          $$107)
        );
        return hash.$values();
      }),
      ($Enumerable_uniq$106.$$arity = 0)
    );

    Opal.def(
      self,
      "$tally",
      ($Enumerable_tally$108 = function $$tally() {
        var self = this;

        return $send(
          $send(self, "group_by", [], "itself".$to_proc()),
          "transform_values",
          [],
          "count".$to_proc()
        );
      }),
      ($Enumerable_tally$108.$$arity = 0)
    );
    $alias(self, "to_a", "entries");

    Opal.def(
      self,
      "$to_h",
      ($Enumerable_to_h$109 = function $$to_h($a) {
        var $iter = $Enumerable_to_h$109.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Enumerable_to_h$109.$$p = null;

        if ($iter) $Enumerable_to_h$109.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if (block !== nil) {
          return $send(
            $send(self, "map", [], block.$to_proc()),
            "to_h",
            Opal.to_a(args)
          );
        }

        var hash = $hash2([], {});

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments);
          var ary = $$($nesting, "Opal")["$coerce_to?"](
              param,
              $$($nesting, "Array"),
              "to_ary"
            ),
            key,
            val;
          if (!ary.$$is_array) {
            self.$raise(
              $$($nesting, "TypeError"),
              "" + "wrong element type " + ary.$class() + " (expected array)"
            );
          }
          if (ary.length !== 2) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "wrong array length (expected 2, was " + ary.$length() + ")"
            );
          }
          key = ary[0];
          val = ary[1];

          Opal.hash_put(hash, key, val);
        };

        self.$each.apply(self, args);

        return hash;
      }),
      ($Enumerable_to_h$109.$$arity = -1)
    );
    return (
      (Opal.def(
        self,
        "$zip",
        ($Enumerable_zip$110 = function $$zip($a) {
          var $iter = $Enumerable_zip$110.$$p,
            block = $iter || nil,
            $post_args,
            others,
            self = this;

          if ($iter) $Enumerable_zip$110.$$p = null;

          if ($iter) $Enumerable_zip$110.$$p = null;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          others = $post_args;
          return $send(self.$to_a(), "zip", Opal.to_a(others));
        }),
        ($Enumerable_zip$110.$$arity = -1)
      ),
      nil) && "zip"
    );
  })($nesting[0], $nesting);
};

Opal.modules["corelib/enumerator"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $breaker = Opal.breaker,
    $slice = Opal.slice,
    $falsy = Opal.falsy,
    $truthy = Opal.truthy,
    $coerce_to = Opal.coerce_to,
    $klass = Opal.klass,
    $send = Opal.send,
    $alias = Opal.alias,
    $send2 = Opal.send2,
    $find_super = Opal.find_super;

  Opal.add_stubs([
    "$require",
    "$include",
    "$allocate",
    "$new",
    "$to_proc",
    "$!",
    "$respond_to?",
    "$nil?",
    "$empty?",
    "$+",
    "$class",
    "$__send__",
    "$call",
    "$enum_for",
    "$size",
    "$destructure",
    "$inspect",
    "$any?",
    "$[]",
    "$raise",
    "$yield",
    "$each",
    "$enumerator_size",
    "$try_convert",
    "$<",
    "$===",
    "$for",
  ]);

  self.$require("corelib/enumerable");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Enumerator");

    var $nesting = [self].concat($parent_nesting),
      $Enumerator_for$1,
      $Enumerator_initialize$2,
      $Enumerator_each$3,
      $Enumerator_size$4,
      $Enumerator_with_index$5,
      $Enumerator_each_with_index$7,
      $Enumerator_inspect$9;

    self.$$prototype.size =
      self.$$prototype.args =
      self.$$prototype.object =
      self.$$prototype.method =
        nil;

    self.$include($$($nesting, "Enumerable"));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(
      self,
      "$for",
      ($Enumerator_for$1 = function (object, $a, $b) {
        var $iter = $Enumerator_for$1.$$p,
          block = $iter || nil,
          $post_args,
          method,
          args,
          self = this;

        if ($iter) $Enumerator_for$1.$$p = null;

        if ($iter) $Enumerator_for$1.$$p = null;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        }

        args = $post_args;

        var obj = self.$allocate();

        obj.object = object;
        obj.size = block;
        obj.method = method;
        obj.args = args;

        return obj;
      }),
      ($Enumerator_for$1.$$arity = -2)
    );

    Opal.def(
      self,
      "$initialize",
      ($Enumerator_initialize$2 = function $$initialize($a) {
        var $iter = $Enumerator_initialize$2.$$p,
          block = $iter || nil,
          $post_args,
          $rest_arg,
          self = this,
          $ret_or_1 = nil;

        if ($iter) $Enumerator_initialize$2.$$p = null;

        if ($iter) $Enumerator_initialize$2.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        if ($truthy(block)) {
          self.object = $send(
            $$($nesting, "Generator"),
            "new",
            [],
            block.$to_proc()
          );
          self.method = "each";
          self.args = [];
          self.size = arguments[0] || nil;
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_1 = self.size))) {
                  return self.size["$respond_to?"]("call")["$!"]();
                } else {
                  return $ret_or_1;
                }
                return nil;
              })()
            )
          ) {
            return (self.size = $coerce_to(
              self.size,
              $$($nesting, "Integer"),
              "to_int"
            ));
          } else {
            return nil;
          }
        } else {
          self.object = arguments[0];
          self.method = arguments[1] || "each";
          self.args = $slice.call(arguments, 2);
          return (self.size = nil);
        }
      }),
      ($Enumerator_initialize$2.$$arity = -1)
    );

    Opal.def(
      self,
      "$each",
      ($Enumerator_each$3 = function $$each($a) {
        var $iter = $Enumerator_each$3.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this,
          $ret_or_2 = nil;

        if ($iter) $Enumerator_each$3.$$p = null;

        if ($iter) $Enumerator_each$3.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_2 = block["$nil?"]()))) {
                return args["$empty?"]();
              } else {
                return $ret_or_2;
              }
              return nil;
            })()
          )
        ) {
          return self;
        }
        args = $rb_plus(self.args, args);
        if ($truthy(block["$nil?"]())) {
          return $send(
            self.$class(),
            "new",
            [self.object, self.method].concat(Opal.to_a(args))
          );
        }
        return $send(
          self.object,
          "__send__",
          [self.method].concat(Opal.to_a(args)),
          block.$to_proc()
        );
      }),
      ($Enumerator_each$3.$$arity = -1)
    );

    Opal.def(
      self,
      "$size",
      ($Enumerator_size$4 = function $$size() {
        var self = this;

        if ($truthy(self.size["$respond_to?"]("call"))) {
          return $send(self.size, "call", Opal.to_a(self.args));
        } else {
          return self.size;
        }
      }),
      ($Enumerator_size$4.$$arity = 0)
    );

    Opal.def(
      self,
      "$with_index",
      ($Enumerator_with_index$5 = function $$with_index(offset) {
        var $iter = $Enumerator_with_index$5.$$p,
          block = $iter || nil,
          $$6,
          self = this;

        if ($iter) $Enumerator_with_index$5.$$p = null;

        if ($iter) $Enumerator_with_index$5.$$p = null;

        if (offset == null) {
          offset = 0;
        }
        offset = (function () {
          if ($truthy(offset)) {
            return $coerce_to(offset, $$($nesting, "Integer"), "to_int");
          } else {
            return 0;
          }
          return nil;
        })();
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["with_index", offset],
            (($$6 = function () {
              var self = $$6.$$s == null ? this : $$6.$$s;

              return self.$size();
            }),
            ($$6.$$s = self),
            ($$6.$$arity = 0),
            $$6)
          );
        }

        var result,
          index = offset;

        self.$each.$$p = function () {
          var param = $$($nesting, "Opal").$destructure(arguments),
            value = block(param, index);

          index++;

          return value;
        };

        return self.$each();
      }),
      ($Enumerator_with_index$5.$$arity = -1)
    );
    $alias(self, "with_object", "each_with_object");

    Opal.def(
      self,
      "$each_with_index",
      ($Enumerator_each_with_index$7 = function $$each_with_index() {
        var $iter = $Enumerator_each_with_index$7.$$p,
          block = $iter || nil,
          $$8,
          self = this;

        if ($iter) $Enumerator_each_with_index$7.$$p = null;

        if ($iter) $Enumerator_each_with_index$7.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_with_index"],
            (($$8 = function () {
              var self = $$8.$$s == null ? this : $$8.$$s;

              return self.$size();
            }),
            ($$8.$$s = self),
            ($$8.$$arity = 0),
            $$8)
          );
        }
        $send2(
          self,
          $find_super(
            self,
            "each_with_index",
            $Enumerator_each_with_index$7,
            false,
            true
          ),
          "each_with_index",
          [],
          $iter
        );
        return self.object;
      }),
      ($Enumerator_each_with_index$7.$$arity = 0)
    );

    Opal.def(
      self,
      "$inspect",
      ($Enumerator_inspect$9 = function $$inspect() {
        var self = this,
          result = nil;

        result =
          "" +
          "#<" +
          self.$class() +
          ": " +
          self.object.$inspect() +
          ":" +
          self.method;
        if ($truthy(self.args["$any?"]())) {
          result = $rb_plus(
            result,
            "" +
              "(" +
              self.args.$inspect()["$[]"]($$($nesting, "Range").$new(1, -2)) +
              ")"
          );
        }
        return $rb_plus(result, ">");
      }),
      ($Enumerator_inspect$9.$$arity = 0)
    );
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Generator");

      var $nesting = [self].concat($parent_nesting),
        $Generator_initialize$10,
        $Generator_each$11;

      self.$$prototype.block = nil;

      self.$include($$($nesting, "Enumerable"));

      Opal.def(
        self,
        "$initialize",
        ($Generator_initialize$10 = function $$initialize() {
          var $iter = $Generator_initialize$10.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $Generator_initialize$10.$$p = null;

          if ($iter) $Generator_initialize$10.$$p = null;
          if ($truthy(block)) {
          } else {
            self.$raise($$($nesting, "LocalJumpError"), "no block given");
          }
          return (self.block = block);
        }),
        ($Generator_initialize$10.$$arity = 0)
      );
      return (
        (Opal.def(
          self,
          "$each",
          ($Generator_each$11 = function $$each($a) {
            var $iter = $Generator_each$11.$$p,
              block = $iter || nil,
              $post_args,
              args,
              self = this,
              yielder = nil;

            if ($iter) $Generator_each$11.$$p = null;

            if ($iter) $Generator_each$11.$$p = null;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;
            yielder = $send(
              $$($nesting, "Yielder"),
              "new",
              [],
              block.$to_proc()
            );

            try {
              args.unshift(yielder);

              Opal.yieldX(self.block, args);
            } catch (e) {
              if (e === $breaker) {
                return $breaker.$v;
              } else {
                throw e;
              }
            }
            return self;
          }),
          ($Generator_each$11.$$arity = -1)
        ),
        nil) && "each"
      );
    })($nesting[0], null, $nesting);
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Yielder");

      var $nesting = [self].concat($parent_nesting),
        $Yielder_initialize$12,
        $Yielder_yield$13,
        $Yielder_$lt$lt$14;

      self.$$prototype.block = nil;

      Opal.def(
        self,
        "$initialize",
        ($Yielder_initialize$12 = function $$initialize() {
          var $iter = $Yielder_initialize$12.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $Yielder_initialize$12.$$p = null;

          if ($iter) $Yielder_initialize$12.$$p = null;
          return (self.block = block);
        }),
        ($Yielder_initialize$12.$$arity = 0)
      );

      Opal.def(
        self,
        "$yield",
        ($Yielder_yield$13 = function ($a) {
          var $post_args,
            values,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          values = $post_args;

          var value = Opal.yieldX(self.block, values);

          if (value === $breaker) {
            throw $breaker;
          }

          return value;
        }),
        ($Yielder_yield$13.$$arity = -1)
      );
      return (
        (Opal.def(
          self,
          "$<<",
          ($Yielder_$lt$lt$14 = function ($a) {
            var $post_args,
              values,
              self = this;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            values = $post_args;
            $send(self, "yield", Opal.to_a(values));
            return self;
          }),
          ($Yielder_$lt$lt$14.$$arity = -1)
        ),
        nil) && "<<"
      );
    })($nesting[0], null, $nesting);
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Lazy");

      var $nesting = [self].concat($parent_nesting),
        $Lazy_initialize$15,
        $Lazy_lazy$18,
        $Lazy_collect$19,
        $Lazy_collect_concat$21,
        $Lazy_drop$25,
        $Lazy_drop_while$27,
        $Lazy_enum_for$29,
        $Lazy_find_all$30,
        $Lazy_grep$32,
        $Lazy_reject$35,
        $Lazy_take$37,
        $Lazy_take_while$39,
        $Lazy_inspect$41;

      self.$$prototype.enumerator = nil;

      (function ($base, $super, $parent_nesting) {
        var self = $klass($base, $super, "StopLazyError");

        var $nesting = [self].concat($parent_nesting);

        return nil;
      })($nesting[0], $$($nesting, "Exception"), $nesting);

      Opal.def(
        self,
        "$initialize",
        ($Lazy_initialize$15 = function $$initialize(object, size) {
          var $iter = $Lazy_initialize$15.$$p,
            block = $iter || nil,
            $$16,
            self = this;

          if ($iter) $Lazy_initialize$15.$$p = null;

          if ($iter) $Lazy_initialize$15.$$p = null;

          if (size == null) {
            size = nil;
          }
          if (block !== nil) {
          } else {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "tried to call lazy new without a block"
            );
          }
          self.enumerator = object;
          return $send2(
            self,
            $find_super(self, "initialize", $Lazy_initialize$15, false, true),
            "initialize",
            [size],
            (($$16 = function (yielder, $a) {
              var self = $$16.$$s == null ? this : $$16.$$s,
                $post_args,
                each_args,
                $$17;

              if (yielder == null) {
                yielder = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              each_args = $post_args;
              try {
                return $send(
                  object,
                  "each",
                  Opal.to_a(each_args),
                  (($$17 = function ($b) {
                    var self = $$17.$$s == null ? this : $$17.$$s,
                      $post_args,
                      args;

                    $post_args = Opal.slice.call(
                      arguments,
                      0,
                      arguments.length
                    );

                    args = $post_args;

                    args.unshift(yielder);

                    Opal.yieldX(block, args);
                  }),
                  ($$17.$$s = self),
                  ($$17.$$arity = -1),
                  $$17)
                );
              } catch ($err) {
                if (Opal.rescue($err, [$$($nesting, "Exception")])) {
                  try {
                    return nil;
                  } finally {
                    Opal.pop_exception();
                  }
                } else {
                  throw $err;
                }
              }
            }),
            ($$16.$$s = self),
            ($$16.$$arity = -2),
            $$16)
          );
        }),
        ($Lazy_initialize$15.$$arity = -2)
      );
      $alias(self, "force", "to_a");

      Opal.def(
        self,
        "$lazy",
        ($Lazy_lazy$18 = function $$lazy() {
          var self = this;

          return self;
        }),
        ($Lazy_lazy$18.$$arity = 0)
      );

      Opal.def(
        self,
        "$collect",
        ($Lazy_collect$19 = function $$collect() {
          var $iter = $Lazy_collect$19.$$p,
            block = $iter || nil,
            $$20,
            self = this;

          if ($iter) $Lazy_collect$19.$$p = null;

          if ($iter) $Lazy_collect$19.$$p = null;
          if ($truthy(block)) {
          } else {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "tried to call lazy map without a block"
            );
          }
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, self.$enumerator_size()],
            (($$20 = function (enum$, $a) {
              var self = $$20.$$s == null ? this : $$20.$$s,
                $post_args,
                args;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;

              var value = Opal.yieldX(block, args);

              enum$.$yield(value);
            }),
            ($$20.$$s = self),
            ($$20.$$arity = -2),
            $$20)
          );
        }),
        ($Lazy_collect$19.$$arity = 0)
      );

      Opal.def(
        self,
        "$collect_concat",
        ($Lazy_collect_concat$21 = function $$collect_concat() {
          var $iter = $Lazy_collect_concat$21.$$p,
            block = $iter || nil,
            $$22,
            self = this;

          if ($iter) $Lazy_collect_concat$21.$$p = null;

          if ($iter) $Lazy_collect_concat$21.$$p = null;
          if ($truthy(block)) {
          } else {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "tried to call lazy map without a block"
            );
          }
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, nil],
            (($$22 = function (enum$, $a) {
              var self = $$22.$$s == null ? this : $$22.$$s,
                $post_args,
                args,
                $$23,
                $$24;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;

              var value = Opal.yieldX(block, args);

              if (
                value["$respond_to?"]("force") &&
                value["$respond_to?"]("each")
              ) {
                $send(
                  value,
                  "each",
                  [],
                  (($$23 = function (v) {
                    var self = $$23.$$s == null ? this : $$23.$$s;

                    if (v == null) {
                      v = nil;
                    }
                    return enum$.$yield(v);
                  }),
                  ($$23.$$s = self),
                  ($$23.$$arity = 1),
                  $$23)
                );
              } else {
                var array = $$($nesting, "Opal").$try_convert(
                  value,
                  $$($nesting, "Array"),
                  "to_ary"
                );

                if (array === nil) {
                  enum$.$yield(value);
                } else {
                  $send(
                    value,
                    "each",
                    [],
                    (($$24 = function (v) {
                      var self = $$24.$$s == null ? this : $$24.$$s;

                      if (v == null) {
                        v = nil;
                      }
                      return enum$.$yield(v);
                    }),
                    ($$24.$$s = self),
                    ($$24.$$arity = 1),
                    $$24)
                  );
                }
              }
            }),
            ($$22.$$s = self),
            ($$22.$$arity = -2),
            $$22)
          );
        }),
        ($Lazy_collect_concat$21.$$arity = 0)
      );

      Opal.def(
        self,
        "$drop",
        ($Lazy_drop$25 = function $$drop(n) {
          var $$26,
            self = this,
            current_size = nil,
            set_size = nil,
            dropped = nil;

          n = $coerce_to(n, $$($nesting, "Integer"), "to_int");
          if ($truthy($rb_lt(n, 0))) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "attempt to drop negative size"
            );
          }
          current_size = self.$enumerator_size();
          set_size = (function () {
            if ($truthy($$($nesting, "Integer")["$==="](current_size))) {
              if ($truthy($rb_lt(n, current_size))) {
                return n;
              } else {
                return current_size;
              }
            } else {
              return current_size;
            }
            return nil;
          })();
          dropped = 0;
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, set_size],
            (($$26 = function (enum$, $a) {
              var self = $$26.$$s == null ? this : $$26.$$s,
                $post_args,
                args;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;
              if ($truthy($rb_lt(dropped, n))) {
                return (dropped = $rb_plus(dropped, 1));
              } else {
                return $send(enum$, "yield", Opal.to_a(args));
              }
            }),
            ($$26.$$s = self),
            ($$26.$$arity = -2),
            $$26)
          );
        }),
        ($Lazy_drop$25.$$arity = 1)
      );

      Opal.def(
        self,
        "$drop_while",
        ($Lazy_drop_while$27 = function $$drop_while() {
          var $iter = $Lazy_drop_while$27.$$p,
            block = $iter || nil,
            $$28,
            self = this,
            succeeding = nil;

          if ($iter) $Lazy_drop_while$27.$$p = null;

          if ($iter) $Lazy_drop_while$27.$$p = null;
          if ($truthy(block)) {
          } else {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "tried to call lazy drop_while without a block"
            );
          }
          succeeding = true;
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, nil],
            (($$28 = function (enum$, $a) {
              var self = $$28.$$s == null ? this : $$28.$$s,
                $post_args,
                args;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;
              if ($truthy(succeeding)) {
                var value = Opal.yieldX(block, args);

                if ($falsy(value)) {
                  succeeding = false;

                  $send(enum$, "yield", Opal.to_a(args));
                }
              } else {
                return $send(enum$, "yield", Opal.to_a(args));
              }
            }),
            ($$28.$$s = self),
            ($$28.$$arity = -2),
            $$28)
          );
        }),
        ($Lazy_drop_while$27.$$arity = 0)
      );

      Opal.def(
        self,
        "$enum_for",
        ($Lazy_enum_for$29 = function $$enum_for($a, $b) {
          var $iter = $Lazy_enum_for$29.$$p,
            block = $iter || nil,
            $post_args,
            method,
            args,
            self = this;

          if ($iter) $Lazy_enum_for$29.$$p = null;

          if ($iter) $Lazy_enum_for$29.$$p = null;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          if ($post_args.length > 0) {
            method = $post_args[0];
            $post_args.splice(0, 1);
          }
          if (method == null) {
            method = "each";
          }

          args = $post_args;
          return $send(
            self.$class(),
            "for",
            [self, method].concat(Opal.to_a(args)),
            block.$to_proc()
          );
        }),
        ($Lazy_enum_for$29.$$arity = -1)
      );
      $alias(self, "filter", "find_all");

      Opal.def(
        self,
        "$find_all",
        ($Lazy_find_all$30 = function $$find_all() {
          var $iter = $Lazy_find_all$30.$$p,
            block = $iter || nil,
            $$31,
            self = this;

          if ($iter) $Lazy_find_all$30.$$p = null;

          if ($iter) $Lazy_find_all$30.$$p = null;
          if ($truthy(block)) {
          } else {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "tried to call lazy select without a block"
            );
          }
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, nil],
            (($$31 = function (enum$, $a) {
              var self = $$31.$$s == null ? this : $$31.$$s,
                $post_args,
                args;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;

              var value = Opal.yieldX(block, args);

              if ($truthy(value)) {
                $send(enum$, "yield", Opal.to_a(args));
              }
            }),
            ($$31.$$s = self),
            ($$31.$$arity = -2),
            $$31)
          );
        }),
        ($Lazy_find_all$30.$$arity = 0)
      );
      $alias(self, "flat_map", "collect_concat");

      Opal.def(
        self,
        "$grep",
        ($Lazy_grep$32 = function $$grep(pattern) {
          var $iter = $Lazy_grep$32.$$p,
            block = $iter || nil,
            $$33,
            $$34,
            self = this;

          if ($iter) $Lazy_grep$32.$$p = null;

          if ($iter) $Lazy_grep$32.$$p = null;
          if ($truthy(block)) {
            return $send(
              $$($nesting, "Lazy"),
              "new",
              [self, nil],
              (($$33 = function (enum$, $a) {
                var self = $$33.$$s == null ? this : $$33.$$s,
                  $post_args,
                  args;

                if (enum$ == null) {
                  enum$ = nil;
                }

                $post_args = Opal.slice.call(arguments, 1, arguments.length);

                args = $post_args;

                var param = $$($nesting, "Opal").$destructure(args),
                  value = pattern["$==="](param);

                if ($truthy(value)) {
                  value = Opal.yield1(block, param);

                  enum$.$yield(Opal.yield1(block, param));
                }
              }),
              ($$33.$$s = self),
              ($$33.$$arity = -2),
              $$33)
            );
          } else {
            return $send(
              $$($nesting, "Lazy"),
              "new",
              [self, nil],
              (($$34 = function (enum$, $a) {
                var self = $$34.$$s == null ? this : $$34.$$s,
                  $post_args,
                  args;

                if (enum$ == null) {
                  enum$ = nil;
                }

                $post_args = Opal.slice.call(arguments, 1, arguments.length);

                args = $post_args;

                var param = $$($nesting, "Opal").$destructure(args),
                  value = pattern["$==="](param);

                if ($truthy(value)) {
                  enum$.$yield(param);
                }
              }),
              ($$34.$$s = self),
              ($$34.$$arity = -2),
              $$34)
            );
          }
        }),
        ($Lazy_grep$32.$$arity = 1)
      );
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");

      Opal.def(
        self,
        "$reject",
        ($Lazy_reject$35 = function $$reject() {
          var $iter = $Lazy_reject$35.$$p,
            block = $iter || nil,
            $$36,
            self = this;

          if ($iter) $Lazy_reject$35.$$p = null;

          if ($iter) $Lazy_reject$35.$$p = null;
          if ($truthy(block)) {
          } else {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "tried to call lazy reject without a block"
            );
          }
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, nil],
            (($$36 = function (enum$, $a) {
              var self = $$36.$$s == null ? this : $$36.$$s,
                $post_args,
                args;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;

              var value = Opal.yieldX(block, args);

              if ($falsy(value)) {
                $send(enum$, "yield", Opal.to_a(args));
              }
            }),
            ($$36.$$s = self),
            ($$36.$$arity = -2),
            $$36)
          );
        }),
        ($Lazy_reject$35.$$arity = 0)
      );

      Opal.def(
        self,
        "$take",
        ($Lazy_take$37 = function $$take(n) {
          var $$38,
            self = this,
            current_size = nil,
            set_size = nil,
            taken = nil;

          n = $coerce_to(n, $$($nesting, "Integer"), "to_int");
          if ($truthy($rb_lt(n, 0))) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "attempt to take negative size"
            );
          }
          current_size = self.$enumerator_size();
          set_size = (function () {
            if ($truthy($$($nesting, "Integer")["$==="](current_size))) {
              if ($truthy($rb_lt(n, current_size))) {
                return n;
              } else {
                return current_size;
              }
            } else {
              return current_size;
            }
            return nil;
          })();
          taken = 0;
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, set_size],
            (($$38 = function (enum$, $a) {
              var self = $$38.$$s == null ? this : $$38.$$s,
                $post_args,
                args;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;
              if ($truthy($rb_lt(taken, n))) {
                $send(enum$, "yield", Opal.to_a(args));
                return (taken = $rb_plus(taken, 1));
              } else {
                return self.$raise($$($nesting, "StopLazyError"));
              }
            }),
            ($$38.$$s = self),
            ($$38.$$arity = -2),
            $$38)
          );
        }),
        ($Lazy_take$37.$$arity = 1)
      );

      Opal.def(
        self,
        "$take_while",
        ($Lazy_take_while$39 = function $$take_while() {
          var $iter = $Lazy_take_while$39.$$p,
            block = $iter || nil,
            $$40,
            self = this;

          if ($iter) $Lazy_take_while$39.$$p = null;

          if ($iter) $Lazy_take_while$39.$$p = null;
          if ($truthy(block)) {
          } else {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "tried to call lazy take_while without a block"
            );
          }
          return $send(
            $$($nesting, "Lazy"),
            "new",
            [self, nil],
            (($$40 = function (enum$, $a) {
              var self = $$40.$$s == null ? this : $$40.$$s,
                $post_args,
                args;

              if (enum$ == null) {
                enum$ = nil;
              }

              $post_args = Opal.slice.call(arguments, 1, arguments.length);

              args = $post_args;

              var value = Opal.yieldX(block, args);

              if ($truthy(value)) {
                $send(enum$, "yield", Opal.to_a(args));
              } else {
                self.$raise($$($nesting, "StopLazyError"));
              }
            }),
            ($$40.$$s = self),
            ($$40.$$arity = -2),
            $$40)
          );
        }),
        ($Lazy_take_while$39.$$arity = 0)
      );
      $alias(self, "to_enum", "enum_for");
      return (
        (Opal.def(
          self,
          "$inspect",
          ($Lazy_inspect$41 = function $$inspect() {
            var self = this;

            return (
              "" +
              "#<" +
              self.$class() +
              ": " +
              self.enumerator.$inspect() +
              ">"
            );
          }),
          ($Lazy_inspect$41.$$arity = 0)
        ),
        nil) && "inspect"
      );
    })($nesting[0], self, $nesting);
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "ArithmeticSequence");

      var $nesting = [self].concat($parent_nesting);

      return nil;
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/numeric"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  function $rb_le(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs <= rhs
      : lhs["$<="](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $alias = Opal.alias,
    $hash2 = Opal.hash2,
    $send = Opal.send;

  Opal.add_stubs([
    "$require",
    "$include",
    "$instance_of?",
    "$class",
    "$Float",
    "$respond_to?",
    "$coerce",
    "$__send__",
    "$===",
    "$raise",
    "$equal?",
    "$-",
    "$*",
    "$div",
    "$<",
    "$-@",
    "$ceil",
    "$to_f",
    "$denominator",
    "$to_r",
    "$==",
    "$floor",
    "$/",
    "$%",
    "$Complex",
    "$zero?",
    "$numerator",
    "$abs",
    "$arg",
    "$coerce_to!",
    "$round",
    "$<=>",
    "$compare",
    "$enum_for",
    "$to_proc",
    "$negative?",
    "$>=",
    "$<=",
    "$+",
    "$to_i",
    "$truncate",
    "$>",
  ]);

  self.$require("corelib/comparable");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Numeric");

    var $nesting = [self].concat($parent_nesting),
      $Numeric_coerce$1,
      $Numeric___coerced__$2,
      $Numeric_$lt_eq_gt$3,
      $Numeric_$plus$$4,
      $Numeric_$minus$$5,
      $Numeric_$percent$6,
      $Numeric_abs$7,
      $Numeric_abs2$8,
      $Numeric_angle$9,
      $Numeric_ceil$10,
      $Numeric_conj$11,
      $Numeric_denominator$12,
      $Numeric_div$13,
      $Numeric_divmod$14,
      $Numeric_fdiv$15,
      $Numeric_floor$16,
      $Numeric_i$17,
      $Numeric_imag$18,
      $Numeric_integer$ques$19,
      $Numeric_nonzero$ques$20,
      $Numeric_numerator$21,
      $Numeric_polar$22,
      $Numeric_quo$23,
      $Numeric_real$24,
      $Numeric_real$ques$25,
      $Numeric_rect$26,
      $Numeric_round$27,
      $Numeric_step$28,
      $Numeric_to_c$29,
      $Numeric_to_int$30,
      $Numeric_truncate$31,
      $Numeric_zero$ques$32,
      $Numeric_positive$ques$33,
      $Numeric_negative$ques$34,
      $Numeric_dup$35,
      $Numeric_clone$36,
      $Numeric_finite$ques$37,
      $Numeric_infinite$ques$38;

    self.$include($$($nesting, "Comparable"));

    Opal.def(
      self,
      "$coerce",
      ($Numeric_coerce$1 = function $$coerce(other) {
        var self = this;

        if ($truthy(other["$instance_of?"](self.$class()))) {
          return [other, self];
        }
        return [self.$Float(other), self.$Float(self)];
      }),
      ($Numeric_coerce$1.$$arity = 1)
    );

    Opal.def(
      self,
      "$__coerced__",
      ($Numeric___coerced__$2 = function $$__coerced__(method, other) {
        var $a,
          $b,
          self = this,
          a = nil,
          b = nil,
          $case = nil;

        if ($truthy(other["$respond_to?"]("coerce"))) {
          ($b = other.$coerce(self)),
            ($a = Opal.to_ary($b)),
            (a = $a[0] == null ? nil : $a[0]),
            (b = $a[1] == null ? nil : $a[1]),
            $b;
          return a.$__send__(method, b);
        } else {
          return (function () {
            $case = method;
            if (
              "+"["$==="]($case) ||
              "-"["$==="]($case) ||
              "*"["$==="]($case) ||
              "/"["$==="]($case) ||
              "%"["$==="]($case) ||
              "&"["$==="]($case) ||
              "|"["$==="]($case) ||
              "^"["$==="]($case) ||
              "**"["$==="]($case)
            ) {
              return self.$raise(
                $$($nesting, "TypeError"),
                "" + other.$class() + " can't be coerced into Numeric"
              );
            } else if (
              ">"["$==="]($case) ||
              ">="["$==="]($case) ||
              "<"["$==="]($case) ||
              "<="["$==="]($case) ||
              "<=>"["$==="]($case)
            ) {
              return self.$raise(
                $$($nesting, "ArgumentError"),
                "" +
                  "comparison of " +
                  self.$class() +
                  " with " +
                  other.$class() +
                  " failed"
              );
            } else {
              return nil;
            }
          })();
        }
      }),
      ($Numeric___coerced__$2.$$arity = 2)
    );

    Opal.def(
      self,
      "$<=>",
      ($Numeric_$lt_eq_gt$3 = function (other) {
        var self = this;

        if ($truthy(self["$equal?"](other))) {
          return 0;
        }
        return nil;
      }),
      ($Numeric_$lt_eq_gt$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$+@",
      ($Numeric_$plus$$4 = function () {
        var self = this;

        return self;
      }),
      ($Numeric_$plus$$4.$$arity = 0)
    );

    Opal.def(
      self,
      "$-@",
      ($Numeric_$minus$$5 = function () {
        var self = this;

        return $rb_minus(0, self);
      }),
      ($Numeric_$minus$$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$%",
      ($Numeric_$percent$6 = function (other) {
        var self = this;

        return $rb_minus(self, $rb_times(other, self.$div(other)));
      }),
      ($Numeric_$percent$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$abs",
      ($Numeric_abs$7 = function $$abs() {
        var self = this;

        if ($rb_lt(self, 0)) {
          return self["$-@"]();
        } else {
          return self;
        }
      }),
      ($Numeric_abs$7.$$arity = 0)
    );

    Opal.def(
      self,
      "$abs2",
      ($Numeric_abs2$8 = function $$abs2() {
        var self = this;

        return $rb_times(self, self);
      }),
      ($Numeric_abs2$8.$$arity = 0)
    );

    Opal.def(
      self,
      "$angle",
      ($Numeric_angle$9 = function $$angle() {
        var self = this;

        if ($rb_lt(self, 0)) {
          return $$$($$($nesting, "Math"), "PI");
        } else {
          return 0;
        }
      }),
      ($Numeric_angle$9.$$arity = 0)
    );
    $alias(self, "arg", "angle");

    Opal.def(
      self,
      "$ceil",
      ($Numeric_ceil$10 = function $$ceil(ndigits) {
        var self = this;

        if (ndigits == null) {
          ndigits = 0;
        }
        return self.$to_f().$ceil(ndigits);
      }),
      ($Numeric_ceil$10.$$arity = -1)
    );

    Opal.def(
      self,
      "$conj",
      ($Numeric_conj$11 = function $$conj() {
        var self = this;

        return self;
      }),
      ($Numeric_conj$11.$$arity = 0)
    );
    $alias(self, "conjugate", "conj");

    Opal.def(
      self,
      "$denominator",
      ($Numeric_denominator$12 = function $$denominator() {
        var self = this;

        return self.$to_r().$denominator();
      }),
      ($Numeric_denominator$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$div",
      ($Numeric_div$13 = function $$div(other) {
        var self = this;

        if (other["$=="](0)) {
          self.$raise($$($nesting, "ZeroDivisionError"), "divided by o");
        }
        return $rb_divide(self, other).$floor();
      }),
      ($Numeric_div$13.$$arity = 1)
    );

    Opal.def(
      self,
      "$divmod",
      ($Numeric_divmod$14 = function $$divmod(other) {
        var self = this;

        return [self.$div(other), self["$%"](other)];
      }),
      ($Numeric_divmod$14.$$arity = 1)
    );

    Opal.def(
      self,
      "$fdiv",
      ($Numeric_fdiv$15 = function $$fdiv(other) {
        var self = this;

        return $rb_divide(self.$to_f(), other);
      }),
      ($Numeric_fdiv$15.$$arity = 1)
    );

    Opal.def(
      self,
      "$floor",
      ($Numeric_floor$16 = function $$floor(ndigits) {
        var self = this;

        if (ndigits == null) {
          ndigits = 0;
        }
        return self.$to_f().$floor(ndigits);
      }),
      ($Numeric_floor$16.$$arity = -1)
    );

    Opal.def(
      self,
      "$i",
      ($Numeric_i$17 = function $$i() {
        var self = this;

        return self.$Complex(0, self);
      }),
      ($Numeric_i$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$imag",
      ($Numeric_imag$18 = function $$imag() {
        var self = this;

        return 0;
      }),
      ($Numeric_imag$18.$$arity = 0)
    );
    $alias(self, "imaginary", "imag");

    Opal.def(
      self,
      "$integer?",
      ($Numeric_integer$ques$19 = function () {
        var self = this;

        return false;
      }),
      ($Numeric_integer$ques$19.$$arity = 0)
    );
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");

    Opal.def(
      self,
      "$nonzero?",
      ($Numeric_nonzero$ques$20 = function () {
        var self = this;

        if ($truthy(self["$zero?"]())) {
          return nil;
        } else {
          return self;
        }
      }),
      ($Numeric_nonzero$ques$20.$$arity = 0)
    );

    Opal.def(
      self,
      "$numerator",
      ($Numeric_numerator$21 = function $$numerator() {
        var self = this;

        return self.$to_r().$numerator();
      }),
      ($Numeric_numerator$21.$$arity = 0)
    );
    $alias(self, "phase", "arg");

    Opal.def(
      self,
      "$polar",
      ($Numeric_polar$22 = function $$polar() {
        var self = this;

        return [self.$abs(), self.$arg()];
      }),
      ($Numeric_polar$22.$$arity = 0)
    );

    Opal.def(
      self,
      "$quo",
      ($Numeric_quo$23 = function $$quo(other) {
        var self = this;

        return $rb_divide(
          $$($nesting, "Opal")["$coerce_to!"](
            self,
            $$($nesting, "Rational"),
            "to_r"
          ),
          other
        );
      }),
      ($Numeric_quo$23.$$arity = 1)
    );

    Opal.def(
      self,
      "$real",
      ($Numeric_real$24 = function $$real() {
        var self = this;

        return self;
      }),
      ($Numeric_real$24.$$arity = 0)
    );

    Opal.def(
      self,
      "$real?",
      ($Numeric_real$ques$25 = function () {
        var self = this;

        return true;
      }),
      ($Numeric_real$ques$25.$$arity = 0)
    );

    Opal.def(
      self,
      "$rect",
      ($Numeric_rect$26 = function $$rect() {
        var self = this;

        return [self, 0];
      }),
      ($Numeric_rect$26.$$arity = 0)
    );
    $alias(self, "rectangular", "rect");

    Opal.def(
      self,
      "$round",
      ($Numeric_round$27 = function $$round(digits) {
        var self = this;

        return self.$to_f().$round(digits);
      }),
      ($Numeric_round$27.$$arity = -1)
    );

    Opal.def(
      self,
      "$step",
      ($Numeric_step$28 = function $$step($a, $b, $c) {
        var $iter = $Numeric_step$28.$$p,
          block = $iter || nil,
          $post_args,
          $kwargs,
          limit,
          step,
          to,
          by,
          $d,
          self = this,
          counter = nil;

        if ($iter) $Numeric_step$28.$$p = null;

        if ($iter) $Numeric_step$28.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $kwargs = Opal.extract_kwargs($post_args);

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        if ($post_args.length > 0) {
          limit = $post_args[0];
          $post_args.splice(0, 1);
        }

        if ($post_args.length > 0) {
          step = $post_args[0];
          $post_args.splice(0, 1);
        }

        to = $kwargs.$$smap["to"];

        by = $kwargs.$$smap["by"];

        if (limit !== undefined && to !== undefined) {
          self.$raise($$($nesting, "ArgumentError"), "to is given twice");
        }

        if (step !== undefined && by !== undefined) {
          self.$raise($$($nesting, "ArgumentError"), "step is given twice");
        }

        if (to !== undefined) {
          limit = to;
        }

        if (by !== undefined) {
          step = by;
        }

        if (limit === undefined) {
          limit = nil;
        }

        function validateParameters() {
          if (step === nil) {
            self.$raise($$($nesting, "TypeError"), "step must be numeric");
          }

          if (step != null && step["$=="](0)) {
            self.$raise($$($nesting, "ArgumentError"), "step can't be 0");
          }

          if (step === nil || step == null) {
            step = 1;
          }

          var sign = step["$<=>"](0);

          if (sign === nil) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "0 can't be coerced into " + step.$class()
            );
          }

          if (limit === nil || limit == null) {
            limit =
              sign > 0
                ? $$$($$($nesting, "Float"), "INFINITY")
                : $$$($$($nesting, "Float"), "INFINITY")["$-@"]();
          }

          $$($nesting, "Opal").$compare(self, limit);
        }

        function stepFloatSize() {
          if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
            return 0;
          } else if (step === Infinity || step === -Infinity) {
            return 1;
          } else {
            var abs = Math.abs,
              floor = Math.floor,
              err =
                ((abs(self) + abs(limit) + abs(limit - self)) / abs(step)) *
                $$$($$($nesting, "Float"), "EPSILON");

            if (err === Infinity || err === -Infinity) {
              return 0;
            } else {
              if (err > 0.5) {
                err = 0.5;
              }

              return floor((limit - self) / step + err) + 1;
            }
          }
        }

        function stepSize() {
          validateParameters();

          if (step === 0) {
            return Infinity;
          }

          if (step % 1 !== 0) {
            return stepFloatSize();
          } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
            return 0;
          } else {
            var ceil = Math.ceil,
              abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

            return ceil(lhs / rhs);
          }
        }

        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["step", limit, step],
            stepSize.$to_proc()
          );
        }

        validateParameters();

        var isDesc = step["$negative?"](),
          isInf =
            step["$=="](0) ||
            (limit === Infinity && !isDesc) ||
            (limit === -Infinity && isDesc);

        if (self.$$is_number && step.$$is_number && limit.$$is_number) {
          if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
            var value = self;

            if (isInf) {
              for (; ; value += step) {
                block(value);
              }
            } else if (isDesc) {
              for (; value >= limit; value += step) {
                block(value);
              }
            } else {
              for (; value <= limit; value += step) {
                block(value);
              }
            }

            return self;
          } else {
            var begin = self.$to_f().valueOf();
            step = step.$to_f().valueOf();
            limit = limit.$to_f().valueOf();

            var n = stepFloatSize();

            if (!isFinite(step)) {
              if (n !== 0) block(begin);
            } else if (step === 0) {
              while (true) {
                block(begin);
              }
            } else {
              for (var i = 0; i < n; i++) {
                var d = i * step + self;
                if (step >= 0 ? limit < d : limit > d) {
                  d = limit;
                }
                block(d);
              }
            }

            return self;
          }
        }
        counter = self;
        while (
          $truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))
        ) {
          Opal.yield1(block, counter);
          counter = $rb_plus(counter, step);
        }
      }),
      ($Numeric_step$28.$$arity = -1)
    );

    Opal.def(
      self,
      "$to_c",
      ($Numeric_to_c$29 = function $$to_c() {
        var self = this;

        return self.$Complex(self, 0);
      }),
      ($Numeric_to_c$29.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_int",
      ($Numeric_to_int$30 = function $$to_int() {
        var self = this;

        return self.$to_i();
      }),
      ($Numeric_to_int$30.$$arity = 0)
    );

    Opal.def(
      self,
      "$truncate",
      ($Numeric_truncate$31 = function $$truncate(ndigits) {
        var self = this;

        if (ndigits == null) {
          ndigits = 0;
        }
        return self.$to_f().$truncate(ndigits);
      }),
      ($Numeric_truncate$31.$$arity = -1)
    );

    Opal.def(
      self,
      "$zero?",
      ($Numeric_zero$ques$32 = function () {
        var self = this;

        return self["$=="](0);
      }),
      ($Numeric_zero$ques$32.$$arity = 0)
    );

    Opal.def(
      self,
      "$positive?",
      ($Numeric_positive$ques$33 = function () {
        var self = this;

        return $rb_gt(self, 0);
      }),
      ($Numeric_positive$ques$33.$$arity = 0)
    );

    Opal.def(
      self,
      "$negative?",
      ($Numeric_negative$ques$34 = function () {
        var self = this;

        return $rb_lt(self, 0);
      }),
      ($Numeric_negative$ques$34.$$arity = 0)
    );

    Opal.def(
      self,
      "$dup",
      ($Numeric_dup$35 = function $$dup() {
        var self = this;

        return self;
      }),
      ($Numeric_dup$35.$$arity = 0)
    );

    Opal.def(
      self,
      "$clone",
      ($Numeric_clone$36 = function $$clone($kwargs) {
        var freeze,
          self = this;

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        freeze = $kwargs.$$smap["freeze"];
        if (freeze == null) {
          freeze = true;
        }
        return self;
      }),
      ($Numeric_clone$36.$$arity = -1)
    );

    Opal.def(
      self,
      "$finite?",
      ($Numeric_finite$ques$37 = function () {
        var self = this;

        return true;
      }),
      ($Numeric_finite$ques$37.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$infinite?",
        ($Numeric_infinite$ques$38 = function () {
          var self = this;

          return nil;
        }),
        ($Numeric_infinite$ques$38.$$arity = 0)
      ),
      nil) && "infinite?"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/array"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $truthy = Opal.truthy,
    $falsy = Opal.falsy,
    $hash_ids = Opal.hash_ids,
    $yield1 = Opal.yield1,
    $hash_get = Opal.hash_get,
    $hash_put = Opal.hash_put,
    $hash_delete = Opal.hash_delete,
    $coerce_to = Opal.coerce_to,
    $respond_to = Opal.respond_to,
    $klass = Opal.klass,
    $hash2 = Opal.hash2,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $send = Opal.send,
    $gvars = Opal.gvars,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$require",
    "$include",
    "$to_a",
    "$warn",
    "$raise",
    "$replace",
    "$respond_to?",
    "$to_ary",
    "$coerce_to?",
    "$===",
    "$join",
    "$to_str",
    "$hash",
    "$<=>",
    "$==",
    "$object_id",
    "$inspect",
    "$enum_for",
    "$class",
    "$bsearch_index",
    "$to_proc",
    "$nil?",
    "$coerce_to!",
    "$>",
    "$*",
    "$enumerator_size",
    "$empty?",
    "$size",
    "$map",
    "$equal?",
    "$dup",
    "$each",
    "$reduce",
    "$-",
    "$[]",
    "$dig",
    "$eql?",
    "$length",
    "$exclude_end?",
    "$flatten",
    "$__id__",
    "$&",
    "$to_s",
    "$new",
    "$max",
    "$min",
    "$!",
    "$>=",
    "$**",
    "$delete_if",
    "$reverse",
    "$rotate",
    "$rand",
    "$at",
    "$keep_if",
    "$shuffle!",
    "$<",
    "$sort",
    "$sort_by",
    "$!=",
    "$times",
    "$[]=",
    "$<<",
    "$uniq",
    "$|",
    "$values",
    "$is_a?",
    "$last",
    "$first",
    "$upto",
    "$reject",
    "$pristine",
    "$singleton_class",
  ]);

  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Array");

    var $nesting = [self].concat($parent_nesting),
      $Array_$$$1,
      $Array_initialize$2,
      $Array_try_convert$3,
      $Array_$$4,
      $Array_$$5,
      $Array_$$6,
      $Array_$plus$7,
      $Array_$minus$8,
      $Array_$lt$lt$9,
      $Array_$lt_eq_gt$10,
      $Array_$eq_eq$11,
      $Array_$$$12,
      $Array_$$$eq$13,
      $Array_any$ques$14,
      $Array_assoc$15,
      $Array_at$16,
      $Array_bsearch_index$17,
      $Array_bsearch$18,
      $Array_cycle$19,
      $Array_clear$21,
      $Array_count$22,
      $Array_initialize_copy$23,
      $Array_collect$24,
      $Array_collect$excl$26,
      $Array_combination$28,
      $Array_repeated_combination$30,
      $Array_compact$32,
      $Array_compact$excl$33,
      $Array_concat$34,
      $Array_delete$37,
      $Array_delete_at$38,
      $Array_delete_if$39,
      $Array_difference$41,
      $Array_dig$43,
      $Array_drop$44,
      $Array_dup$45,
      $Array_each$46,
      $Array_each_index$48,
      $Array_empty$ques$50,
      $Array_eql$ques$51,
      $Array_fetch$52,
      $Array_fill$53,
      $Array_first$54,
      $Array_flatten$55,
      $Array_flatten$excl$56,
      $Array_hash$57,
      $Array_include$ques$58,
      $Array_index$59,
      $Array_insert$60,
      $Array_inspect$61,
      $Array_intersection$62,
      $Array_join$64,
      $Array_keep_if$65,
      $Array_last$67,
      $Array_length$68,
      $Array_max$69,
      $Array_min$70,
      $Array_permutation$71,
      $Array_repeated_permutation$73,
      $Array_pop$75,
      $Array_product$76,
      $Array_push$77,
      $Array_rassoc$78,
      $Array_reject$79,
      $Array_reject$excl$81,
      $Array_replace$83,
      $Array_reverse$84,
      $Array_reverse$excl$85,
      $Array_reverse_each$86,
      $Array_rindex$88,
      $Array_rotate$89,
      $Array_rotate$excl$90,
      $Array_sample$93,
      $Array_select$94,
      $Array_select$excl$96,
      $Array_shift$98,
      $Array_shuffle$99,
      $Array_shuffle$excl$100,
      $Array_slice$excl$101,
      $Array_sort$102,
      $Array_sort$excl$103,
      $Array_sort_by$excl$104,
      $Array_take$106,
      $Array_take_while$107,
      $Array_to_a$108,
      $Array_to_ary$109,
      $Array_to_h$110,
      $Array_transpose$111,
      $Array_union$114,
      $Array_uniq$116,
      $Array_uniq$excl$117,
      $Array_unshift$118,
      $Array_values_at$119,
      $Array_zip$122,
      $Array_inherited$123,
      $Array_instance_variables$124,
      $Array_pack$126;

    self.$include($$($nesting, "Enumerable"));
    Opal.defineProperty(self.$$prototype, "$$is_array", true);

    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace(obj.$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value,
        raised = null,
        updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i]);
          } catch (error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i];
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
    Opal.defs(
      self,
      "$[]",
      ($Array_$$$1 = function ($a) {
        var $post_args,
          objects,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        objects = $post_args;
        return toArraySubclass(objects, self);
      }),
      ($Array_$$$1.$$arity = -1)
    );

    Opal.def(
      self,
      "$initialize",
      ($Array_initialize$2 = function $$initialize(size, obj) {
        var $iter = $Array_initialize$2.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_initialize$2.$$p = null;

        if ($iter) $Array_initialize$2.$$p = null;

        if (size == null) {
          size = nil;
        }

        if (obj == null) {
          obj = nil;
        }

        if (obj !== nil && block !== nil) {
          self.$warn("warning: block supersedes default value argument");
        }

        if (size > $$$($$($nesting, "Integer"), "MAX")) {
          self.$raise($$($nesting, "ArgumentError"), "array size too big");
        }

        if (arguments.length > 2) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "wrong number of arguments (" + arguments.length + " for 0..2)"
          );
        }

        if (arguments.length === 0) {
          self.splice(0, self.length);
          return self;
        }

        if (arguments.length === 1) {
          if (size.$$is_array) {
            self.$replace(size.$to_a());
            return self;
          } else if (size["$respond_to?"]("to_ary")) {
            self.$replace(size.$to_ary());
            return self;
          }
        }

        size = $coerce_to(size, $$($nesting, "Integer"), "to_int");

        if (size < 0) {
          self.$raise($$($nesting, "ArgumentError"), "negative array size");
        }

        self.splice(0, self.length);
        var i, value;

        if (block === nil) {
          for (i = 0; i < size; i++) {
            self.push(obj);
          }
        } else {
          for (i = 0, value; i < size; i++) {
            value = block(i);
            self[i] = value;
          }
        }

        return self;
      }),
      ($Array_initialize$2.$$arity = -1)
    );
    Opal.defs(
      self,
      "$try_convert",
      ($Array_try_convert$3 = function $$try_convert(obj) {
        var self = this;

        return $$($nesting, "Opal")["$coerce_to?"](
          obj,
          $$($nesting, "Array"),
          "to_ary"
        );
      }),
      ($Array_try_convert$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$&",
      ($Array_$$4 = function (other) {
        var self = this;

        other = (function () {
          if ($truthy($$($nesting, "Array")["$==="](other))) {
            return other.$to_a();
          } else {
            return $coerce_to(other, $$($nesting, "Array"), "to_ary").$to_a();
          }
          return nil;
        })();

        var result = [],
          hash = $hash2([], {}),
          i,
          length,
          item;

        for (i = 0, length = other.length; i < length; i++) {
          $hash_put(hash, other[i], true);
        }

        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_delete(hash, item) !== undefined) {
            result.push(item);
          }
        }

        return result;
      }),
      ($Array_$$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$|",
      ($Array_$$5 = function (other) {
        var self = this;

        other = (function () {
          if ($truthy($$($nesting, "Array")["$==="](other))) {
            return other.$to_a();
          } else {
            return $coerce_to(other, $$($nesting, "Array"), "to_ary").$to_a();
          }
          return nil;
        })();

        var hash = $hash2([], {}),
          i,
          length,
          item;

        for (i = 0, length = self.length; i < length; i++) {
          $hash_put(hash, self[i], true);
        }

        for (i = 0, length = other.length; i < length; i++) {
          $hash_put(hash, other[i], true);
        }

        return hash.$keys();
      }),
      ($Array_$$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$*",
      ($Array_$$6 = function (other) {
        var self = this;

        if ($truthy(other["$respond_to?"]("to_str"))) {
          return self.$join(other.$to_str());
        }
        other = $coerce_to(other, $$($nesting, "Integer"), "to_int");
        if ($truthy(other < 0)) {
          self.$raise($$($nesting, "ArgumentError"), "negative argument");
        }

        var result = [],
          converted = self.$to_a();

        for (var i = 0; i < other; i++) {
          result = result.concat(converted);
        }

        return result;
      }),
      ($Array_$$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$+",
      ($Array_$plus$7 = function (other) {
        var self = this;

        other = (function () {
          if ($truthy($$($nesting, "Array")["$==="](other))) {
            return other.$to_a();
          } else {
            return $coerce_to(other, $$($nesting, "Array"), "to_ary").$to_a();
          }
          return nil;
        })();
        return self.concat(other);
      }),
      ($Array_$plus$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$-",
      ($Array_$minus$8 = function (other) {
        var self = this;

        other = (function () {
          if ($truthy($$($nesting, "Array")["$==="](other))) {
            return other.$to_a();
          } else {
            return $coerce_to(other, $$($nesting, "Array"), "to_ary").$to_a();
          }
          return nil;
        })();
        if ($truthy(self.length === 0)) {
          return [];
        }
        if ($truthy(other.length === 0)) {
          return self.slice();
        }

        var result = [],
          hash = $hash2([], {}),
          i,
          length,
          item;

        for (i = 0, length = other.length; i < length; i++) {
          $hash_put(hash, other[i], true);
        }

        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            result.push(item);
          }
        }

        return result;
      }),
      ($Array_$minus$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$<<",
      ($Array_$lt$lt$9 = function (object) {
        var self = this;

        self.push(object);
        return self;
      }),
      ($Array_$lt$lt$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=>",
      ($Array_$lt_eq_gt$10 = function (other) {
        var self = this;

        if ($truthy($$($nesting, "Array")["$==="](other))) {
          other = other.$to_a();
        } else if ($truthy(other["$respond_to?"]("to_ary"))) {
          other = other.$to_ary().$to_a();
        } else {
          return nil;
        }

        if (self.$hash() === other.$hash()) {
          return 0;
        }

        var count = Math.min(self.length, other.length);

        for (var i = 0; i < count; i++) {
          var tmp = self[i]["$<=>"](other[i]);

          if (tmp !== 0) {
            return tmp;
          }
        }

        return self.length["$<=>"](other.length);
      }),
      ($Array_$lt_eq_gt$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($Array_$eq_eq$11 = function (other) {
        var self = this;

        var recursed = {};

        function _eqeq(array, other) {
          var i, length, a, b;

          if (array === other) return true;

          if (!other.$$is_array) {
            if ($respond_to(other, "$to_ary")) {
              return other["$=="](array);
            } else {
              return false;
            }
          }

          if (array.$$constructor !== Array) array = array.$to_a();
          if (other.$$constructor !== Array) other = other.$to_a();

          if (array.length !== other.length) {
            return false;
          }

          recursed[array.$object_id()] = true;

          for (i = 0, length = array.length; i < length; i++) {
            a = array[i];
            b = other[i];
            if (a.$$is_array) {
              if (b.$$is_array && b.length !== a.length) {
                return false;
              }
              if (!recursed.hasOwnProperty(a.$object_id())) {
                if (!_eqeq(a, b)) {
                  return false;
                }
              }
            } else {
              if (!a["$=="](b)) {
                return false;
              }
            }
          }

          return true;
        }

        return _eqeq(self, other);
      }),
      ($Array_$eq_eq$11.$$arity = 1)
    );

    function $array_slice_range(self, index) {
      var size = self.length,
        exclude,
        from,
        to,
        result;

      exclude = index.excl;
      from = $coerce_to(index.begin, Opal.Integer, "to_int");
      to = $coerce_to(index.end, Opal.Integer, "to_int");

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
        exclude,
        from,
        to,
        result;

      index = $coerce_to(index, Opal.Integer, "to_int");

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      } else {
        length = $coerce_to(length, Opal.Integer, "to_int");

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
    Opal.def(
      self,
      "$[]",
      ($Array_$$$12 = function (index, length) {
        var self = this;

        if (index.$$is_range) {
          return $array_slice_range(self, index);
        } else {
          return $array_slice_index_length(self, index, length);
        }
      }),
      ($Array_$$$12.$$arity = -2)
    );

    Opal.def(
      self,
      "$[]=",
      ($Array_$$$eq$13 = function (index, value, extra) {
        var self = this,
          data = nil,
          length = nil;

        var i,
          size = self.length;
        if ($truthy($$($nesting, "Range")["$==="](index))) {
          data = (function () {
            if ($truthy($$($nesting, "Array")["$==="](value))) {
              return value.$to_a();
            } else if ($truthy(value["$respond_to?"]("to_ary"))) {
              return value.$to_ary().$to_a();
            } else {
              return [value];
            }
            return nil;
          })();

          var exclude = index.excl,
            from = $coerce_to(index.begin, $$($nesting, "Integer"), "to_int"),
            to = $coerce_to(index.end, $$($nesting, "Integer"), "to_int");

          if (from < 0) {
            from += size;

            if (from < 0) {
              self.$raise(
                $$($nesting, "RangeError"),
                "" + index.$inspect() + " out of range"
              );
            }
          }

          if (to < 0) {
            to += size;
          }

          if (!exclude) {
            to += 1;
          }

          if (from > size) {
            for (i = size; i < from; i++) {
              self[i] = nil;
            }
          }

          if (to < 0) {
            self.splice.apply(self, [from, 0].concat(data));
          } else {
            self.splice.apply(self, [from, to - from].concat(data));
          }

          return value;
        } else {
          if ($truthy(extra === undefined)) {
            length = 1;
          } else {
            length = value;
            value = extra;
            data = (function () {
              if ($truthy($$($nesting, "Array")["$==="](value))) {
                return value.$to_a();
              } else if ($truthy(value["$respond_to?"]("to_ary"))) {
                return value.$to_ary().$to_a();
              } else {
                return [value];
              }
              return nil;
            })();
          }

          var old;

          index = $coerce_to(index, $$($nesting, "Integer"), "to_int");
          length = $coerce_to(length, $$($nesting, "Integer"), "to_int");

          if (index < 0) {
            old = index;
            index += size;

            if (index < 0) {
              self.$raise(
                $$($nesting, "IndexError"),
                "" +
                  "index " +
                  old +
                  " too small for array; minimum " +
                  -self.length
              );
            }
          }

          if (length < 0) {
            self.$raise(
              $$($nesting, "IndexError"),
              "" + "negative length (" + length + ")"
            );
          }

          if (index > size) {
            for (i = size; i < index; i++) {
              self[i] = nil;
            }
          }

          if (extra === undefined) {
            self[index] = value;
          } else {
            self.splice.apply(self, [index, length].concat(data));
          }

          return value;
        }
      }),
      ($Array_$$$eq$13.$$arity = -3)
    );

    Opal.def(
      self,
      "$any?",
      ($Array_any$ques$14 = function (pattern) {
        var $iter = $Array_any$ques$14.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_any$ques$14.$$p = null;

        if ($iter) $Array_any$ques$14.$$p = null;
        if (self.length === 0) return false;
        return $send2(
          self,
          $find_super(self, "any?", $Array_any$ques$14, false, true),
          "any?",
          [pattern],
          $iter
        );
      }),
      ($Array_any$ques$14.$$arity = -1)
    );

    Opal.def(
      self,
      "$assoc",
      ($Array_assoc$15 = function $$assoc(object) {
        var self = this;

        for (var i = 0, length = self.length, item; i < length; i++) {
          if (((item = self[i]), item.length && item[0]["$=="](object))) {
            return item;
          }
        }

        return nil;
      }),
      ($Array_assoc$15.$$arity = 1)
    );

    Opal.def(
      self,
      "$at",
      ($Array_at$16 = function $$at(index) {
        var self = this;

        index = $coerce_to(index, $$($nesting, "Integer"), "to_int");

        if (index < 0) {
          index += self.length;
        }

        if (index < 0 || index >= self.length) {
          return nil;
        }

        return self[index];
      }),
      ($Array_at$16.$$arity = 1)
    );

    Opal.def(
      self,
      "$bsearch_index",
      ($Array_bsearch_index$17 = function $$bsearch_index() {
        var $iter = $Array_bsearch_index$17.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_bsearch_index$17.$$p = null;

        if ($iter) $Array_bsearch_index$17.$$p = null;
        if (block !== nil) {
        } else {
          return self.$enum_for("bsearch_index");
        }

        var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

        while (min < max) {
          mid = min + Math.floor((max - min) / 2);
          val = self[mid];
          ret = $yield1(block, val);

          if (ret === true) {
            satisfied = mid;
            smaller = true;
          } else if (ret === false || ret === nil) {
            smaller = false;
          } else if (ret.$$is_number) {
            if (ret === 0) {
              return mid;
            }
            smaller = ret < 0;
          } else {
            self.$raise(
              $$($nesting, "TypeError"),
              "" +
                "wrong argument type " +
                ret.$class() +
                " (must be numeric, true, false or nil)"
            );
          }

          if (smaller) {
            max = mid;
          } else {
            min = mid + 1;
          }
        }

        return satisfied;
      }),
      ($Array_bsearch_index$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$bsearch",
      ($Array_bsearch$18 = function $$bsearch() {
        var $iter = $Array_bsearch$18.$$p,
          block = $iter || nil,
          self = this,
          index = nil;

        if ($iter) $Array_bsearch$18.$$p = null;

        if ($iter) $Array_bsearch$18.$$p = null;
        if (block !== nil) {
        } else {
          return self.$enum_for("bsearch");
        }
        index = $send(self, "bsearch_index", [], block.$to_proc());

        if (index != null && index.$$is_number) {
          return self[index];
        } else {
          return index;
        }
      }),
      ($Array_bsearch$18.$$arity = 0)
    );

    Opal.def(
      self,
      "$cycle",
      ($Array_cycle$19 = function $$cycle(n) {
        var $iter = $Array_cycle$19.$$p,
          block = $iter || nil,
          $$20,
          self = this,
          $ret_or_1 = nil;

        if ($iter) $Array_cycle$19.$$p = null;

        if ($iter) $Array_cycle$19.$$p = null;

        if (n == null) {
          n = nil;
        }
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["cycle", n],
            (($$20 = function () {
              var self = $$20.$$s == null ? this : $$20.$$s;

              if ($truthy(n["$nil?"]())) {
                return $$$($$($nesting, "Float"), "INFINITY");
              } else {
                n = $$($nesting, "Opal")["$coerce_to!"](
                  n,
                  $$($nesting, "Integer"),
                  "to_int"
                );
                if ($truthy($rb_gt(n, 0))) {
                  return $rb_times(self.$enumerator_size(), n);
                } else {
                  return 0;
                }
              }
            }),
            ($$20.$$s = self),
            ($$20.$$arity = 0),
            $$20)
          );
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_1 = self["$empty?"]()))) {
                return $ret_or_1;
              } else {
                return n["$=="](0);
              }
              return nil;
            })()
          )
        ) {
          return nil;
        }

        var i, length, value;

        if (n === nil) {
          while (true) {
            for (i = 0, length = self.length; i < length; i++) {
              value = $yield1(block, self[i]);
            }
          }
        } else {
          n = $$($nesting, "Opal")["$coerce_to!"](
            n,
            $$($nesting, "Integer"),
            "to_int"
          );
          if (n <= 0) {
            return self;
          }

          while (n > 0) {
            for (i = 0, length = self.length; i < length; i++) {
              value = $yield1(block, self[i]);
            }

            n--;
          }
        }
        return self;
      }),
      ($Array_cycle$19.$$arity = -1)
    );

    Opal.def(
      self,
      "$clear",
      ($Array_clear$21 = function $$clear() {
        var self = this;

        self.splice(0, self.length);
        return self;
      }),
      ($Array_clear$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$count",
      ($Array_count$22 = function $$count(object) {
        var $iter = $Array_count$22.$$p,
          block = $iter || nil,
          self = this,
          $ret_or_2 = nil;

        if ($iter) $Array_count$22.$$p = null;

        if ($iter) $Array_count$22.$$p = null;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_2 = object !== undefined))) {
                return $ret_or_2;
              } else {
                return block;
              }
              return nil;
            })()
          )
        ) {
          return $send2(
            self,
            $find_super(self, "count", $Array_count$22, false, true),
            "count",
            [object],
            $iter
          );
        } else {
          return self.$size();
        }
      }),
      ($Array_count$22.$$arity = -1)
    );

    Opal.def(
      self,
      "$initialize_copy",
      ($Array_initialize_copy$23 = function $$initialize_copy(other) {
        var self = this;

        return self.$replace(other);
      }),
      ($Array_initialize_copy$23.$$arity = 1)
    );

    Opal.def(
      self,
      "$collect",
      ($Array_collect$24 = function $$collect() {
        var $iter = $Array_collect$24.$$p,
          block = $iter || nil,
          $$25,
          self = this;

        if ($iter) $Array_collect$24.$$p = null;

        if ($iter) $Array_collect$24.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["collect"],
            (($$25 = function () {
              var self = $$25.$$s == null ? this : $$25.$$s;

              return self.$size();
            }),
            ($$25.$$s = self),
            ($$25.$$arity = 0),
            $$25)
          );
        }

        var result = [];

        for (var i = 0, length = self.length; i < length; i++) {
          var value = $yield1(block, self[i]);
          result.push(value);
        }

        return result;
      }),
      ($Array_collect$24.$$arity = 0)
    );

    Opal.def(
      self,
      "$collect!",
      ($Array_collect$excl$26 = function () {
        var $iter = $Array_collect$excl$26.$$p,
          block = $iter || nil,
          $$27,
          self = this;

        if ($iter) $Array_collect$excl$26.$$p = null;

        if ($iter) $Array_collect$excl$26.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["collect!"],
            (($$27 = function () {
              var self = $$27.$$s == null ? this : $$27.$$s;

              return self.$size();
            }),
            ($$27.$$s = self),
            ($$27.$$arity = 0),
            $$27)
          );
        }

        for (var i = 0, length = self.length; i < length; i++) {
          var value = $yield1(block, self[i]);
          self[i] = value;
        }
        return self;
      }),
      ($Array_collect$excl$26.$$arity = 0)
    );

    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return (
          binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)
        );
      }

      return 0;
    }
    Opal.def(
      self,
      "$combination",
      ($Array_combination$28 = function $$combination(n) {
        var $$29,
          $iter = $Array_combination$28.$$p,
          $yield = $iter || nil,
          self = this,
          num = nil;

        if ($iter) $Array_combination$28.$$p = null;

        num = $$($nesting, "Opal")["$coerce_to!"](
          n,
          $$($nesting, "Integer"),
          "to_int"
        );
        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["combination", num],
            (($$29 = function () {
              var self = $$29.$$s == null ? this : $$29.$$s;

              return binomial_coefficient(self.length, num);
            }),
            ($$29.$$s = self),
            ($$29.$$arity = 0),
            $$29)
          );
        }

        var i, length, stack, chosen, lev, done, next;

        if (num === 0) {
          Opal.yield1($yield, []);
        } else if (num === 1) {
          for (i = 0, length = self.length; i < length; i++) {
            Opal.yield1($yield, [self[i]]);
          }
        } else if (num === self.length) {
          Opal.yield1($yield, self.slice());
        } else if (num >= 0 && num < self.length) {
          stack = [];
          for (i = 0; i <= num + 1; i++) {
            stack.push(0);
          }

          chosen = [];
          lev = 0;
          done = false;
          stack[0] = -1;

          while (!done) {
            chosen[lev] = self[stack[lev + 1]];
            while (lev < num - 1) {
              lev++;
              next = stack[lev + 1] = stack[lev] + 1;
              chosen[lev] = self[next];
            }
            Opal.yield1($yield, chosen.slice());
            lev++;
            do {
              done = lev === 0;
              stack[lev]++;
              lev--;
            } while (stack[lev + 1] + num === self.length + lev + 1);
          }
        }
        return self;
      }),
      ($Array_combination$28.$$arity = 1)
    );

    Opal.def(
      self,
      "$repeated_combination",
      ($Array_repeated_combination$30 = function $$repeated_combination(n) {
        var $$31,
          $iter = $Array_repeated_combination$30.$$p,
          $yield = $iter || nil,
          self = this,
          num = nil;

        if ($iter) $Array_repeated_combination$30.$$p = null;

        num = $$($nesting, "Opal")["$coerce_to!"](
          n,
          $$($nesting, "Integer"),
          "to_int"
        );
        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["repeated_combination", num],
            (($$31 = function () {
              var self = $$31.$$s == null ? this : $$31.$$s;

              return binomial_coefficient(self.length + num - 1, num);
            }),
            ($$31.$$s = self),
            ($$31.$$arity = 0),
            $$31)
          );
        }

        function iterate(max, from, buffer, self) {
          if (buffer.length == max) {
            var copy = buffer.slice();
            Opal.yield1($yield, copy);
            return;
          }
          for (var i = from; i < self.length; i++) {
            buffer.push(self[i]);
            iterate(max, i, buffer, self);
            buffer.pop();
          }
        }

        if (num >= 0) {
          iterate(num, 0, [], self);
        }
        return self;
      }),
      ($Array_repeated_combination$30.$$arity = 1)
    );

    Opal.def(
      self,
      "$compact",
      ($Array_compact$32 = function $$compact() {
        var self = this;

        var result = [];

        for (var i = 0, length = self.length, item; i < length; i++) {
          if ((item = self[i]) !== nil) {
            result.push(item);
          }
        }

        return result;
      }),
      ($Array_compact$32.$$arity = 0)
    );

    Opal.def(
      self,
      "$compact!",
      ($Array_compact$excl$33 = function () {
        var self = this;

        var original = self.length;

        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] === nil) {
            self.splice(i, 1);

            length--;
            i--;
          }
        }

        return self.length === original ? nil : self;
      }),
      ($Array_compact$excl$33.$$arity = 0)
    );

    Opal.def(
      self,
      "$concat",
      ($Array_concat$34 = function $$concat($a) {
        var $post_args,
          others,
          $$35,
          $$36,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        others = $post_args;
        others = $send(
          others,
          "map",
          [],
          (($$35 = function (other) {
            var self = $$35.$$s == null ? this : $$35.$$s;

            if (other == null) {
              other = nil;
            }
            other = (function () {
              if ($truthy($$($nesting, "Array")["$==="](other))) {
                return other.$to_a();
              } else {
                return $coerce_to(
                  other,
                  $$($nesting, "Array"),
                  "to_ary"
                ).$to_a();
              }
              return nil;
            })();
            if ($truthy(other["$equal?"](self))) {
              other = other.$dup();
            }
            return other;
          }),
          ($$35.$$s = self),
          ($$35.$$arity = 1),
          $$35)
        );
        $send(
          others,
          "each",
          [],
          (($$36 = function (other) {
            var self = $$36.$$s == null ? this : $$36.$$s;

            if (other == null) {
              other = nil;
            }

            for (var i = 0, length = other.length; i < length; i++) {
              self.push(other[i]);
            }
          }),
          ($$36.$$s = self),
          ($$36.$$arity = 1),
          $$36)
        );
        return self;
      }),
      ($Array_concat$34.$$arity = -1)
    );

    Opal.def(
      self,
      "$delete",
      ($Array_delete$37 = function (object) {
        var $iter = $Array_delete$37.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Array_delete$37.$$p = null;

        var original = self.length;

        for (var i = 0, length = original; i < length; i++) {
          if (self[i]["$=="](object)) {
            self.splice(i, 1);

            length--;
            i--;
          }
        }

        if (self.length === original) {
          if ($yield !== nil) {
            return Opal.yieldX($yield, []);
          }
          return nil;
        }
        return object;
      }),
      ($Array_delete$37.$$arity = 1)
    );

    Opal.def(
      self,
      "$delete_at",
      ($Array_delete_at$38 = function $$delete_at(index) {
        var self = this;

        index = $coerce_to(index, $$($nesting, "Integer"), "to_int");

        if (index < 0) {
          index += self.length;
        }

        if (index < 0 || index >= self.length) {
          return nil;
        }

        var result = self[index];

        self.splice(index, 1);

        return result;
      }),
      ($Array_delete_at$38.$$arity = 1)
    );

    Opal.def(
      self,
      "$delete_if",
      ($Array_delete_if$39 = function $$delete_if() {
        var $iter = $Array_delete_if$39.$$p,
          block = $iter || nil,
          $$40,
          self = this;

        if ($iter) $Array_delete_if$39.$$p = null;

        if ($iter) $Array_delete_if$39.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["delete_if"],
            (($$40 = function () {
              var self = $$40.$$s == null ? this : $$40.$$s;

              return self.$size();
            }),
            ($$40.$$s = self),
            ($$40.$$arity = 0),
            $$40)
          );
        }
        filterIf(self, $falsy, block);
        return self;
      }),
      ($Array_delete_if$39.$$arity = 0)
    );

    Opal.def(
      self,
      "$difference",
      ($Array_difference$41 = function $$difference($a) {
        var $post_args,
          arrays,
          $$42,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        arrays = $post_args;
        return $send(
          arrays,
          "reduce",
          [self.$to_a().$dup()],
          (($$42 = function (a, b) {
            var self = $$42.$$s == null ? this : $$42.$$s;

            if (a == null) {
              a = nil;
            }

            if (b == null) {
              b = nil;
            }
            return $rb_minus(a, b);
          }),
          ($$42.$$s = self),
          ($$42.$$arity = 2),
          $$42)
        );
      }),
      ($Array_difference$41.$$arity = -1)
    );

    Opal.def(
      self,
      "$dig",
      ($Array_dig$43 = function $$dig(idx, $a) {
        var $post_args,
          idxs,
          self = this,
          item = nil;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        idxs = $post_args;
        item = self["$[]"](idx);

        if (item === nil || idxs.length === 0) {
          return item;
        }
        if ($truthy(item["$respond_to?"]("dig"))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + item.$class() + " does not have #dig method"
          );
        }
        return $send(item, "dig", Opal.to_a(idxs));
      }),
      ($Array_dig$43.$$arity = -2)
    );

    Opal.def(
      self,
      "$drop",
      ($Array_drop$44 = function $$drop(number) {
        var self = this;

        if (number < 0) {
          self.$raise($$($nesting, "ArgumentError"));
        }

        return self.slice(number);
      }),
      ($Array_drop$44.$$arity = 1)
    );

    Opal.def(
      self,
      "$dup",
      ($Array_dup$45 = function $$dup() {
        var $iter = $Array_dup$45.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Array_dup$45.$$p = null;

        if (
          self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine
        ) {
          return self.slice(0);
        }
        return $send2(
          self,
          $find_super(self, "dup", $Array_dup$45, false, true),
          "dup",
          [],
          $iter
        );
      }),
      ($Array_dup$45.$$arity = 0)
    );

    Opal.def(
      self,
      "$each",
      ($Array_each$46 = function $$each() {
        var $iter = $Array_each$46.$$p,
          block = $iter || nil,
          $$47,
          self = this;

        if ($iter) $Array_each$46.$$p = null;

        if ($iter) $Array_each$46.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each"],
            (($$47 = function () {
              var self = $$47.$$s == null ? this : $$47.$$s;

              return self.$size();
            }),
            ($$47.$$s = self),
            ($$47.$$arity = 0),
            $$47)
          );
        }

        for (var i = 0, length = self.length; i < length; i++) {
          var value = $yield1(block, self[i]);
        }
        return self;
      }),
      ($Array_each$46.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_index",
      ($Array_each_index$48 = function $$each_index() {
        var $iter = $Array_each_index$48.$$p,
          block = $iter || nil,
          $$49,
          self = this;

        if ($iter) $Array_each_index$48.$$p = null;

        if ($iter) $Array_each_index$48.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_index"],
            (($$49 = function () {
              var self = $$49.$$s == null ? this : $$49.$$s;

              return self.$size();
            }),
            ($$49.$$s = self),
            ($$49.$$arity = 0),
            $$49)
          );
        }

        for (var i = 0, length = self.length; i < length; i++) {
          var value = $yield1(block, i);
        }
        return self;
      }),
      ($Array_each_index$48.$$arity = 0)
    );

    Opal.def(
      self,
      "$empty?",
      ($Array_empty$ques$50 = function () {
        var self = this;

        return self.length === 0;
      }),
      ($Array_empty$ques$50.$$arity = 0)
    );

    Opal.def(
      self,
      "$eql?",
      ($Array_eql$ques$51 = function (other) {
        var self = this;

        var recursed = {};

        function _eql(array, other) {
          var i, length, a, b;

          if (!other.$$is_array) {
            return false;
          }

          other = other.$to_a();

          if (array.length !== other.length) {
            return false;
          }

          recursed[array.$object_id()] = true;

          for (i = 0, length = array.length; i < length; i++) {
            a = array[i];
            b = other[i];
            if (a.$$is_array) {
              if (b.$$is_array && b.length !== a.length) {
                return false;
              }
              if (!recursed.hasOwnProperty(a.$object_id())) {
                if (!_eql(a, b)) {
                  return false;
                }
              }
            } else {
              if (!a["$eql?"](b)) {
                return false;
              }
            }
          }

          return true;
        }

        return _eql(self, other);
      }),
      ($Array_eql$ques$51.$$arity = 1)
    );

    Opal.def(
      self,
      "$fetch",
      ($Array_fetch$52 = function $$fetch(index, defaults) {
        var $iter = $Array_fetch$52.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_fetch$52.$$p = null;

        if ($iter) $Array_fetch$52.$$p = null;
        var original = index;

        index = $coerce_to(index, $$($nesting, "Integer"), "to_int");

        if (index < 0) {
          index += self.length;
        }

        if (index >= 0 && index < self.length) {
          return self[index];
        }

        if (block !== nil && defaults != null) {
          self.$warn("warning: block supersedes default value argument");
        }

        if (block !== nil) {
          return block(original);
        }

        if (defaults != null) {
          return defaults;
        }

        if (self.length === 0) {
          self.$raise(
            $$($nesting, "IndexError"),
            "" + "index " + original + " outside of array bounds: 0...0"
          );
        } else {
          self.$raise(
            $$($nesting, "IndexError"),
            "" +
              "index " +
              original +
              " outside of array bounds: -" +
              self.length +
              "..." +
              self.length
          );
        }
      }),
      ($Array_fetch$52.$$arity = -2)
    );

    Opal.def(
      self,
      "$fill",
      ($Array_fill$53 = function $$fill($a) {
        var $iter = $Array_fill$53.$$p,
          block = $iter || nil,
          $post_args,
          args,
          $b,
          $c,
          self = this,
          one = nil,
          two = nil,
          obj = nil,
          left = nil,
          right = nil;

        if ($iter) $Array_fill$53.$$p = null;

        if ($iter) $Array_fill$53.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        var i, length, value;
        if ($truthy(block)) {
          if ($truthy(args.length > 2)) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "wrong number of arguments (" + args.$length() + " for 0..2)"
            );
          }
          ($c = args),
            ($b = Opal.to_ary($c)),
            (one = $b[0] == null ? nil : $b[0]),
            (two = $b[1] == null ? nil : $b[1]),
            $c;
        } else {
          if ($truthy(args.length == 0)) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "wrong number of arguments (0 for 1..3)"
            );
          } else if ($truthy(args.length > 3)) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "wrong number of arguments (" + args.$length() + " for 1..3)"
            );
          }
          ($c = args),
            ($b = Opal.to_ary($c)),
            (obj = $b[0] == null ? nil : $b[0]),
            (one = $b[1] == null ? nil : $b[1]),
            (two = $b[2] == null ? nil : $b[2]),
            $c;
        }
        if ($truthy($$($nesting, "Range")["$==="](one))) {
          if ($truthy(two)) {
            self.$raise($$($nesting, "TypeError"), "length invalid with range");
          }
          left = $coerce_to(one.begin, $$($nesting, "Integer"), "to_int");
          if ($truthy(left < 0)) {
            left += this.length;
          }
          if ($truthy(left < 0)) {
            self.$raise(
              $$($nesting, "RangeError"),
              "" + one.$inspect() + " out of range"
            );
          }
          right = $coerce_to(one.end, $$($nesting, "Integer"), "to_int");
          if ($truthy(right < 0)) {
            right += this.length;
          }
          if ($truthy(one["$exclude_end?"]())) {
          } else {
            right += 1;
          }
          if ($truthy(right <= left)) {
            return self;
          }
        } else if ($truthy(one)) {
          left = $coerce_to(one, $$($nesting, "Integer"), "to_int");
          if ($truthy(left < 0)) {
            left += this.length;
          }
          if ($truthy(left < 0)) {
            left = 0;
          }
          if ($truthy(two)) {
            right = $coerce_to(two, $$($nesting, "Integer"), "to_int");
            if ($truthy(right == 0)) {
              return self;
            }
            right += left;
          } else {
            right = this.length;
          }
        } else {
          left = 0;
          right = this.length;
        }
        if ($truthy(left > this.length)) {
          for (i = this.length; i < right; i++) {
            self[i] = nil;
          }
        }
        if ($truthy(right > this.length)) {
          this.length = right;
        }
        if ($truthy(block)) {
          for (length = this.length; left < right; left++) {
            value = block(left);
            self[left] = value;
          }
        } else {
          for (length = this.length; left < right; left++) {
            self[left] = obj;
          }
        }
        return self;
      }),
      ($Array_fill$53.$$arity = -1)
    );

    Opal.def(
      self,
      "$first",
      ($Array_first$54 = function $$first(count) {
        var self = this;

        if (count == null) {
          return self.length === 0 ? nil : self[0];
        }

        count = $coerce_to(count, $$($nesting, "Integer"), "to_int");

        if (count < 0) {
          self.$raise($$($nesting, "ArgumentError"), "negative array size");
        }

        return self.slice(0, count);
      }),
      ($Array_first$54.$$arity = -1)
    );

    Opal.def(
      self,
      "$flatten",
      ($Array_flatten$55 = function $$flatten(level) {
        var self = this;

        function _flatten(array, level) {
          var result = [],
            i,
            length,
            item,
            ary;

          array = array.$to_a();

          for (i = 0, length = array.length; i < length; i++) {
            item = array[i];

            if (!$respond_to(item, "$to_ary", true)) {
              result.push(item);
              continue;
            }

            ary = item.$to_ary();

            if (ary === nil) {
              result.push(item);
              continue;
            }

            if (!ary.$$is_array) {
              self.$raise($$($nesting, "TypeError"));
            }

            if (ary === self) {
              self.$raise($$($nesting, "ArgumentError"));
            }

            switch (level) {
              case undefined:
                result = result.concat(_flatten(ary));
                break;
              case 0:
                result.push(ary);
                break;
              default:
                result.push.apply(result, _flatten(ary, level - 1));
            }
          }
          return result;
        }

        if (level !== undefined) {
          level = $coerce_to(level, $$($nesting, "Integer"), "to_int");
        }

        return _flatten(self, level);
      }),
      ($Array_flatten$55.$$arity = -1)
    );

    Opal.def(
      self,
      "$flatten!",
      ($Array_flatten$excl$56 = function (level) {
        var self = this;

        var flattened = self.$flatten(level);

        if (self.length == flattened.length) {
          for (var i = 0, length = self.length; i < length; i++) {
            if (self[i] !== flattened[i]) {
              break;
            }
          }

          if (i == length) {
            return nil;
          }
        }

        self.$replace(flattened);
        return self;
      }),
      ($Array_flatten$excl$56.$$arity = -1)
    );

    Opal.def(
      self,
      "$hash",
      ($Array_hash$57 = function $$hash() {
        var self = this;

        var top = $hash_ids === undefined,
          result = ["A"],
          hash_id = self.$object_id(),
          item,
          i,
          key;

        try {
          if (top) {
            $hash_ids = Object.create(null);
          }

          // return early for recursive structures
          if ($hash_ids[hash_id]) {
            return "self";
          }

          for (key in $hash_ids) {
            item = $hash_ids[key];
            if (self["$eql?"](item)) {
              return "self";
            }
          }

          $hash_ids[hash_id] = self;

          for (i = 0; i < self.length; i++) {
            item = self[i];
            result.push(item.$hash());
          }

          return result.join(",");
        } finally {
          if (top) {
            $hash_ids = undefined;
          }
        }
      }),
      ($Array_hash$57.$$arity = 0)
    );

    Opal.def(
      self,
      "$include?",
      ($Array_include$ques$58 = function (member) {
        var self = this;

        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i]["$=="](member)) {
            return true;
          }
        }

        return false;
      }),
      ($Array_include$ques$58.$$arity = 1)
    );

    Opal.def(
      self,
      "$index",
      ($Array_index$59 = function $$index(object) {
        var $iter = $Array_index$59.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_index$59.$$p = null;

        if ($iter) $Array_index$59.$$p = null;
        var i, length, value;

        if (object != null && block !== nil) {
          self.$warn("warning: given block not used");
        }

        if (object != null) {
          for (i = 0, length = self.length; i < length; i++) {
            if (self[i]["$=="](object)) {
              return i;
            }
          }
        } else if (block !== nil) {
          for (i = 0, length = self.length; i < length; i++) {
            value = block(self[i]);

            if (value !== false && value !== nil) {
              return i;
            }
          }
        } else {
          return self.$enum_for("index");
        }

        return nil;
      }),
      ($Array_index$59.$$arity = -1)
    );

    Opal.def(
      self,
      "$insert",
      ($Array_insert$60 = function $$insert(index, $a) {
        var $post_args,
          objects,
          self = this;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        objects = $post_args;

        index = $coerce_to(index, $$($nesting, "Integer"), "to_int");

        if (objects.length > 0) {
          if (index < 0) {
            index += self.length + 1;

            if (index < 0) {
              self.$raise(
                $$($nesting, "IndexError"),
                "" + index + " is out of bounds"
              );
            }
          }
          if (index > self.length) {
            for (var i = self.length; i < index; i++) {
              self.push(nil);
            }
          }

          self.splice.apply(self, [index, 0].concat(objects));
        }
        return self;
      }),
      ($Array_insert$60.$$arity = -2)
    );

    Opal.def(
      self,
      "$inspect",
      ($Array_inspect$61 = function $$inspect() {
        var self = this;

        var result = [],
          id = self.$__id__();

        for (var i = 0, length = self.length; i < length; i++) {
          var item = self["$[]"](i);

          if (item.$__id__() === id) {
            result.push("[...]");
          } else {
            result.push(item.$inspect());
          }
        }

        return "[" + result.join(", ") + "]";
      }),
      ($Array_inspect$61.$$arity = 0)
    );

    Opal.def(
      self,
      "$intersection",
      ($Array_intersection$62 = function $$intersection($a) {
        var $post_args,
          arrays,
          $$63,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        arrays = $post_args;
        return $send(
          arrays,
          "reduce",
          [self.$to_a().$dup()],
          (($$63 = function (a, b) {
            var self = $$63.$$s == null ? this : $$63.$$s;

            if (a == null) {
              a = nil;
            }

            if (b == null) {
              b = nil;
            }
            return a["$&"](b);
          }),
          ($$63.$$s = self),
          ($$63.$$arity = 2),
          $$63)
        );
      }),
      ($Array_intersection$62.$$arity = -1)
    );

    Opal.def(
      self,
      "$join",
      ($Array_join$64 = function $$join(sep) {
        var self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        if (sep == null) {
          sep = nil;
        }
        if ($truthy(self.length === 0)) {
          return "";
        }
        if ($truthy(sep === nil)) {
          sep = $gvars[","];
        }

        var result = [];
        var i, length, item, tmp;

        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];

          if ($respond_to(item, "$to_str")) {
            tmp = item.$to_str();

            if (tmp !== nil) {
              result.push(tmp.$to_s());

              continue;
            }
          }

          if ($respond_to(item, "$to_ary")) {
            tmp = item.$to_ary();

            if (tmp === self) {
              self.$raise($$($nesting, "ArgumentError"));
            }

            if (tmp !== nil) {
              result.push(tmp.$join(sep));

              continue;
            }
          }

          if ($respond_to(item, "$to_s")) {
            tmp = item.$to_s();

            if (tmp !== nil) {
              result.push(tmp);

              continue;
            }
          }

          self.$raise(
            $$($nesting, "NoMethodError").$new(
              "" +
                Opal.inspect(item) +
                " doesn't respond to #to_str, #to_ary or #to_s",
              "to_str"
            )
          );
        }

        if (sep === nil) {
          return result.join("");
        } else {
          return result.join(
            $$($nesting, "Opal")
              ["$coerce_to!"](sep, $$($nesting, "String"), "to_str")
              .$to_s()
          );
        }
      }),
      ($Array_join$64.$$arity = -1)
    );

    Opal.def(
      self,
      "$keep_if",
      ($Array_keep_if$65 = function $$keep_if() {
        var $iter = $Array_keep_if$65.$$p,
          block = $iter || nil,
          $$66,
          self = this;

        if ($iter) $Array_keep_if$65.$$p = null;

        if ($iter) $Array_keep_if$65.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["keep_if"],
            (($$66 = function () {
              var self = $$66.$$s == null ? this : $$66.$$s;

              return self.$size();
            }),
            ($$66.$$s = self),
            ($$66.$$arity = 0),
            $$66)
          );
        }
        filterIf(self, $truthy, block);
        return self;
      }),
      ($Array_keep_if$65.$$arity = 0)
    );

    Opal.def(
      self,
      "$last",
      ($Array_last$67 = function $$last(count) {
        var self = this;

        if (count == null) {
          return self.length === 0 ? nil : self[self.length - 1];
        }

        count = $coerce_to(count, $$($nesting, "Integer"), "to_int");

        if (count < 0) {
          self.$raise($$($nesting, "ArgumentError"), "negative array size");
        }

        if (count > self.length) {
          count = self.length;
        }

        return self.slice(self.length - count, self.length);
      }),
      ($Array_last$67.$$arity = -1)
    );

    Opal.def(
      self,
      "$length",
      ($Array_length$68 = function $$length() {
        var self = this;

        return self.length;
      }),
      ($Array_length$68.$$arity = 0)
    );
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");

    Opal.def(
      self,
      "$max",
      ($Array_max$69 = function $$max(n) {
        var $iter = $Array_max$69.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_max$69.$$p = null;

        if ($iter) $Array_max$69.$$p = null;
        return $send(self.$each(), "max", [n], block.$to_proc());
      }),
      ($Array_max$69.$$arity = -1)
    );

    Opal.def(
      self,
      "$min",
      ($Array_min$70 = function $$min() {
        var $iter = $Array_min$70.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_min$70.$$p = null;

        if ($iter) $Array_min$70.$$p = null;
        return $send(self.$each(), "min", [], block.$to_proc());
      }),
      ($Array_min$70.$$arity = 0)
    );

    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
    Opal.def(
      self,
      "$permutation",
      ($Array_permutation$71 = function $$permutation(num) {
        var $iter = $Array_permutation$71.$$p,
          block = $iter || nil,
          $$72,
          self = this,
          perm = nil,
          used = nil;

        if ($iter) $Array_permutation$71.$$p = null;

        if ($iter) $Array_permutation$71.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["permutation", num],
            (($$72 = function () {
              var self = $$72.$$s == null ? this : $$72.$$s;

              return descending_factorial(
                self.length,
                num === undefined ? self.length : num
              );
            }),
            ($$72.$$s = self),
            ($$72.$$arity = 0),
            $$72)
          );
        }

        var permute, offensive, output;

        if (num === undefined) {
          num = self.length;
        } else {
          num = $coerce_to(num, $$($nesting, "Integer"), "to_int");
        }

        if (num < 0 || self.length < num) {
          // no permutations, yield nothing
        } else if (num === 0) {
          // exactly one permutation: the zero-length array
          Opal.yield1(block, []);
        } else if (num === 1) {
          // this is a special, easy case
          for (var i = 0; i < self.length; i++) {
            Opal.yield1(block, [self[i]]);
          }
        } else {
          // this is the general case
          perm = $$($nesting, "Array").$new(num);
          used = $$($nesting, "Array").$new(self.length, false);

          permute = function (num, perm, index, used, blk) {
            self = this;
            for (var i = 0; i < self.length; i++) {
              if (used["$[]"](i)["$!"]()) {
                perm[index] = i;
                if (index < num - 1) {
                  used[i] = true;
                  permute.call(self, num, perm, index + 1, used, blk);
                  used[i] = false;
                } else {
                  output = [];
                  for (var j = 0; j < perm.length; j++) {
                    output.push(self[perm[j]]);
                  }
                  $yield1(blk, output);
                }
              }
            }
          };

          if (block !== nil) {
            // offensive (both definitions) copy.
            offensive = self.slice();
            permute.call(offensive, num, perm, 0, used, block);
          } else {
            permute.call(self, num, perm, 0, used, block);
          }
        }
        return self;
      }),
      ($Array_permutation$71.$$arity = -1)
    );

    Opal.def(
      self,
      "$repeated_permutation",
      ($Array_repeated_permutation$73 = function $$repeated_permutation(n) {
        var $$74,
          $iter = $Array_repeated_permutation$73.$$p,
          $yield = $iter || nil,
          self = this,
          num = nil;

        if ($iter) $Array_repeated_permutation$73.$$p = null;

        num = $$($nesting, "Opal")["$coerce_to!"](
          n,
          $$($nesting, "Integer"),
          "to_int"
        );
        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["repeated_permutation", num],
            (($$74 = function () {
              var self = $$74.$$s == null ? this : $$74.$$s;

              if ($truthy($rb_ge(num, 0))) {
                return self.$size()["$**"](num);
              } else {
                return 0;
              }
            }),
            ($$74.$$s = self),
            ($$74.$$arity = 0),
            $$74)
          );
        }

        function iterate(max, buffer, self) {
          if (buffer.length == max) {
            var copy = buffer.slice();
            Opal.yield1($yield, copy);
            return;
          }
          for (var i = 0; i < self.length; i++) {
            buffer.push(self[i]);
            iterate(max, buffer, self);
            buffer.pop();
          }
        }

        iterate(num, [], self.slice());
        return self;
      }),
      ($Array_repeated_permutation$73.$$arity = 1)
    );

    Opal.def(
      self,
      "$pop",
      ($Array_pop$75 = function $$pop(count) {
        var self = this;

        if ($truthy(count === undefined)) {
          if ($truthy(self.length === 0)) {
            return nil;
          }
          return self.pop();
        }
        count = $coerce_to(count, $$($nesting, "Integer"), "to_int");
        if ($truthy(count < 0)) {
          self.$raise($$($nesting, "ArgumentError"), "negative array size");
        }
        if ($truthy(self.length === 0)) {
          return [];
        }
        if ($truthy(count === 1)) {
          return [self.pop()];
        } else if ($truthy(count > self.length)) {
          return self.splice(0, self.length);
        } else {
          return self.splice(self.length - count, self.length);
        }
      }),
      ($Array_pop$75.$$arity = -1)
    );

    Opal.def(
      self,
      "$product",
      ($Array_product$76 = function $$product($a) {
        var $iter = $Array_product$76.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Array_product$76.$$p = null;

        if ($iter) $Array_product$76.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        var result = block !== nil ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths = new Array(n),
          arrays = new Array(n),
          i,
          m,
          subarray,
          len,
          resultlen = 1;

        arrays[0] = self;
        for (i = 1; i < n; i++) {
          arrays[i] = $coerce_to(args[i - 1], $$($nesting, "Array"), "to_ary");
        }

        for (i = 0; i < n; i++) {
          len = arrays[i].length;
          if (len === 0) {
            return result || self;
          }
          resultlen *= len;
          if (resultlen > 2147483647) {
            self.$raise($$($nesting, "RangeError"), "too big to product");
          }
          lengths[i] = len;
          counters[i] = 0;
        }

        outer_loop: for (;;) {
          subarray = [];
          for (i = 0; i < n; i++) {
            subarray.push(arrays[i][counters[i]]);
          }
          if (result) {
            result.push(subarray);
          } else {
            Opal.yield1(block, subarray);
          }
          m = n - 1;
          counters[m]++;
          while (counters[m] === lengths[m]) {
            counters[m] = 0;
            if (--m < 0) break outer_loop;
            counters[m]++;
          }
        }

        return result || self;
      }),
      ($Array_product$76.$$arity = -1)
    );

    Opal.def(
      self,
      "$push",
      ($Array_push$77 = function $$push($a) {
        var $post_args,
          objects,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        objects = $post_args;

        for (var i = 0, length = objects.length; i < length; i++) {
          self.push(objects[i]);
        }
        return self;
      }),
      ($Array_push$77.$$arity = -1)
    );
    $alias(self, "append", "push");

    Opal.def(
      self,
      "$rassoc",
      ($Array_rassoc$78 = function $$rassoc(object) {
        var self = this;

        for (var i = 0, length = self.length, item; i < length; i++) {
          item = self[i];

          if (item.length && item[1] !== undefined) {
            if (item[1]["$=="](object)) {
              return item;
            }
          }
        }

        return nil;
      }),
      ($Array_rassoc$78.$$arity = 1)
    );

    Opal.def(
      self,
      "$reject",
      ($Array_reject$79 = function $$reject() {
        var $iter = $Array_reject$79.$$p,
          block = $iter || nil,
          $$80,
          self = this;

        if ($iter) $Array_reject$79.$$p = null;

        if ($iter) $Array_reject$79.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["reject"],
            (($$80 = function () {
              var self = $$80.$$s == null ? this : $$80.$$s;

              return self.$size();
            }),
            ($$80.$$s = self),
            ($$80.$$arity = 0),
            $$80)
          );
        }

        var result = [];

        for (var i = 0, length = self.length, value; i < length; i++) {
          value = block(self[i]);

          if (value === false || value === nil) {
            result.push(self[i]);
          }
        }
        return result;
      }),
      ($Array_reject$79.$$arity = 0)
    );

    Opal.def(
      self,
      "$reject!",
      ($Array_reject$excl$81 = function () {
        var $iter = $Array_reject$excl$81.$$p,
          block = $iter || nil,
          $$82,
          self = this,
          original = nil;

        if ($iter) $Array_reject$excl$81.$$p = null;

        if ($iter) $Array_reject$excl$81.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["reject!"],
            (($$82 = function () {
              var self = $$82.$$s == null ? this : $$82.$$s;

              return self.$size();
            }),
            ($$82.$$s = self),
            ($$82.$$arity = 0),
            $$82)
          );
        }
        original = self.$length();
        $send(self, "delete_if", [], block.$to_proc());
        if (self.$length()["$=="](original)) {
          return nil;
        } else {
          return self;
        }
      }),
      ($Array_reject$excl$81.$$arity = 0)
    );

    Opal.def(
      self,
      "$replace",
      ($Array_replace$83 = function $$replace(other) {
        var self = this;

        other = (function () {
          if ($truthy($$($nesting, "Array")["$==="](other))) {
            return other.$to_a();
          } else {
            return $coerce_to(other, $$($nesting, "Array"), "to_ary").$to_a();
          }
          return nil;
        })();

        self.splice(0, self.length);
        self.push.apply(self, other);
        return self;
      }),
      ($Array_replace$83.$$arity = 1)
    );

    Opal.def(
      self,
      "$reverse",
      ($Array_reverse$84 = function $$reverse() {
        var self = this;

        return self.slice(0).reverse();
      }),
      ($Array_reverse$84.$$arity = 0)
    );

    Opal.def(
      self,
      "$reverse!",
      ($Array_reverse$excl$85 = function () {
        var self = this;

        return self.reverse();
      }),
      ($Array_reverse$excl$85.$$arity = 0)
    );

    Opal.def(
      self,
      "$reverse_each",
      ($Array_reverse_each$86 = function $$reverse_each() {
        var $iter = $Array_reverse_each$86.$$p,
          block = $iter || nil,
          $$87,
          self = this;

        if ($iter) $Array_reverse_each$86.$$p = null;

        if ($iter) $Array_reverse_each$86.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["reverse_each"],
            (($$87 = function () {
              var self = $$87.$$s == null ? this : $$87.$$s;

              return self.$size();
            }),
            ($$87.$$s = self),
            ($$87.$$arity = 0),
            $$87)
          );
        }
        $send(self.$reverse(), "each", [], block.$to_proc());
        return self;
      }),
      ($Array_reverse_each$86.$$arity = 0)
    );

    Opal.def(
      self,
      "$rindex",
      ($Array_rindex$88 = function $$rindex(object) {
        var $iter = $Array_rindex$88.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_rindex$88.$$p = null;

        if ($iter) $Array_rindex$88.$$p = null;
        var i, value;

        if (object != null && block !== nil) {
          self.$warn("warning: given block not used");
        }

        if (object != null) {
          for (i = self.length - 1; i >= 0; i--) {
            if (i >= self.length) {
              break;
            }
            if (self[i]["$=="](object)) {
              return i;
            }
          }
        } else if (block !== nil) {
          for (i = self.length - 1; i >= 0; i--) {
            if (i >= self.length) {
              break;
            }

            value = block(self[i]);

            if (value !== false && value !== nil) {
              return i;
            }
          }
        } else if (object == null) {
          return self.$enum_for("rindex");
        }

        return nil;
      }),
      ($Array_rindex$88.$$arity = -1)
    );

    Opal.def(
      self,
      "$rotate",
      ($Array_rotate$89 = function $$rotate(n) {
        var self = this;

        if (n == null) {
          n = 1;
        }

        var ary, idx, firstPart, lastPart;

        n = $coerce_to(n, $$($nesting, "Integer"), "to_int");

        if (self.length === 1) {
          return self.slice();
        }
        if (self.length === 0) {
          return [];
        }

        ary = self.slice();
        idx = n % ary.length;

        firstPart = ary.slice(idx);
        lastPart = ary.slice(0, idx);
        return firstPart.concat(lastPart);
      }),
      ($Array_rotate$89.$$arity = -1)
    );

    Opal.def(
      self,
      "$rotate!",
      ($Array_rotate$excl$90 = function (cnt) {
        var self = this,
          ary = nil;

        if (cnt == null) {
          cnt = 1;
        }

        if (self.length === 0 || self.length === 1) {
          return self;
        }
        cnt = $coerce_to(cnt, $$($nesting, "Integer"), "to_int");
        ary = self.$rotate(cnt);
        return self.$replace(ary);
      }),
      ($Array_rotate$excl$90.$$arity = -1)
    );
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "SampleRandom");

      var $nesting = [self].concat($parent_nesting),
        $SampleRandom_initialize$91,
        $SampleRandom_rand$92;

      self.$$prototype.rng = nil;

      Opal.def(
        self,
        "$initialize",
        ($SampleRandom_initialize$91 = function $$initialize(rng) {
          var self = this;

          return (self.rng = rng);
        }),
        ($SampleRandom_initialize$91.$$arity = 1)
      );
      return (
        (Opal.def(
          self,
          "$rand",
          ($SampleRandom_rand$92 = function $$rand(size) {
            var self = this,
              random = nil;

            random = $coerce_to(
              self.rng.$rand(size),
              $$($nesting, "Integer"),
              "to_int"
            );
            if ($truthy(random < 0)) {
              self.$raise(
                $$($nesting, "RangeError"),
                "random value must be >= 0"
              );
            }
            if ($truthy(random < size)) {
            } else {
              self.$raise(
                $$($nesting, "RangeError"),
                "random value must be less than Array size"
              );
            }
            return random;
          }),
          ($SampleRandom_rand$92.$$arity = 1)
        ),
        nil) && "rand"
      );
    })($nesting[0], null, $nesting);

    Opal.def(
      self,
      "$sample",
      ($Array_sample$93 = function $$sample(count, options) {
        var self = this,
          o = nil,
          $ret_or_3 = nil,
          rng = nil,
          $ret_or_4 = nil;

        if ($truthy(count === undefined)) {
          return self.$at($$($nesting, "Kernel").$rand(self.length));
        }
        if ($truthy(options === undefined)) {
          if (
            $truthy(
              (o = $$($nesting, "Opal")["$coerce_to?"](
                count,
                $$($nesting, "Hash"),
                "to_hash"
              ))
            )
          ) {
            options = o;
            count = nil;
          } else {
            options = nil;
            count = $coerce_to(count, $$($nesting, "Integer"), "to_int");
          }
        } else {
          count = $coerce_to(count, $$($nesting, "Integer"), "to_int");
          options = $coerce_to(options, $$($nesting, "Hash"), "to_hash");
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_3 = count))) {
                return count < 0;
              } else {
                return $ret_or_3;
              }
              return nil;
            })()
          )
        ) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "count must be greater than 0"
          );
        }
        if ($truthy(options)) {
          rng = options["$[]"]("random");
        }
        rng = (function () {
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_4 = rng))) {
                  return rng["$respond_to?"]("rand");
                } else {
                  return $ret_or_4;
                }
                return nil;
              })()
            )
          ) {
            return $$($nesting, "SampleRandom").$new(rng);
          } else {
            return $$($nesting, "Kernel");
          }
          return nil;
        })();
        if ($truthy(count)) {
        } else {
          return self[rng.$rand(self.length)];
        }

        var abandon, spin, result, i, j, k, targetIndex, oldValue;

        if (count > self.length) {
          count = self.length;
        }

        switch (count) {
          case 0:
            return [];
            break;
          case 1:
            return [self[rng.$rand(self.length)]];
            break;
          case 2:
            i = rng.$rand(self.length);
            j = rng.$rand(self.length);
            if (i === j) {
              j = i === 0 ? i + 1 : i - 1;
            }
            return [self[i], self[j]];
            break;
          default:
            if (self.length / count > 3) {
              abandon = false;
              spin = 0;

              result = $$($nesting, "Array").$new(count);
              i = 1;

              result[0] = rng.$rand(self.length);
              while (i < count) {
                k = rng.$rand(self.length);
                j = 0;

                while (j < i) {
                  while (k === result[j]) {
                    spin++;
                    if (spin > 100) {
                      abandon = true;
                      break;
                    }
                    k = rng.$rand(self.length);
                  }
                  if (abandon) {
                    break;
                  }

                  j++;
                }

                if (abandon) {
                  break;
                }

                result[i] = k;

                i++;
              }

              if (!abandon) {
                i = 0;
                while (i < count) {
                  result[i] = self[result[i]];
                  i++;
                }

                return result;
              }
            }

            result = self.slice();

            for (var c = 0; c < count; c++) {
              targetIndex = rng.$rand(self.length);
              oldValue = result[c];
              result[c] = result[targetIndex];
              result[targetIndex] = oldValue;
            }

            return count === self.length ? result : result["$[]"](0, count);
        }
      }),
      ($Array_sample$93.$$arity = -1)
    );

    Opal.def(
      self,
      "$select",
      ($Array_select$94 = function $$select() {
        var $iter = $Array_select$94.$$p,
          block = $iter || nil,
          $$95,
          self = this;

        if ($iter) $Array_select$94.$$p = null;

        if ($iter) $Array_select$94.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["select"],
            (($$95 = function () {
              var self = $$95.$$s == null ? this : $$95.$$s;

              return self.$size();
            }),
            ($$95.$$s = self),
            ($$95.$$arity = 0),
            $$95)
          );
        }

        var result = [];

        for (var i = 0, length = self.length, item, value; i < length; i++) {
          item = self[i];

          value = $yield1(block, item);

          if ($truthy(value)) {
            result.push(item);
          }
        }

        return result;
      }),
      ($Array_select$94.$$arity = 0)
    );

    Opal.def(
      self,
      "$select!",
      ($Array_select$excl$96 = function () {
        var $iter = $Array_select$excl$96.$$p,
          block = $iter || nil,
          $$97,
          self = this;

        if ($iter) $Array_select$excl$96.$$p = null;

        if ($iter) $Array_select$excl$96.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["select!"],
            (($$97 = function () {
              var self = $$97.$$s == null ? this : $$97.$$s;

              return self.$size();
            }),
            ($$97.$$s = self),
            ($$97.$$arity = 0),
            $$97)
          );
        }

        var original = self.length;
        $send(self, "keep_if", [], block.$to_proc());
        return self.length === original ? nil : self;
      }),
      ($Array_select$excl$96.$$arity = 0)
    );
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");

    Opal.def(
      self,
      "$shift",
      ($Array_shift$98 = function $$shift(count) {
        var self = this;

        if ($truthy(count === undefined)) {
          if ($truthy(self.length === 0)) {
            return nil;
          }
          return shiftNoArg(self);
        }
        count = $coerce_to(count, $$($nesting, "Integer"), "to_int");
        if ($truthy(count < 0)) {
          self.$raise($$($nesting, "ArgumentError"), "negative array size");
        }
        if ($truthy(self.length === 0)) {
          return [];
        }
        return self.splice(0, count);
      }),
      ($Array_shift$98.$$arity = -1)
    );
    $alias(self, "size", "length");

    Opal.def(
      self,
      "$shuffle",
      ($Array_shuffle$99 = function $$shuffle(rng) {
        var self = this;

        return self.$dup().$to_a()["$shuffle!"](rng);
      }),
      ($Array_shuffle$99.$$arity = -1)
    );

    Opal.def(
      self,
      "$shuffle!",
      ($Array_shuffle$excl$100 = function (rng) {
        var self = this;

        var randgen,
          i = self.length,
          j,
          tmp;

        if (rng !== undefined) {
          rng = $$($nesting, "Opal")["$coerce_to?"](
            rng,
            $$($nesting, "Hash"),
            "to_hash"
          );

          if (rng !== nil) {
            rng = rng["$[]"]("random");

            if (rng !== nil && rng["$respond_to?"]("rand")) {
              randgen = rng;
            }
          }
        }

        while (i) {
          if (randgen) {
            j = randgen.$rand(i).$to_int();

            if (j < 0) {
              self.$raise(
                $$($nesting, "RangeError"),
                "" + "random number too small " + j
              );
            }

            if (j >= i) {
              self.$raise(
                $$($nesting, "RangeError"),
                "" + "random number too big " + j
              );
            }
          } else {
            j = self.$rand(i);
          }

          tmp = self[--i];
          self[i] = self[j];
          self[j] = tmp;
        }

        return self;
      }),
      ($Array_shuffle$excl$100.$$arity = -1)
    );
    $alias(self, "slice", "[]");

    Opal.def(
      self,
      "$slice!",
      ($Array_slice$excl$101 = function (index, length) {
        var self = this,
          result = nil,
          range = nil,
          range_start = nil,
          range_end = nil,
          start = nil;

        result = nil;
        if ($truthy(length === undefined)) {
          if ($truthy($$($nesting, "Range")["$==="](index))) {
            range = index;
            result = self["$[]"](range);
            range_start = $coerce_to(
              range.begin,
              $$($nesting, "Integer"),
              "to_int"
            );
            range_end = $coerce_to(
              range.end,
              $$($nesting, "Integer"),
              "to_int"
            );

            if (range_start < 0) {
              range_start += self.length;
            }

            if (range_end < 0) {
              range_end += self.length;
            } else if (range_end >= self.length) {
              range_end = self.length - 1;
              if (range.excl) {
                range_end += 1;
              }
            }

            var range_length = range_end - range_start;
            if (range.excl) {
              range_end -= 1;
            } else {
              range_length += 1;
            }

            if (
              range_start < self.length &&
              range_start >= 0 &&
              range_end < self.length &&
              range_end >= 0 &&
              range_length > 0
            ) {
              self.splice(range_start, range_length);
            }
          } else {
            start = $coerce_to(index, $$($nesting, "Integer"), "to_int");

            if (start < 0) {
              start += self.length;
            }

            if (start < 0 || start >= self.length) {
              return nil;
            }

            result = self[start];

            if (start === 0) {
              self.shift();
            } else {
              self.splice(start, 1);
            }
          }
        } else {
          start = $coerce_to(index, $$($nesting, "Integer"), "to_int");
          length = $coerce_to(length, $$($nesting, "Integer"), "to_int");

          if (length < 0) {
            return nil;
          }

          var end = start + length;

          result = self["$[]"](start, length);

          if (start < 0) {
            start += self.length;
          }

          if (start + length > self.length) {
            length = self.length - start;
          }

          if (start < self.length && start >= 0) {
            self.splice(start, length);
          }
        }
        return result;
      }),
      ($Array_slice$excl$101.$$arity = -2)
    );

    Opal.def(
      self,
      "$sort",
      ($Array_sort$102 = function $$sort() {
        var $iter = $Array_sort$102.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_sort$102.$$p = null;

        if ($iter) $Array_sort$102.$$p = null;
        if ($truthy(self.length > 1)) {
        } else {
          return self;
        }

        if (block === nil) {
          block = function (a, b) {
            return a["$<=>"](b);
          };
        }

        return self.slice().sort(function (x, y) {
          var ret = block(x, y);

          if (ret === nil) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" +
                "comparison of " +
                x.$inspect() +
                " with " +
                y.$inspect() +
                " failed"
            );
          }

          return $rb_gt(ret, 0) ? 1 : $rb_lt(ret, 0) ? -1 : 0;
        });
      }),
      ($Array_sort$102.$$arity = 0)
    );

    Opal.def(
      self,
      "$sort!",
      ($Array_sort$excl$103 = function () {
        var $iter = $Array_sort$excl$103.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_sort$excl$103.$$p = null;

        if ($iter) $Array_sort$excl$103.$$p = null;

        var result;

        if (block !== nil) {
          result = $send(self.slice(), "sort", [], block.$to_proc());
        } else {
          result = self.slice().$sort();
        }

        self.length = 0;
        for (var i = 0, length = result.length; i < length; i++) {
          self.push(result[i]);
        }

        return self;
      }),
      ($Array_sort$excl$103.$$arity = 0)
    );

    Opal.def(
      self,
      "$sort_by!",
      ($Array_sort_by$excl$104 = function () {
        var $iter = $Array_sort_by$excl$104.$$p,
          block = $iter || nil,
          $$105,
          self = this;

        if ($iter) $Array_sort_by$excl$104.$$p = null;

        if ($iter) $Array_sort_by$excl$104.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["sort_by!"],
            (($$105 = function () {
              var self = $$105.$$s == null ? this : $$105.$$s;

              return self.$size();
            }),
            ($$105.$$s = self),
            ($$105.$$arity = 0),
            $$105)
          );
        }
        return self.$replace($send(self, "sort_by", [], block.$to_proc()));
      }),
      ($Array_sort_by$excl$104.$$arity = 0)
    );

    Opal.def(
      self,
      "$take",
      ($Array_take$106 = function $$take(count) {
        var self = this;

        if (count < 0) {
          self.$raise($$($nesting, "ArgumentError"));
        }

        return self.slice(0, count);
      }),
      ($Array_take$106.$$arity = 1)
    );

    Opal.def(
      self,
      "$take_while",
      ($Array_take_while$107 = function $$take_while() {
        var $iter = $Array_take_while$107.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_take_while$107.$$p = null;

        if ($iter) $Array_take_while$107.$$p = null;

        var result = [];

        for (var i = 0, length = self.length, item, value; i < length; i++) {
          item = self[i];

          value = block(item);

          if (value === false || value === nil) {
            return result;
          }

          result.push(item);
        }

        return result;
      }),
      ($Array_take_while$107.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_a",
      ($Array_to_a$108 = function $$to_a() {
        var self = this;

        if (self.$$class === Opal.Array) {
          return self;
        } else {
          return Opal.Array.$new(self);
        }
      }),
      ($Array_to_a$108.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_ary",
      ($Array_to_ary$109 = function $$to_ary() {
        var self = this;

        return self;
      }),
      ($Array_to_ary$109.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_h",
      ($Array_to_h$110 = function $$to_h() {
        var $iter = $Array_to_h$110.$$p,
          block = $iter || nil,
          self = this,
          array = nil;

        if ($iter) $Array_to_h$110.$$p = null;

        if ($iter) $Array_to_h$110.$$p = null;
        array = self;
        if (block !== nil) {
          array = $send(array, "map", [], block.$to_proc());
        }

        var i,
          len = array.length,
          ary,
          key,
          val,
          hash = $hash2([], {});

        for (i = 0; i < len; i++) {
          ary = $$($nesting, "Opal")["$coerce_to?"](
            array[i],
            $$($nesting, "Array"),
            "to_ary"
          );
          if (!ary.$$is_array) {
            self.$raise(
              $$($nesting, "TypeError"),
              "" +
                "wrong element type " +
                ary.$class() +
                " at " +
                i +
                " (expected array)"
            );
          }
          if (ary.length !== 2) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" +
                "wrong array length at " +
                i +
                " (expected 2, was " +
                ary.$length() +
                ")"
            );
          }
          key = ary[0];
          val = ary[1];
          $hash_put(hash, key, val);
        }

        return hash;
      }),
      ($Array_to_h$110.$$arity = 0)
    );
    $alias(self, "to_s", "inspect");

    Opal.def(
      self,
      "$transpose",
      ($Array_transpose$111 = function $$transpose() {
        var $$112,
          self = this,
          result = nil,
          max = nil;

        if ($truthy(self["$empty?"]())) {
          return [];
        }
        result = [];
        max = nil;
        $send(
          self,
          "each",
          [],
          (($$112 = function (row) {
            var self = $$112.$$s == null ? this : $$112.$$s,
              $$113,
              $ret_or_5 = nil;

            if (row == null) {
              row = nil;
            }
            row = (function () {
              if ($truthy($$($nesting, "Array")["$==="](row))) {
                return row.$to_a();
              } else {
                return $coerce_to(row, $$($nesting, "Array"), "to_ary").$to_a();
              }
              return nil;
            })();
            max = (function () {
              if ($truthy(($ret_or_5 = max))) {
                return $ret_or_5;
              } else {
                return row.length;
              }
              return nil;
            })();
            if ($truthy(row.length["$!="](max))) {
              self.$raise(
                $$($nesting, "IndexError"),
                "" +
                  "element size differs (" +
                  row.length +
                  " should be " +
                  max +
                  ")"
              );
            }
            return $send(
              row.length,
              "times",
              [],
              (($$113 = function (i) {
                var self = $$113.$$s == null ? this : $$113.$$s,
                  entry = nil,
                  $ret_or_6 = nil,
                  $writer = nil;

                if (i == null) {
                  i = nil;
                }
                entry = (function () {
                  if ($truthy(($ret_or_6 = result["$[]"](i)))) {
                    return $ret_or_6;
                  } else {
                    $writer = [i, []];
                    $send(result, "[]=", Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];
                  }
                  return nil;
                })();
                return entry["$<<"](row.$at(i));
              }),
              ($$113.$$s = self),
              ($$113.$$arity = 1),
              $$113)
            );
          }),
          ($$112.$$s = self),
          ($$112.$$arity = 1),
          $$112)
        );
        return result;
      }),
      ($Array_transpose$111.$$arity = 0)
    );

    Opal.def(
      self,
      "$union",
      ($Array_union$114 = function $$union($a) {
        var $post_args,
          arrays,
          $$115,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        arrays = $post_args;
        return $send(
          arrays,
          "reduce",
          [self.$uniq()],
          (($$115 = function (a, b) {
            var self = $$115.$$s == null ? this : $$115.$$s;

            if (a == null) {
              a = nil;
            }

            if (b == null) {
              b = nil;
            }
            return a["$|"](b);
          }),
          ($$115.$$s = self),
          ($$115.$$arity = 2),
          $$115)
        );
      }),
      ($Array_union$114.$$arity = -1)
    );

    Opal.def(
      self,
      "$uniq",
      ($Array_uniq$116 = function $$uniq() {
        var $iter = $Array_uniq$116.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_uniq$116.$$p = null;

        if ($iter) $Array_uniq$116.$$p = null;

        var hash = $hash2([], {}),
          i,
          length,
          item,
          key;

        if (block === nil) {
          for (i = 0, length = self.length; i < length; i++) {
            item = self[i];
            if ($hash_get(hash, item) === undefined) {
              $hash_put(hash, item, item);
            }
          }
        } else {
          for (i = 0, length = self.length; i < length; i++) {
            item = self[i];
            key = $yield1(block, item);
            if ($hash_get(hash, key) === undefined) {
              $hash_put(hash, key, item);
            }
          }
        }

        return hash.$values();
      }),
      ($Array_uniq$116.$$arity = 0)
    );

    Opal.def(
      self,
      "$uniq!",
      ($Array_uniq$excl$117 = function () {
        var $iter = $Array_uniq$excl$117.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_uniq$excl$117.$$p = null;

        if ($iter) $Array_uniq$excl$117.$$p = null;

        var original_length = self.length,
          hash = $hash2([], {}),
          i,
          length,
          item,
          key;

        for (i = 0, length = original_length; i < length; i++) {
          item = self[i];
          key = block === nil ? item : $yield1(block, item);

          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
            continue;
          }

          self.splice(i, 1);
          length--;
          i--;
        }

        return self.length === original_length ? nil : self;
      }),
      ($Array_uniq$excl$117.$$arity = 0)
    );

    Opal.def(
      self,
      "$unshift",
      ($Array_unshift$118 = function $$unshift($a) {
        var $post_args,
          objects,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        objects = $post_args;

        var selfLength = self.length;
        var objectsLength = objects.length;
        if (objectsLength == 0) return self;
        var index = selfLength - objectsLength;
        for (var i = 0; i < objectsLength; i++) {
          self.push(self[index + i]);
        }
        var len = selfLength - 1;
        while (len - objectsLength >= 0) {
          self[len] = self[len - objectsLength];
          len--;
        }
        for (var j = 0; j < objectsLength; j++) {
          self[j] = objects[j];
        }
        return self;
      }),
      ($Array_unshift$118.$$arity = -1)
    );
    $alias(self, "prepend", "unshift");

    Opal.def(
      self,
      "$values_at",
      ($Array_values_at$119 = function $$values_at($a) {
        var $post_args,
          args,
          $$120,
          self = this,
          out = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        out = [];
        $send(
          args,
          "each",
          [],
          (($$120 = function (elem) {
            var self = $$120.$$s == null ? this : $$120.$$s,
              $$121,
              finish = nil,
              start = nil,
              i = nil;

            if (elem == null) {
              elem = nil;
            }
            if ($truthy(elem["$is_a?"]($$($nesting, "Range")))) {
              finish = $coerce_to(
                elem.$last(),
                $$($nesting, "Integer"),
                "to_int"
              );
              start = $coerce_to(
                elem.$first(),
                $$($nesting, "Integer"),
                "to_int"
              );

              if (start < 0) {
                start = start + self.length;
                return nil;
              }
              if (finish < 0) {
                finish = finish + self.length;
              }
              if (elem["$exclude_end?"]()) {
                finish--;
              }
              if (finish < start) {
                return nil;
              }
              return $send(
                start,
                "upto",
                [finish],
                (($$121 = function (i) {
                  var self = $$121.$$s == null ? this : $$121.$$s;

                  if (i == null) {
                    i = nil;
                  }
                  return out["$<<"](self.$at(i));
                }),
                ($$121.$$s = self),
                ($$121.$$arity = 1),
                $$121)
              );
            } else {
              i = $coerce_to(elem, $$($nesting, "Integer"), "to_int");
              return out["$<<"](self.$at(i));
            }
          }),
          ($$120.$$s = self),
          ($$120.$$arity = 1),
          $$120)
        );
        return out;
      }),
      ($Array_values_at$119.$$arity = -1)
    );

    Opal.def(
      self,
      "$zip",
      ($Array_zip$122 = function $$zip($a) {
        var $iter = $Array_zip$122.$$p,
          block = $iter || nil,
          $post_args,
          others,
          self = this,
          $ret_or_7 = nil;

        if ($iter) $Array_zip$122.$$p = null;

        if ($iter) $Array_zip$122.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        others = $post_args;

        var result = [],
          size = self.length,
          part,
          o,
          i,
          j,
          jj;

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j];
          if (o.$$is_array) {
            continue;
          }
          if (o.$$is_range || o.$$is_enumerator) {
            others[j] = o.$take(size);
            continue;
          }
          others[j] = (function () {
            if (
              $truthy(
                ($ret_or_7 = $$($nesting, "Opal")["$coerce_to?"](
                  o,
                  $$($nesting, "Array"),
                  "to_ary"
                ))
              )
            ) {
              return $ret_or_7;
            } else {
              return $$($nesting, "Opal")["$coerce_to!"](
                o,
                $$($nesting, "Enumerator"),
                "to_enum",
                "each"
              );
            }
            return nil;
          })().$to_a();
        }

        for (i = 0; i < size; i++) {
          part = [self[i]];

          for (j = 0, jj = others.length; j < jj; j++) {
            o = others[j][i];

            if (o == null) {
              o = nil;
            }

            part[j + 1] = o;
          }

          result[i] = part;
        }

        if (block !== nil) {
          for (i = 0; i < size; i++) {
            Opal.yield1(block, result[i]);
          }

          return nil;
        }

        return result;
      }),
      ($Array_zip$122.$$arity = -1)
    );
    Opal.defs(
      self,
      "$inherited",
      ($Array_inherited$123 = function $$inherited(klass) {
        var self = this;

        klass.$$prototype.$to_a = function () {
          return this.slice(0, this.length);
        };
      }),
      ($Array_inherited$123.$$arity = 1)
    );

    Opal.def(
      self,
      "$instance_variables",
      ($Array_instance_variables$124 = function $$instance_variables() {
        var $$125,
          $iter = $Array_instance_variables$124.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Array_instance_variables$124.$$p = null;
        return $send(
          $send2(
            self,
            $find_super(
              self,
              "instance_variables",
              $Array_instance_variables$124,
              false,
              true
            ),
            "instance_variables",
            [],
            $iter
          ),
          "reject",
          [],
          (($$125 = function (ivar) {
            var self = $$125.$$s == null ? this : $$125.$$s,
              $ret_or_8 = nil;

            if (ivar == null) {
              ivar = nil;
            }
            if ($truthy(($ret_or_8 = /^@\d+$/.test(ivar)))) {
              return $ret_or_8;
            } else {
              return ivar["$=="]("@length");
            }
          }),
          ($$125.$$s = self),
          ($$125.$$arity = 1),
          $$125)
        );
      }),
      ($Array_instance_variables$124.$$arity = 0)
    );
    $$($nesting, "Opal").$pristine(self.$singleton_class(), "allocate");
    $$($nesting, "Opal").$pristine(
      self,
      "copy_instance_variables",
      "initialize_dup"
    );
    return (
      (Opal.def(
        self,
        "$pack",
        ($Array_pack$126 = function $$pack($a) {
          var $post_args,
            args,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          args = $post_args;
          return self.$raise(
            "To use Array#pack, you must first require 'corelib/array/pack'."
          );
        }),
        ($Array_pack$126.$$arity = -1)
      ),
      nil) && "pack"
    );
  })($nesting[0], Array, $nesting);
};

Opal.modules["corelib/hash"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $send = Opal.send,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$require",
    "$include",
    "$coerce_to?",
    "$[]",
    "$merge!",
    "$allocate",
    "$raise",
    "$coerce_to!",
    "$each",
    "$fetch",
    "$>=",
    "$>",
    "$==",
    "$compare_by_identity",
    "$lambda?",
    "$abs",
    "$arity",
    "$enum_for",
    "$size",
    "$respond_to?",
    "$class",
    "$dig",
    "$except!",
    "$dup",
    "$delete",
    "$new",
    "$inspect",
    "$map",
    "$to_proc",
    "$flatten",
    "$eql?",
    "$default",
    "$default_proc",
    "$default_proc=",
    "$-",
    "$default=",
    "$to_h",
    "$proc",
  ]);

  self.$require("corelib/enumerable");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Hash");

    var $nesting = [self].concat($parent_nesting),
      $Hash_$$$1,
      $Hash_allocate$2,
      $Hash_try_convert$3,
      $Hash_initialize$4,
      $Hash_$eq_eq$5,
      $Hash_$gt_eq$6,
      $Hash_$gt$8,
      $Hash_$lt$9,
      $Hash_$lt_eq$10,
      $Hash_$$$11,
      $Hash_$$$eq$12,
      $Hash_assoc$13,
      $Hash_clear$14,
      $Hash_clone$15,
      $Hash_compact$16,
      $Hash_compact$excl$17,
      $Hash_compare_by_identity$18,
      $Hash_compare_by_identity$ques$19,
      $Hash_default$20,
      $Hash_default$eq$21,
      $Hash_default_proc$22,
      $Hash_default_proc$eq$23,
      $Hash_delete$24,
      $Hash_delete_if$25,
      $Hash_dig$27,
      $Hash_each$28,
      $Hash_each_key$30,
      $Hash_each_value$32,
      $Hash_empty$ques$34,
      $Hash_except$35,
      $Hash_except$excl$36,
      $Hash_fetch$38,
      $Hash_fetch_values$39,
      $Hash_flatten$41,
      $Hash_has_key$ques$42,
      $Hash_has_value$ques$43,
      $Hash_hash$44,
      $Hash_index$45,
      $Hash_indexes$46,
      $Hash_inspect$47,
      $Hash_invert$48,
      $Hash_keep_if$49,
      $Hash_keys$51,
      $Hash_length$52,
      $Hash_merge$53,
      $Hash_merge$excl$54,
      $Hash_rassoc$55,
      $Hash_rehash$56,
      $Hash_reject$57,
      $Hash_reject$excl$59,
      $Hash_replace$61,
      $Hash_select$62,
      $Hash_select$excl$64,
      $Hash_shift$66,
      $Hash_slice$67,
      $Hash_to_a$68,
      $Hash_to_h$69,
      $Hash_to_hash$70,
      $Hash_to_proc$71,
      $Hash_transform_keys$73,
      $Hash_transform_keys$excl$75,
      $Hash_transform_values$77,
      $Hash_transform_values$excl$79,
      $Hash_values$81;

    self.$include($$($nesting, "Enumerable"));
    self.$$prototype.$$is_hash = true;
    Opal.defs(
      self,
      "$[]",
      ($Hash_$$$1 = function ($a) {
        var $post_args,
          argv,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        argv = $post_args;

        var hash,
          argc = argv.length,
          i;

        if (argc === 1) {
          hash = $$($nesting, "Opal")["$coerce_to?"](
            argv["$[]"](0),
            $$($nesting, "Hash"),
            "to_hash"
          );
          if (hash !== nil) {
            return self.$allocate()["$merge!"](hash);
          }

          argv = $$($nesting, "Opal")["$coerce_to?"](
            argv["$[]"](0),
            $$($nesting, "Array"),
            "to_ary"
          );
          if (argv === nil) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "odd number of arguments for Hash"
            );
          }

          argc = argv.length;
          hash = self.$allocate();

          for (i = 0; i < argc; i++) {
            if (!argv[i].$$is_array) continue;
            switch (argv[i].length) {
              case 1:
                hash.$store(argv[i][0], nil);
                break;
              case 2:
                hash.$store(argv[i][0], argv[i][1]);
                break;
              default:
                self.$raise(
                  $$($nesting, "ArgumentError"),
                  "" +
                    "invalid number of elements (" +
                    argv[i].length +
                    " for 1..2)"
                );
            }
          }

          return hash;
        }

        if (argc % 2 !== 0) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "odd number of arguments for Hash"
          );
        }

        hash = self.$allocate();

        for (i = 0; i < argc; i += 2) {
          hash.$store(argv[i], argv[i + 1]);
        }

        return hash;
      }),
      ($Hash_$$$1.$$arity = -1)
    );
    Opal.defs(
      self,
      "$allocate",
      ($Hash_allocate$2 = function $$allocate() {
        var self = this;

        var hash = new self.$$constructor();

        Opal.hash_init(hash);

        hash.$$none = nil;
        hash.$$proc = nil;

        return hash;
      }),
      ($Hash_allocate$2.$$arity = 0)
    );
    Opal.defs(
      self,
      "$try_convert",
      ($Hash_try_convert$3 = function $$try_convert(obj) {
        var self = this;

        return $$($nesting, "Opal")["$coerce_to?"](
          obj,
          $$($nesting, "Hash"),
          "to_hash"
        );
      }),
      ($Hash_try_convert$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$initialize",
      ($Hash_initialize$4 = function $$initialize(defaults) {
        var $iter = $Hash_initialize$4.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Hash_initialize$4.$$p = null;

        if ($iter) $Hash_initialize$4.$$p = null;
        if (defaults !== undefined && block !== nil) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "wrong number of arguments (1 for 0)"
          );
        }
        self.$$none = defaults === undefined ? nil : defaults;
        self.$$proc = block;

        return self;
      }),
      ($Hash_initialize$4.$$arity = -1)
    );

    Opal.def(
      self,
      "$==",
      ($Hash_$eq_eq$5 = function (other) {
        var self = this;

        if (self === other) {
          return true;
        }

        if (!other.$$is_hash) {
          return false;
        }

        if (self.$$keys.length !== other.$$keys.length) {
          return false;
        }

        for (
          var i = 0,
            keys = self.$$keys,
            length = keys.length,
            key,
            value,
            other_value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
            other_value = other.$$smap[key];
          } else {
            value = key.value;
            other_value = Opal.hash_get(other, key.key);
          }

          if (other_value === undefined || !value["$eql?"](other_value)) {
            return false;
          }
        }

        return true;
      }),
      ($Hash_$eq_eq$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$>=",
      ($Hash_$gt_eq$6 = function (other) {
        var $$7,
          self = this,
          result = nil;

        other = $$($nesting, "Opal")["$coerce_to!"](
          other,
          $$($nesting, "Hash"),
          "to_hash"
        );

        if (self.$$keys.length < other.$$keys.length) {
          return false;
        }
        result = true;
        $send(
          other,
          "each",
          [],
          (($$7 = function (other_key, other_val) {
            var self = $$7.$$s == null ? this : $$7.$$s,
              val = nil;

            if (other_key == null) {
              other_key = nil;
            }

            if (other_val == null) {
              other_val = nil;
            }
            val = self.$fetch(other_key, null);

            if (val == null || val !== other_val) {
              result = false;
              return;
            }
          }),
          ($$7.$$s = self),
          ($$7.$$arity = 2),
          $$7)
        );
        return result;
      }),
      ($Hash_$gt_eq$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$>",
      ($Hash_$gt$8 = function (other) {
        var self = this;

        other = $$($nesting, "Opal")["$coerce_to!"](
          other,
          $$($nesting, "Hash"),
          "to_hash"
        );

        if (self.$$keys.length <= other.$$keys.length) {
          return false;
        }
        return $rb_ge(self, other);
      }),
      ($Hash_$gt$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$<",
      ($Hash_$lt$9 = function (other) {
        var self = this;

        other = $$($nesting, "Opal")["$coerce_to!"](
          other,
          $$($nesting, "Hash"),
          "to_hash"
        );
        return $rb_gt(other, self);
      }),
      ($Hash_$lt$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=",
      ($Hash_$lt_eq$10 = function (other) {
        var self = this;

        other = $$($nesting, "Opal")["$coerce_to!"](
          other,
          $$($nesting, "Hash"),
          "to_hash"
        );
        return $rb_ge(other, self);
      }),
      ($Hash_$lt_eq$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$[]",
      ($Hash_$$$11 = function (key) {
        var self = this;

        var value = Opal.hash_get(self, key);

        if (value !== undefined) {
          return value;
        }

        return self.$default(key);
      }),
      ($Hash_$$$11.$$arity = 1)
    );

    Opal.def(
      self,
      "$[]=",
      ($Hash_$$$eq$12 = function (key, value) {
        var self = this;

        Opal.hash_put(self, key, value);
        return value;
      }),
      ($Hash_$$$eq$12.$$arity = 2)
    );

    Opal.def(
      self,
      "$assoc",
      ($Hash_assoc$13 = function $$assoc(object) {
        var self = this;

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            if (key["$=="](object)) {
              return [key, self.$$smap[key]];
            }
          } else {
            if (key.key["$=="](object)) {
              return [key.key, key.value];
            }
          }
        }

        return nil;
      }),
      ($Hash_assoc$13.$$arity = 1)
    );

    Opal.def(
      self,
      "$clear",
      ($Hash_clear$14 = function $$clear() {
        var self = this;

        Opal.hash_init(self);
        return self;
      }),
      ($Hash_clear$14.$$arity = 0)
    );

    Opal.def(
      self,
      "$clone",
      ($Hash_clone$15 = function $$clone() {
        var self = this;

        var hash = new self.$$class();

        Opal.hash_init(hash);
        Opal.hash_clone(self, hash);

        return hash;
      }),
      ($Hash_clone$15.$$arity = 0)
    );

    Opal.def(
      self,
      "$compact",
      ($Hash_compact$16 = function $$compact() {
        var self = this;

        var hash = Opal.hash();

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          if (value !== nil) {
            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }),
      ($Hash_compact$16.$$arity = 0)
    );

    Opal.def(
      self,
      "$compact!",
      ($Hash_compact$excl$17 = function () {
        var self = this;

        var changes_were_made = false;

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          if (value === nil) {
            if (Opal.hash_delete(self, key) !== undefined) {
              changes_were_made = true;
              length--;
              i--;
            }
          }
        }

        return changes_were_made ? self : nil;
      }),
      ($Hash_compact$excl$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$compare_by_identity",
      ($Hash_compare_by_identity$18 = function $$compare_by_identity() {
        var self = this;

        var i,
          ii,
          key,
          keys = self.$$keys,
          identity_hash;

        if (self.$$by_identity) return self;
        if (self.$$keys.length === 0) {
          self.$$by_identity = true;
          return self;
        }

        identity_hash = $hash2([], {}).$compare_by_identity();
        for (i = 0, ii = keys.length; i < ii; i++) {
          key = keys[i];
          if (!key.$$is_string) key = key.key;
          Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
        }

        self.$$by_identity = true;
        self.$$map = identity_hash.$$map;
        self.$$smap = identity_hash.$$smap;
        return self;
      }),
      ($Hash_compare_by_identity$18.$$arity = 0)
    );

    Opal.def(
      self,
      "$compare_by_identity?",
      ($Hash_compare_by_identity$ques$19 = function () {
        var self = this;

        return self.$$by_identity === true;
      }),
      ($Hash_compare_by_identity$ques$19.$$arity = 0)
    );

    Opal.def(
      self,
      "$default",
      ($Hash_default$20 = function (key) {
        var self = this;

        if (
          key !== undefined &&
          self.$$proc !== nil &&
          self.$$proc !== undefined
        ) {
          return self.$$proc.$call(self, key);
        }
        if (self.$$none === undefined) {
          return nil;
        }
        return self.$$none;
      }),
      ($Hash_default$20.$$arity = -1)
    );

    Opal.def(
      self,
      "$default=",
      ($Hash_default$eq$21 = function (object) {
        var self = this;

        self.$$proc = nil;
        self.$$none = object;

        return object;
      }),
      ($Hash_default$eq$21.$$arity = 1)
    );

    Opal.def(
      self,
      "$default_proc",
      ($Hash_default_proc$22 = function $$default_proc() {
        var self = this;

        if (self.$$proc !== undefined) {
          return self.$$proc;
        }
        return nil;
      }),
      ($Hash_default_proc$22.$$arity = 0)
    );

    Opal.def(
      self,
      "$default_proc=",
      ($Hash_default_proc$eq$23 = function (default_proc) {
        var self = this;

        var proc = default_proc;

        if (proc !== nil) {
          proc = $$($nesting, "Opal")["$coerce_to!"](
            proc,
            $$($nesting, "Proc"),
            "to_proc"
          );

          if (proc["$lambda?"]() && proc.$arity().$abs() !== 2) {
            self.$raise(
              $$($nesting, "TypeError"),
              "default_proc takes two arguments"
            );
          }
        }

        self.$$none = nil;
        self.$$proc = proc;

        return default_proc;
      }),
      ($Hash_default_proc$eq$23.$$arity = 1)
    );

    Opal.def(
      self,
      "$delete",
      ($Hash_delete$24 = function (key) {
        var $iter = $Hash_delete$24.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Hash_delete$24.$$p = null;

        if ($iter) $Hash_delete$24.$$p = null;

        var value = Opal.hash_delete(self, key);

        if (value !== undefined) {
          return value;
        }

        if (block !== nil) {
          return Opal.yield1(block, key);
        }

        return nil;
      }),
      ($Hash_delete$24.$$arity = 1)
    );

    Opal.def(
      self,
      "$delete_if",
      ($Hash_delete_if$25 = function $$delete_if() {
        var $iter = $Hash_delete_if$25.$$p,
          block = $iter || nil,
          $$26,
          self = this;

        if ($iter) $Hash_delete_if$25.$$p = null;

        if ($iter) $Hash_delete_if$25.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["delete_if"],
            (($$26 = function () {
              var self = $$26.$$s == null ? this : $$26.$$s;

              return self.$size();
            }),
            ($$26.$$s = self),
            ($$26.$$arity = 0),
            $$26)
          );
        }

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          obj = block(key, value);

          if (obj !== false && obj !== nil) {
            if (Opal.hash_delete(self, key) !== undefined) {
              length--;
              i--;
            }
          }
        }

        return self;
      }),
      ($Hash_delete_if$25.$$arity = 0)
    );
    $alias(self, "dup", "clone");

    Opal.def(
      self,
      "$dig",
      ($Hash_dig$27 = function $$dig(key, $a) {
        var $post_args,
          keys,
          self = this,
          item = nil;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        keys = $post_args;
        item = self["$[]"](key);

        if (item === nil || keys.length === 0) {
          return item;
        }
        if ($truthy(item["$respond_to?"]("dig"))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + item.$class() + " does not have #dig method"
          );
        }
        return $send(item, "dig", Opal.to_a(keys));
      }),
      ($Hash_dig$27.$$arity = -2)
    );

    Opal.def(
      self,
      "$each",
      ($Hash_each$28 = function $$each() {
        var $iter = $Hash_each$28.$$p,
          block = $iter || nil,
          $$29,
          self = this;

        if ($iter) $Hash_each$28.$$p = null;

        if ($iter) $Hash_each$28.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each"],
            (($$29 = function () {
              var self = $$29.$$s == null ? this : $$29.$$s;

              return self.$size();
            }),
            ($$29.$$s = self),
            ($$29.$$arity = 0),
            $$29)
          );
        }

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          Opal.yield1(block, [key, value]);
        }

        return self;
      }),
      ($Hash_each$28.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_key",
      ($Hash_each_key$30 = function $$each_key() {
        var $iter = $Hash_each_key$30.$$p,
          block = $iter || nil,
          $$31,
          self = this;

        if ($iter) $Hash_each_key$30.$$p = null;

        if ($iter) $Hash_each_key$30.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_key"],
            (($$31 = function () {
              var self = $$31.$$s == null ? this : $$31.$$s;

              return self.$size();
            }),
            ($$31.$$s = self),
            ($$31.$$arity = 0),
            $$31)
          );
        }

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key;
          i < length;
          i++
        ) {
          key = keys[i];

          block(key.$$is_string ? key : key.key);
        }

        return self;
      }),
      ($Hash_each_key$30.$$arity = 0)
    );
    $alias(self, "each_pair", "each");

    Opal.def(
      self,
      "$each_value",
      ($Hash_each_value$32 = function $$each_value() {
        var $iter = $Hash_each_value$32.$$p,
          block = $iter || nil,
          $$33,
          self = this;

        if ($iter) $Hash_each_value$32.$$p = null;

        if ($iter) $Hash_each_value$32.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_value"],
            (($$33 = function () {
              var self = $$33.$$s == null ? this : $$33.$$s;

              return self.$size();
            }),
            ($$33.$$s = self),
            ($$33.$$arity = 0),
            $$33)
          );
        }

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key;
          i < length;
          i++
        ) {
          key = keys[i];

          block(key.$$is_string ? self.$$smap[key] : key.value);
        }

        return self;
      }),
      ($Hash_each_value$32.$$arity = 0)
    );

    Opal.def(
      self,
      "$empty?",
      ($Hash_empty$ques$34 = function () {
        var self = this;

        return self.$$keys.length === 0;
      }),
      ($Hash_empty$ques$34.$$arity = 0)
    );
    $alias(self, "eql?", "==");

    Opal.def(
      self,
      "$except",
      ($Hash_except$35 = function $$except($a) {
        var $post_args,
          keys,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        keys = $post_args;
        return $send(self.$dup(), "except!", Opal.to_a(keys));
      }),
      ($Hash_except$35.$$arity = -1)
    );

    Opal.def(
      self,
      "$except!",
      ($Hash_except$excl$36 = function ($a) {
        var $post_args,
          keys,
          $$37,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        keys = $post_args;
        $send(
          keys,
          "each",
          [],
          (($$37 = function (key) {
            var self = $$37.$$s == null ? this : $$37.$$s;

            if (key == null) {
              key = nil;
            }
            return self.$delete(key);
          }),
          ($$37.$$s = self),
          ($$37.$$arity = 1),
          $$37)
        );
        return self;
      }),
      ($Hash_except$excl$36.$$arity = -1)
    );

    Opal.def(
      self,
      "$fetch",
      ($Hash_fetch$38 = function $$fetch(key, defaults) {
        var $iter = $Hash_fetch$38.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Hash_fetch$38.$$p = null;

        if ($iter) $Hash_fetch$38.$$p = null;
        var value = Opal.hash_get(self, key);

        if (value !== undefined) {
          return value;
        }

        if (block !== nil) {
          return block(key);
        }

        if (defaults !== undefined) {
          return defaults;
        }
        return self.$raise(
          $$($nesting, "KeyError").$new(
            "" + "key not found: " + key.$inspect(),
            $hash2(["key", "receiver"], { key: key, receiver: self })
          )
        );
      }),
      ($Hash_fetch$38.$$arity = -2)
    );

    Opal.def(
      self,
      "$fetch_values",
      ($Hash_fetch_values$39 = function $$fetch_values($a) {
        var $iter = $Hash_fetch_values$39.$$p,
          block = $iter || nil,
          $post_args,
          keys,
          $$40,
          self = this;

        if ($iter) $Hash_fetch_values$39.$$p = null;

        if ($iter) $Hash_fetch_values$39.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        keys = $post_args;
        return $send(
          keys,
          "map",
          [],
          (($$40 = function (key) {
            var self = $$40.$$s == null ? this : $$40.$$s;

            if (key == null) {
              key = nil;
            }
            return $send(self, "fetch", [key], block.$to_proc());
          }),
          ($$40.$$s = self),
          ($$40.$$arity = 1),
          $$40)
        );
      }),
      ($Hash_fetch_values$39.$$arity = -1)
    );

    Opal.def(
      self,
      "$flatten",
      ($Hash_flatten$41 = function $$flatten(level) {
        var self = this;

        if (level == null) {
          level = 1;
        }
        level = $$($nesting, "Opal")["$coerce_to!"](
          level,
          $$($nesting, "Integer"),
          "to_int"
        );

        var result = [];

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key);

          if (value.$$is_array) {
            if (level === 1) {
              result.push(value);
              continue;
            }

            result = result.concat(value.$flatten(level - 2));
            continue;
          }

          result.push(value);
        }

        return result;
      }),
      ($Hash_flatten$41.$$arity = -1)
    );

    Opal.def(
      self,
      "$has_key?",
      ($Hash_has_key$ques$42 = function (key) {
        var self = this;

        return Opal.hash_get(self, key) !== undefined;
      }),
      ($Hash_has_key$ques$42.$$arity = 1)
    );

    Opal.def(
      self,
      "$has_value?",
      ($Hash_has_value$ques$43 = function (value) {
        var self = this;

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key;
          i < length;
          i++
        ) {
          key = keys[i];

          if ((key.$$is_string ? self.$$smap[key] : key.value)["$=="](value)) {
            return true;
          }
        }

        return false;
      }),
      ($Hash_has_value$ques$43.$$arity = 1)
    );

    Opal.def(
      self,
      "$hash",
      ($Hash_hash$44 = function $$hash() {
        var self = this;

        var top = Opal.hash_ids === undefined,
          hash_id = self.$object_id(),
          result = ["Hash"],
          key,
          item;

        try {
          if (top) {
            Opal.hash_ids = Object.create(null);
          }

          if (Opal[hash_id]) {
            return "self";
          }

          for (key in Opal.hash_ids) {
            item = Opal.hash_ids[key];
            if (self["$eql?"](item)) {
              return "self";
            }
          }

          Opal.hash_ids[hash_id] = self;

          for (
            var i = 0, keys = self.$$keys, length = keys.length;
            i < length;
            i++
          ) {
            key = keys[i];

            if (key.$$is_string) {
              result.push([key, self.$$smap[key].$hash()]);
            } else {
              result.push([key.key_hash, key.value.$hash()]);
            }
          }

          return result.sort().join();
        } finally {
          if (top) {
            Opal.hash_ids = undefined;
          }
        }
      }),
      ($Hash_hash$44.$$arity = 0)
    );
    $alias(self, "include?", "has_key?");

    Opal.def(
      self,
      "$index",
      ($Hash_index$45 = function $$index(object) {
        var self = this;

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          if (value["$=="](object)) {
            return key;
          }
        }

        return nil;
      }),
      ($Hash_index$45.$$arity = 1)
    );

    Opal.def(
      self,
      "$indexes",
      ($Hash_indexes$46 = function $$indexes($a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        var result = [];

        for (var i = 0, length = args.length, key, value; i < length; i++) {
          key = args[i];
          value = Opal.hash_get(self, key);

          if (value === undefined) {
            result.push(self.$default());
            continue;
          }

          result.push(value);
        }

        return result;
      }),
      ($Hash_indexes$46.$$arity = -1)
    );
    $alias(self, "indices", "indexes");
    var inspect_ids;

    Opal.def(
      self,
      "$inspect",
      ($Hash_inspect$47 = function $$inspect() {
        var self = this;

        var top = inspect_ids === undefined,
          hash_id = self.$object_id(),
          result = [];

        try {
          if (top) {
            inspect_ids = {};
          }

          if (inspect_ids.hasOwnProperty(hash_id)) {
            return "{...}";
          }

          inspect_ids[hash_id] = true;

          for (
            var i = 0, keys = self.$$keys, length = keys.length, key, value;
            i < length;
            i++
          ) {
            key = keys[i];

            if (key.$$is_string) {
              value = self.$$smap[key];
            } else {
              value = key.value;
              key = key.key;
            }

            result.push(key.$inspect() + "=>" + value.$inspect());
          }

          return "{" + result.join(", ") + "}";
        } finally {
          if (top) {
            inspect_ids = undefined;
          }
        }
      }),
      ($Hash_inspect$47.$$arity = 0)
    );

    Opal.def(
      self,
      "$invert",
      ($Hash_invert$48 = function $$invert() {
        var self = this;

        var hash = Opal.hash();

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          Opal.hash_put(hash, value, key);
        }

        return hash;
      }),
      ($Hash_invert$48.$$arity = 0)
    );

    Opal.def(
      self,
      "$keep_if",
      ($Hash_keep_if$49 = function $$keep_if() {
        var $iter = $Hash_keep_if$49.$$p,
          block = $iter || nil,
          $$50,
          self = this;

        if ($iter) $Hash_keep_if$49.$$p = null;

        if ($iter) $Hash_keep_if$49.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["keep_if"],
            (($$50 = function () {
              var self = $$50.$$s == null ? this : $$50.$$s;

              return self.$size();
            }),
            ($$50.$$s = self),
            ($$50.$$arity = 0),
            $$50)
          );
        }

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          obj = block(key, value);

          if (obj === false || obj === nil) {
            if (Opal.hash_delete(self, key) !== undefined) {
              length--;
              i--;
            }
          }
        }

        return self;
      }),
      ($Hash_keep_if$49.$$arity = 0)
    );
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");

    Opal.def(
      self,
      "$keys",
      ($Hash_keys$51 = function $$keys() {
        var self = this;

        var result = [];

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            result.push(key);
          } else {
            result.push(key.key);
          }
        }

        return result;
      }),
      ($Hash_keys$51.$$arity = 0)
    );

    Opal.def(
      self,
      "$length",
      ($Hash_length$52 = function $$length() {
        var self = this;

        return self.$$keys.length;
      }),
      ($Hash_length$52.$$arity = 0)
    );
    $alias(self, "member?", "has_key?");

    Opal.def(
      self,
      "$merge",
      ($Hash_merge$53 = function $$merge($a) {
        var $iter = $Hash_merge$53.$$p,
          block = $iter || nil,
          $post_args,
          others,
          self = this;

        if ($iter) $Hash_merge$53.$$p = null;

        if ($iter) $Hash_merge$53.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        others = $post_args;
        return $send(
          self.$dup(),
          "merge!",
          Opal.to_a(others),
          block.$to_proc()
        );
      }),
      ($Hash_merge$53.$$arity = -1)
    );

    Opal.def(
      self,
      "$merge!",
      ($Hash_merge$excl$54 = function ($a) {
        var $iter = $Hash_merge$excl$54.$$p,
          block = $iter || nil,
          $post_args,
          others,
          self = this;

        if ($iter) $Hash_merge$excl$54.$$p = null;

        if ($iter) $Hash_merge$excl$54.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        others = $post_args;

        var i, j, other, other_keys, length, key, value, other_value;
        for (i = 0; i < others.length; ++i) {
          other = $$($nesting, "Opal")["$coerce_to!"](
            others[i],
            $$($nesting, "Hash"),
            "to_hash"
          );
          (other_keys = other.$$keys), (length = other_keys.length);

          if (block === nil) {
            for (j = 0; j < length; j++) {
              key = other_keys[j];

              if (key.$$is_string) {
                other_value = other.$$smap[key];
              } else {
                other_value = key.value;
                key = key.key;
              }

              Opal.hash_put(self, key, other_value);
            }
          } else {
            for (j = 0; j < length; j++) {
              key = other_keys[j];

              if (key.$$is_string) {
                other_value = other.$$smap[key];
              } else {
                other_value = key.value;
                key = key.key;
              }

              value = Opal.hash_get(self, key);

              if (value === undefined) {
                Opal.hash_put(self, key, other_value);
                continue;
              }

              Opal.hash_put(self, key, block(key, value, other_value));
            }
          }
        }

        return self;
      }),
      ($Hash_merge$excl$54.$$arity = -1)
    );

    Opal.def(
      self,
      "$rassoc",
      ($Hash_rassoc$55 = function $$rassoc(object) {
        var self = this;

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          if (value["$=="](object)) {
            return [key, value];
          }
        }

        return nil;
      }),
      ($Hash_rassoc$55.$$arity = 1)
    );

    Opal.def(
      self,
      "$rehash",
      ($Hash_rehash$56 = function $$rehash() {
        var self = this;

        Opal.hash_rehash(self);
        return self;
      }),
      ($Hash_rehash$56.$$arity = 0)
    );

    Opal.def(
      self,
      "$reject",
      ($Hash_reject$57 = function $$reject() {
        var $iter = $Hash_reject$57.$$p,
          block = $iter || nil,
          $$58,
          self = this;

        if ($iter) $Hash_reject$57.$$p = null;

        if ($iter) $Hash_reject$57.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["reject"],
            (($$58 = function () {
              var self = $$58.$$s == null ? this : $$58.$$s;

              return self.$size();
            }),
            ($$58.$$s = self),
            ($$58.$$arity = 0),
            $$58)
          );
        }

        var hash = Opal.hash();

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          obj = block(key, value);

          if (obj === false || obj === nil) {
            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }),
      ($Hash_reject$57.$$arity = 0)
    );

    Opal.def(
      self,
      "$reject!",
      ($Hash_reject$excl$59 = function () {
        var $iter = $Hash_reject$excl$59.$$p,
          block = $iter || nil,
          $$60,
          self = this;

        if ($iter) $Hash_reject$excl$59.$$p = null;

        if ($iter) $Hash_reject$excl$59.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["reject!"],
            (($$60 = function () {
              var self = $$60.$$s == null ? this : $$60.$$s;

              return self.$size();
            }),
            ($$60.$$s = self),
            ($$60.$$arity = 0),
            $$60)
          );
        }

        var changes_were_made = false;

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          obj = block(key, value);

          if (obj !== false && obj !== nil) {
            if (Opal.hash_delete(self, key) !== undefined) {
              changes_were_made = true;
              length--;
              i--;
            }
          }
        }

        return changes_were_made ? self : nil;
      }),
      ($Hash_reject$excl$59.$$arity = 0)
    );

    Opal.def(
      self,
      "$replace",
      ($Hash_replace$61 = function $$replace(other) {
        var self = this,
          $writer = nil;

        other = $$($nesting, "Opal")["$coerce_to!"](
          other,
          $$($nesting, "Hash"),
          "to_hash"
        );

        Opal.hash_init(self);

        for (
          var i = 0,
            other_keys = other.$$keys,
            length = other_keys.length,
            key,
            value,
            other_value;
          i < length;
          i++
        ) {
          key = other_keys[i];

          if (key.$$is_string) {
            other_value = other.$$smap[key];
          } else {
            other_value = key.value;
            key = key.key;
          }

          Opal.hash_put(self, key, other_value);
        }
        if ($truthy(other.$default_proc())) {
          $writer = [other.$default_proc()];
          $send(self, "default_proc=", Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        } else {
          $writer = [other.$default()];
          $send(self, "default=", Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        }
        return self;
      }),
      ($Hash_replace$61.$$arity = 1)
    );

    Opal.def(
      self,
      "$select",
      ($Hash_select$62 = function $$select() {
        var $iter = $Hash_select$62.$$p,
          block = $iter || nil,
          $$63,
          self = this;

        if ($iter) $Hash_select$62.$$p = null;

        if ($iter) $Hash_select$62.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["select"],
            (($$63 = function () {
              var self = $$63.$$s == null ? this : $$63.$$s;

              return self.$size();
            }),
            ($$63.$$s = self),
            ($$63.$$arity = 0),
            $$63)
          );
        }

        var hash = Opal.hash();

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          obj = block(key, value);

          if (obj !== false && obj !== nil) {
            Opal.hash_put(hash, key, value);
          }
        }

        return hash;
      }),
      ($Hash_select$62.$$arity = 0)
    );

    Opal.def(
      self,
      "$select!",
      ($Hash_select$excl$64 = function () {
        var $iter = $Hash_select$excl$64.$$p,
          block = $iter || nil,
          $$65,
          self = this;

        if ($iter) $Hash_select$excl$64.$$p = null;

        if ($iter) $Hash_select$excl$64.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["select!"],
            (($$65 = function () {
              var self = $$65.$$s == null ? this : $$65.$$s;

              return self.$size();
            }),
            ($$65.$$s = self),
            ($$65.$$arity = 0),
            $$65)
          );
        }

        var result = nil;

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value, obj;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          obj = block(key, value);

          if (obj === false || obj === nil) {
            if (Opal.hash_delete(self, key) !== undefined) {
              length--;
              i--;
            }
            result = self;
          }
        }

        return result;
      }),
      ($Hash_select$excl$64.$$arity = 0)
    );
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");

    Opal.def(
      self,
      "$shift",
      ($Hash_shift$66 = function $$shift() {
        var self = this;

        var keys = self.$$keys,
          key;

        if (keys.length > 0) {
          key = keys[0];

          key = key.$$is_string ? key : key.key;

          return [key, Opal.hash_delete(self, key)];
        }

        return self.$default(nil);
      }),
      ($Hash_shift$66.$$arity = 0)
    );
    $alias(self, "size", "length");

    Opal.def(
      self,
      "$slice",
      ($Hash_slice$67 = function $$slice($a) {
        var $post_args,
          keys,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        keys = $post_args;

        var result = Opal.hash();

        for (var i = 0, length = keys.length; i < length; i++) {
          var key = keys[i],
            value = Opal.hash_get(self, key);

          if (value !== undefined) {
            Opal.hash_put(result, key, value);
          }
        }

        return result;
      }),
      ($Hash_slice$67.$$arity = -1)
    );
    $alias(self, "store", "[]=");

    Opal.def(
      self,
      "$to_a",
      ($Hash_to_a$68 = function $$to_a() {
        var self = this;

        var result = [];

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push([key, value]);
        }

        return result;
      }),
      ($Hash_to_a$68.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_h",
      ($Hash_to_h$69 = function $$to_h() {
        var $iter = $Hash_to_h$69.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Hash_to_h$69.$$p = null;

        if ($iter) $Hash_to_h$69.$$p = null;
        if (block !== nil) {
          return $send(self, "map", [], block.$to_proc()).$to_h();
        }

        if (self.$$class === Opal.Hash) {
          return self;
        }

        var hash = new Opal.Hash();

        Opal.hash_init(hash);
        Opal.hash_clone(self, hash);

        return hash;
      }),
      ($Hash_to_h$69.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_hash",
      ($Hash_to_hash$70 = function $$to_hash() {
        var self = this;

        return self;
      }),
      ($Hash_to_hash$70.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_proc",
      ($Hash_to_proc$71 = function $$to_proc() {
        var $$72,
          self = this;

        return $send(
          self,
          "proc",
          [],
          (($$72 = function (key) {
            var self = $$72.$$s == null ? this : $$72.$$s;

            if (key == null) {
              self.$raise($$($nesting, "ArgumentError"), "no key given");
            }
            return self["$[]"](key);
          }),
          ($$72.$$s = self),
          ($$72.$$arity = -1),
          $$72)
        );
      }),
      ($Hash_to_proc$71.$$arity = 0)
    );
    $alias(self, "to_s", "inspect");

    Opal.def(
      self,
      "$transform_keys",
      ($Hash_transform_keys$73 = function $$transform_keys() {
        var $iter = $Hash_transform_keys$73.$$p,
          block = $iter || nil,
          $$74,
          self = this;

        if ($iter) $Hash_transform_keys$73.$$p = null;

        if ($iter) $Hash_transform_keys$73.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["transform_keys"],
            (($$74 = function () {
              var self = $$74.$$s == null ? this : $$74.$$s;

              return self.$size();
            }),
            ($$74.$$s = self),
            ($$74.$$arity = 0),
            $$74)
          );
        }

        var result = Opal.hash();

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          key = Opal.yield1(block, key);

          Opal.hash_put(result, key, value);
        }

        return result;
      }),
      ($Hash_transform_keys$73.$$arity = 0)
    );

    Opal.def(
      self,
      "$transform_keys!",
      ($Hash_transform_keys$excl$75 = function () {
        var $iter = $Hash_transform_keys$excl$75.$$p,
          block = $iter || nil,
          $$76,
          self = this;

        if ($iter) $Hash_transform_keys$excl$75.$$p = null;

        if ($iter) $Hash_transform_keys$excl$75.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["transform_keys!"],
            (($$76 = function () {
              var self = $$76.$$s == null ? this : $$76.$$s;

              return self.$size();
            }),
            ($$76.$$s = self),
            ($$76.$$arity = 0),
            $$76)
          );
        }

        var keys = Opal.slice.call(self.$$keys),
          i,
          length = keys.length,
          key,
          value,
          new_key;

        for (i = 0; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          new_key = Opal.yield1(block, key);

          Opal.hash_delete(self, key);
          Opal.hash_put(self, new_key, value);
        }

        return self;
      }),
      ($Hash_transform_keys$excl$75.$$arity = 0)
    );

    Opal.def(
      self,
      "$transform_values",
      ($Hash_transform_values$77 = function $$transform_values() {
        var $iter = $Hash_transform_values$77.$$p,
          block = $iter || nil,
          $$78,
          self = this;

        if ($iter) $Hash_transform_values$77.$$p = null;

        if ($iter) $Hash_transform_values$77.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["transform_values"],
            (($$78 = function () {
              var self = $$78.$$s == null ? this : $$78.$$s;

              return self.$size();
            }),
            ($$78.$$s = self),
            ($$78.$$arity = 0),
            $$78)
          );
        }

        var result = Opal.hash();

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          value = Opal.yield1(block, value);

          Opal.hash_put(result, key, value);
        }

        return result;
      }),
      ($Hash_transform_values$77.$$arity = 0)
    );

    Opal.def(
      self,
      "$transform_values!",
      ($Hash_transform_values$excl$79 = function () {
        var $iter = $Hash_transform_values$excl$79.$$p,
          block = $iter || nil,
          $$80,
          self = this;

        if ($iter) $Hash_transform_values$excl$79.$$p = null;

        if ($iter) $Hash_transform_values$excl$79.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["transform_values!"],
            (($$80 = function () {
              var self = $$80.$$s == null ? this : $$80.$$s;

              return self.$size();
            }),
            ($$80.$$s = self),
            ($$80.$$arity = 0),
            $$80)
          );
        }

        for (
          var i = 0, keys = self.$$keys, length = keys.length, key, value;
          i < length;
          i++
        ) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          value = Opal.yield1(block, value);

          Opal.hash_put(self, key, value);
        }

        return self;
      }),
      ($Hash_transform_values$excl$79.$$arity = 0)
    );
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    $alias(self, "values_at", "indexes");
    return (
      (Opal.def(
        self,
        "$values",
        ($Hash_values$81 = function $$values() {
          var self = this;

          var result = [];

          for (
            var i = 0, keys = self.$$keys, length = keys.length, key;
            i < length;
            i++
          ) {
            key = keys[i];

            if (key.$$is_string) {
              result.push(self.$$smap[key]);
            } else {
              result.push(key.value);
            }
          }

          return result;
        }),
        ($Hash_values$81.$$arity = 0)
      ),
      nil) && "values"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/number"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  function $rb_le(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs <= rhs
      : lhs["$<="](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $truthy = Opal.truthy,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $send = Opal.send;

  Opal.add_stubs([
    "$require",
    "$bridge",
    "$raise",
    "$name",
    "$class",
    "$Float",
    "$respond_to?",
    "$coerce_to!",
    "$__coerced__",
    "$===",
    "$!",
    "$>",
    "$**",
    "$new",
    "$<",
    "$to_f",
    "$==",
    "$nan?",
    "$infinite?",
    "$enum_for",
    "$+",
    "$-",
    "$gcd",
    "$lcm",
    "$%",
    "$/",
    "$frexp",
    "$to_i",
    "$ldexp",
    "$rationalize",
    "$*",
    "$<<",
    "$to_r",
    "$truncate",
    "$-@",
    "$size",
    "$<=",
    "$>=",
    "$inspect",
  ]);

  self.$require("corelib/numeric");
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Number");

    var $nesting = [self].concat($parent_nesting),
      $Number_coerce$2,
      $Number___id__$3,
      $Number_$plus$4,
      $Number_$minus$5,
      $Number_$$6,
      $Number_$slash$7,
      $Number_$percent$8,
      $Number_$$9,
      $Number_$$10,
      $Number_$$11,
      $Number_$lt$12,
      $Number_$lt_eq$13,
      $Number_$gt$14,
      $Number_$gt_eq$15,
      $Number_$lt_eq_gt$16,
      $Number_$lt$lt$17,
      $Number_$gt$gt$18,
      $Number_$$$19,
      $Number_$plus$$20,
      $Number_$minus$$21,
      $Number_$$22,
      $Number_$$$23,
      $Number_$eq_eq_eq$24,
      $Number_$eq_eq$25,
      $Number_abs$26,
      $Number_abs2$27,
      $Number_allbits$ques$28,
      $Number_anybits$ques$29,
      $Number_angle$30,
      $Number_bit_length$31,
      $Number_ceil$32,
      $Number_chr$33,
      $Number_denominator$34,
      $Number_downto$35,
      $Number_equal$ques$37,
      $Number_even$ques$38,
      $Number_floor$39,
      $Number_gcd$40,
      $Number_gcdlcm$41,
      $Number_integer$ques$42,
      $Number_is_a$ques$43,
      $Number_instance_of$ques$44,
      $Number_lcm$45,
      $Number_next$46,
      $Number_nobits$ques$47,
      $Number_nonzero$ques$48,
      $Number_numerator$49,
      $Number_odd$ques$50,
      $Number_ord$51,
      $Number_pow$52,
      $Number_pred$53,
      $Number_quo$54,
      $Number_rationalize$55,
      $Number_remainder$56,
      $Number_round$57,
      $Number_times$58,
      $Number_to_f$60,
      $Number_to_i$61,
      $Number_to_r$62,
      $Number_to_s$63,
      $Number_truncate$64,
      $Number_digits$65,
      $Number_divmod$66,
      $Number_upto$67,
      $Number_zero$ques$69,
      $Number_size$70,
      $Number_nan$ques$71,
      $Number_finite$ques$72,
      $Number_infinite$ques$73,
      $Number_positive$ques$74,
      $Number_negative$ques$75;

    $$($nesting, "Opal").$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, "$$is_number", true);
    self.$$is_number_class = true;
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $allocate$1;

      Opal.def(
        self,
        "$allocate",
        ($allocate$1 = function $$allocate() {
          var self = this;

          return self.$raise(
            $$($nesting, "TypeError"),
            "" + "allocator undefined for " + self.$name()
          );
        }),
        ($allocate$1.$$arity = 0)
      );

      Opal.udef(self, "$" + "new");
      return nil;
    })(Opal.get_singleton_class(self), $nesting);

    Opal.def(
      self,
      "$coerce",
      ($Number_coerce$2 = function $$coerce(other) {
        var self = this;

        if (other === nil) {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "can't convert " + other.$class() + " into Float"
          );
        } else if (other.$$is_string) {
          return [self.$Float(other), self];
        } else if (other["$respond_to?"]("to_f")) {
          return [
            $$($nesting, "Opal")["$coerce_to!"](
              other,
              $$($nesting, "Float"),
              "to_f"
            ),
            self,
          ];
        } else if (other.$$is_number) {
          return [other, self];
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "can't convert " + other.$class() + " into Float"
          );
        }
      }),
      ($Number_coerce$2.$$arity = 1)
    );

    Opal.def(
      self,
      "$__id__",
      ($Number___id__$3 = function $$__id__() {
        var self = this;

        return self * 2 + 1;
      }),
      ($Number___id__$3.$$arity = 0)
    );
    $alias(self, "object_id", "__id__");

    Opal.def(
      self,
      "$+",
      ($Number_$plus$4 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self + other;
        } else {
          return self.$__coerced__("+", other);
        }
      }),
      ($Number_$plus$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$-",
      ($Number_$minus$5 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self - other;
        } else {
          return self.$__coerced__("-", other);
        }
      }),
      ($Number_$minus$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$*",
      ($Number_$$6 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self * other;
        } else {
          return self.$__coerced__("*", other);
        }
      }),
      ($Number_$$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$/",
      ($Number_$slash$7 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self / other;
        } else {
          return self.$__coerced__("/", other);
        }
      }),
      ($Number_$slash$7.$$arity = 1)
    );
    $alias(self, "fdiv", "/");

    Opal.def(
      self,
      "$%",
      ($Number_$percent$8 = function (other) {
        var self = this;

        if (other.$$is_number) {
          if (other == -Infinity) {
            return other;
          } else if (other == 0) {
            self.$raise($$($nesting, "ZeroDivisionError"), "divided by 0");
          } else if (other < 0 || self < 0) {
            return ((self % other) + other) % other;
          } else {
            return self % other;
          }
        } else {
          return self.$__coerced__("%", other);
        }
      }),
      ($Number_$percent$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$&",
      ($Number_$$9 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self & other;
        } else {
          return self.$__coerced__("&", other);
        }
      }),
      ($Number_$$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$|",
      ($Number_$$10 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self | other;
        } else {
          return self.$__coerced__("|", other);
        }
      }),
      ($Number_$$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$^",
      ($Number_$$11 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self ^ other;
        } else {
          return self.$__coerced__("^", other);
        }
      }),
      ($Number_$$11.$$arity = 1)
    );

    Opal.def(
      self,
      "$<",
      ($Number_$lt$12 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self < other;
        } else {
          return self.$__coerced__("<", other);
        }
      }),
      ($Number_$lt$12.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=",
      ($Number_$lt_eq$13 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self <= other;
        } else {
          return self.$__coerced__("<=", other);
        }
      }),
      ($Number_$lt_eq$13.$$arity = 1)
    );

    Opal.def(
      self,
      "$>",
      ($Number_$gt$14 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self > other;
        } else {
          return self.$__coerced__(">", other);
        }
      }),
      ($Number_$gt$14.$$arity = 1)
    );

    Opal.def(
      self,
      "$>=",
      ($Number_$gt_eq$15 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self >= other;
        } else {
          return self.$__coerced__(">=", other);
        }
      }),
      ($Number_$gt_eq$15.$$arity = 1)
    );

    var spaceship_operator = function (self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      } else {
        return self.$__coerced__("<=>", other);
      }
    };
    Opal.def(
      self,
      "$<=>",
      ($Number_$lt_eq_gt$16 = function (other) {
        var self = this;

        try {
          return spaceship_operator(self, other);
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, "ArgumentError")])) {
            try {
              return nil;
            } finally {
              Opal.pop_exception();
            }
          } else {
            throw $err;
          }
        }
      }),
      ($Number_$lt_eq_gt$16.$$arity = 1)
    );

    Opal.def(
      self,
      "$<<",
      ($Number_$lt$lt$17 = function (count) {
        var self = this;

        count = $$($nesting, "Opal")["$coerce_to!"](
          count,
          $$($nesting, "Integer"),
          "to_int"
        );
        return count > 0 ? self << count : self >> -count;
      }),
      ($Number_$lt$lt$17.$$arity = 1)
    );

    Opal.def(
      self,
      "$>>",
      ($Number_$gt$gt$18 = function (count) {
        var self = this;

        count = $$($nesting, "Opal")["$coerce_to!"](
          count,
          $$($nesting, "Integer"),
          "to_int"
        );
        return count > 0 ? self >> count : self << -count;
      }),
      ($Number_$gt$gt$18.$$arity = 1)
    );

    Opal.def(
      self,
      "$[]",
      ($Number_$$$19 = function (bit) {
        var self = this;

        bit = $$($nesting, "Opal")["$coerce_to!"](
          bit,
          $$($nesting, "Integer"),
          "to_int"
        );

        if (bit < 0) {
          return 0;
        }
        if (bit >= 32) {
          return self < 0 ? 1 : 0;
        }
        return (self >> bit) & 1;
      }),
      ($Number_$$$19.$$arity = 1)
    );

    Opal.def(
      self,
      "$+@",
      ($Number_$plus$$20 = function () {
        var self = this;

        return +self;
      }),
      ($Number_$plus$$20.$$arity = 0)
    );

    Opal.def(
      self,
      "$-@",
      ($Number_$minus$$21 = function () {
        var self = this;

        return -self;
      }),
      ($Number_$minus$$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$~",
      ($Number_$$22 = function () {
        var self = this;

        return ~self;
      }),
      ($Number_$$22.$$arity = 0)
    );

    Opal.def(
      self,
      "$**",
      ($Number_$$$23 = function (other) {
        var self = this,
          $ret_or_1 = nil,
          $ret_or_2 = nil,
          $ret_or_3 = nil;

        if ($truthy($$($nesting, "Integer")["$==="](other))) {
          if (
            $truthy(
              (function () {
                if (
                  $truthy(
                    ($ret_or_1 = $$($nesting, "Integer")["$==="](self)["$!"]())
                  )
                ) {
                  return $ret_or_1;
                } else {
                  return $rb_gt(other, 0);
                }
                return nil;
              })()
            )
          ) {
            return Math.pow(self, other);
          } else {
            return $$($nesting, "Rational").$new(self, 1)["$**"](other);
          }
        } else if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_2 = $rb_lt(self, 0)))) {
                if (
                  $truthy(($ret_or_3 = $$($nesting, "Float")["$==="](other)))
                ) {
                  return $ret_or_3;
                } else {
                  return $$($nesting, "Rational")["$==="](other);
                }
              } else {
                return $ret_or_2;
              }
              return nil;
            })()
          )
        ) {
          return $$($nesting, "Complex").$new(self, 0)["$**"](other.$to_f());
        } else if ($truthy(other.$$is_number != null)) {
          return Math.pow(self, other);
        } else {
          return self.$__coerced__("**", other);
        }
      }),
      ($Number_$$$23.$$arity = 1)
    );

    Opal.def(
      self,
      "$===",
      ($Number_$eq_eq_eq$24 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self.valueOf() === other.valueOf();
        } else if (other["$respond_to?"]("==")) {
          return other["$=="](self);
        } else {
          return false;
        }
      }),
      ($Number_$eq_eq_eq$24.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($Number_$eq_eq$25 = function (other) {
        var self = this;

        if (other.$$is_number) {
          return self.valueOf() === other.valueOf();
        } else if (other["$respond_to?"]("==")) {
          return other["$=="](self);
        } else {
          return false;
        }
      }),
      ($Number_$eq_eq$25.$$arity = 1)
    );

    Opal.def(
      self,
      "$abs",
      ($Number_abs$26 = function $$abs() {
        var self = this;

        return Math.abs(self);
      }),
      ($Number_abs$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$abs2",
      ($Number_abs2$27 = function $$abs2() {
        var self = this;

        return Math.abs(self * self);
      }),
      ($Number_abs2$27.$$arity = 0)
    );

    Opal.def(
      self,
      "$allbits?",
      ($Number_allbits$ques$28 = function (mask) {
        var self = this;

        mask = $$($nesting, "Opal")["$coerce_to!"](
          mask,
          $$($nesting, "Integer"),
          "to_int"
        );
        return (self & mask) == mask;
      }),
      ($Number_allbits$ques$28.$$arity = 1)
    );

    Opal.def(
      self,
      "$anybits?",
      ($Number_anybits$ques$29 = function (mask) {
        var self = this;

        mask = $$($nesting, "Opal")["$coerce_to!"](
          mask,
          $$($nesting, "Integer"),
          "to_int"
        );
        return (self & mask) !== 0;
      }),
      ($Number_anybits$ques$29.$$arity = 1)
    );

    Opal.def(
      self,
      "$angle",
      ($Number_angle$30 = function $$angle() {
        var self = this;

        if ($truthy(self["$nan?"]())) {
          return self;
        }

        if (self == 0) {
          if (1 / self > 0) {
            return 0;
          } else {
            return Math.PI;
          }
        } else if (self < 0) {
          return Math.PI;
        } else {
          return 0;
        }
      }),
      ($Number_angle$30.$$arity = 0)
    );
    $alias(self, "arg", "angle");
    $alias(self, "phase", "angle");

    Opal.def(
      self,
      "$bit_length",
      ($Number_bit_length$31 = function $$bit_length() {
        var self = this;

        if ($truthy($$($nesting, "Integer")["$==="](self))) {
        } else {
          self.$raise(
            $$($nesting, "NoMethodError").$new(
              "" + "undefined method `bit_length` for " + self + ":Float",
              "bit_length"
            )
          );
        }

        if (self === 0 || self === -1) {
          return 0;
        }

        var result = 0,
          value = self < 0 ? ~self : self;

        while (value != 0) {
          result += 1;
          value >>>= 1;
        }

        return result;
      }),
      ($Number_bit_length$31.$$arity = 0)
    );

    Opal.def(
      self,
      "$ceil",
      ($Number_ceil$32 = function $$ceil(ndigits) {
        var self = this;

        if (ndigits == null) {
          ndigits = 0;
        }

        var f = self.$to_f();

        if (f % 1 === 0 && ndigits >= 0) {
          return f;
        }

        var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

        if (f % 1 === 0) {
          result = Math.round(result);
        }

        return result;
      }),
      ($Number_ceil$32.$$arity = -1)
    );

    Opal.def(
      self,
      "$chr",
      ($Number_chr$33 = function $$chr(encoding) {
        var self = this;

        return Opal.enc(String.fromCharCode(self), encoding || "BINARY");
      }),
      ($Number_chr$33.$$arity = -1)
    );

    Opal.def(
      self,
      "$denominator",
      ($Number_denominator$34 = function $$denominator() {
        var $iter = $Number_denominator$34.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_4 = nil;

        if ($iter) $Number_denominator$34.$$p = null;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_4 = self["$nan?"]()))) {
                return $ret_or_4;
              } else {
                return self["$infinite?"]();
              }
              return nil;
            })()
          )
        ) {
          return 1;
        } else {
          return $send2(
            self,
            $find_super(
              self,
              "denominator",
              $Number_denominator$34,
              false,
              true
            ),
            "denominator",
            [],
            $iter
          );
        }
      }),
      ($Number_denominator$34.$$arity = 0)
    );

    Opal.def(
      self,
      "$downto",
      ($Number_downto$35 = function $$downto(stop) {
        var $iter = $Number_downto$35.$$p,
          block = $iter || nil,
          $$36,
          self = this;

        if ($iter) $Number_downto$35.$$p = null;

        if ($iter) $Number_downto$35.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["downto", stop],
            (($$36 = function () {
              var self = $$36.$$s == null ? this : $$36.$$s;

              if ($truthy($$($nesting, "Numeric")["$==="](stop))) {
              } else {
                self.$raise(
                  $$($nesting, "ArgumentError"),
                  "" +
                    "comparison of " +
                    self.$class() +
                    " with " +
                    stop.$class() +
                    " failed"
                );
              }
              if ($truthy($rb_gt(stop, self))) {
                return 0;
              } else {
                return $rb_plus($rb_minus(self, stop), 1);
              }
            }),
            ($$36.$$s = self),
            ($$36.$$arity = 0),
            $$36)
          );
        }

        if (!stop.$$is_number) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" +
              "comparison of " +
              self.$class() +
              " with " +
              stop.$class() +
              " failed"
          );
        }
        for (var i = self; i >= stop; i--) {
          block(i);
        }
        return self;
      }),
      ($Number_downto$35.$$arity = 1)
    );
    $alias(self, "eql?", "==");

    Opal.def(
      self,
      "$equal?",
      ($Number_equal$ques$37 = function (other) {
        var self = this,
          $ret_or_5 = nil;

        if ($truthy(($ret_or_5 = self["$=="](other)))) {
          return $ret_or_5;
        } else {
          return isNaN(self) && isNaN(other);
        }
      }),
      ($Number_equal$ques$37.$$arity = 1)
    );

    Opal.def(
      self,
      "$even?",
      ($Number_even$ques$38 = function () {
        var self = this;

        return self % 2 === 0;
      }),
      ($Number_even$ques$38.$$arity = 0)
    );

    Opal.def(
      self,
      "$floor",
      ($Number_floor$39 = function $$floor(ndigits) {
        var self = this;

        if (ndigits == null) {
          ndigits = 0;
        }

        var f = self.$to_f();

        if (f % 1 === 0 && ndigits >= 0) {
          return f;
        }

        var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

        if (f % 1 === 0) {
          result = Math.round(result);
        }

        return result;
      }),
      ($Number_floor$39.$$arity = -1)
    );

    Opal.def(
      self,
      "$gcd",
      ($Number_gcd$40 = function $$gcd(other) {
        var self = this;

        if ($truthy($$($nesting, "Integer")["$==="](other))) {
        } else {
          self.$raise($$($nesting, "TypeError"), "not an integer");
        }

        var min = Math.abs(self),
          max = Math.abs(other);

        while (min > 0) {
          var tmp = min;

          min = max % min;
          max = tmp;
        }

        return max;
      }),
      ($Number_gcd$40.$$arity = 1)
    );

    Opal.def(
      self,
      "$gcdlcm",
      ($Number_gcdlcm$41 = function $$gcdlcm(other) {
        var self = this;

        return [self.$gcd(other), self.$lcm(other)];
      }),
      ($Number_gcdlcm$41.$$arity = 1)
    );

    Opal.def(
      self,
      "$integer?",
      ($Number_integer$ques$42 = function () {
        var self = this;

        return self % 1 === 0;
      }),
      ($Number_integer$ques$42.$$arity = 0)
    );

    Opal.def(
      self,
      "$is_a?",
      ($Number_is_a$ques$43 = function (klass) {
        var $iter = $Number_is_a$ques$43.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_6 = nil,
          $ret_or_7 = nil,
          $ret_or_8 = nil;

        if ($iter) $Number_is_a$ques$43.$$p = null;

        if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_6 = klass["$=="]($$($nesting, "Integer"))))
              ) {
                return $$($nesting, "Integer")["$==="](self);
              } else {
                return $ret_or_6;
              }
              return nil;
            })()
          )
        ) {
          return true;
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_7 = klass["$=="]($$($nesting, "Integer"))))
              ) {
                return $$($nesting, "Integer")["$==="](self);
              } else {
                return $ret_or_7;
              }
              return nil;
            })()
          )
        ) {
          return true;
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_8 = klass["$=="]($$($nesting, "Float"))))) {
                return $$($nesting, "Float")["$==="](self);
              } else {
                return $ret_or_8;
              }
              return nil;
            })()
          )
        ) {
          return true;
        }
        return $send2(
          self,
          $find_super(self, "is_a?", $Number_is_a$ques$43, false, true),
          "is_a?",
          [klass],
          $iter
        );
      }),
      ($Number_is_a$ques$43.$$arity = 1)
    );
    $alias(self, "kind_of?", "is_a?");

    Opal.def(
      self,
      "$instance_of?",
      ($Number_instance_of$ques$44 = function (klass) {
        var $iter = $Number_instance_of$ques$44.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_9 = nil,
          $ret_or_10 = nil,
          $ret_or_11 = nil;

        if ($iter) $Number_instance_of$ques$44.$$p = null;

        if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_9 = klass["$=="]($$($nesting, "Integer"))))
              ) {
                return $$($nesting, "Integer")["$==="](self);
              } else {
                return $ret_or_9;
              }
              return nil;
            })()
          )
        ) {
          return true;
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_10 = klass["$=="]($$($nesting, "Integer"))))
              ) {
                return $$($nesting, "Integer")["$==="](self);
              } else {
                return $ret_or_10;
              }
              return nil;
            })()
          )
        ) {
          return true;
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_11 = klass["$=="]($$($nesting, "Float"))))) {
                return $$($nesting, "Float")["$==="](self);
              } else {
                return $ret_or_11;
              }
              return nil;
            })()
          )
        ) {
          return true;
        }
        return $send2(
          self,
          $find_super(
            self,
            "instance_of?",
            $Number_instance_of$ques$44,
            false,
            true
          ),
          "instance_of?",
          [klass],
          $iter
        );
      }),
      ($Number_instance_of$ques$44.$$arity = 1)
    );

    Opal.def(
      self,
      "$lcm",
      ($Number_lcm$45 = function $$lcm(other) {
        var self = this;

        if ($truthy($$($nesting, "Integer")["$==="](other))) {
        } else {
          self.$raise($$($nesting, "TypeError"), "not an integer");
        }

        if (self == 0 || other == 0) {
          return 0;
        } else {
          return Math.abs((self * other) / self.$gcd(other));
        }
      }),
      ($Number_lcm$45.$$arity = 1)
    );
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");

    Opal.def(
      self,
      "$next",
      ($Number_next$46 = function $$next() {
        var self = this;

        return self + 1;
      }),
      ($Number_next$46.$$arity = 0)
    );

    Opal.def(
      self,
      "$nobits?",
      ($Number_nobits$ques$47 = function (mask) {
        var self = this;

        mask = $$($nesting, "Opal")["$coerce_to!"](
          mask,
          $$($nesting, "Integer"),
          "to_int"
        );
        return (self & mask) == 0;
      }),
      ($Number_nobits$ques$47.$$arity = 1)
    );

    Opal.def(
      self,
      "$nonzero?",
      ($Number_nonzero$ques$48 = function () {
        var self = this;

        return self == 0 ? nil : self;
      }),
      ($Number_nonzero$ques$48.$$arity = 0)
    );

    Opal.def(
      self,
      "$numerator",
      ($Number_numerator$49 = function $$numerator() {
        var $iter = $Number_numerator$49.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_12 = nil;

        if ($iter) $Number_numerator$49.$$p = null;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_12 = self["$nan?"]()))) {
                return $ret_or_12;
              } else {
                return self["$infinite?"]();
              }
              return nil;
            })()
          )
        ) {
          return self;
        } else {
          return $send2(
            self,
            $find_super(self, "numerator", $Number_numerator$49, false, true),
            "numerator",
            [],
            $iter
          );
        }
      }),
      ($Number_numerator$49.$$arity = 0)
    );

    Opal.def(
      self,
      "$odd?",
      ($Number_odd$ques$50 = function () {
        var self = this;

        return self % 2 !== 0;
      }),
      ($Number_odd$ques$50.$$arity = 0)
    );

    Opal.def(
      self,
      "$ord",
      ($Number_ord$51 = function $$ord() {
        var self = this;

        return self;
      }),
      ($Number_ord$51.$$arity = 0)
    );

    Opal.def(
      self,
      "$pow",
      ($Number_pow$52 = function $$pow(b, m) {
        var self = this;

        if (self == 0) {
          self.$raise($$($nesting, "ZeroDivisionError"), "divided by 0");
        }

        if (m === undefined) {
          return self["$**"](b);
        } else {
          if (!$$($nesting, "Integer")["$==="](b)) {
            self.$raise(
              $$($nesting, "TypeError"),
              "Integer#pow() 2nd argument not allowed unless a 1st argument is integer"
            );
          }

          if (b < 0) {
            self.$raise(
              $$($nesting, "TypeError"),
              "Integer#pow() 1st argument cannot be negative when 2nd argument specified"
            );
          }

          if (!$$($nesting, "Integer")["$==="](m)) {
            self.$raise(
              $$($nesting, "TypeError"),
              "Integer#pow() 2nd argument not allowed unless all arguments are integers"
            );
          }

          if (m === 0) {
            self.$raise($$($nesting, "ZeroDivisionError"), "divided by 0");
          }

          return self["$**"](b)["$%"](m);
        }
      }),
      ($Number_pow$52.$$arity = -2)
    );

    Opal.def(
      self,
      "$pred",
      ($Number_pred$53 = function $$pred() {
        var self = this;

        return self - 1;
      }),
      ($Number_pred$53.$$arity = 0)
    );

    Opal.def(
      self,
      "$quo",
      ($Number_quo$54 = function $$quo(other) {
        var $iter = $Number_quo$54.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Number_quo$54.$$p = null;
        if ($truthy($$($nesting, "Integer")["$==="](self))) {
          return $send2(
            self,
            $find_super(self, "quo", $Number_quo$54, false, true),
            "quo",
            [other],
            $iter
          );
        } else {
          return $rb_divide(self, other);
        }
      }),
      ($Number_quo$54.$$arity = 1)
    );

    Opal.def(
      self,
      "$rationalize",
      ($Number_rationalize$55 = function $$rationalize(eps) {
        var $a,
          $b,
          self = this,
          f = nil,
          n = nil;

        if (arguments.length > 1) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "wrong number of arguments (" + arguments.length + " for 0..1)"
          );
        }
        if ($truthy($$($nesting, "Integer")["$==="](self))) {
          return $$($nesting, "Rational").$new(self, 1);
        } else if ($truthy(self["$infinite?"]())) {
          return self.$raise($$($nesting, "FloatDomainError"), "Infinity");
        } else if ($truthy(self["$nan?"]())) {
          return self.$raise($$($nesting, "FloatDomainError"), "NaN");
        } else if ($truthy(eps == null)) {
          ($b = $$($nesting, "Math").$frexp(self)),
            ($a = Opal.to_ary($b)),
            (f = $a[0] == null ? nil : $a[0]),
            (n = $a[1] == null ? nil : $a[1]),
            $b;
          f = $$($nesting, "Math")
            .$ldexp(f, $$$($$($nesting, "Float"), "MANT_DIG"))
            .$to_i();
          n = $rb_minus(n, $$$($$($nesting, "Float"), "MANT_DIG"));
          return $$($nesting, "Rational")
            .$new($rb_times(2, f), (1)["$<<"]($rb_minus(1, n)))
            .$rationalize(
              $$($nesting, "Rational").$new(1, (1)["$<<"]($rb_minus(1, n)))
            );
        } else {
          return self.$to_r().$rationalize(eps);
        }
      }),
      ($Number_rationalize$55.$$arity = -1)
    );

    Opal.def(
      self,
      "$remainder",
      ($Number_remainder$56 = function $$remainder(y) {
        var self = this;

        return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()));
      }),
      ($Number_remainder$56.$$arity = 1)
    );

    Opal.def(
      self,
      "$round",
      ($Number_round$57 = function $$round(ndigits) {
        var $a,
          $b,
          self = this,
          $ret_or_13 = nil,
          $ret_or_14 = nil,
          $ret_or_15 = nil,
          _ = nil,
          exp = nil;

        if ($truthy($$($nesting, "Integer")["$==="](self))) {
          if ($truthy(ndigits == null)) {
            return self;
          }
          if (
            $truthy(
              (function () {
                if (
                  $truthy(($ret_or_13 = $$($nesting, "Float")["$==="](ndigits)))
                ) {
                  return ndigits["$infinite?"]();
                } else {
                  return $ret_or_13;
                }
                return nil;
              })()
            )
          ) {
            self.$raise($$($nesting, "RangeError"), "Infinity");
          }
          ndigits = $$($nesting, "Opal")["$coerce_to!"](
            ndigits,
            $$($nesting, "Integer"),
            "to_int"
          );
          if ($truthy($rb_lt(ndigits, $$$($$($nesting, "Integer"), "MIN")))) {
            self.$raise($$($nesting, "RangeError"), "out of bounds");
          }
          if ($truthy(ndigits >= 0)) {
            return self;
          }
          ndigits = ndigits["$-@"]();

          if (0.415241 * ndigits - 0.125 > self.$size()) {
            return 0;
          }

          var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

          return self < 0 ? -x : x;
        } else {
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_14 = self["$nan?"]()))) {
                  return ndigits == null;
                } else {
                  return $ret_or_14;
                }
                return nil;
              })()
            )
          ) {
            self.$raise($$($nesting, "FloatDomainError"), "NaN");
          }
          ndigits = $$($nesting, "Opal")["$coerce_to!"](
            ndigits || 0,
            $$($nesting, "Integer"),
            "to_int"
          );
          if ($truthy($rb_le(ndigits, 0))) {
            if ($truthy(self["$nan?"]())) {
              self.$raise($$($nesting, "RangeError"), "NaN");
            } else if ($truthy(self["$infinite?"]())) {
              self.$raise($$($nesting, "FloatDomainError"), "Infinity");
            }
          } else if (ndigits["$=="](0)) {
            return Math.round(self);
          } else if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_15 = self["$nan?"]()))) {
                  return $ret_or_15;
                } else {
                  return self["$infinite?"]();
                }
                return nil;
              })()
            )
          ) {
            return self;
          }
          ($b = $$($nesting, "Math").$frexp(self)),
            ($a = Opal.to_ary($b)),
            (_ = $a[0] == null ? nil : $a[0]),
            (exp = $a[1] == null ? nil : $a[1]),
            $b;
          if (
            $truthy(
              $rb_ge(
                ndigits,
                $rb_minus(
                  $rb_plus($$$($$($nesting, "Float"), "DIG"), 2),
                  (function () {
                    if ($truthy($rb_gt(exp, 0))) {
                      return $rb_divide(exp, 4);
                    } else {
                      return $rb_minus($rb_divide(exp, 3), 1);
                    }
                    return nil;
                  })()
                )
              )
            )
          ) {
            return self;
          }
          if (
            $truthy(
              $rb_lt(
                ndigits,
                (function () {
                  if ($truthy($rb_gt(exp, 0))) {
                    return $rb_plus($rb_divide(exp, 3), 1);
                  } else {
                    return $rb_divide(exp, 4);
                  }
                  return nil;
                })()["$-@"]()
              )
            )
          ) {
            return 0;
          }
          return (
            Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits)
          );
        }
      }),
      ($Number_round$57.$$arity = -1)
    );
    $alias(self, "succ", "next");

    Opal.def(
      self,
      "$times",
      ($Number_times$58 = function $$times() {
        var $iter = $Number_times$58.$$p,
          block = $iter || nil,
          $$59,
          self = this;

        if ($iter) $Number_times$58.$$p = null;

        if ($iter) $Number_times$58.$$p = null;
        if ($truthy(block)) {
        } else {
          return $send(
            self,
            "enum_for",
            ["times"],
            (($$59 = function () {
              var self = $$59.$$s == null ? this : $$59.$$s;

              return self;
            }),
            ($$59.$$s = self),
            ($$59.$$arity = 0),
            $$59)
          );
        }

        for (var i = 0; i < self; i++) {
          block(i);
        }
        return self;
      }),
      ($Number_times$58.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_f",
      ($Number_to_f$60 = function $$to_f() {
        var self = this;

        return self;
      }),
      ($Number_to_f$60.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_i",
      ($Number_to_i$61 = function $$to_i() {
        var self = this;

        return self < 0 ? Math.ceil(self) : Math.floor(self);
      }),
      ($Number_to_i$61.$$arity = 0)
    );
    $alias(self, "to_int", "to_i");

    Opal.def(
      self,
      "$to_r",
      ($Number_to_r$62 = function $$to_r() {
        var $a,
          $b,
          self = this,
          f = nil,
          e = nil;

        if ($truthy($$($nesting, "Integer")["$==="](self))) {
          return $$($nesting, "Rational").$new(self, 1);
        } else {
          ($b = $$($nesting, "Math").$frexp(self)),
            ($a = Opal.to_ary($b)),
            (f = $a[0] == null ? nil : $a[0]),
            (e = $a[1] == null ? nil : $a[1]),
            $b;
          f = $$($nesting, "Math")
            .$ldexp(f, $$$($$($nesting, "Float"), "MANT_DIG"))
            .$to_i();
          e = $rb_minus(e, $$$($$($nesting, "Float"), "MANT_DIG"));
          return $rb_times(
            f,
            $$$($$($nesting, "Float"), "RADIX")["$**"](e)
          ).$to_r();
        }
      }),
      ($Number_to_r$62.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Number_to_s$63 = function $$to_s(base) {
        var self = this,
          $ret_or_16 = nil,
          $ret_or_17 = nil;

        if (base == null) {
          base = 10;
        }
        base = $$($nesting, "Opal")["$coerce_to!"](
          base,
          $$($nesting, "Integer"),
          "to_int"
        );
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_16 = $rb_lt(base, 2)))) {
                return $ret_or_16;
              } else {
                return $rb_gt(base, 36);
              }
              return nil;
            })()
          )
        ) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "invalid radix " + base
          );
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_17 = self["$=="](0)))) {
                return 1 / self === -Infinity;
              } else {
                return $ret_or_17;
              }
              return nil;
            })()
          )
        ) {
          return "-0.0";
        }
        return self.toString(base);
      }),
      ($Number_to_s$63.$$arity = -1)
    );

    Opal.def(
      self,
      "$truncate",
      ($Number_truncate$64 = function $$truncate(ndigits) {
        var self = this;

        if (ndigits == null) {
          ndigits = 0;
        }

        var f = self.$to_f();

        if (f % 1 === 0 && ndigits >= 0) {
          return f;
        }

        var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

        if (f % 1 === 0) {
          result = Math.round(result);
        }

        return result;
      }),
      ($Number_truncate$64.$$arity = -1)
    );
    $alias(self, "inspect", "to_s");

    Opal.def(
      self,
      "$digits",
      ($Number_digits$65 = function $$digits(base) {
        var self = this;

        if (base == null) {
          base = 10;
        }
        if ($rb_lt(self, 0)) {
          self.$raise(
            $$$($$($nesting, "Math"), "DomainError"),
            "out of domain"
          );
        }
        base = $$($nesting, "Opal")["$coerce_to!"](
          base,
          $$($nesting, "Integer"),
          "to_int"
        );
        if ($truthy($rb_lt(base, 2))) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "invalid radix " + base
          );
        }

        if (self != parseInt(self))
          self.$raise(
            $$($nesting, "NoMethodError"),
            "" + "undefined method `digits' for " + self.$inspect()
          );

        var value = self,
          result = [];

        if (self == 0) {
          return [0];
        }

        while (value != 0) {
          result.push(value % base);
          value = parseInt(value / base, 10);
        }

        return result;
      }),
      ($Number_digits$65.$$arity = -1)
    );

    Opal.def(
      self,
      "$divmod",
      ($Number_divmod$66 = function $$divmod(other) {
        var $iter = $Number_divmod$66.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_18 = nil;

        if ($iter) $Number_divmod$66.$$p = null;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_18 = self["$nan?"]()))) {
                return $ret_or_18;
              } else {
                return other["$nan?"]();
              }
              return nil;
            })()
          )
        ) {
          return self.$raise($$($nesting, "FloatDomainError"), "NaN");
        } else if ($truthy(self["$infinite?"]())) {
          return self.$raise($$($nesting, "FloatDomainError"), "Infinity");
        } else {
          return $send2(
            self,
            $find_super(self, "divmod", $Number_divmod$66, false, true),
            "divmod",
            [other],
            $iter
          );
        }
      }),
      ($Number_divmod$66.$$arity = 1)
    );

    Opal.def(
      self,
      "$upto",
      ($Number_upto$67 = function $$upto(stop) {
        var $iter = $Number_upto$67.$$p,
          block = $iter || nil,
          $$68,
          self = this;

        if ($iter) $Number_upto$67.$$p = null;

        if ($iter) $Number_upto$67.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["upto", stop],
            (($$68 = function () {
              var self = $$68.$$s == null ? this : $$68.$$s;

              if ($truthy($$($nesting, "Numeric")["$==="](stop))) {
              } else {
                self.$raise(
                  $$($nesting, "ArgumentError"),
                  "" +
                    "comparison of " +
                    self.$class() +
                    " with " +
                    stop.$class() +
                    " failed"
                );
              }
              if ($truthy($rb_lt(stop, self))) {
                return 0;
              } else {
                return $rb_plus($rb_minus(stop, self), 1);
              }
            }),
            ($$68.$$s = self),
            ($$68.$$arity = 0),
            $$68)
          );
        }

        if (!stop.$$is_number) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" +
              "comparison of " +
              self.$class() +
              " with " +
              stop.$class() +
              " failed"
          );
        }
        for (var i = self; i <= stop; i++) {
          block(i);
        }
        return self;
      }),
      ($Number_upto$67.$$arity = 1)
    );

    Opal.def(
      self,
      "$zero?",
      ($Number_zero$ques$69 = function () {
        var self = this;

        return self == 0;
      }),
      ($Number_zero$ques$69.$$arity = 0)
    );

    Opal.def(
      self,
      "$size",
      ($Number_size$70 = function $$size() {
        var self = this;

        return 4;
      }),
      ($Number_size$70.$$arity = 0)
    );

    Opal.def(
      self,
      "$nan?",
      ($Number_nan$ques$71 = function () {
        var self = this;

        return isNaN(self);
      }),
      ($Number_nan$ques$71.$$arity = 0)
    );

    Opal.def(
      self,
      "$finite?",
      ($Number_finite$ques$72 = function () {
        var self = this;

        return self != Infinity && self != -Infinity && !isNaN(self);
      }),
      ($Number_finite$ques$72.$$arity = 0)
    );

    Opal.def(
      self,
      "$infinite?",
      ($Number_infinite$ques$73 = function () {
        var self = this;

        if (self == Infinity) {
          return +1;
        } else if (self == -Infinity) {
          return -1;
        } else {
          return nil;
        }
      }),
      ($Number_infinite$ques$73.$$arity = 0)
    );

    Opal.def(
      self,
      "$positive?",
      ($Number_positive$ques$74 = function () {
        var self = this;

        return self != 0 && (self == Infinity || 1 / self > 0);
      }),
      ($Number_positive$ques$74.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$negative?",
        ($Number_negative$ques$75 = function () {
          var self = this;

          return self == -Infinity || 1 / self < 0;
        }),
        ($Number_negative$ques$75.$$arity = 0)
      ),
      nil) && "negative?"
    );
  })($nesting[0], $$($nesting, "Numeric"), $nesting);
  Opal.const_set($nesting[0], "Fixnum", $$($nesting, "Number"));
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Integer");

    var $nesting = [self].concat($parent_nesting);

    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $allocate$76,
        $sqrt$77;

      Opal.def(
        self,
        "$allocate",
        ($allocate$76 = function $$allocate() {
          var self = this;

          return self.$raise(
            $$($nesting, "TypeError"),
            "" + "allocator undefined for " + self.$name()
          );
        }),
        ($allocate$76.$$arity = 0)
      );

      Opal.udef(self, "$" + "new");
      return (
        (Opal.def(
          self,
          "$sqrt",
          ($sqrt$77 = function $$sqrt(n) {
            var self = this;

            n = $$($nesting, "Opal")["$coerce_to!"](
              n,
              $$($nesting, "Integer"),
              "to_int"
            );

            if (n < 0) {
              self.$raise(
                $$$($$($nesting, "Math"), "DomainError"),
                'Numerical argument is out of domain - "isqrt"'
              );
            }

            return parseInt(Math.sqrt(n), 10);
          }),
          ($sqrt$77.$$arity = 1)
        ),
        nil) && "sqrt"
      );
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], "MAX", Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], "MIN", -Math.pow(2, 30));
  })($nesting[0], $$($nesting, "Numeric"), $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Float");

    var $nesting = [self].concat($parent_nesting);

    self.$$is_number_class = true;
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $allocate$78,
        $eq_eq_eq$79;

      Opal.def(
        self,
        "$allocate",
        ($allocate$78 = function $$allocate() {
          var self = this;

          return self.$raise(
            $$($nesting, "TypeError"),
            "" + "allocator undefined for " + self.$name()
          );
        }),
        ($allocate$78.$$arity = 0)
      );

      Opal.udef(self, "$" + "new");
      return (
        (Opal.def(
          self,
          "$===",
          ($eq_eq_eq$79 = function (other) {
            var self = this;

            return !!other.$$is_number;
          }),
          ($eq_eq_eq$79.$$arity = 1)
        ),
        nil) && "==="
      );
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], "INFINITY", Infinity);
    Opal.const_set($nesting[0], "MAX", Number.MAX_VALUE);
    Opal.const_set($nesting[0], "MIN", Number.MIN_VALUE);
    Opal.const_set($nesting[0], "NAN", NaN);
    Opal.const_set($nesting[0], "DIG", 15);
    Opal.const_set($nesting[0], "MANT_DIG", 53);
    Opal.const_set($nesting[0], "RADIX", 2);
    return Opal.const_set(
      $nesting[0],
      "EPSILON",
      Number.EPSILON || 2.2204460492503130808472633361816e-16
    );
  })($nesting[0], $$($nesting, "Numeric"), $nesting);
};

Opal.modules["corelib/range"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_le(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs <= rhs
      : lhs["$<="](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $send = Opal.send,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$require",
    "$include",
    "$attr_reader",
    "$raise",
    "$<=>",
    "$nil?",
    "$include?",
    "$!",
    "$<",
    "$<=",
    "$enum_for",
    "$size",
    "$upto",
    "$to_proc",
    "$respond_to?",
    "$class",
    "$succ",
    "$==",
    "$===",
    "$exclude_end?",
    "$eql?",
    "$begin",
    "$end",
    "$last",
    "$to_a",
    "$>",
    "$-@",
    "$-",
    "$to_i",
    "$coerce_to!",
    "$ceil",
    "$/",
    "$loop",
    "$+",
    "$*",
    "$>=",
    "$each_with_index",
    "$%",
    "$bsearch",
    "$inspect",
    "$[]",
    "$hash",
  ]);

  self.$require("corelib/enumerable");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Range");

    var $nesting = [self].concat($parent_nesting),
      $Range_initialize$1,
      $Range_$eq_eq_eq$2,
      $Range_count$3,
      $Range_to_a$4,
      $Range_cover$ques$5,
      $Range_each$6,
      $Range_eql$ques$8,
      $Range_exclude_end$ques$9,
      $Range_first$10,
      $Range_last$11,
      $Range_max$12,
      $Range_min$13,
      $Range_size$14,
      $Range_step$15,
      $Range_bsearch$19,
      $Range_to_s$20,
      $Range_inspect$21,
      $Range_marshal_load$22,
      $Range_hash$23;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;

    self.$include($$($nesting, "Enumerable"));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");

    Opal.def(
      self,
      "$initialize",
      ($Range_initialize$1 = function $$initialize(first, last, exclude) {
        var self = this,
          $ret_or_1 = nil,
          $ret_or_2 = nil;

        if (exclude == null) {
          exclude = false;
        }
        if ($truthy(self.begin)) {
          self.$raise($$($nesting, "NameError"), "'initialize' called twice");
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_1 = (function () {
                    if ($truthy(($ret_or_2 = first["$<=>"](last)))) {
                      return $ret_or_2;
                    } else {
                      return first["$nil?"]();
                    }
                    return nil;
                  })())
                )
              ) {
                return $ret_or_1;
              } else {
                return last["$nil?"]();
              }
              return nil;
            })()
          )
        ) {
        } else {
          self.$raise($$($nesting, "ArgumentError"), "bad value for range");
        }
        self.begin = first;
        self.end = last;
        return (self.excl = exclude);
      }),
      ($Range_initialize$1.$$arity = -3)
    );

    Opal.def(
      self,
      "$===",
      ($Range_$eq_eq_eq$2 = function (value) {
        var self = this;

        return self["$include?"](value);
      }),
      ($Range_$eq_eq_eq$2.$$arity = 1)
    );

    function is_infinite(self) {
      if (
        self.begin === nil ||
        self.end === nil ||
        self.begin === -Infinity ||
        self.end === Infinity ||
        self.begin === Infinity ||
        self.end === -Infinity
      )
        return true;
      return false;
    }
    Opal.def(
      self,
      "$count",
      ($Range_count$3 = function $$count() {
        var $iter = $Range_count$3.$$p,
          block = $iter || nil,
          self = this,
          $ret_or_3 = nil;

        if ($iter) $Range_count$3.$$p = null;

        if ($iter) $Range_count$3.$$p = null;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_3 = (block !== nil)["$!"]()))) {
                return is_infinite(self);
              } else {
                return $ret_or_3;
              }
              return nil;
            })()
          )
        ) {
          return $$$($$($nesting, "Float"), "INFINITY");
        }
        return $send2(
          self,
          $find_super(self, "count", $Range_count$3, false, true),
          "count",
          [],
          $iter
        );
      }),
      ($Range_count$3.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_a",
      ($Range_to_a$4 = function $$to_a() {
        var $iter = $Range_to_a$4.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Range_to_a$4.$$p = null;

        if ($truthy(is_infinite(self))) {
          self.$raise(
            $$($nesting, "TypeError"),
            "cannot convert endless range to an array"
          );
        }
        return $send2(
          self,
          $find_super(self, "to_a", $Range_to_a$4, false, true),
          "to_a",
          [],
          $iter
        );
      }),
      ($Range_to_a$4.$$arity = 0)
    );

    Opal.def(
      self,
      "$cover?",
      ($Range_cover$ques$5 = function (value) {
        var self = this,
          beg_cmp = nil,
          $ret_or_4 = nil,
          $ret_or_5 = nil,
          $ret_or_6 = nil,
          end_cmp = nil,
          $ret_or_7 = nil,
          $ret_or_8 = nil,
          $ret_or_9 = nil,
          $ret_or_10 = nil,
          $ret_or_11 = nil,
          $ret_or_12 = nil,
          $ret_or_13 = nil;

        beg_cmp = (function () {
          if (
            $truthy(
              ($ret_or_4 = (function () {
                if (
                  $truthy(
                    ($ret_or_5 = (function () {
                      if ($truthy(($ret_or_6 = self.begin["$nil?"]()))) {
                        return -1;
                      } else {
                        return $ret_or_6;
                      }
                      return nil;
                    })())
                  )
                ) {
                  return $ret_or_5;
                } else {
                  return self.begin["$<=>"](value);
                }
                return nil;
              })())
            )
          ) {
            return $ret_or_4;
          } else {
            return false;
          }
          return nil;
        })();
        end_cmp = (function () {
          if (
            $truthy(
              ($ret_or_7 = (function () {
                if (
                  $truthy(
                    ($ret_or_8 = (function () {
                      if ($truthy(($ret_or_9 = self.end["$nil?"]()))) {
                        return -1;
                      } else {
                        return $ret_or_9;
                      }
                      return nil;
                    })())
                  )
                ) {
                  return $ret_or_8;
                } else {
                  return value["$<=>"](self.end);
                }
                return nil;
              })())
            )
          ) {
            return $ret_or_7;
          } else {
            return false;
          }
          return nil;
        })();
        if (
          $truthy(
            ($ret_or_10 = (function () {
              if (
                $truthy(
                  ($ret_or_11 = (function () {
                    if ($truthy(self.excl)) {
                      if ($truthy(($ret_or_12 = end_cmp))) {
                        return $rb_lt(end_cmp, 0);
                      } else {
                        return $ret_or_12;
                      }
                    } else if ($truthy(($ret_or_13 = end_cmp))) {
                      return $rb_le(end_cmp, 0);
                    } else {
                      return $ret_or_13;
                    }
                    return nil;
                  })())
                )
              ) {
                return beg_cmp;
              } else {
                return $ret_or_11;
              }
              return nil;
            })())
          )
        ) {
          return $rb_le(beg_cmp, 0);
        } else {
          return $ret_or_10;
        }
      }),
      ($Range_cover$ques$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$each",
      ($Range_each$6 = function $$each() {
        var $iter = $Range_each$6.$$p,
          block = $iter || nil,
          $$7,
          $a,
          self = this,
          current = nil,
          last = nil,
          $ret_or_14 = nil,
          $ret_or_15 = nil;

        if ($iter) $Range_each$6.$$p = null;

        if ($iter) $Range_each$6.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each"],
            (($$7 = function () {
              var self = $$7.$$s == null ? this : $$7.$$s;

              return self.$size();
            }),
            ($$7.$$s = self),
            ($$7.$$arity = 0),
            $$7)
          );
        }

        var i, limit;

        if (self.begin.$$is_number && self.end.$$is_number) {
          if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
            self.$raise($$($nesting, "TypeError"), "can't iterate from Float");
          }

          for (
            i = self.begin,
              limit =
                self.end +
                (function () {
                  if ($truthy(self.excl)) {
                    return 0;
                  } else {
                    return 1;
                  }
                  return nil;
                })();
            i < limit;
            i++
          ) {
            block(i);
          }

          return self;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          $send(self.begin, "upto", [self.end, self.excl], block.$to_proc());
          return self;
        }
        current = self.begin;
        last = self.end;
        if ($truthy(current["$respond_to?"]("succ"))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "can't iterate from " + current.$class()
          );
        }
        while (
          $truthy(
            (function () {
              if ($truthy(($ret_or_14 = self.end["$nil?"]()))) {
                return $ret_or_14;
              } else {
                return $rb_lt(current["$<=>"](last), 0);
              }
              return nil;
            })()
          )
        ) {
          Opal.yield1(block, current);
          current = current.$succ();
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_15 = self.excl["$!"]()))) {
                return current["$=="](last);
              } else {
                return $ret_or_15;
              }
              return nil;
            })()
          )
        ) {
          Opal.yield1(block, current);
        }
        return self;
      }),
      ($Range_each$6.$$arity = 0)
    );

    Opal.def(
      self,
      "$eql?",
      ($Range_eql$ques$8 = function (other) {
        var self = this,
          $ret_or_16 = nil,
          $ret_or_17 = nil;

        if ($truthy($$($nesting, "Range")["$==="](other))) {
        } else {
          return false;
        }
        if (
          $truthy(
            ($ret_or_16 = (function () {
              if (
                $truthy(
                  ($ret_or_17 = self.excl["$==="](other["$exclude_end?"]()))
                )
              ) {
                return self.begin["$eql?"](other.$begin());
              } else {
                return $ret_or_17;
              }
              return nil;
            })())
          )
        ) {
          return self.end["$eql?"](other.$end());
        } else {
          return $ret_or_16;
        }
      }),
      ($Range_eql$ques$8.$$arity = 1)
    );
    $alias(self, "==", "eql?");

    Opal.def(
      self,
      "$exclude_end?",
      ($Range_exclude_end$ques$9 = function () {
        var self = this;

        return self.excl;
      }),
      ($Range_exclude_end$ques$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$first",
      ($Range_first$10 = function $$first(n) {
        var $iter = $Range_first$10.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Range_first$10.$$p = null;

        if ($truthy(self.begin["$nil?"]())) {
          self.$raise(
            $$($nesting, "RangeError"),
            "cannot get the minimum of beginless range"
          );
        }
        if ($truthy(n == null)) {
          return self.begin;
        }
        return $send2(
          self,
          $find_super(self, "first", $Range_first$10, false, true),
          "first",
          [n],
          $iter
        );
      }),
      ($Range_first$10.$$arity = -1)
    );
    $alias(self, "include?", "cover?");

    Opal.def(
      self,
      "$last",
      ($Range_last$11 = function $$last(n) {
        var self = this;

        if ($truthy(self.end["$nil?"]())) {
          self.$raise(
            $$($nesting, "RangeError"),
            "cannot get the maximum of endless range"
          );
        }
        if ($truthy(n == null)) {
          return self.end;
        }
        return self.$to_a().$last(n);
      }),
      ($Range_last$11.$$arity = -1)
    );

    Opal.def(
      self,
      "$max",
      ($Range_max$12 = function $$max() {
        var $iter = $Range_max$12.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_18 = nil,
          $ret_or_19 = nil,
          $ret_or_20 = nil;

        if ($iter) $Range_max$12.$$p = null;
        if ($truthy(self.end["$nil?"]())) {
          return self.$raise(
            $$($nesting, "RangeError"),
            "cannot get the maximum of endless range"
          );
        } else if ($yield !== nil) {
          return $send2(
            self,
            $find_super(self, "max", $Range_max$12, false, true),
            "max",
            [],
            $iter
          );
        } else if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_18 = self.begin["$nil?"]()["$!"]()))) {
                if ($truthy(($ret_or_19 = $rb_gt(self.begin, self.end)))) {
                  return $ret_or_19;
                } else if ($truthy(($ret_or_20 = self.excl))) {
                  return self.begin["$=="](self.end);
                } else {
                  return $ret_or_20;
                }
              } else {
                return $ret_or_18;
              }
              return nil;
            })()
          )
        ) {
          return nil;
        } else {
          return self.excl ? self.end - 1 : self.end;
        }
      }),
      ($Range_max$12.$$arity = 0)
    );
    $alias(self, "member?", "cover?");

    Opal.def(
      self,
      "$min",
      ($Range_min$13 = function $$min() {
        var $iter = $Range_min$13.$$p,
          $yield = $iter || nil,
          self = this,
          $ret_or_21 = nil,
          $ret_or_22 = nil,
          $ret_or_23 = nil;

        if ($iter) $Range_min$13.$$p = null;
        if ($truthy(self.begin["$nil?"]())) {
          return self.$raise(
            $$($nesting, "RangeError"),
            "cannot get the minimum of beginless range"
          );
        } else if ($yield !== nil) {
          return $send2(
            self,
            $find_super(self, "min", $Range_min$13, false, true),
            "min",
            [],
            $iter
          );
        } else if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_21 = self.end["$nil?"]()["$!"]()))) {
                if ($truthy(($ret_or_22 = $rb_gt(self.begin, self.end)))) {
                  return $ret_or_22;
                } else if ($truthy(($ret_or_23 = self.excl))) {
                  return self.begin["$=="](self.end);
                } else {
                  return $ret_or_23;
                }
              } else {
                return $ret_or_21;
              }
              return nil;
            })()
          )
        ) {
          return nil;
        } else {
          return self.begin;
        }
      }),
      ($Range_min$13.$$arity = 0)
    );

    Opal.def(
      self,
      "$size",
      ($Range_size$14 = function $$size() {
        var self = this,
          infinity = nil,
          $ret_or_24 = nil,
          $ret_or_25 = nil,
          $ret_or_26 = nil,
          $ret_or_27 = nil,
          range_begin = nil,
          range_end = nil;

        infinity = $$$($$($nesting, "Float"), "INFINITY");
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_24 = (function () {
                    if ($truthy(($ret_or_25 = self.begin["$=="](infinity)))) {
                      return self.end["$nil?"]()["$!"]();
                    } else {
                      return $ret_or_25;
                    }
                    return nil;
                  })())
                )
              ) {
                return $ret_or_24;
              } else {
                if (
                  $truthy(($ret_or_26 = self.end["$=="](infinity["$-@"]())))
                ) {
                  return self.begin["$nil?"]()["$!"]();
                } else {
                  return $ret_or_26;
                }
              }
              return nil;
            })()
          )
        ) {
          return 0;
        }
        if ($truthy(is_infinite(self))) {
          return infinity;
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_27 = $$($nesting, "Numeric")["$==="](self.begin))
                )
              ) {
                return $$($nesting, "Numeric")["$==="](self.end);
              } else {
                return $ret_or_27;
              }
              return nil;
            })()
          )
        ) {
        } else {
          return nil;
        }
        range_begin = self.begin;
        range_end = self.end;
        if ($truthy(self.excl)) {
          range_end = $rb_minus(range_end, 1);
        }
        if ($truthy($rb_lt(range_end, range_begin))) {
          return 0;
        }
        return (Math.abs(range_end - range_begin) + 1).$to_i();
      }),
      ($Range_size$14.$$arity = 0)
    );

    Opal.def(
      self,
      "$step",
      ($Range_step$15 = function $$step(n) {
        var $$16,
          $$17,
          $$18,
          $iter = $Range_step$15.$$p,
          $yield = $iter || nil,
          self = this,
          i = nil;

        if ($iter) $Range_step$15.$$p = null;

        if (n == null) {
          n = 1;
        }

        function coerceStepSize() {
          if (!n.$$is_number) {
            n = $$($nesting, "Opal")["$coerce_to!"](
              n,
              $$($nesting, "Integer"),
              "to_int"
            );
          }

          if (n < 0) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "step can't be negative"
            );
          } else if (n === 0) {
            self.$raise($$($nesting, "ArgumentError"), "step can't be 0");
          }
        }

        function enumeratorSize() {
          if (!self.begin["$respond_to?"]("succ")) {
            return nil;
          }

          if (self.begin.$$is_string && self.end.$$is_string) {
            return nil;
          }

          if (n % 1 === 0) {
            return $rb_divide(self.$size(), n).$ceil();
          } else {
            // n is a float
            var begin = self.begin,
              end = self.end,
              abs = Math.abs,
              floor = Math.floor,
              err =
                ((abs(begin) + abs(end) + abs(end - begin)) / abs(n)) *
                $$$($$($nesting, "Float"), "EPSILON"),
              size;

            if (err > 0.5) {
              err = 0.5;
            }

            if (self.excl) {
              size = floor((end - begin) / n - err);
              if (size * n + begin < end) {
                size++;
              }
            } else {
              size = floor((end - begin) / n + err) + 1;
            }

            return size;
          }
        }
        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["step", n],
            (($$16 = function () {
              var self = $$16.$$s == null ? this : $$16.$$s;

              coerceStepSize();
              return enumeratorSize();
            }),
            ($$16.$$s = self),
            ($$16.$$arity = 0),
            $$16)
          );
        }
        coerceStepSize();
        if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
          i = 0;
          (function () {
            var $brk = Opal.new_brk();
            try {
              return $send(
                self,
                "loop",
                [],
                (($$17 = function () {
                  var self = $$17.$$s == null ? this : $$17.$$s,
                    current = nil;
                  if (self.begin == null) self.begin = nil;
                  if (self.excl == null) self.excl = nil;
                  if (self.end == null) self.end = nil;

                  current = $rb_plus(self.begin, $rb_times(i, n));
                  if ($truthy(self.excl)) {
                    if ($truthy($rb_ge(current, self.end))) {
                      Opal.brk(nil, $brk);
                    }
                  } else if ($truthy($rb_gt(current, self.end))) {
                    Opal.brk(nil, $brk);
                  }
                  Opal.yield1($yield, current);
                  return (i = $rb_plus(i, 1));
                }),
                ($$17.$$s = self),
                ($$17.$$brk = $brk),
                ($$17.$$arity = 0),
                $$17)
              );
            } catch (err) {
              if (err === $brk) {
                return err.$v;
              } else {
                throw err;
              }
            }
          })();
        } else {
          if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
            self.$raise(
              $$($nesting, "TypeError"),
              "no implicit conversion to float from string"
            );
          }
          $send(
            self,
            "each_with_index",
            [],
            (($$18 = function (value, idx) {
              var self = $$18.$$s == null ? this : $$18.$$s;

              if (value == null) {
                value = nil;
              }

              if (idx == null) {
                idx = nil;
              }
              if (idx["$%"](n)["$=="](0)) {
                return Opal.yield1($yield, value);
              } else {
                return nil;
              }
            }),
            ($$18.$$s = self),
            ($$18.$$arity = 2),
            $$18)
          );
        }
        return self;
      }),
      ($Range_step$15.$$arity = -1)
    );

    Opal.def(
      self,
      "$bsearch",
      ($Range_bsearch$19 = function $$bsearch() {
        var $iter = $Range_bsearch$19.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Range_bsearch$19.$$p = null;

        if ($iter) $Range_bsearch$19.$$p = null;
        if (block !== nil) {
        } else {
          return self.$enum_for("bsearch");
        }
        if (
          $truthy(
            is_infinite(self) &&
              (self.begin.$$is_number || self.end.$$is_number)
          )
        ) {
          self.$raise(
            $$($nesting, "NotImplementedError"),
            "Can't #bsearch an infinite range"
          );
        }
        if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "can't do binary search for " + self.begin.$class()
          );
        }
        return $send(self.$to_a(), "bsearch", [], block.$to_proc());
      }),
      ($Range_bsearch$19.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Range_to_s$20 = function $$to_s() {
        var self = this,
          $ret_or_28 = nil,
          $ret_or_29 = nil;

        return (
          "" +
          (function () {
            if ($truthy(($ret_or_28 = self.begin))) {
              return $ret_or_28;
            } else {
              return "";
            }
            return nil;
          })() +
          (function () {
            if ($truthy(self.excl)) {
              return "...";
            } else {
              return "..";
            }
            return nil;
          })() +
          (function () {
            if ($truthy(($ret_or_29 = self.end))) {
              return $ret_or_29;
            } else {
              return "";
            }
            return nil;
          })()
        );
      }),
      ($Range_to_s$20.$$arity = 0)
    );

    Opal.def(
      self,
      "$inspect",
      ($Range_inspect$21 = function $$inspect() {
        var self = this,
          $ret_or_30 = nil,
          $ret_or_31 = nil;

        return (
          "" +
          (function () {
            if ($truthy(($ret_or_30 = self.begin))) {
              return self.begin.$inspect();
            } else {
              return $ret_or_30;
            }
            return nil;
          })() +
          (function () {
            if ($truthy(self.excl)) {
              return "...";
            } else {
              return "..";
            }
            return nil;
          })() +
          (function () {
            if ($truthy(($ret_or_31 = self.end))) {
              return self.end.$inspect();
            } else {
              return $ret_or_31;
            }
            return nil;
          })()
        );
      }),
      ($Range_inspect$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$marshal_load",
      ($Range_marshal_load$22 = function $$marshal_load(args) {
        var self = this;

        self.begin = args["$[]"]("begin");
        self.end = args["$[]"]("end");
        return (self.excl = args["$[]"]("excl"));
      }),
      ($Range_marshal_load$22.$$arity = 1)
    );
    return (
      (Opal.def(
        self,
        "$hash",
        ($Range_hash$23 = function $$hash() {
          var self = this;

          return [self.begin, self.end, self.excl].$hash();
        }),
        ($Range_hash$23.$$arity = 0)
      ),
      nil) && "hash"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/proc"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $slice = Opal.slice,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $alias = Opal.alias,
    $send = Opal.send;

  Opal.add_stubs([
    "$raise",
    "$proc",
    "$call",
    "$to_proc",
    "$new",
    "$source_location",
    "$coerce_to!",
  ]);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Proc");

    var $nesting = [self].concat($parent_nesting),
      $Proc_new$1,
      $Proc_call$2,
      $Proc_$gt$gt$3,
      $Proc_$lt$lt$5,
      $Proc_to_proc$7,
      $Proc_lambda$ques$8,
      $Proc_arity$9,
      $Proc_source_location$10,
      $Proc_binding$11,
      $Proc_parameters$12,
      $Proc_curry$13,
      $Proc_dup$14;

    Opal.defineProperty(self.$$prototype, "$$is_proc", true);
    Opal.defineProperty(self.$$prototype, "$$is_lambda", false);
    Opal.defs(
      self,
      "$new",
      ($Proc_new$1 = function () {
        var $iter = $Proc_new$1.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Proc_new$1.$$p = null;

        if ($iter) $Proc_new$1.$$p = null;
        if ($truthy(block)) {
        } else {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "tried to create a Proc object without a block"
          );
        }
        return block;
      }),
      ($Proc_new$1.$$arity = 0)
    );

    Opal.def(
      self,
      "$call",
      ($Proc_call$2 = function $$call($a) {
        var $iter = $Proc_call$2.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Proc_call$2.$$p = null;

        if ($iter) $Proc_call$2.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        if (block !== nil) {
          self.$$p = block;
        }

        var result,
          $brk = self.$$brk;

        if ($brk) {
          try {
            if (self.$$is_lambda) {
              result = self.apply(null, args);
            } else {
              result = Opal.yieldX(self, args);
            }
          } catch (err) {
            if (err === $brk) {
              return $brk.$v;
            } else {
              throw err;
            }
          }
        } else {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          } else {
            result = Opal.yieldX(self, args);
          }
        }

        return result;
      }),
      ($Proc_call$2.$$arity = -1)
    );
    $alias(self, "[]", "call");
    $alias(self, "===", "call");
    $alias(self, "yield", "call");

    Opal.def(
      self,
      "$>>",
      ($Proc_$gt$gt$3 = function (other) {
        var $$4,
          $iter = $Proc_$gt$gt$3.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Proc_$gt$gt$3.$$p = null;
        return $send(
          self,
          "proc",
          [],
          (($$4 = function ($a) {
            var self = $$4.$$s == null ? this : $$4.$$s,
              $iter = $$4.$$p,
              block = $iter || nil,
              $post_args,
              args,
              out = nil;

            if ($iter) $$4.$$p = null;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;
            out = $send(self, "call", Opal.to_a(args), block.$to_proc());
            return other.$call(out);
          }),
          ($$4.$$s = self),
          ($$4.$$arity = -1),
          $$4)
        );
      }),
      ($Proc_$gt$gt$3.$$arity = 1)
    );

    Opal.def(
      self,
      "$<<",
      ($Proc_$lt$lt$5 = function (other) {
        var $$6,
          $iter = $Proc_$lt$lt$5.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Proc_$lt$lt$5.$$p = null;
        return $send(
          self,
          "proc",
          [],
          (($$6 = function ($a) {
            var self = $$6.$$s == null ? this : $$6.$$s,
              $iter = $$6.$$p,
              block = $iter || nil,
              $post_args,
              args,
              out = nil;

            if ($iter) $$6.$$p = null;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;
            out = $send(other, "call", Opal.to_a(args), block.$to_proc());
            return self.$call(out);
          }),
          ($$6.$$s = self),
          ($$6.$$arity = -1),
          $$6)
        );
      }),
      ($Proc_$lt$lt$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$to_proc",
      ($Proc_to_proc$7 = function $$to_proc() {
        var self = this;

        return self;
      }),
      ($Proc_to_proc$7.$$arity = 0)
    );

    Opal.def(
      self,
      "$lambda?",
      ($Proc_lambda$ques$8 = function () {
        var self = this;

        return !!self.$$is_lambda;
      }),
      ($Proc_lambda$ques$8.$$arity = 0)
    );

    Opal.def(
      self,
      "$arity",
      ($Proc_arity$9 = function $$arity() {
        var self = this;

        if (self.$$is_curried) {
          return -1;
        } else {
          return self.$$arity;
        }
      }),
      ($Proc_arity$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$source_location",
      ($Proc_source_location$10 = function $$source_location() {
        var self = this;

        if (self.$$is_curried) {
          return nil;
        }
        return nil;
      }),
      ($Proc_source_location$10.$$arity = 0)
    );

    Opal.def(
      self,
      "$binding",
      ($Proc_binding$11 = function $$binding() {
        var $a,
          self = this;

        if (self.$$is_curried) {
          self.$raise($$($nesting, "ArgumentError"), "Can't create Binding");
        }
        if (
          $truthy(
            ($a = $$($nesting, "Binding", "skip_raise")) ? "constant" : nil
          )
        ) {
          return $$($nesting, "Binding").$new(
            nil,
            [],
            self.$$s,
            self.$source_location()
          );
        } else {
          return nil;
        }
      }),
      ($Proc_binding$11.$$arity = 0)
    );

    Opal.def(
      self,
      "$parameters",
      ($Proc_parameters$12 = function $$parameters() {
        var self = this;

        if (self.$$is_curried) {
          return [["rest"]];
        } else if (self.$$parameters) {
          if (self.$$is_lambda) {
            return self.$$parameters;
          } else {
            var result = [],
              i,
              length;

            for (i = 0, length = self.$$parameters.length; i < length; i++) {
              var parameter = self.$$parameters[i];

              if (parameter[0] === "req") {
                // required arguments always have name
                parameter = ["opt", parameter[1]];
              }

              result.push(parameter);
            }

            return result;
          }
        } else {
          return [];
        }
      }),
      ($Proc_parameters$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$curry",
      ($Proc_curry$13 = function $$curry(arity) {
        var self = this;

        if (arity === undefined) {
          arity = self.length;
        } else {
          arity = $$($nesting, "Opal")["$coerce_to!"](
            arity,
            $$($nesting, "Integer"),
            "to_int"
          );
          if (self.$$is_lambda && arity !== self.length) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" +
                "wrong number of arguments (" +
                arity +
                " for " +
                self.length +
                ")"
            );
          }
        }

        function curried() {
          var args = $slice.call(arguments),
            length = args.length,
            result;

          if (length > arity && self.$$is_lambda && !self.$$is_curried) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" +
                "wrong number of arguments (" +
                length +
                " for " +
                arity +
                ")"
            );
          }

          if (length >= arity) {
            return self.$call.apply(self, args);
          }

          result = function () {
            return curried.apply(null, args.concat($slice.call(arguments)));
          };
          result.$$is_lambda = self.$$is_lambda;
          result.$$is_curried = true;

          return result;
        }

        curried.$$is_lambda = self.$$is_lambda;
        curried.$$is_curried = true;
        return curried;
      }),
      ($Proc_curry$13.$$arity = -1)
    );

    Opal.def(
      self,
      "$dup",
      ($Proc_dup$14 = function $$dup() {
        var self = this;

        var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

        for (var prop in self) {
          if (self.hasOwnProperty(prop)) {
            proc[prop] = self[prop];
          }
        }

        return proc;
      }),
      ($Proc_dup$14.$$arity = 0)
    );
    return $alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting);
};

Opal.modules["corelib/method"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$attr_reader",
    "$arity",
    "$curry",
    "$>>",
    "$<<",
    "$new",
    "$class",
    "$join",
    "$source_location",
    "$raise",
  ]);

  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Method");

    var $nesting = [self].concat($parent_nesting),
      $Method_initialize$1,
      $Method_arity$2,
      $Method_parameters$3,
      $Method_source_location$4,
      $Method_comments$5,
      $Method_call$6,
      $Method_curry$7,
      $Method_$gt$gt$8,
      $Method_$lt$lt$9,
      $Method_unbind$10,
      $Method_to_proc$11,
      $Method_inspect$12;

    self.$$prototype.method =
      self.$$prototype.receiver =
      self.$$prototype.owner =
      self.$$prototype.name =
        nil;

    self.$attr_reader("owner", "receiver", "name");

    Opal.def(
      self,
      "$initialize",
      ($Method_initialize$1 = function $$initialize(
        receiver,
        owner,
        method,
        name
      ) {
        var self = this;

        self.receiver = receiver;
        self.owner = owner;
        self.name = name;
        return (self.method = method);
      }),
      ($Method_initialize$1.$$arity = 4)
    );

    Opal.def(
      self,
      "$arity",
      ($Method_arity$2 = function $$arity() {
        var self = this;

        return self.method.$arity();
      }),
      ($Method_arity$2.$$arity = 0)
    );

    Opal.def(
      self,
      "$parameters",
      ($Method_parameters$3 = function $$parameters() {
        var self = this;

        return self.method.$$parameters;
      }),
      ($Method_parameters$3.$$arity = 0)
    );

    Opal.def(
      self,
      "$source_location",
      ($Method_source_location$4 = function $$source_location() {
        var self = this,
          $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.method.$$source_location))) {
          return $ret_or_1;
        } else {
          return ["(eval)", 0];
        }
      }),
      ($Method_source_location$4.$$arity = 0)
    );

    Opal.def(
      self,
      "$comments",
      ($Method_comments$5 = function $$comments() {
        var self = this,
          $ret_or_2 = nil;

        if ($truthy(($ret_or_2 = self.method.$$comments))) {
          return $ret_or_2;
        } else {
          return [];
        }
      }),
      ($Method_comments$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$call",
      ($Method_call$6 = function $$call($a) {
        var $iter = $Method_call$6.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Method_call$6.$$p = null;

        if ($iter) $Method_call$6.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        self.method.$$p = block;

        return self.method.apply(self.receiver, args);
      }),
      ($Method_call$6.$$arity = -1)
    );

    Opal.def(
      self,
      "$curry",
      ($Method_curry$7 = function $$curry(arity) {
        var self = this;

        return self.method.$curry(arity);
      }),
      ($Method_curry$7.$$arity = -1)
    );
    $alias(self, "[]", "call");
    $alias(self, "===", "call");

    Opal.def(
      self,
      "$>>",
      ($Method_$gt$gt$8 = function (other) {
        var self = this;

        return self.method["$>>"](other);
      }),
      ($Method_$gt$gt$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$<<",
      ($Method_$lt$lt$9 = function (other) {
        var self = this;

        return self.method["$<<"](other);
      }),
      ($Method_$lt$lt$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$unbind",
      ($Method_unbind$10 = function $$unbind() {
        var self = this;

        return $$($nesting, "UnboundMethod").$new(
          self.receiver.$class(),
          self.owner,
          self.method,
          self.name
        );
      }),
      ($Method_unbind$10.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_proc",
      ($Method_to_proc$11 = function $$to_proc() {
        var self = this;

        var proc = self.$call.bind(self);
        proc.$$unbound = self.method;
        proc.$$is_lambda = true;
        proc.$$arity = self.method.$$arity;
        proc.$$parameters = self.method.$$parameters;
        return proc;
      }),
      ($Method_to_proc$11.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$inspect",
        ($Method_inspect$12 = function $$inspect() {
          var self = this;

          return (
            "" +
            "#<" +
            self.$class() +
            ": " +
            self.receiver.$class() +
            "#" +
            self.name +
            " (defined in " +
            self.owner +
            " in " +
            self.$source_location().$join(":") +
            ")>"
          );
        }),
        ($Method_inspect$12.$$arity = 0)
      ),
      nil) && "inspect"
    );
  })($nesting[0], null, $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "UnboundMethod");

    var $nesting = [self].concat($parent_nesting),
      $UnboundMethod_initialize$13,
      $UnboundMethod_arity$14,
      $UnboundMethod_parameters$15,
      $UnboundMethod_source_location$16,
      $UnboundMethod_comments$17,
      $UnboundMethod_bind$18,
      $UnboundMethod_inspect$19;

    self.$$prototype.method =
      self.$$prototype.owner =
      self.$$prototype.name =
      self.$$prototype.source =
        nil;

    self.$attr_reader("source", "owner", "name");

    Opal.def(
      self,
      "$initialize",
      ($UnboundMethod_initialize$13 = function $$initialize(
        source,
        owner,
        method,
        name
      ) {
        var self = this;

        self.source = source;
        self.owner = owner;
        self.method = method;
        return (self.name = name);
      }),
      ($UnboundMethod_initialize$13.$$arity = 4)
    );

    Opal.def(
      self,
      "$arity",
      ($UnboundMethod_arity$14 = function $$arity() {
        var self = this;

        return self.method.$arity();
      }),
      ($UnboundMethod_arity$14.$$arity = 0)
    );

    Opal.def(
      self,
      "$parameters",
      ($UnboundMethod_parameters$15 = function $$parameters() {
        var self = this;

        return self.method.$$parameters;
      }),
      ($UnboundMethod_parameters$15.$$arity = 0)
    );

    Opal.def(
      self,
      "$source_location",
      ($UnboundMethod_source_location$16 = function $$source_location() {
        var self = this,
          $ret_or_3 = nil;

        if ($truthy(($ret_or_3 = self.method.$$source_location))) {
          return $ret_or_3;
        } else {
          return ["(eval)", 0];
        }
      }),
      ($UnboundMethod_source_location$16.$$arity = 0)
    );

    Opal.def(
      self,
      "$comments",
      ($UnboundMethod_comments$17 = function $$comments() {
        var self = this,
          $ret_or_4 = nil;

        if ($truthy(($ret_or_4 = self.method.$$comments))) {
          return $ret_or_4;
        } else {
          return [];
        }
      }),
      ($UnboundMethod_comments$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$bind",
      ($UnboundMethod_bind$18 = function $$bind(object) {
        var self = this;

        if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
          return $$($nesting, "Method").$new(
            object,
            self.owner,
            self.method,
            self.name
          );
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" +
              "can't bind singleton method to a different class (expected " +
              object +
              ".kind_of?(" +
              self.owner +
              " to be true)"
          );
        }
      }),
      ($UnboundMethod_bind$18.$$arity = 1)
    );
    return (
      (Opal.def(
        self,
        "$inspect",
        ($UnboundMethod_inspect$19 = function $$inspect() {
          var self = this;

          return (
            "" +
            "#<" +
            self.$class() +
            ": " +
            self.source +
            "#" +
            self.name +
            " (defined in " +
            self.owner +
            " in " +
            self.$source_location().$join(":") +
            ")>"
          );
        }),
        ($UnboundMethod_inspect$19.$$arity = 0)
      ),
      nil) && "inspect"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/variables"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $gvars = Opal.gvars,
    $hash2 = Opal.hash2;

  Opal.add_stubs(["$new"]);

  $gvars["&"] = $gvars["~"] = $gvars["`"] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = $gvars['"'] = Opal.loaded_features;
  $gvars.LOAD_PATH = $gvars[":"] = [];
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], "ARGV", []);
  Opal.const_set($nesting[0], "ARGF", $$($nesting, "Object").$new());
  Opal.const_set($nesting[0], "ENV", $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

Opal.modules["corelib/io"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $alias = Opal.alias,
    $gvars = Opal.gvars,
    $range = Opal.range,
    $send = Opal.send,
    $hash2 = Opal.hash2,
    $writer = nil;

  Opal.add_stubs([
    "$include?",
    "$!",
    "$match?",
    "$attr_accessor",
    "$size",
    "$attr_reader",
    "$write",
    "$String",
    "$chomp",
    "$sysread_noraise",
    "$+",
    "$!=",
    "$[]",
    "$ord",
    "$getc",
    "$readchar",
    "$raise",
    "$gets",
    "$==",
    "$to_str",
    "$split",
    "$length",
    "$sub",
    "$sysread",
    "$>",
    "$to_a",
    "$each_line",
    "$enum_for",
    "$getbyte",
    "$closed_write?",
    "$closed_read?",
    "$new",
    "$write_proc=",
    "$-",
    "$read_proc=",
  ]);

  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "IO");

    var $nesting = [self].concat($parent_nesting),
      $IO_initialize$1,
      $IO_fileno$2,
      $IO_tty$ques$3,
      $IO_write$4,
      $IO_flush$5,
      $IO_$lt$lt$6,
      $IO_print$7,
      $IO_puts$8,
      $IO_getc$9,
      $IO_getbyte$10,
      $IO_readbyte$11,
      $IO_readchar$12,
      $IO_readline$13,
      $IO_gets$14,
      $IO_sysread$15,
      $IO_sysread_noraise$16,
      $IO_readpartial$17,
      $IO_read$18,
      $IO_readlines$19,
      $IO_each$20,
      $IO_each_byte$21,
      $IO_each_char$22,
      $IO_close$23,
      $IO_close_read$24,
      $IO_close_write$25,
      $IO_closed$ques$26,
      $IO_closed_read$ques$27,
      $IO_closed_write$ques$28,
      $IO_check_writable$29,
      $IO_check_readable$30;

    self.$$prototype.fd =
      self.$$prototype.read_buffer =
      self.$$prototype.closed =
        nil;

    Opal.const_set($nesting[0], "SEEK_SET", 0);
    Opal.const_set($nesting[0], "SEEK_CUR", 1);
    Opal.const_set($nesting[0], "SEEK_END", 2);
    Opal.const_set($nesting[0], "SEEK_DATA", 3);
    Opal.const_set($nesting[0], "SEEK_HOLE", 4);
    Opal.const_set($nesting[0], "READABLE", 1);
    Opal.const_set($nesting[0], "WRITABLE", 4);

    Opal.def(
      self,
      "$initialize",
      ($IO_initialize$1 = function $$initialize(fd, flags) {
        var self = this,
          $ret_or_1 = nil,
          $ret_or_2 = nil;

        if (flags == null) {
          flags = "r";
        }
        self.fd = fd;
        self.flags = flags;
        self.eof = false;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_1 = flags["$include?"]("r")))) {
                return flags["$match?"](/[wa+]/)["$!"]();
              } else {
                return $ret_or_1;
              }
              return nil;
            })()
          )
        ) {
          return (self.closed = "write");
        } else if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_2 = flags["$match?"](/[wa]/)))) {
                return flags["$match?"](/[r+]/)["$!"]();
              } else {
                return $ret_or_2;
              }
              return nil;
            })()
          )
        ) {
          return (self.closed = "read");
        } else {
          return nil;
        }
      }),
      ($IO_initialize$1.$$arity = -2)
    );

    Opal.def(
      self,
      "$fileno",
      ($IO_fileno$2 = function $$fileno() {
        var self = this;

        return self.fd;
      }),
      ($IO_fileno$2.$$arity = 0)
    );

    Opal.def(
      self,
      "$tty?",
      ($IO_tty$ques$3 = function () {
        var self = this;

        return self.tty == true;
      }),
      ($IO_tty$ques$3.$$arity = 0)
    );
    self.$attr_accessor("write_proc");
    self.$attr_accessor("read_proc");

    Opal.def(
      self,
      "$write",
      ($IO_write$4 = function $$write(string) {
        var self = this;

        self.write_proc(string);
        return string.$size();
      }),
      ($IO_write$4.$$arity = 1)
    );
    self.$attr_accessor("sync", "tty");
    self.$attr_reader("eof");
    $alias(self, "eof?", "eof");

    Opal.def(
      self,
      "$flush",
      ($IO_flush$5 = function $$flush() {
        var self = this;

        return nil;
      }),
      ($IO_flush$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$<<",
      ($IO_$lt$lt$6 = function (string) {
        var self = this;

        self.$write(string);
        return self;
      }),
      ($IO_$lt$lt$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$print",
      ($IO_print$7 = function $$print($a) {
        var $post_args,
          args,
          self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i]);
        }
        self.$write(args.join($gvars[","]));
        return nil;
      }),
      ($IO_print$7.$$arity = -1)
    );

    Opal.def(
      self,
      "$puts",
      ($IO_puts$8 = function $$puts($a) {
        var $post_args,
          args,
          self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;

        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i]).$chomp();
        }
        self.$write(args.concat([nil]).join($gvars["/"]));
        return nil;
      }),
      ($IO_puts$8.$$arity = -1)
    );

    Opal.def(
      self,
      "$getc",
      ($IO_getc$9 = function $$getc() {
        var $a,
          self = this,
          $ret_or_3 = nil,
          parts = nil,
          ret = nil;

        self.read_buffer = (function () {
          if ($truthy(($ret_or_3 = self.read_buffer))) {
            return $ret_or_3;
          } else {
            return "";
          }
          return nil;
        })();
        parts = "";
        do {
          self.read_buffer = $rb_plus(self.read_buffer, parts);
          if ($truthy(self.read_buffer["$!="](""))) {
            ret = self.read_buffer["$[]"](0);
            self.read_buffer = self.read_buffer["$[]"]($range(1, -1, false));
            return ret;
          }
        } while ($truthy((parts = self.$sysread_noraise(1))));
        return nil;
      }),
      ($IO_getc$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$getbyte",
      ($IO_getbyte$10 = function $$getbyte() {
        var $a,
          self = this;

        return (
          ($a = self.$getc()),
          $a === nil || $a == null ? nil : $send($a, "ord", [])
        );
      }),
      ($IO_getbyte$10.$$arity = 0)
    );

    Opal.def(
      self,
      "$readbyte",
      ($IO_readbyte$11 = function $$readbyte() {
        var self = this;

        return self.$readchar().$ord();
      }),
      ($IO_readbyte$11.$$arity = 0)
    );

    Opal.def(
      self,
      "$readchar",
      ($IO_readchar$12 = function $$readchar() {
        var self = this,
          $ret_or_4 = nil;

        if ($truthy(($ret_or_4 = self.$getc()))) {
          return $ret_or_4;
        } else {
          return self.$raise($$($nesting, "EOFError"), "end of file reached");
        }
      }),
      ($IO_readchar$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$readline",
      ($IO_readline$13 = function $$readline($a) {
        var $post_args,
          args,
          self = this,
          $ret_or_5 = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if ($truthy(($ret_or_5 = $send(self, "gets", Opal.to_a(args))))) {
          return $ret_or_5;
        } else {
          return self.$raise($$($nesting, "EOFError"), "end of file reached");
        }
      }),
      ($IO_readline$13.$$arity = -1)
    );

    Opal.def(
      self,
      "$gets",
      ($IO_gets$14 = function $$gets(sep, limit, opts) {
        var $a,
          $b,
          $c,
          self = this,
          $ret_or_6 = nil,
          $ret_or_7 = nil,
          $ret_or_8 = nil,
          $ret_or_9 = nil,
          orig_sep = nil,
          $ret_or_10 = nil,
          seplen = nil,
          $ret_or_11 = nil,
          data = nil,
          ret = nil,
          $ret_or_12 = nil,
          orig_buffer = nil,
          $ret_or_13 = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        if (sep == null) {
          sep = false;
        }

        if (limit == null) {
          limit = nil;
        }

        if (opts == null) {
          opts = $hash2([], {});
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_6 = sep.$$is_number))) {
                return limit["$!"]();
              } else {
                return $ret_or_6;
              }
              return nil;
            })()
          )
        ) {
          ($a = [false, sep, limit]),
            (sep = $a[0]),
            (limit = $a[1]),
            (opts = $a[2]),
            $a;
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_7 = (function () {
                    if ($truthy(($ret_or_8 = sep.$$is_hash))) {
                      return limit["$!"]();
                    } else {
                      return $ret_or_8;
                    }
                    return nil;
                  })())
                )
              ) {
                return opts["$=="]($hash2([], {}));
              } else {
                return $ret_or_7;
              }
              return nil;
            })()
          )
        ) {
          ($a = [false, nil, sep]),
            (sep = $a[0]),
            (limit = $a[1]),
            (opts = $a[2]),
            $a;
        } else if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_9 = limit.$$is_hash))) {
                return opts["$=="]($hash2([], {}));
              } else {
                return $ret_or_9;
              }
              return nil;
            })()
          )
        ) {
          ($a = [sep, nil, limit]),
            (sep = $a[0]),
            (limit = $a[1]),
            (opts = $a[2]),
            $a;
        }
        orig_sep = sep;
        if (sep["$=="](false)) {
          sep = $gvars["/"];
        }
        if (sep["$=="]("")) {
          sep = /\r?\n\r?\n/;
        }
        sep = (function () {
          if ($truthy(($ret_or_10 = sep))) {
            return $ret_or_10;
          } else {
            return "";
          }
          return nil;
        })();
        if (orig_sep["$=="]("")) {
        } else {
          sep = sep.$to_str();
        }
        seplen = orig_sep == "" ? 2 : sep.length;
        if (sep["$=="](" ")) {
          sep = / /;
        }
        self.read_buffer = (function () {
          if ($truthy(($ret_or_11 = self.read_buffer))) {
            return $ret_or_11;
          } else {
            return "";
          }
          return nil;
        })();
        data = "";
        ret = nil;
        do {
          self.read_buffer = $rb_plus(self.read_buffer, data);
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_12 = sep["$!="]("")))) {
                  if ($truthy(sep.$$is_regexp)) {
                    return self.read_buffer["$match?"](sep);
                  } else {
                    return self.read_buffer["$include?"](sep);
                  }
                } else {
                  return $ret_or_12;
                }
                return nil;
              })()
            )
          ) {
            orig_buffer = self.read_buffer;
            ($c = self.read_buffer.$split(sep, 2)),
              ($b = Opal.to_ary($c)),
              (ret = $b[0] == null ? nil : $b[0]),
              (self.read_buffer = $b[1] == null ? nil : $b[1]),
              $c;
            if ($truthy(ret["$!="](orig_buffer))) {
              ret = $rb_plus(ret, orig_buffer["$[]"](ret.$length(), seplen));
            }
            break;
          }
        } while (
          $truthy(
            (data = self.$sysread_noraise(
              (function () {
                if (sep["$=="]("")) {
                  return 65536;
                } else {
                  return 1;
                }
                return nil;
              })()
            ))
          )
        );
        if ($truthy(ret)) {
        } else {
          ($a = [
            (function () {
              if ($truthy(($ret_or_13 = self.read_buffer))) {
                return $ret_or_13;
              } else {
                return "";
              }
              return nil;
            })(),
            "",
          ]),
            (ret = $a[0]),
            (self.read_buffer = $a[1]),
            $a;
          if (ret["$=="]("")) {
            ret = nil;
          }
        }
        if ($truthy(ret)) {
          if ($truthy(limit)) {
            ret = ret["$[]"](Opal.Range.$new(0, limit, true));
            self.read_buffer = $rb_plus(
              ret["$[]"](Opal.Range.$new(limit, -1, false)),
              self.read_buffer
            );
          }
          if ($truthy(opts["$[]"]("chomp"))) {
            ret = ret.$sub(/\r?\n$/, "");
          }
          if (orig_sep["$=="]("")) {
            ret = ret.$sub(/^[\r\n]+/, "");
          }
        }
        if (orig_sep["$=="](false)) {
          $gvars._ = ret;
        }
        return ret;
      }),
      ($IO_gets$14.$$arity = -1)
    );

    Opal.def(
      self,
      "$sysread",
      ($IO_sysread$15 = function $$sysread(integer) {
        var self = this,
          $ret_or_14 = nil;

        if ($truthy(($ret_or_14 = self.read_proc(integer)))) {
          return $ret_or_14;
        } else {
          self.eof = true;
          return self.$raise($$($nesting, "EOFError"), "end of file reached");
        }
      }),
      ($IO_sysread$15.$$arity = 1)
    );

    Opal.def(
      self,
      "$sysread_noraise",
      ($IO_sysread_noraise$16 = function $$sysread_noraise(integer) {
        var self = this;

        try {
          return self.$sysread(integer);
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, "EOFError")])) {
            try {
              return nil;
            } finally {
              Opal.pop_exception();
            }
          } else {
            throw $err;
          }
        }
      }),
      ($IO_sysread_noraise$16.$$arity = 1)
    );

    Opal.def(
      self,
      "$readpartial",
      ($IO_readpartial$17 = function $$readpartial(integer) {
        var $a,
          self = this,
          $ret_or_15 = nil,
          part = nil,
          $ret_or_16 = nil,
          ret = nil;

        self.read_buffer = (function () {
          if ($truthy(($ret_or_15 = self.read_buffer))) {
            return $ret_or_15;
          } else {
            return "";
          }
          return nil;
        })();
        part = self.$sysread(integer);
        ($a = [
          $rb_plus(
            self.read_buffer,
            (function () {
              if ($truthy(($ret_or_16 = part))) {
                return $ret_or_16;
              } else {
                return "";
              }
              return nil;
            })()
          ),
          "",
        ]),
          (ret = $a[0]),
          (self.read_buffer = $a[1]),
          $a;
        if (ret["$=="]("")) {
          ret = nil;
        }
        return ret;
      }),
      ($IO_readpartial$17.$$arity = 1)
    );

    Opal.def(
      self,
      "$read",
      ($IO_read$18 = function $$read(integer) {
        var $a,
          $b,
          self = this,
          $ret_or_17 = nil,
          parts = nil,
          ret = nil,
          $ret_or_18 = nil,
          $ret_or_19 = nil;

        if (integer == null) {
          integer = nil;
        }
        self.read_buffer = (function () {
          if ($truthy(($ret_or_17 = self.read_buffer))) {
            return $ret_or_17;
          } else {
            return "";
          }
          return nil;
        })();
        parts = "";
        ret = nil;
        do {
          self.read_buffer = $rb_plus(self.read_buffer, parts);
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_19 = integer))) {
                  return $rb_gt(self.read_buffer.$length(), integer);
                } else {
                  return $ret_or_19;
                }
                return nil;
              })()
            )
          ) {
            ($b = [
              self.read_buffer["$[]"](Opal.Range.$new(0, integer, true)),
              self.read_buffer["$[]"](Opal.Range.$new(integer, -1, false)),
            ]),
              (ret = $b[0]),
              (self.read_buffer = $b[1]),
              $b;
            return ret;
          }
        } while (
          $truthy(
            (parts = self.$sysread_noraise(
              (function () {
                if ($truthy(($ret_or_18 = integer))) {
                  return $ret_or_18;
                } else {
                  return 65536;
                }
                return nil;
              })()
            ))
          )
        );
        ($a = [self.read_buffer, ""]),
          (ret = $a[0]),
          (self.read_buffer = $a[1]),
          $a;
        return ret;
      }),
      ($IO_read$18.$$arity = -1)
    );

    Opal.def(
      self,
      "$readlines",
      ($IO_readlines$19 = function $$readlines(separator) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        if (separator == null) {
          separator = $gvars["/"];
        }
        return self.$each_line(separator).$to_a();
      }),
      ($IO_readlines$19.$$arity = -1)
    );

    Opal.def(
      self,
      "$each",
      ($IO_each$20 = function $$each($a, $b) {
        var $iter = $IO_each$20.$$p,
          block = $iter || nil,
          $post_args,
          sep,
          args,
          $c,
          self = this,
          s = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        if ($iter) $IO_each$20.$$p = null;

        if ($iter) $IO_each$20.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        if ($post_args.length > 0) {
          sep = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (sep == null) {
          sep = $gvars["/"];
        }

        args = $post_args;
        if (block !== nil) {
        } else {
          return $send(self, "enum_for", ["each", sep].concat(Opal.to_a(args)));
        }
        while (
          $truthy((s = $send(self, "gets", [sep].concat(Opal.to_a(args)))))
        ) {
          Opal.yield1(block, s);
        }
        return self;
      }),
      ($IO_each$20.$$arity = -1)
    );
    $alias(self, "each_line", "each");

    Opal.def(
      self,
      "$each_byte",
      ($IO_each_byte$21 = function $$each_byte() {
        var $iter = $IO_each_byte$21.$$p,
          block = $iter || nil,
          $a,
          self = this,
          s = nil;

        if ($iter) $IO_each_byte$21.$$p = null;

        if ($iter) $IO_each_byte$21.$$p = null;
        if (block !== nil) {
        } else {
          return self.$enum_for("each_byte");
        }
        while ($truthy((s = self.$getbyte()))) {
          Opal.yield1(block, s);
        }
        return self;
      }),
      ($IO_each_byte$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_char",
      ($IO_each_char$22 = function $$each_char() {
        var $iter = $IO_each_char$22.$$p,
          block = $iter || nil,
          $a,
          self = this,
          s = nil;

        if ($iter) $IO_each_char$22.$$p = null;

        if ($iter) $IO_each_char$22.$$p = null;
        if (block !== nil) {
        } else {
          return self.$enum_for("each_char");
        }
        while ($truthy((s = self.$getc()))) {
          Opal.yield1(block, s);
        }
        return self;
      }),
      ($IO_each_char$22.$$arity = 0)
    );

    Opal.def(
      self,
      "$close",
      ($IO_close$23 = function $$close() {
        var self = this;

        return (self.closed = "both");
      }),
      ($IO_close$23.$$arity = 0)
    );

    Opal.def(
      self,
      "$close_read",
      ($IO_close_read$24 = function $$close_read() {
        var self = this;

        if (self.closed["$=="]("write")) {
          return (self.closed = "both");
        } else {
          return (self.closed = "read");
        }
      }),
      ($IO_close_read$24.$$arity = 0)
    );

    Opal.def(
      self,
      "$close_write",
      ($IO_close_write$25 = function $$close_write() {
        var self = this;

        if (self.closed["$=="]("read")) {
          return (self.closed = "both");
        } else {
          return (self.closed = "write");
        }
      }),
      ($IO_close_write$25.$$arity = 0)
    );

    Opal.def(
      self,
      "$closed?",
      ($IO_closed$ques$26 = function () {
        var self = this;

        return self.closed["$=="]("both");
      }),
      ($IO_closed$ques$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$closed_read?",
      ($IO_closed_read$ques$27 = function () {
        var self = this,
          $ret_or_20 = nil;

        if ($truthy(($ret_or_20 = self.closed["$=="]("read")))) {
          return $ret_or_20;
        } else {
          return self.closed["$=="]("both");
        }
      }),
      ($IO_closed_read$ques$27.$$arity = 0)
    );

    Opal.def(
      self,
      "$closed_write?",
      ($IO_closed_write$ques$28 = function () {
        var self = this,
          $ret_or_21 = nil;

        if ($truthy(($ret_or_21 = self.closed["$=="]("write")))) {
          return $ret_or_21;
        } else {
          return self.closed["$=="]("both");
        }
      }),
      ($IO_closed_write$ques$28.$$arity = 0)
    );

    Opal.def(
      self,
      "$check_writable",
      ($IO_check_writable$29 = function $$check_writable() {
        var self = this;

        if ($truthy(self["$closed_write?"]())) {
          return self.$raise($$($nesting, "IOError"), "not opened for writing");
        } else {
          return nil;
        }
      }),
      ($IO_check_writable$29.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$check_readable",
        ($IO_check_readable$30 = function $$check_readable() {
          var self = this;

          if ($truthy(self["$closed_read?"]())) {
            return self.$raise(
              $$($nesting, "IOError"),
              "not opened for reading"
            );
          } else {
            return nil;
          }
        }),
        ($IO_check_readable$30.$$arity = 0)
      ),
      nil) && "check_readable"
    );
  })($nesting[0], null, $nesting);
  Opal.const_set(
    $nesting[0],
    "STDIN",
    ($gvars.stdin = $$($nesting, "IO").$new(0, "r"))
  );
  Opal.const_set(
    $nesting[0],
    "STDOUT",
    ($gvars.stdout = $$($nesting, "IO").$new(1, "w"))
  );
  Opal.const_set(
    $nesting[0],
    "STDERR",
    ($gvars.stderr = $$($nesting, "IO").$new(2, "w"))
  );
  var console = Opal.global.console;

  $writer = [
    typeof process === "object" && typeof process.stdout === "object"
      ? function (s) {
          process.stdout.write(s);
        }
      : function (s) {
          console.log(s);
        },
  ];
  $send($$($nesting, "STDOUT"), "write_proc=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [
    typeof process === "object" && typeof process.stderr === "object"
      ? function (s) {
          process.stderr.write(s);
        }
      : function (s) {
          console.warn(s);
        },
  ];
  $send($$($nesting, "STDERR"), "write_proc=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [
    function (s) {
      var p = prompt();
      if (p !== null) return p + "\n";
      return nil;
    },
  ];
  $send($$($nesting, "STDIN"), "read_proc=", Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];
};

Opal.modules["opal/regexp_anchors"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module;

  Opal.add_stubs(["$new"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Opal");

    var $nesting = [self].concat($parent_nesting);

    Opal.const_set($nesting[0], "REGEXP_START", "^");
    Opal.const_set($nesting[0], "REGEXP_END", "$");
    Opal.const_set(
      $nesting[0],
      "FORBIDDEN_STARTING_IDENTIFIER_CHARS",
      "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F"
    );
    Opal.const_set(
      $nesting[0],
      "FORBIDDEN_ENDING_IDENTIFIER_CHARS",
      "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F"
    );
    Opal.const_set(
      $nesting[0],
      "INLINE_IDENTIFIER_REGEXP",
      $$($nesting, "Regexp").$new(
        "" +
          "[^" +
          $$($nesting, "FORBIDDEN_STARTING_IDENTIFIER_CHARS") +
          "]*[^" +
          $$($nesting, "FORBIDDEN_ENDING_IDENTIFIER_CHARS") +
          "]"
      )
    );
    Opal.const_set(
      $nesting[0],
      "FORBIDDEN_CONST_NAME_CHARS",
      "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F"
    );
    return Opal.const_set(
      $nesting[0],
      "CONST_NAME_REGEXP",
      $$($nesting, "Regexp").$new(
        "" +
          $$($nesting, "REGEXP_START") +
          "(::)?[A-Z][^" +
          $$($nesting, "FORBIDDEN_CONST_NAME_CHARS") +
          "]*" +
          $$($nesting, "REGEXP_END")
      )
    );
  })($nesting[0], $nesting);
};

Opal.modules["opal/mini"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.add_stubs(["$require"]);

  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  self.$require("corelib/io");
  return self.$require("opal/regexp_anchors");
};

Opal.modules["corelib/main"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var $to_s$1,
    $include$2,
    $autoload$3,
    $using$4,
    self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $send = Opal.send;

  Opal.add_stubs(["$include", "$autoload", "$raise"]);

  Opal.defs(
    self,
    "$to_s",
    ($to_s$1 = function $$to_s() {
      var self = this;

      return "main";
    }),
    ($to_s$1.$$arity = 0)
  );
  Opal.defs(
    self,
    "$include",
    ($include$2 = function $$include(mod) {
      var self = this;

      return $$($nesting, "Object").$include(mod);
    }),
    ($include$2.$$arity = 1)
  );
  Opal.defs(
    self,
    "$autoload",
    ($autoload$3 = function $$autoload($a) {
      var $post_args,
        args,
        self = this;

      $post_args = Opal.slice.call(arguments, 0, arguments.length);

      args = $post_args;
      return $send($$($nesting, "Object"), "autoload", Opal.to_a(args));
    }),
    ($autoload$3.$$arity = -1)
  );
  return (
    (Opal.defs(
      self,
      "$using",
      ($using$4 = function $$using(mod) {
        var self = this;

        return self.$raise("main.using is permitted only at toplevel");
      }),
      ($using$4.$$arity = 1)
    ),
    nil) && "using"
  );
};

Opal.modules["corelib/kernel/format"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $coerce_to = Opal.coerce_to,
    $module = Opal.module,
    $truthy = Opal.truthy,
    $gvars = Opal.gvars,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$==",
    "$length",
    "$respond_to?",
    "$[]",
    "$coerce_to?",
    "$nil?",
    "$to_a",
    "$raise",
    "$to_int",
    "$fetch",
    "$Integer",
    "$Float",
    "$to_ary",
    "$to_str",
    "$inspect",
    "$to_s",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_format$1;

    Opal.def(
      self,
      "$format",
      ($Kernel_format$1 = function $$format(format_string, $a) {
        var $post_args,
          args,
          self = this,
          $ret_or_1 = nil,
          ary = nil;
        if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        args = $post_args;
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_1 = args.$length()["$=="](1)))) {
                return args["$[]"](0)["$respond_to?"]("to_ary");
              } else {
                return $ret_or_1;
              }
              return nil;
            })()
          )
        ) {
          ary = $$($nesting, "Opal")["$coerce_to?"](
            args["$[]"](0),
            $$($nesting, "Array"),
            "to_ary"
          );
          if ($truthy(ary["$nil?"]())) {
          } else {
            args = ary.$to_a();
          }
        }

        var result = "",
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS = 4,
          FZERO = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC = 64,
          FPREC0 = 128;

        function CHECK_FOR_FLAGS() {
          if (flags & FWIDTH) {
            self.$raise($$($nesting, "ArgumentError"), "flag after width");
          }
          if (flags & FPREC0) {
            self.$raise($$($nesting, "ArgumentError"), "flag after precision");
          }
        }

        function CHECK_FOR_WIDTH() {
          if (flags & FWIDTH) {
            self.$raise($$($nesting, "ArgumentError"), "width given twice");
          }
          if (flags & FPREC0) {
            self.$raise($$($nesting, "ArgumentError"), "width after precision");
          }
        }

        function GET_NTH_ARG(num) {
          if (num >= args.length) {
            self.$raise($$($nesting, "ArgumentError"), "too few arguments");
          }
          return args[num];
        }

        function GET_NEXT_ARG() {
          switch (pos_arg_num) {
            case -1:
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" + "unnumbered(" + seq_arg_num + ") mixed with numbered"
              ); // raise
            case -2:
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" + "unnumbered(" + seq_arg_num + ") mixed with named"
              ); // raise
          }
          pos_arg_num = seq_arg_num++;
          return GET_NTH_ARG(pos_arg_num - 1);
        }

        function GET_POS_ARG(num) {
          if (pos_arg_num > 0) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "numbered(" + num + ") after unnumbered(" + pos_arg_num + ")"
            );
          }
          if (pos_arg_num === -2) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "numbered(" + num + ") after named"
            );
          }
          if (num < 1) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "invalid index - " + num + "$"
            );
          }
          pos_arg_num = -1;
          return GET_NTH_ARG(num - 1);
        }

        function GET_ARG() {
          return next_arg === undefined ? GET_NEXT_ARG() : next_arg;
        }

        function READ_NUM(label) {
          var num,
            str = "";
          for (; ; i++) {
            if (i === len) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "malformed format string - %*[0-9]"
              );
            }
            if (
              format_string.charCodeAt(i) < 48 ||
              format_string.charCodeAt(i) > 57
            ) {
              i--;
              num = parseInt(str, 10) || 0;
              if (num > 2147483647) {
                self.$raise(
                  $$($nesting, "ArgumentError"),
                  "" + label + " too big"
                );
              }
              return num;
            }
            str += format_string.charAt(i);
          }
        }

        function READ_NUM_AFTER_ASTER(label) {
          var arg,
            num = READ_NUM(label);
          if (format_string.charAt(i + 1) === "$") {
            i++;
            arg = GET_POS_ARG(num);
          } else {
            arg = GET_NEXT_ARG();
          }
          return arg.$to_int();
        }

        for (
          i = format_string.indexOf("%");
          i !== -1;
          i = format_string.indexOf("%", i)
        ) {
          str = undefined;

          flags = FNONE;
          width = -1;
          precision = -1;
          next_arg = undefined;

          end_slice = i;

          i++;

          switch (format_string.charAt(i)) {
            case "%":
              begin_slice = i;
            // no-break
            case "":
            case "\n":
            case "\0":
              i++;
              continue;
          }

          format_sequence: for (; i < len; i++) {
            switch (format_string.charAt(i)) {
              case " ":
                CHECK_FOR_FLAGS();
                flags |= FSPACE;
                continue format_sequence;

              case "#":
                CHECK_FOR_FLAGS();
                flags |= FSHARP;
                continue format_sequence;

              case "+":
                CHECK_FOR_FLAGS();
                flags |= FPLUS;
                continue format_sequence;

              case "-":
                CHECK_FOR_FLAGS();
                flags |= FMINUS;
                continue format_sequence;

              case "0":
                CHECK_FOR_FLAGS();
                flags |= FZERO;
                continue format_sequence;

              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                tmp_num = READ_NUM("width");
                if (format_string.charAt(i + 1) === "$") {
                  if (i + 2 === len) {
                    str = "%";
                    i++;
                    break format_sequence;
                  }
                  if (next_arg !== undefined) {
                    self.$raise(
                      $$($nesting, "ArgumentError"),
                      "" + "value given twice - %" + tmp_num + "$"
                    );
                  }
                  next_arg = GET_POS_ARG(tmp_num);
                  i++;
                } else {
                  CHECK_FOR_WIDTH();
                  flags |= FWIDTH;
                  width = tmp_num;
                }
                continue format_sequence;

              case "<":
              case "{":
                closing_brace_char =
                  format_string.charAt(i) === "<" ? ">" : "}";
                hash_parameter_key = "";

                i++;

                for (; ; i++) {
                  if (i === len) {
                    self.$raise(
                      $$($nesting, "ArgumentError"),
                      "malformed name - unmatched parenthesis"
                    );
                  }
                  if (format_string.charAt(i) === closing_brace_char) {
                    if (pos_arg_num > 0) {
                      self.$raise(
                        $$($nesting, "ArgumentError"),
                        "" +
                          "named " +
                          hash_parameter_key +
                          " after unnumbered(" +
                          pos_arg_num +
                          ")"
                      );
                    }
                    if (pos_arg_num === -1) {
                      self.$raise(
                        $$($nesting, "ArgumentError"),
                        "" + "named " + hash_parameter_key + " after numbered"
                      );
                    }
                    pos_arg_num = -2;

                    if (args[0] === undefined || !args[0].$$is_hash) {
                      self.$raise(
                        $$($nesting, "ArgumentError"),
                        "one hash required"
                      );
                    }

                    next_arg = args[0].$fetch(hash_parameter_key);

                    if (closing_brace_char === ">") {
                      continue format_sequence;
                    } else {
                      str = next_arg.toString();
                      if (precision !== -1) {
                        str = str.slice(0, precision);
                      }
                      if (flags & FMINUS) {
                        while (str.length < width) {
                          str = str + " ";
                        }
                      } else {
                        while (str.length < width) {
                          str = " " + str;
                        }
                      }
                      break format_sequence;
                    }
                  }
                  hash_parameter_key += format_string.charAt(i);
                }
              // raise

              case "*":
                i++;
                CHECK_FOR_WIDTH();
                flags |= FWIDTH;
                width = READ_NUM_AFTER_ASTER("width");
                if (width < 0) {
                  flags |= FMINUS;
                  width = -width;
                }
                continue format_sequence;

              case ".":
                if (flags & FPREC0) {
                  self.$raise(
                    $$($nesting, "ArgumentError"),
                    "precision given twice"
                  );
                }
                flags |= FPREC | FPREC0;
                precision = 0;
                i++;
                if (format_string.charAt(i) === "*") {
                  i++;
                  precision = READ_NUM_AFTER_ASTER("precision");
                  if (precision < 0) {
                    flags &= ~FPREC;
                  }
                  continue format_sequence;
                }
                precision = READ_NUM("precision");
                continue format_sequence;

              case "d":
              case "i":
              case "u":
                arg = self.$Integer(GET_ARG());
                if (arg >= 0) {
                  str = arg.toString();
                  while (str.length < precision) {
                    str = "0" + str;
                  }
                  if (flags & FMINUS) {
                    if (flags & FPLUS || flags & FSPACE) {
                      str = (flags & FPLUS ? "+" : " ") + str;
                    }
                    while (str.length < width) {
                      str = str + " ";
                    }
                  } else {
                    if (flags & FZERO && precision === -1) {
                      while (
                        str.length <
                        width - (flags & FPLUS || flags & FSPACE ? 1 : 0)
                      ) {
                        str = "0" + str;
                      }
                      if (flags & FPLUS || flags & FSPACE) {
                        str = (flags & FPLUS ? "+" : " ") + str;
                      }
                    } else {
                      if (flags & FPLUS || flags & FSPACE) {
                        str = (flags & FPLUS ? "+" : " ") + str;
                      }
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                  }
                } else {
                  str = (-arg).toString();
                  while (str.length < precision) {
                    str = "0" + str;
                  }
                  if (flags & FMINUS) {
                    str = "-" + str;
                    while (str.length < width) {
                      str = str + " ";
                    }
                  } else {
                    if (flags & FZERO && precision === -1) {
                      while (str.length < width - 1) {
                        str = "0" + str;
                      }
                      str = "-" + str;
                    } else {
                      str = "-" + str;
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                  }
                }
                break format_sequence;

              case "b":
              case "B":
              case "o":
              case "x":
              case "X":
                switch (format_string.charAt(i)) {
                  case "b":
                  case "B":
                    base_number = 2;
                    base_prefix = "0b";
                    base_neg_zero_regex = /^1+/;
                    base_neg_zero_digit = "1";
                    break;
                  case "o":
                    base_number = 8;
                    base_prefix = "0";
                    base_neg_zero_regex = /^3?7+/;
                    base_neg_zero_digit = "7";
                    break;
                  case "x":
                  case "X":
                    base_number = 16;
                    base_prefix = "0x";
                    base_neg_zero_regex = /^f+/;
                    base_neg_zero_digit = "f";
                    break;
                }
                arg = self.$Integer(GET_ARG());
                if (arg >= 0) {
                  str = arg.toString(base_number);
                  while (str.length < precision) {
                    str = "0" + str;
                  }
                  if (flags & FMINUS) {
                    if (flags & FPLUS || flags & FSPACE) {
                      str = (flags & FPLUS ? "+" : " ") + str;
                    }
                    if (flags & FSHARP && arg !== 0) {
                      str = base_prefix + str;
                    }
                    while (str.length < width) {
                      str = str + " ";
                    }
                  } else {
                    if (flags & FZERO && precision === -1) {
                      while (
                        str.length <
                        width -
                          (flags & FPLUS || flags & FSPACE ? 1 : 0) -
                          (flags & FSHARP && arg !== 0 ? base_prefix.length : 0)
                      ) {
                        str = "0" + str;
                      }
                      if (flags & FSHARP && arg !== 0) {
                        str = base_prefix + str;
                      }
                      if (flags & FPLUS || flags & FSPACE) {
                        str = (flags & FPLUS ? "+" : " ") + str;
                      }
                    } else {
                      if (flags & FSHARP && arg !== 0) {
                        str = base_prefix + str;
                      }
                      if (flags & FPLUS || flags & FSPACE) {
                        str = (flags & FPLUS ? "+" : " ") + str;
                      }
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                  }
                } else {
                  if (flags & FPLUS || flags & FSPACE) {
                    str = (-arg).toString(base_number);
                    while (str.length < precision) {
                      str = "0" + str;
                    }
                    if (flags & FMINUS) {
                      if (flags & FSHARP) {
                        str = base_prefix + str;
                      }
                      str = "-" + str;
                      while (str.length < width) {
                        str = str + " ";
                      }
                    } else {
                      if (flags & FZERO && precision === -1) {
                        while (
                          str.length <
                          width - 1 - (flags & FSHARP ? 2 : 0)
                        ) {
                          str = "0" + str;
                        }
                        if (flags & FSHARP) {
                          str = base_prefix + str;
                        }
                        str = "-" + str;
                      } else {
                        if (flags & FSHARP) {
                          str = base_prefix + str;
                        }
                        str = "-" + str;
                        while (str.length < width) {
                          str = " " + str;
                        }
                      }
                    }
                  } else {
                    str = (arg >>> 0)
                      .toString(base_number)
                      .replace(base_neg_zero_regex, base_neg_zero_digit);
                    while (str.length < precision - 2) {
                      str = base_neg_zero_digit + str;
                    }
                    if (flags & FMINUS) {
                      str = ".." + str;
                      if (flags & FSHARP) {
                        str = base_prefix + str;
                      }
                      while (str.length < width) {
                        str = str + " ";
                      }
                    } else {
                      if (flags & FZERO && precision === -1) {
                        while (
                          str.length <
                          width - 2 - (flags & FSHARP ? base_prefix.length : 0)
                        ) {
                          str = base_neg_zero_digit + str;
                        }
                        str = ".." + str;
                        if (flags & FSHARP) {
                          str = base_prefix + str;
                        }
                      } else {
                        str = ".." + str;
                        if (flags & FSHARP) {
                          str = base_prefix + str;
                        }
                        while (str.length < width) {
                          str = " " + str;
                        }
                      }
                    }
                  }
                }
                if (
                  format_string.charAt(i) ===
                  format_string.charAt(i).toUpperCase()
                ) {
                  str = str.toUpperCase();
                }
                break format_sequence;

              case "f":
              case "e":
              case "E":
              case "g":
              case "G":
                arg = self.$Float(GET_ARG());
                if (arg >= 0 || isNaN(arg)) {
                  if (arg === Infinity) {
                    str = "Inf";
                  } else {
                    switch (format_string.charAt(i)) {
                      case "f":
                        str = arg.toFixed(precision === -1 ? 6 : precision);
                        break;
                      case "e":
                      case "E":
                        str = arg.toExponential(
                          precision === -1 ? 6 : precision
                        );
                        break;
                      case "g":
                      case "G":
                        str = arg.toExponential();
                        exponent = parseInt(str.split("e")[1], 10);
                        if (
                          !(
                            exponent < -4 ||
                            exponent >= (precision === -1 ? 6 : precision)
                          )
                        ) {
                          str = arg.toPrecision(
                            precision === -1
                              ? flags & FSHARP
                                ? 6
                                : undefined
                              : precision
                          );
                        }
                        break;
                    }
                  }
                  if (flags & FMINUS) {
                    if (flags & FPLUS || flags & FSPACE) {
                      str = (flags & FPLUS ? "+" : " ") + str;
                    }
                    while (str.length < width) {
                      str = str + " ";
                    }
                  } else {
                    if (flags & FZERO && arg !== Infinity && !isNaN(arg)) {
                      while (
                        str.length <
                        width - (flags & FPLUS || flags & FSPACE ? 1 : 0)
                      ) {
                        str = "0" + str;
                      }
                      if (flags & FPLUS || flags & FSPACE) {
                        str = (flags & FPLUS ? "+" : " ") + str;
                      }
                    } else {
                      if (flags & FPLUS || flags & FSPACE) {
                        str = (flags & FPLUS ? "+" : " ") + str;
                      }
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                  }
                } else {
                  if (arg === -Infinity) {
                    str = "Inf";
                  } else {
                    switch (format_string.charAt(i)) {
                      case "f":
                        str = (-arg).toFixed(precision === -1 ? 6 : precision);
                        break;
                      case "e":
                      case "E":
                        str = (-arg).toExponential(
                          precision === -1 ? 6 : precision
                        );
                        break;
                      case "g":
                      case "G":
                        str = (-arg).toExponential();
                        exponent = parseInt(str.split("e")[1], 10);
                        if (
                          !(
                            exponent < -4 ||
                            exponent >= (precision === -1 ? 6 : precision)
                          )
                        ) {
                          str = (-arg).toPrecision(
                            precision === -1
                              ? flags & FSHARP
                                ? 6
                                : undefined
                              : precision
                          );
                        }
                        break;
                    }
                  }
                  if (flags & FMINUS) {
                    str = "-" + str;
                    while (str.length < width) {
                      str = str + " ";
                    }
                  } else {
                    if (flags & FZERO && arg !== -Infinity) {
                      while (str.length < width - 1) {
                        str = "0" + str;
                      }
                      str = "-" + str;
                    } else {
                      str = "-" + str;
                      while (str.length < width) {
                        str = " " + str;
                      }
                    }
                  }
                }
                if (
                  format_string.charAt(i) ===
                    format_string.charAt(i).toUpperCase() &&
                  arg !== Infinity &&
                  arg !== -Infinity &&
                  !isNaN(arg)
                ) {
                  str = str.toUpperCase();
                }
                str = str.replace(/([eE][-+]?)([0-9])$/, "$10$2");
                break format_sequence;

              case "a":
              case "A":
                // Not implemented because there are no specs for this field type.
                self.$raise(
                  $$($nesting, "NotImplementedError"),
                  "`A` and `a` format field types are not implemented in Opal yet"
                );
              // raise

              case "c":
                arg = GET_ARG();
                if (arg["$respond_to?"]("to_ary")) {
                  arg = arg.$to_ary()[0];
                }
                if (arg["$respond_to?"]("to_str")) {
                  str = arg.$to_str();
                } else {
                  str = String.fromCharCode(
                    $coerce_to(arg, $$($nesting, "Integer"), "to_int")
                  );
                }
                if (str.length !== 1) {
                  self.$raise(
                    $$($nesting, "ArgumentError"),
                    "%c requires a character"
                  );
                }
                if (flags & FMINUS) {
                  while (str.length < width) {
                    str = str + " ";
                  }
                } else {
                  while (str.length < width) {
                    str = " " + str;
                  }
                }
                break format_sequence;

              case "p":
                str = GET_ARG().$inspect();
                if (precision !== -1) {
                  str = str.slice(0, precision);
                }
                if (flags & FMINUS) {
                  while (str.length < width) {
                    str = str + " ";
                  }
                } else {
                  while (str.length < width) {
                    str = " " + str;
                  }
                }
                break format_sequence;

              case "s":
                str = GET_ARG().$to_s();
                if (precision !== -1) {
                  str = str.slice(0, precision);
                }
                if (flags & FMINUS) {
                  while (str.length < width) {
                    str = str + " ";
                  }
                } else {
                  while (str.length < width) {
                    str = " " + str;
                  }
                }
                break format_sequence;

              default:
                self.$raise(
                  $$($nesting, "ArgumentError"),
                  "" + "malformed format string - %" + format_string.charAt(i)
                );
            }
          }

          if (str === undefined) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "malformed format string - %"
            );
          }

          result += format_string.slice(begin_slice, end_slice) + str;
          begin_slice = i + 1;
        }

        if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "too many arguments for format string"
          );
        }

        return result + format_string.slice(begin_slice);
      }),
      ($Kernel_format$1.$$arity = -2)
    );
    return $alias(self, "sprintf", "format");
  })($nesting[0], $nesting);
};

Opal.modules["corelib/string/encoding"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var $$14,
    $$17,
    $$20,
    $$22,
    $$25,
    $$27,
    self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $send = Opal.send,
    $alias = Opal.alias,
    $writer = nil;

  Opal.add_stubs([
    "$require",
    "$+",
    "$[]",
    "$clone",
    "$initialize",
    "$new",
    "$instance_eval",
    "$to_proc",
    "$each",
    "$const_set",
    "$tr",
    "$==",
    "$default_external",
    "$attr_accessor",
    "$singleton_class",
    "$attr_reader",
    "$raise",
    "$register",
    "$length",
    "$bytes",
    "$force_encoding",
    "$dup",
    "$bytesize",
    "$enum_for",
    "$each_byte",
    "$to_a",
    "$each_char",
    "$each_codepoint",
    "$coerce_to!",
    "$find",
    "$<",
    "$default_external=",
    "$-",
  ]);

  self.$require("corelib/string");
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Encoding");

    var $nesting = [self].concat($parent_nesting),
      $Encoding_register$1,
      $Encoding_find$3,
      $Encoding_initialize$4,
      $Encoding_ascii_compatible$ques$5,
      $Encoding_dummy$ques$6,
      $Encoding_binary$ques$7,
      $Encoding_to_s$8,
      $Encoding_inspect$9,
      $Encoding_charsize$10,
      $Encoding_each_char$11,
      $Encoding_each_byte$12,
      $Encoding_bytesize$13;

    self.$$prototype.ascii =
      self.$$prototype.dummy =
      self.$$prototype.name =
        nil;

    Opal.defs(
      self,
      "$register",
      ($Encoding_register$1 = function $$register(name, options) {
        var $iter = $Encoding_register$1.$$p,
          block = $iter || nil,
          $$2,
          self = this,
          names = nil,
          $ret_or_1 = nil,
          ascii = nil,
          $ret_or_2 = nil,
          dummy = nil,
          $ret_or_3 = nil,
          encoding = nil,
          register = nil;

        if ($iter) $Encoding_register$1.$$p = null;

        if ($iter) $Encoding_register$1.$$p = null;

        if (options == null) {
          options = $hash2([], {});
        }
        names = $rb_plus(
          [name],
          (function () {
            if ($truthy(($ret_or_1 = options["$[]"]("aliases")))) {
              return $ret_or_1;
            } else {
              return [];
            }
            return nil;
          })()
        );
        ascii = (function () {
          if ($truthy(($ret_or_2 = options["$[]"]("ascii")))) {
            return $ret_or_2;
          } else {
            return false;
          }
          return nil;
        })();
        dummy = (function () {
          if ($truthy(($ret_or_3 = options["$[]"]("dummy")))) {
            return $ret_or_3;
          } else {
            return false;
          }
          return nil;
        })();
        if ($truthy(options["$[]"]("inherits"))) {
          encoding = options["$[]"]("inherits").$clone();
          encoding.$initialize(name, names, ascii, dummy);
        } else {
          encoding = self.$new(name, names, ascii, dummy);
        }
        if (block !== nil) {
          $send(encoding, "instance_eval", [], block.$to_proc());
        }
        register = Opal.encodings;
        return $send(
          names,
          "each",
          [],
          (($$2 = function (encoding_name) {
            var self = $$2.$$s == null ? this : $$2.$$s;

            if (encoding_name == null) {
              encoding_name = nil;
            }
            self.$const_set(encoding_name.$tr("-", "_"), encoding);
            return (register[encoding_name] = encoding);
          }),
          ($$2.$$s = self),
          ($$2.$$arity = 1),
          $$2)
        );
      }),
      ($Encoding_register$1.$$arity = -2)
    );
    Opal.defs(
      self,
      "$find",
      ($Encoding_find$3 = function $$find(name) {
        var self = this;

        if (name["$=="]("default_external")) {
          return self.$default_external();
        }
        return Opal.find_encoding(name);
      }),
      ($Encoding_find$3.$$arity = 1)
    );
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");

    Opal.def(
      self,
      "$initialize",
      ($Encoding_initialize$4 = function $$initialize(
        name,
        names,
        ascii,
        dummy
      ) {
        var self = this;

        self.name = name;
        self.names = names;
        self.ascii = ascii;
        return (self.dummy = dummy);
      }),
      ($Encoding_initialize$4.$$arity = 4)
    );

    Opal.def(
      self,
      "$ascii_compatible?",
      ($Encoding_ascii_compatible$ques$5 = function () {
        var self = this;

        return self.ascii;
      }),
      ($Encoding_ascii_compatible$ques$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$dummy?",
      ($Encoding_dummy$ques$6 = function () {
        var self = this;

        return self.dummy;
      }),
      ($Encoding_dummy$ques$6.$$arity = 0)
    );

    Opal.def(
      self,
      "$binary?",
      ($Encoding_binary$ques$7 = function () {
        var self = this;

        return false;
      }),
      ($Encoding_binary$ques$7.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Encoding_to_s$8 = function $$to_s() {
        var self = this;

        return self.name;
      }),
      ($Encoding_to_s$8.$$arity = 0)
    );

    Opal.def(
      self,
      "$inspect",
      ($Encoding_inspect$9 = function $$inspect() {
        var self = this;

        return (
          "" +
          "#<Encoding:" +
          self.name +
          (function () {
            if ($truthy(self.dummy)) {
              return " (dummy)";
            } else {
              return nil;
            }
            return nil;
          })() +
          ">"
        );
      }),
      ($Encoding_inspect$9.$$arity = 0)
    );

    Opal.def(
      self,
      "$charsize",
      ($Encoding_charsize$10 = function $$charsize(string) {
        var self = this;

        var len = 0;
        for (var i = 0, length = string.length; i < length; i++) {
          var charcode = string.charCodeAt(i);
          if (!(charcode >= 0xd800 && charcode <= 0xdbff)) {
            len++;
          }
        }
        return len;
      }),
      ($Encoding_charsize$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$each_char",
      ($Encoding_each_char$11 = function $$each_char(string) {
        var $iter = $Encoding_each_char$11.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Encoding_each_char$11.$$p = null;

        if ($iter) $Encoding_each_char$11.$$p = null;

        var low_surrogate = "";
        for (var i = 0, length = string.length; i < length; i++) {
          var charcode = string.charCodeAt(i);
          var chr = string.charAt(i);
          if (charcode >= 0xdc00 && charcode <= 0xdfff) {
            low_surrogate = chr;
            continue;
          } else if (charcode >= 0xd800 && charcode <= 0xdbff) {
            chr = low_surrogate + chr;
          }
          if (string.encoding.name != "UTF-8") {
            chr = new String(chr);
            chr.encoding = string.encoding;
          }
          Opal.yield1(block, chr);
        }
      }),
      ($Encoding_each_char$11.$$arity = 1)
    );

    Opal.def(
      self,
      "$each_byte",
      ($Encoding_each_byte$12 = function $$each_byte($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise($$($nesting, "NotImplementedError"));
      }),
      ($Encoding_each_byte$12.$$arity = -1)
    );

    Opal.def(
      self,
      "$bytesize",
      ($Encoding_bytesize$13 = function $$bytesize($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise($$($nesting, "NotImplementedError"));
      }),
      ($Encoding_bytesize$13.$$arity = -1)
    );
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "EncodingError");

      var $nesting = [self].concat($parent_nesting);

      return nil;
    })($nesting[0], $$($nesting, "StandardError"), $nesting);
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "CompatibilityError");

      var $nesting = [self].concat($parent_nesting);

      return nil;
    })($nesting[0], $$($nesting, "EncodingError"), $nesting);
  })($nesting[0], null, $nesting);
  $send(
    $$($nesting, "Encoding"),
    "register",
    [
      "UTF-8",
      $hash2(["aliases", "ascii"], { aliases: ["CP65001"], ascii: true }),
    ],
    (($$14 = function () {
      var self = $$14.$$s == null ? this : $$14.$$s,
        $each_byte$15,
        $bytesize$16;

      Opal.def(
        self,
        "$each_byte",
        ($each_byte$15 = function $$each_byte(string) {
          var $iter = $each_byte$15.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $each_byte$15.$$p = null;

          if ($iter) $each_byte$15.$$p = null;

          // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
          var units = Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);

            // is surrogate component
            if (codePoint > 0xd7ff && codePoint < 0xe000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xdbff) {
                  // unexpected trail
                  if ((units -= 3) > -1) {
                    Opal.yield1(block, 0xef);
                    Opal.yield1(block, 0xbf);
                    Opal.yield1(block, 0xbd);
                  }
                  continue;
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) {
                    Opal.yield1(block, 0xef);
                    Opal.yield1(block, 0xbf);
                    Opal.yield1(block, 0xbd);
                  }
                  continue;
                }

                // valid lead
                leadSurrogate = codePoint;

                continue;
              }

              // 2 leads in a row
              if (codePoint < 0xdc00) {
                if ((units -= 3) > -1) {
                  Opal.yield1(block, 0xef);
                  Opal.yield1(block, 0xbf);
                  Opal.yield1(block, 0xbd);
                }
                leadSurrogate = codePoint;
                continue;
              }

              // valid surrogate pair
              codePoint =
                (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) +
                0x10000;
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xef);
                Opal.yield1(block, 0xbf);
                Opal.yield1(block, 0xbd);
              }
            }

            leadSurrogate = null;

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break;
              Opal.yield1(block, codePoint);
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break;
              Opal.yield1(block, (codePoint >> 0x6) | 0xc0);
              Opal.yield1(block, (codePoint & 0x3f) | 0x80);
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break;
              Opal.yield1(block, (codePoint >> 0xc) | 0xe0);
              Opal.yield1(block, ((codePoint >> 0x6) & 0x3f) | 0x80);
              Opal.yield1(block, (codePoint & 0x3f) | 0x80);
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break;
              Opal.yield1(block, (codePoint >> 0x12) | 0xf0);
              Opal.yield1(block, ((codePoint >> 0xc) & 0x3f) | 0x80);
              Opal.yield1(block, ((codePoint >> 0x6) & 0x3f) | 0x80);
              Opal.yield1(block, (codePoint & 0x3f) | 0x80);
            } else {
              // Invalid code point
            }
          }
        }),
        ($each_byte$15.$$arity = 1)
      );
      return (
        (Opal.def(
          self,
          "$bytesize",
          ($bytesize$16 = function $$bytesize(string) {
            var self = this;

            return string.$bytes().$length();
          }),
          ($bytesize$16.$$arity = 1)
        ),
        nil) && "bytesize"
      );
    }),
    ($$14.$$s = self),
    ($$14.$$arity = 0),
    $$14)
  );
  $send(
    $$($nesting, "Encoding"),
    "register",
    ["UTF-16LE"],
    (($$17 = function () {
      var self = $$17.$$s == null ? this : $$17.$$s,
        $each_byte$18,
        $bytesize$19;

      Opal.def(
        self,
        "$each_byte",
        ($each_byte$18 = function $$each_byte(string) {
          var $iter = $each_byte$18.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $each_byte$18.$$p = null;

          if ($iter) $each_byte$18.$$p = null;

          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);

            Opal.yield1(block, code & 0xff);
            Opal.yield1(block, code >> 8);
          }
        }),
        ($each_byte$18.$$arity = 1)
      );
      return (
        (Opal.def(
          self,
          "$bytesize",
          ($bytesize$19 = function $$bytesize(string) {
            var self = this;

            return string.length * 2;
          }),
          ($bytesize$19.$$arity = 1)
        ),
        nil) && "bytesize"
      );
    }),
    ($$17.$$s = self),
    ($$17.$$arity = 0),
    $$17)
  );
  $send(
    $$($nesting, "Encoding"),
    "register",
    [
      "UTF-16BE",
      $hash2(["inherits"], {
        inherits: $$$($$($nesting, "Encoding"), "UTF_16LE"),
      }),
    ],
    (($$20 = function () {
      var self = $$20.$$s == null ? this : $$20.$$s,
        $each_byte$21;

      return (
        (Opal.def(
          self,
          "$each_byte",
          ($each_byte$21 = function $$each_byte(string) {
            var $iter = $each_byte$21.$$p,
              block = $iter || nil,
              self = this;

            if ($iter) $each_byte$21.$$p = null;

            if ($iter) $each_byte$21.$$p = null;

            for (var i = 0, length = string.length; i < length; i++) {
              var code = string.charCodeAt(i);

              Opal.yield1(block, code >> 8);
              Opal.yield1(block, code & 0xff);
            }
          }),
          ($each_byte$21.$$arity = 1)
        ),
        nil) && "each_byte"
      );
    }),
    ($$20.$$s = self),
    ($$20.$$arity = 0),
    $$20)
  );
  $send(
    $$($nesting, "Encoding"),
    "register",
    ["UTF-32LE"],
    (($$22 = function () {
      var self = $$22.$$s == null ? this : $$22.$$s,
        $each_byte$23,
        $bytesize$24;

      Opal.def(
        self,
        "$each_byte",
        ($each_byte$23 = function $$each_byte(string) {
          var $iter = $each_byte$23.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $each_byte$23.$$p = null;

          if ($iter) $each_byte$23.$$p = null;

          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);

            Opal.yield1(block, code & 0xff);
            Opal.yield1(block, code >> 8);
            Opal.yield1(block, 0);
            Opal.yield1(block, 0);
          }
        }),
        ($each_byte$23.$$arity = 1)
      );
      return (
        (Opal.def(
          self,
          "$bytesize",
          ($bytesize$24 = function $$bytesize(string) {
            var self = this;

            return string.length * 4;
          }),
          ($bytesize$24.$$arity = 1)
        ),
        nil) && "bytesize"
      );
    }),
    ($$22.$$s = self),
    ($$22.$$arity = 0),
    $$22)
  );
  $send(
    $$($nesting, "Encoding"),
    "register",
    [
      "UTF-32BE",
      $hash2(["inherits"], {
        inherits: $$$($$($nesting, "Encoding"), "UTF_32LE"),
      }),
    ],
    (($$25 = function () {
      var self = $$25.$$s == null ? this : $$25.$$s,
        $each_byte$26;

      return (
        (Opal.def(
          self,
          "$each_byte",
          ($each_byte$26 = function $$each_byte(string) {
            var $iter = $each_byte$26.$$p,
              block = $iter || nil,
              self = this;

            if ($iter) $each_byte$26.$$p = null;

            if ($iter) $each_byte$26.$$p = null;

            for (var i = 0, length = string.length; i < length; i++) {
              var code = string.charCodeAt(i);

              Opal.yield1(block, 0);
              Opal.yield1(block, 0);
              Opal.yield1(block, code >> 8);
              Opal.yield1(block, code & 0xff);
            }
          }),
          ($each_byte$26.$$arity = 1)
        ),
        nil) && "each_byte"
      );
    }),
    ($$25.$$s = self),
    ($$25.$$arity = 0),
    $$25)
  );
  $send(
    $$($nesting, "Encoding"),
    "register",
    [
      "ASCII-8BIT",
      $hash2(["aliases", "ascii"], { aliases: ["BINARY"], ascii: true }),
    ],
    (($$27 = function () {
      var self = $$27.$$s == null ? this : $$27.$$s,
        $each_char$28,
        $charsize$29,
        $each_byte$30,
        $bytesize$31,
        $binary$ques$32;

      Opal.def(
        self,
        "$each_char",
        ($each_char$28 = function $$each_char(string) {
          var $iter = $each_char$28.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $each_char$28.$$p = null;

          if ($iter) $each_char$28.$$p = null;

          for (var i = 0, length = string.length; i < length; i++) {
            var chr = new String(string.charAt(i));
            chr.encoding = string.encoding;
            Opal.yield1(block, chr);
          }
        }),
        ($each_char$28.$$arity = 1)
      );

      Opal.def(
        self,
        "$charsize",
        ($charsize$29 = function $$charsize(string) {
          var self = this;

          return string.length;
        }),
        ($charsize$29.$$arity = 1)
      );

      Opal.def(
        self,
        "$each_byte",
        ($each_byte$30 = function $$each_byte(string) {
          var $iter = $each_byte$30.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $each_byte$30.$$p = null;

          if ($iter) $each_byte$30.$$p = null;

          for (var i = 0, length = string.length; i < length; i++) {
            var code = string.charCodeAt(i);
            Opal.yield1(block, code & 0xff);
          }
        }),
        ($each_byte$30.$$arity = 1)
      );

      Opal.def(
        self,
        "$bytesize",
        ($bytesize$31 = function $$bytesize(string) {
          var self = this;

          return string.length;
        }),
        ($bytesize$31.$$arity = 1)
      );
      return (
        (Opal.def(
          self,
          "$binary?",
          ($binary$ques$32 = function () {
            var self = this;

            return true;
          }),
          ($binary$ques$32.$$arity = 0)
        ),
        nil) && "binary?"
      );
    }),
    ($$27.$$s = self),
    ($$27.$$arity = 0),
    $$27)
  );
  $$($nesting, "Encoding").$register(
    "ISO-8859-1",
    $hash2(["aliases", "ascii", "inherits"], {
      aliases: ["ISO8859-1"],
      ascii: true,
      inherits: $$$($$($nesting, "Encoding"), "ASCII_8BIT"),
    })
  );
  $$($nesting, "Encoding").$register(
    "US-ASCII",
    $hash2(["aliases", "ascii", "inherits"], {
      aliases: ["ASCII"],
      ascii: true,
      inherits: $$$($$($nesting, "Encoding"), "ASCII_8BIT"),
    })
  );
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String_b$33,
      $String_bytesize$34,
      $String_each_byte$35,
      $String_bytes$37,
      $String_each_char$38,
      $String_chars$40,
      $String_each_codepoint$41,
      $String_codepoints$42,
      $String_encode$43,
      $String_force_encoding$44,
      $String_getbyte$45,
      $String_initialize_copy$46,
      $String_length$47,
      $String_valid_encoding$ques$48;

    self.$$prototype.internal_encoding =
      self.$$prototype.bytes =
      self.$$prototype.encoding =
        nil;

    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.defineProperty(String.prototype, "bytes", nil);
    Opal.defineProperty(
      String.prototype,
      "encoding",
      $$$($$($nesting, "Encoding"), "UTF_8")
    );
    Opal.defineProperty(
      String.prototype,
      "internal_encoding",
      $$$($$($nesting, "Encoding"), "UTF_8")
    );

    Opal.def(
      self,
      "$b",
      ($String_b$33 = function $$b() {
        var self = this;

        return self.$dup().$force_encoding("binary");
      }),
      ($String_b$33.$$arity = 0)
    );

    Opal.def(
      self,
      "$bytesize",
      ($String_bytesize$34 = function $$bytesize() {
        var self = this;

        return self.internal_encoding.$bytesize(self);
      }),
      ($String_bytesize$34.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_byte",
      ($String_each_byte$35 = function $$each_byte() {
        var $iter = $String_each_byte$35.$$p,
          block = $iter || nil,
          $$36,
          self = this;

        if ($iter) $String_each_byte$35.$$p = null;

        if ($iter) $String_each_byte$35.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_byte"],
            (($$36 = function () {
              var self = $$36.$$s == null ? this : $$36.$$s;

              return self.$bytesize();
            }),
            ($$36.$$s = self),
            ($$36.$$arity = 0),
            $$36)
          );
        }
        $send(self.internal_encoding, "each_byte", [self], block.$to_proc());
        return self;
      }),
      ($String_each_byte$35.$$arity = 0)
    );

    Opal.def(
      self,
      "$bytes",
      ($String_bytes$37 = function $$bytes() {
        var self = this,
          $ret_or_4 = nil;

        if (typeof self === "string") {
          return new String(self).$each_byte().$to_a();
        }
        self.bytes = (function () {
          if ($truthy(($ret_or_4 = self.bytes))) {
            return $ret_or_4;
          } else {
            return self.$each_byte().$to_a();
          }
          return nil;
        })();
        return self.bytes.$dup();
      }),
      ($String_bytes$37.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_char",
      ($String_each_char$38 = function $$each_char() {
        var $iter = $String_each_char$38.$$p,
          block = $iter || nil,
          $$39,
          self = this;

        if ($iter) $String_each_char$38.$$p = null;

        if ($iter) $String_each_char$38.$$p = null;
        if (block !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_char"],
            (($$39 = function () {
              var self = $$39.$$s == null ? this : $$39.$$s;

              return self.$length();
            }),
            ($$39.$$s = self),
            ($$39.$$arity = 0),
            $$39)
          );
        }
        $send(self.encoding, "each_char", [self], block.$to_proc());
        return self;
      }),
      ($String_each_char$38.$$arity = 0)
    );

    Opal.def(
      self,
      "$chars",
      ($String_chars$40 = function $$chars() {
        var $iter = $String_chars$40.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $String_chars$40.$$p = null;

        if ($iter) $String_chars$40.$$p = null;
        if ($truthy(block)) {
        } else {
          return self.$each_char().$to_a();
        }
        return $send(self, "each_char", [], block.$to_proc());
      }),
      ($String_chars$40.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_codepoint",
      ($String_each_codepoint$41 = function $$each_codepoint() {
        var $iter = $String_each_codepoint$41.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $String_each_codepoint$41.$$p = null;

        if ($iter) $String_each_codepoint$41.$$p = null;
        if (block !== nil) {
        } else {
          return self.$enum_for("each_codepoint");
        }

        for (var i = 0, length = self.length; i < length; i++) {
          Opal.yield1(block, self.codePointAt(i));
        }
        return self;
      }),
      ($String_each_codepoint$41.$$arity = 0)
    );

    Opal.def(
      self,
      "$codepoints",
      ($String_codepoints$42 = function $$codepoints() {
        var $iter = $String_codepoints$42.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $String_codepoints$42.$$p = null;

        if ($iter) $String_codepoints$42.$$p = null;
        if (block !== nil) {
          return $send(self, "each_codepoint", [], block.$to_proc());
        }
        return self.$each_codepoint().$to_a();
      }),
      ($String_codepoints$42.$$arity = 0)
    );

    Opal.def(
      self,
      "$encode",
      ($String_encode$43 = function $$encode(encoding) {
        var self = this;

        return Opal.enc(self, encoding);
      }),
      ($String_encode$43.$$arity = 1)
    );

    Opal.def(
      self,
      "$force_encoding",
      ($String_force_encoding$44 = function $$force_encoding(encoding) {
        var self = this;

        var str = self;

        if (encoding === str.encoding) {
          return str;
        }

        encoding = $$($nesting, "Opal")["$coerce_to!"](
          encoding,
          $$($nesting, "String"),
          "to_s"
        );
        encoding = $$($nesting, "Encoding").$find(encoding);

        if (encoding === str.encoding) {
          return str;
        }

        str = Opal.set_encoding(str, encoding);

        return str;
      }),
      ($String_force_encoding$44.$$arity = 1)
    );

    Opal.def(
      self,
      "$getbyte",
      ($String_getbyte$45 = function $$getbyte(idx) {
        var self = this,
          string_bytes = nil;

        string_bytes = self.$bytes();
        idx = $$($nesting, "Opal")["$coerce_to!"](
          idx,
          $$($nesting, "Integer"),
          "to_int"
        );
        if ($truthy($rb_lt(string_bytes.$length(), idx))) {
          return nil;
        }
        return string_bytes["$[]"](idx);
      }),
      ($String_getbyte$45.$$arity = 1)
    );

    Opal.def(
      self,
      "$initialize_copy",
      ($String_initialize_copy$46 = function $$initialize_copy(other) {
        var self = this;

        return (
          "" +
          "\n" +
          "      self.encoding = other.encoding;\n" +
          "      self.internal_encoding = other.internal_encoding;\n" +
          "    "
        );
      }),
      ($String_initialize_copy$46.$$arity = 1)
    );

    Opal.def(
      self,
      "$length",
      ($String_length$47 = function $$length() {
        var self = this;

        return self.length;
      }),
      ($String_length$47.$$arity = 0)
    );
    $alias(self, "size", "length");
    return (
      (Opal.def(
        self,
        "$valid_encoding?",
        ($String_valid_encoding$ques$48 = function () {
          var self = this;

          return true;
        }),
        ($String_valid_encoding$ques$48.$$arity = 0)
      ),
      nil) && "valid_encoding?"
    );
  })($nesting[0], null, $nesting);

  $writer = [$$$($$($nesting, "Encoding"), "UTF_8")];
  $send($$($nesting, "Encoding"), "default_external=", Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];
};

Opal.modules["corelib/math"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $type_error = Opal.type_error,
    $module = Opal.module,
    $truthy = Opal.truthy;

  Opal.add_stubs([
    "$new",
    "$raise",
    "$Float",
    "$Integer",
    "$module_function",
    "$checked",
    "$float!",
    "$===",
    "$gamma",
    "$-",
    "$integer!",
    "$/",
    "$infinite?",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Math");

    var $nesting = [self].concat($parent_nesting),
      $Math_checked$1,
      $Math_float$excl$2,
      $Math_integer$excl$3,
      $Math_acos$4,
      $Math_acosh$5,
      $Math_asin$6,
      $Math_asinh$7,
      $Math_atan$8,
      $Math_atan2$9,
      $Math_atanh$10,
      $Math_cbrt$11,
      $Math_cos$12,
      $Math_cosh$13,
      $Math_erf$14,
      $Math_erfc$15,
      $Math_exp$16,
      $Math_frexp$17,
      $Math_gamma$18,
      $Math_hypot$19,
      $Math_ldexp$20,
      $Math_lgamma$21,
      $Math_log$22,
      $Math_log10$23,
      $Math_log2$24,
      $Math_sin$25,
      $Math_sinh$26,
      $Math_sqrt$27,
      $Math_tan$28,
      $Math_tanh$29;

    Opal.const_set($nesting[0], "E", Math.E);
    Opal.const_set($nesting[0], "PI", Math.PI);
    Opal.const_set(
      $nesting[0],
      "DomainError",
      $$($nesting, "Class").$new($$($nesting, "StandardError"))
    );
    Opal.defs(
      self,
      "$checked",
      ($Math_checked$1 = function $$checked(method, $a) {
        var $post_args,
          args,
          self = this;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        args = $post_args;

        if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
          return NaN;
        }

        var result = Math[method].apply(null, args);

        if (isNaN(result)) {
          self.$raise(
            $$($nesting, "DomainError"),
            "" + 'Numerical argument is out of domain - "' + method + '"'
          );
        }

        return result;
      }),
      ($Math_checked$1.$$arity = -2)
    );
    Opal.defs(
      self,
      "$float!",
      ($Math_float$excl$2 = function (value) {
        var self = this;

        try {
          return self.$Float(value);
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, "ArgumentError")])) {
            try {
              return self.$raise($type_error(value, $$($nesting, "Float")));
            } finally {
              Opal.pop_exception();
            }
          } else {
            throw $err;
          }
        }
      }),
      ($Math_float$excl$2.$$arity = 1)
    );
    Opal.defs(
      self,
      "$integer!",
      ($Math_integer$excl$3 = function (value) {
        var self = this;

        try {
          return self.$Integer(value);
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, "ArgumentError")])) {
            try {
              return self.$raise($type_error(value, $$($nesting, "Integer")));
            } finally {
              Opal.pop_exception();
            }
          } else {
            throw $err;
          }
        }
      }),
      ($Math_integer$excl$3.$$arity = 1)
    );
    self.$module_function();

    Opal.def(
      self,
      "$acos",
      ($Math_acos$4 = function $$acos(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "acos",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_acos$4.$$arity = 1)
    );
    if ($truthy(typeof Math.acosh !== "undefined")) {
    } else {
      Math.acosh = function (x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      };
    }

    Opal.def(
      self,
      "$acosh",
      ($Math_acosh$5 = function $$acosh(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "acosh",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_acosh$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$asin",
      ($Math_asin$6 = function $$asin(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "asin",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_asin$6.$$arity = 1)
    );
    if ($truthy(typeof Math.asinh !== "undefined")) {
    } else {
      Math.asinh = function (x) {
        return Math.log(x + Math.sqrt(x * x + 1));
      };
    }

    Opal.def(
      self,
      "$asinh",
      ($Math_asinh$7 = function $$asinh(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "asinh",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_asinh$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$atan",
      ($Math_atan$8 = function $$atan(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "atan",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_atan$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$atan2",
      ($Math_atan2$9 = function $$atan2(y, x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "atan2",
          $$($nesting, "Math")["$float!"](y),
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_atan2$9.$$arity = 2)
    );
    if ($truthy(typeof Math.atanh !== "undefined")) {
    } else {
      Math.atanh = function (x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      };
    }

    Opal.def(
      self,
      "$atanh",
      ($Math_atanh$10 = function $$atanh(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "atanh",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_atanh$10.$$arity = 1)
    );
    if ($truthy(typeof Math.cbrt !== "undefined")) {
    } else {
      Math.cbrt = function (x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r = x,
          ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + ((1.0 / 3.0) * x) / (r * r);
        r = (2.0 / 3.0) * r + ((1.0 / 3.0) * x) / (r * r);
        r = (2.0 / 3.0) * r + ((1.0 / 3.0) * x) / (r * r);
        r = (2.0 / 3.0) * r + ((1.0 / 3.0) * x) / (r * r);

        return r;
      };
    }

    Opal.def(
      self,
      "$cbrt",
      ($Math_cbrt$11 = function $$cbrt(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "cbrt",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_cbrt$11.$$arity = 1)
    );

    Opal.def(
      self,
      "$cos",
      ($Math_cos$12 = function $$cos(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "cos",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_cos$12.$$arity = 1)
    );
    if ($truthy(typeof Math.cosh !== "undefined")) {
    } else {
      Math.cosh = function (x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      };
    }

    Opal.def(
      self,
      "$cosh",
      ($Math_cosh$13 = function $$cosh(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "cosh",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_cosh$13.$$arity = 1)
    );
    if ($truthy(typeof Math.erf !== "undefined")) {
    } else {
      Opal.defineProperty(Math, "erf", function (x) {
        var A1 = 0.254829592,
          A2 = -0.284496736,
          A3 = 1.421413741,
          A4 = -1.453152027,
          A5 = 1.061405429,
          P = 0.3275911;

        var sign = 1;

        if (x < 0) {
          sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y =
          1.0 -
          ((((A5 * t + A4) * t + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    }

    Opal.def(
      self,
      "$erf",
      ($Math_erf$14 = function $$erf(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "erf",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_erf$14.$$arity = 1)
    );
    if ($truthy(typeof Math.erfc !== "undefined")) {
    } else {
      Opal.defineProperty(Math, "erfc", function (x) {
        var z = Math.abs(x),
          t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
          A2 = t * A1 + 1.48851587,
          A3 = t * A2 + -1.13520398,
          A4 = t * A3 + 0.27886807,
          A5 = t * A4 + -0.18628806,
          A6 = t * A5 + 0.09678418,
          A7 = t * A6 + 0.37409196,
          A8 = t * A7 + 1.00002368,
          A9 = t * A8,
          A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        } else {
          return a;
        }
      });
    }

    Opal.def(
      self,
      "$erfc",
      ($Math_erfc$15 = function $$erfc(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "erfc",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_erfc$15.$$arity = 1)
    );

    Opal.def(
      self,
      "$exp",
      ($Math_exp$16 = function $$exp(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "exp",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_exp$16.$$arity = 1)
    );

    Opal.def(
      self,
      "$frexp",
      ($Math_frexp$17 = function $$frexp(x) {
        var self = this;

        x = $$($nesting, "Math")["$float!"](x);

        if (isNaN(x)) {
          return [NaN, 0];
        }

        var ex = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

        return [frac, ex];
      }),
      ($Math_frexp$17.$$arity = 1)
    );

    Opal.def(
      self,
      "$gamma",
      ($Math_gamma$18 = function $$gamma(n) {
        var self = this;

        n = $$($nesting, "Math")["$float!"](n);

        var i, t, x, value, result, twoN, threeN, fourN, fiveN;

        var G = 4.7421875;

        var P = [
          0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
          14.136097974741747174, -0.49191381609762019978,
          0.33994649984811888699e-4, 0.46523628927048575665e-4,
          -0.98374475304879564677e-4, 0.15808870322491248884e-3,
          -0.21026444172410488319e-3, 0.2174396181152126432e-3,
          -0.16431810653676389022e-3, 0.84418223983852743293e-4,
          -0.2619083840158140867e-4, 0.36899182659531622704e-5,
        ];

        if (isNaN(n)) {
          return NaN;
        }

        if (n === 0 && 1 / n < 0) {
          return -Infinity;
        }

        if (n === -1 || n === -Infinity) {
          self.$raise(
            $$($nesting, "DomainError"),
            'Numerical argument is out of domain - "gamma"'
          );
        }

        if ($$($nesting, "Integer")["$==="](n)) {
          if (n <= 0) {
            return isFinite(n) ? Infinity : NaN;
          }

          if (n > 171) {
            return Infinity;
          }

          value = n - 2;
          result = n - 1;

          while (value > 1) {
            result *= value;
            value--;
          }

          if (result == 0) {
            result = 1;
          }

          return result;
        }

        if (n < 0.5) {
          return (
            Math.PI /
            (Math.sin(Math.PI * n) *
              $$($nesting, "Math").$gamma($rb_minus(1, n)))
          );
        }

        if (n >= 171.35) {
          return Infinity;
        }

        if (n > 85.0) {
          twoN = n * n;
          threeN = twoN * n;
          fourN = threeN * n;
          fiveN = fourN * n;

          return (
            Math.sqrt((2 * Math.PI) / n) *
            Math.pow(n / Math.E, n) *
            (1 +
              1 / (12 * n) +
              1 / (288 * twoN) -
              139 / (51840 * threeN) -
              571 / (2488320 * fourN) +
              163879 / (209018880 * fiveN) +
              5246819 / (75246796800 * fiveN * n))
          );
        }

        n -= 1;
        x = P[0];

        for (i = 1; i < P.length; ++i) {
          x += P[i] / (n + i);
        }

        t = n + G + 0.5;

        return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
      }),
      ($Math_gamma$18.$$arity = 1)
    );
    if ($truthy(typeof Math.hypot !== "undefined")) {
    } else {
      Math.hypot = function (x, y) {
        return Math.sqrt(x * x + y * y);
      };
    }

    Opal.def(
      self,
      "$hypot",
      ($Math_hypot$19 = function $$hypot(x, y) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "hypot",
          $$($nesting, "Math")["$float!"](x),
          $$($nesting, "Math")["$float!"](y)
        );
      }),
      ($Math_hypot$19.$$arity = 2)
    );

    Opal.def(
      self,
      "$ldexp",
      ($Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
        var self = this;

        mantissa = $$($nesting, "Math")["$float!"](mantissa);
        exponent = $$($nesting, "Math")["$integer!"](exponent);

        if (isNaN(exponent)) {
          self.$raise(
            $$($nesting, "RangeError"),
            "float NaN out of range of integer"
          );
        }

        return mantissa * Math.pow(2, exponent);
      }),
      ($Math_ldexp$20.$$arity = 2)
    );

    Opal.def(
      self,
      "$lgamma",
      ($Math_lgamma$21 = function $$lgamma(n) {
        var self = this;

        if (n == -1) {
          return [Infinity, 1];
        } else {
          return [
            Math.log(Math.abs($$($nesting, "Math").$gamma(n))),
            $$($nesting, "Math").$gamma(n) < 0 ? -1 : 1,
          ];
        }
      }),
      ($Math_lgamma$21.$$arity = 1)
    );

    Opal.def(
      self,
      "$log",
      ($Math_log$22 = function $$log(x, base) {
        var self = this;

        if ($truthy($$($nesting, "String")["$==="](x))) {
          self.$raise($type_error(x, $$($nesting, "Float")));
        }
        if ($truthy(base == null)) {
          return $$($nesting, "Math").$checked(
            "log",
            $$($nesting, "Math")["$float!"](x)
          );
        } else {
          if ($truthy($$($nesting, "String")["$==="](base))) {
            self.$raise($type_error(base, $$($nesting, "Float")));
          }
          return $rb_divide(
            $$($nesting, "Math").$checked(
              "log",
              $$($nesting, "Math")["$float!"](x)
            ),
            $$($nesting, "Math").$checked(
              "log",
              $$($nesting, "Math")["$float!"](base)
            )
          );
        }
      }),
      ($Math_log$22.$$arity = -2)
    );
    if ($truthy(typeof Math.log10 !== "undefined")) {
    } else {
      Math.log10 = function (x) {
        return Math.log(x) / Math.LN10;
      };
    }

    Opal.def(
      self,
      "$log10",
      ($Math_log10$23 = function $$log10(x) {
        var self = this;

        if ($truthy($$($nesting, "String")["$==="](x))) {
          self.$raise($type_error(x, $$($nesting, "Float")));
        }
        return $$($nesting, "Math").$checked(
          "log10",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_log10$23.$$arity = 1)
    );
    if ($truthy(typeof Math.log2 !== "undefined")) {
    } else {
      Math.log2 = function (x) {
        return Math.log(x) / Math.LN2;
      };
    }

    Opal.def(
      self,
      "$log2",
      ($Math_log2$24 = function $$log2(x) {
        var self = this;

        if ($truthy($$($nesting, "String")["$==="](x))) {
          self.$raise($type_error(x, $$($nesting, "Float")));
        }
        return $$($nesting, "Math").$checked(
          "log2",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_log2$24.$$arity = 1)
    );

    Opal.def(
      self,
      "$sin",
      ($Math_sin$25 = function $$sin(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "sin",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_sin$25.$$arity = 1)
    );
    if ($truthy(typeof Math.sinh !== "undefined")) {
    } else {
      Math.sinh = function (x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      };
    }

    Opal.def(
      self,
      "$sinh",
      ($Math_sinh$26 = function $$sinh(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "sinh",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_sinh$26.$$arity = 1)
    );

    Opal.def(
      self,
      "$sqrt",
      ($Math_sqrt$27 = function $$sqrt(x) {
        var self = this;

        return $$($nesting, "Math").$checked(
          "sqrt",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_sqrt$27.$$arity = 1)
    );

    Opal.def(
      self,
      "$tan",
      ($Math_tan$28 = function $$tan(x) {
        var self = this;

        x = $$($nesting, "Math")["$float!"](x);
        if ($truthy(x["$infinite?"]())) {
          return $$$($$($nesting, "Float"), "NAN");
        }
        return $$($nesting, "Math").$checked(
          "tan",
          $$($nesting, "Math")["$float!"](x)
        );
      }),
      ($Math_tan$28.$$arity = 1)
    );
    if ($truthy(typeof Math.tanh !== "undefined")) {
    } else {
      Math.tanh = function (x) {
        if (x == Infinity) {
          return 1;
        } else if (x == -Infinity) {
          return -1;
        } else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      };
    }
    return (
      (Opal.def(
        self,
        "$tanh",
        ($Math_tanh$29 = function $$tanh(x) {
          var self = this;

          return $$($nesting, "Math").$checked(
            "tanh",
            $$($nesting, "Math")["$float!"](x)
          );
        }),
        ($Math_tanh$29.$$arity = 1)
      ),
      nil) && "tanh"
    );
  })($nesting[0], $nesting);
};

Opal.modules["corelib/complex/base"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $truthy = Opal.truthy,
    $klass = Opal.klass;

  Opal.add_stubs(["$new", "$from_string"]);

  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_Complex$1;

    return (
      (Opal.def(
        self,
        "$Complex",
        ($Kernel_Complex$1 = function $$Complex(real, imag) {
          var self = this;

          if (imag == null) {
            imag = nil;
          }
          if ($truthy(imag)) {
            return $$($nesting, "Complex").$new(real, imag);
          } else {
            return $$($nesting, "Complex").$new(real, 0);
          }
        }),
        ($Kernel_Complex$1.$$arity = -2)
      ),
      nil) && "Complex"
    );
  })($nesting[0], $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String_to_c$2;

    return (
      (Opal.def(
        self,
        "$to_c",
        ($String_to_c$2 = function $$to_c() {
          var self = this;

          return $$($nesting, "Complex").$from_string(self);
        }),
        ($String_to_c$2.$$arity = 0)
      ),
      nil) && "to_c"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/complex"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$require",
    "$===",
    "$real?",
    "$raise",
    "$new",
    "$*",
    "$cos",
    "$sin",
    "$attr_reader",
    "$class",
    "$==",
    "$real",
    "$imag",
    "$Complex",
    "$-@",
    "$+",
    "$__coerced__",
    "$-",
    "$nan?",
    "$/",
    "$conj",
    "$abs2",
    "$quo",
    "$polar",
    "$exp",
    "$log",
    "$>",
    "$!=",
    "$divmod",
    "$**",
    "$hypot",
    "$atan2",
    "$lcm",
    "$denominator",
    "$finite?",
    "$infinite?",
    "$numerator",
    "$abs",
    "$arg",
    "$rationalize",
    "$to_f",
    "$to_i",
    "$to_r",
    "$inspect",
    "$positive?",
    "$zero?",
    "$Rational",
  ]);

  self.$require("corelib/numeric");
  self.$require("corelib/complex/base");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Complex");

    var $nesting = [self].concat($parent_nesting),
      $Complex_rect$1,
      $Complex_polar$2,
      $Complex_initialize$3,
      $Complex_coerce$4,
      $Complex_$eq_eq$5,
      $Complex_$minus$$6,
      $Complex_$plus$7,
      $Complex_$minus$8,
      $Complex_$$9,
      $Complex_$slash$10,
      $Complex_$$$11,
      $Complex_abs$12,
      $Complex_abs2$13,
      $Complex_angle$14,
      $Complex_conj$15,
      $Complex_denominator$16,
      $Complex_eql$ques$17,
      $Complex_fdiv$18,
      $Complex_finite$ques$19,
      $Complex_hash$20,
      $Complex_infinite$ques$21,
      $Complex_inspect$22,
      $Complex_numerator$23,
      $Complex_polar$24,
      $Complex_rationalize$25,
      $Complex_real$ques$26,
      $Complex_rect$27,
      $Complex_to_f$28,
      $Complex_to_i$29,
      $Complex_to_r$30,
      $Complex_to_s$31,
      $Complex_from_string$32;

    self.$$prototype.real = self.$$prototype.imag = nil;

    Opal.defs(
      self,
      "$rect",
      ($Complex_rect$1 = function $$rect(real, imag) {
        var self = this,
          $ret_or_1 = nil,
          $ret_or_2 = nil,
          $ret_or_3 = nil;

        if (imag == null) {
          imag = 0;
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_1 = (function () {
                    if (
                      $truthy(
                        ($ret_or_2 = (function () {
                          if (
                            $truthy(
                              ($ret_or_3 = $$($nesting, "Numeric")["$==="](
                                real
                              ))
                            )
                          ) {
                            return real["$real?"]();
                          } else {
                            return $ret_or_3;
                          }
                          return nil;
                        })())
                      )
                    ) {
                      return $$($nesting, "Numeric")["$==="](imag);
                    } else {
                      return $ret_or_2;
                    }
                    return nil;
                  })())
                )
              ) {
                return imag["$real?"]();
              } else {
                return $ret_or_1;
              }
              return nil;
            })()
          )
        ) {
        } else {
          self.$raise($$($nesting, "TypeError"), "not a real");
        }
        return self.$new(real, imag);
      }),
      ($Complex_rect$1.$$arity = -2)
    );
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return $alias(self, "rectangular", "rect");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(
      self,
      "$polar",
      ($Complex_polar$2 = function $$polar(r, theta) {
        var self = this,
          $ret_or_4 = nil,
          $ret_or_5 = nil,
          $ret_or_6 = nil;

        if (theta == null) {
          theta = 0;
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_4 = (function () {
                    if (
                      $truthy(
                        ($ret_or_5 = (function () {
                          if (
                            $truthy(
                              ($ret_or_6 = $$($nesting, "Numeric")["$==="](r))
                            )
                          ) {
                            return r["$real?"]();
                          } else {
                            return $ret_or_6;
                          }
                          return nil;
                        })())
                      )
                    ) {
                      return $$($nesting, "Numeric")["$==="](theta);
                    } else {
                      return $ret_or_5;
                    }
                    return nil;
                  })())
                )
              ) {
                return theta["$real?"]();
              } else {
                return $ret_or_4;
              }
              return nil;
            })()
          )
        ) {
        } else {
          self.$raise($$($nesting, "TypeError"), "not a real");
        }
        return self.$new(
          $rb_times(r, $$($nesting, "Math").$cos(theta)),
          $rb_times(r, $$($nesting, "Math").$sin(theta))
        );
      }),
      ($Complex_polar$2.$$arity = -2)
    );
    self.$attr_reader("real", "imag");

    Opal.def(
      self,
      "$initialize",
      ($Complex_initialize$3 = function $$initialize(real, imag) {
        var self = this;

        if (imag == null) {
          imag = 0;
        }
        self.real = real;
        return (self.imag = imag);
      }),
      ($Complex_initialize$3.$$arity = -2)
    );

    Opal.def(
      self,
      "$coerce",
      ($Complex_coerce$4 = function $$coerce(other) {
        var self = this,
          $ret_or_7 = nil;

        if ($truthy($$($nesting, "Complex")["$==="](other))) {
          return [other, self];
        } else if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_7 = $$($nesting, "Numeric")["$==="](other)))
              ) {
                return other["$real?"]();
              } else {
                return $ret_or_7;
              }
              return nil;
            })()
          )
        ) {
          return [$$($nesting, "Complex").$new(other, 0), self];
        } else {
          return self.$raise(
            $$($nesting, "TypeError"),
            "" + other.$class() + " can't be coerced into Complex"
          );
        }
      }),
      ($Complex_coerce$4.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($Complex_$eq_eq$5 = function (other) {
        var self = this,
          $ret_or_8 = nil,
          $ret_or_9 = nil,
          $ret_or_10 = nil;

        if ($truthy($$($nesting, "Complex")["$==="](other))) {
          if ($truthy(($ret_or_8 = self.real["$=="](other.$real())))) {
            return self.imag["$=="](other.$imag());
          } else {
            return $ret_or_8;
          }
        } else if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_9 = $$($nesting, "Numeric")["$==="](other)))
              ) {
                return other["$real?"]();
              } else {
                return $ret_or_9;
              }
              return nil;
            })()
          )
        ) {
          if ($truthy(($ret_or_10 = self.real["$=="](other)))) {
            return self.imag["$=="](0);
          } else {
            return $ret_or_10;
          }
        } else {
          return other["$=="](self);
        }
      }),
      ($Complex_$eq_eq$5.$$arity = 1)
    );

    Opal.def(
      self,
      "$-@",
      ($Complex_$minus$$6 = function () {
        var self = this;

        return self.$Complex(self.real["$-@"](), self.imag["$-@"]());
      }),
      ($Complex_$minus$$6.$$arity = 0)
    );

    Opal.def(
      self,
      "$+",
      ($Complex_$plus$7 = function (other) {
        var self = this,
          $ret_or_11 = nil;

        if ($truthy($$($nesting, "Complex")["$==="](other))) {
          return self.$Complex(
            $rb_plus(self.real, other.$real()),
            $rb_plus(self.imag, other.$imag())
          );
        } else if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_11 = $$($nesting, "Numeric")["$==="](other)))
              ) {
                return other["$real?"]();
              } else {
                return $ret_or_11;
              }
              return nil;
            })()
          )
        ) {
          return self.$Complex($rb_plus(self.real, other), self.imag);
        } else {
          return self.$__coerced__("+", other);
        }
      }),
      ($Complex_$plus$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$-",
      ($Complex_$minus$8 = function (other) {
        var self = this,
          $ret_or_12 = nil;

        if ($truthy($$($nesting, "Complex")["$==="](other))) {
          return self.$Complex(
            $rb_minus(self.real, other.$real()),
            $rb_minus(self.imag, other.$imag())
          );
        } else if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_12 = $$($nesting, "Numeric")["$==="](other)))
              ) {
                return other["$real?"]();
              } else {
                return $ret_or_12;
              }
              return nil;
            })()
          )
        ) {
          return self.$Complex($rb_minus(self.real, other), self.imag);
        } else {
          return self.$__coerced__("-", other);
        }
      }),
      ($Complex_$minus$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$*",
      ($Complex_$$9 = function (other) {
        var self = this,
          $ret_or_13 = nil;

        if ($truthy($$($nesting, "Complex")["$==="](other))) {
          return self.$Complex(
            $rb_minus(
              $rb_times(self.real, other.$real()),
              $rb_times(self.imag, other.$imag())
            ),
            $rb_plus(
              $rb_times(self.real, other.$imag()),
              $rb_times(self.imag, other.$real())
            )
          );
        } else if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_13 = $$($nesting, "Numeric")["$==="](other)))
              ) {
                return other["$real?"]();
              } else {
                return $ret_or_13;
              }
              return nil;
            })()
          )
        ) {
          return self.$Complex(
            $rb_times(self.real, other),
            $rb_times(self.imag, other)
          );
        } else {
          return self.$__coerced__("*", other);
        }
      }),
      ($Complex_$$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$/",
      ($Complex_$slash$10 = function (other) {
        var self = this,
          $ret_or_14 = nil,
          $ret_or_15 = nil,
          $ret_or_16 = nil,
          $ret_or_17 = nil,
          $ret_or_18 = nil,
          $ret_or_19 = nil,
          $ret_or_20 = nil,
          $ret_or_21 = nil;

        if ($truthy($$($nesting, "Complex")["$==="](other))) {
          if (
            $truthy(
              (function () {
                if (
                  $truthy(
                    ($ret_or_14 = (function () {
                      if (
                        $truthy(
                          ($ret_or_15 = (function () {
                            if (
                              $truthy(
                                ($ret_or_16 = (function () {
                                  if (
                                    $truthy(
                                      ($ret_or_17 = $$($nesting, "Number")[
                                        "$==="
                                      ](self.real))
                                    )
                                  ) {
                                    return self.real["$nan?"]();
                                  } else {
                                    return $ret_or_17;
                                  }
                                  return nil;
                                })())
                              )
                            ) {
                              return $ret_or_16;
                            } else {
                              if (
                                $truthy(
                                  ($ret_or_18 = $$($nesting, "Number")["$==="](
                                    self.imag
                                  ))
                                )
                              ) {
                                return self.imag["$nan?"]();
                              } else {
                                return $ret_or_18;
                              }
                            }
                            return nil;
                          })())
                        )
                      ) {
                        return $ret_or_15;
                      } else {
                        if (
                          $truthy(
                            ($ret_or_19 = $$($nesting, "Number")["$==="](
                              other.$real()
                            ))
                          )
                        ) {
                          return other.$real()["$nan?"]();
                        } else {
                          return $ret_or_19;
                        }
                      }
                      return nil;
                    })())
                  )
                ) {
                  return $ret_or_14;
                } else {
                  if (
                    $truthy(
                      ($ret_or_20 = $$($nesting, "Number")["$==="](
                        other.$imag()
                      ))
                    )
                  ) {
                    return other.$imag()["$nan?"]();
                  } else {
                    return $ret_or_20;
                  }
                }
                return nil;
              })()
            )
          ) {
            return $$($nesting, "Complex").$new(
              $$$($$($nesting, "Float"), "NAN"),
              $$$($$($nesting, "Float"), "NAN")
            );
          } else {
            return $rb_divide($rb_times(self, other.$conj()), other.$abs2());
          }
        } else if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_21 = $$($nesting, "Numeric")["$==="](other)))
              ) {
                return other["$real?"]();
              } else {
                return $ret_or_21;
              }
              return nil;
            })()
          )
        ) {
          return self.$Complex(self.real.$quo(other), self.imag.$quo(other));
        } else {
          return self.$__coerced__("/", other);
        }
      }),
      ($Complex_$slash$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$**",
      ($Complex_$$$11 = function (other) {
        var $a,
          $b,
          $c,
          $d,
          self = this,
          r = nil,
          theta = nil,
          ore = nil,
          oim = nil,
          nr = nil,
          ntheta = nil,
          x = nil,
          z = nil,
          n = nil,
          div = nil,
          mod = nil,
          $ret_or_22 = nil;

        if (other["$=="](0)) {
          return $$($nesting, "Complex").$new(1, 0);
        }
        if ($truthy($$($nesting, "Complex")["$==="](other))) {
          ($b = self.$polar()),
            ($a = Opal.to_ary($b)),
            (r = $a[0] == null ? nil : $a[0]),
            (theta = $a[1] == null ? nil : $a[1]),
            $b;
          ore = other.$real();
          oim = other.$imag();
          nr = $$($nesting, "Math").$exp(
            $rb_minus(
              $rb_times(ore, $$($nesting, "Math").$log(r)),
              $rb_times(oim, theta)
            )
          );
          ntheta = $rb_plus(
            $rb_times(theta, ore),
            $rb_times(oim, $$($nesting, "Math").$log(r))
          );
          return $$($nesting, "Complex").$polar(nr, ntheta);
        } else if ($truthy($$($nesting, "Integer")["$==="](other))) {
          if ($truthy($rb_gt(other, 0))) {
            x = self;
            z = x;
            n = $rb_minus(other, 1);
            while ($truthy(n["$!="](0))) {
              ($c = n.$divmod(2)),
                ($b = Opal.to_ary($c)),
                (div = $b[0] == null ? nil : $b[0]),
                (mod = $b[1] == null ? nil : $b[1]),
                $c;
              while (mod["$=="](0)) {
                x = self.$Complex(
                  $rb_minus(
                    $rb_times(x.$real(), x.$real()),
                    $rb_times(x.$imag(), x.$imag())
                  ),
                  $rb_times($rb_times(2, x.$real()), x.$imag())
                );
                n = div;
                ($d = n.$divmod(2)),
                  ($c = Opal.to_ary($d)),
                  (div = $c[0] == null ? nil : $c[0]),
                  (mod = $c[1] == null ? nil : $c[1]),
                  $d;
              }
              z = $rb_times(z, x);
              n = $rb_minus(n, 1);
            }
            return z;
          } else {
            return $rb_divide($$($nesting, "Rational").$new(1, 1), self)["$**"](
              other["$-@"]()
            );
          }
        } else if (
          $truthy(
            (function () {
              if (
                $truthy(($ret_or_22 = $$($nesting, "Float")["$==="](other)))
              ) {
                return $ret_or_22;
              } else {
                return $$($nesting, "Rational")["$==="](other);
              }
              return nil;
            })()
          )
        ) {
          ($b = self.$polar()),
            ($a = Opal.to_ary($b)),
            (r = $a[0] == null ? nil : $a[0]),
            (theta = $a[1] == null ? nil : $a[1]),
            $b;
          return $$($nesting, "Complex").$polar(
            r["$**"](other),
            $rb_times(theta, other)
          );
        } else {
          return self.$__coerced__("**", other);
        }
      }),
      ($Complex_$$$11.$$arity = 1)
    );

    Opal.def(
      self,
      "$abs",
      ($Complex_abs$12 = function $$abs() {
        var self = this;

        return $$($nesting, "Math").$hypot(self.real, self.imag);
      }),
      ($Complex_abs$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$abs2",
      ($Complex_abs2$13 = function $$abs2() {
        var self = this;

        return $rb_plus(
          $rb_times(self.real, self.real),
          $rb_times(self.imag, self.imag)
        );
      }),
      ($Complex_abs2$13.$$arity = 0)
    );

    Opal.def(
      self,
      "$angle",
      ($Complex_angle$14 = function $$angle() {
        var self = this;

        return $$($nesting, "Math").$atan2(self.imag, self.real);
      }),
      ($Complex_angle$14.$$arity = 0)
    );
    $alias(self, "arg", "angle");

    Opal.def(
      self,
      "$conj",
      ($Complex_conj$15 = function $$conj() {
        var self = this;

        return self.$Complex(self.real, self.imag["$-@"]());
      }),
      ($Complex_conj$15.$$arity = 0)
    );
    $alias(self, "conjugate", "conj");

    Opal.def(
      self,
      "$denominator",
      ($Complex_denominator$16 = function $$denominator() {
        var self = this;

        return self.real.$denominator().$lcm(self.imag.$denominator());
      }),
      ($Complex_denominator$16.$$arity = 0)
    );
    $alias(self, "divide", "/");

    Opal.def(
      self,
      "$eql?",
      ($Complex_eql$ques$17 = function (other) {
        var self = this,
          $ret_or_23 = nil,
          $ret_or_24 = nil;

        if (
          $truthy(
            ($ret_or_23 = (function () {
              if (
                $truthy(($ret_or_24 = $$($nesting, "Complex")["$==="](other)))
              ) {
                return self.real.$class()["$=="](self.imag.$class());
              } else {
                return $ret_or_24;
              }
              return nil;
            })())
          )
        ) {
          return self["$=="](other);
        } else {
          return $ret_or_23;
        }
      }),
      ($Complex_eql$ques$17.$$arity = 1)
    );

    Opal.def(
      self,
      "$fdiv",
      ($Complex_fdiv$18 = function $$fdiv(other) {
        var self = this;

        if ($truthy($$($nesting, "Numeric")["$==="](other))) {
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + other.$class() + " can't be coerced into Complex"
          );
        }
        return $rb_divide(self, other);
      }),
      ($Complex_fdiv$18.$$arity = 1)
    );

    Opal.def(
      self,
      "$finite?",
      ($Complex_finite$ques$19 = function () {
        var self = this,
          $ret_or_25 = nil;

        if ($truthy(($ret_or_25 = self.real["$finite?"]()))) {
          return self.imag["$finite?"]();
        } else {
          return $ret_or_25;
        }
      }),
      ($Complex_finite$ques$19.$$arity = 0)
    );

    Opal.def(
      self,
      "$hash",
      ($Complex_hash$20 = function $$hash() {
        var self = this;

        return "" + "Complex:" + self.real + ":" + self.imag;
      }),
      ($Complex_hash$20.$$arity = 0)
    );
    $alias(self, "imaginary", "imag");

    Opal.def(
      self,
      "$infinite?",
      ($Complex_infinite$ques$21 = function () {
        var self = this,
          $ret_or_26 = nil;

        if ($truthy(($ret_or_26 = self.real["$infinite?"]()))) {
          return $ret_or_26;
        } else {
          return self.imag["$infinite?"]();
        }
      }),
      ($Complex_infinite$ques$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$inspect",
      ($Complex_inspect$22 = function $$inspect() {
        var self = this;

        return "" + "(" + self + ")";
      }),
      ($Complex_inspect$22.$$arity = 0)
    );
    $alias(self, "magnitude", "abs");

    Opal.udef(self, "$" + "negative?");

    Opal.def(
      self,
      "$numerator",
      ($Complex_numerator$23 = function $$numerator() {
        var self = this,
          d = nil;

        d = self.$denominator();
        return self.$Complex(
          $rb_times(
            self.real.$numerator(),
            $rb_divide(d, self.real.$denominator())
          ),
          $rb_times(
            self.imag.$numerator(),
            $rb_divide(d, self.imag.$denominator())
          )
        );
      }),
      ($Complex_numerator$23.$$arity = 0)
    );
    $alias(self, "phase", "arg");

    Opal.def(
      self,
      "$polar",
      ($Complex_polar$24 = function $$polar() {
        var self = this;

        return [self.$abs(), self.$arg()];
      }),
      ($Complex_polar$24.$$arity = 0)
    );

    Opal.udef(self, "$" + "positive?");
    $alias(self, "quo", "/");

    Opal.def(
      self,
      "$rationalize",
      ($Complex_rationalize$25 = function $$rationalize(eps) {
        var self = this;

        if (arguments.length > 1) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "wrong number of arguments (" + arguments.length + " for 0..1)"
          );
        }
        if ($truthy(self.imag["$!="](0))) {
          self.$raise(
            $$($nesting, "RangeError"),
            "" + "can't' convert " + self + " into Rational"
          );
        }
        return self.$real().$rationalize(eps);
      }),
      ($Complex_rationalize$25.$$arity = -1)
    );

    Opal.def(
      self,
      "$real?",
      ($Complex_real$ques$26 = function () {
        var self = this;

        return false;
      }),
      ($Complex_real$ques$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$rect",
      ($Complex_rect$27 = function $$rect() {
        var self = this;

        return [self.real, self.imag];
      }),
      ($Complex_rect$27.$$arity = 0)
    );
    $alias(self, "rectangular", "rect");

    Opal.udef(self, "$" + "step");

    Opal.def(
      self,
      "$to_f",
      ($Complex_to_f$28 = function $$to_f() {
        var self = this;

        if (self.imag["$=="](0)) {
        } else {
          self.$raise(
            $$($nesting, "RangeError"),
            "" + "can't convert " + self + " into Float"
          );
        }
        return self.real.$to_f();
      }),
      ($Complex_to_f$28.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_i",
      ($Complex_to_i$29 = function $$to_i() {
        var self = this;

        if (self.imag["$=="](0)) {
        } else {
          self.$raise(
            $$($nesting, "RangeError"),
            "" + "can't convert " + self + " into Integer"
          );
        }
        return self.real.$to_i();
      }),
      ($Complex_to_i$29.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_r",
      ($Complex_to_r$30 = function $$to_r() {
        var self = this;

        if (self.imag["$=="](0)) {
        } else {
          self.$raise(
            $$($nesting, "RangeError"),
            "" + "can't convert " + self + " into Rational"
          );
        }
        return self.real.$to_r();
      }),
      ($Complex_to_r$30.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Complex_to_s$31 = function $$to_s() {
        var self = this,
          result = nil,
          $ret_or_27 = nil,
          $ret_or_28 = nil,
          $ret_or_29 = nil,
          $ret_or_30 = nil,
          $ret_or_31 = nil;

        result = self.real.$inspect();
        result = $rb_plus(
          result,
          (function () {
            if (
              $truthy(
                (function () {
                  if (
                    $truthy(
                      ($ret_or_27 = (function () {
                        if (
                          $truthy(
                            ($ret_or_28 = (function () {
                              if (
                                $truthy(
                                  ($ret_or_29 = $$($nesting, "Number")["$==="](
                                    self.imag
                                  ))
                                )
                              ) {
                                return self.imag["$nan?"]();
                              } else {
                                return $ret_or_29;
                              }
                              return nil;
                            })())
                          )
                        ) {
                          return $ret_or_28;
                        } else {
                          return self.imag["$positive?"]();
                        }
                        return nil;
                      })())
                    )
                  ) {
                    return $ret_or_27;
                  } else {
                    return self.imag["$zero?"]();
                  }
                  return nil;
                })()
              )
            ) {
              return "+";
            } else {
              return "-";
            }
            return nil;
          })()
        );
        result = $rb_plus(result, self.imag.$abs().$inspect());
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_30 = $$($nesting, "Number")["$==="](self.imag))
                )
              ) {
                if ($truthy(($ret_or_31 = self.imag["$nan?"]()))) {
                  return $ret_or_31;
                } else {
                  return self.imag["$infinite?"]();
                }
              } else {
                return $ret_or_30;
              }
              return nil;
            })()
          )
        ) {
          result = $rb_plus(result, "*");
        }
        return $rb_plus(result, "i");
      }),
      ($Complex_to_s$31.$$arity = 0)
    );
    Opal.const_set($nesting[0], "I", self.$new(0, 1));
    return (
      (Opal.defs(
        self,
        "$from_string",
        ($Complex_from_string$32 = function $$from_string(str) {
          var self = this;

          var re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
            match = str.match(re),
            real,
            imag,
            denominator;

          function isFloat() {
            return re.test(str);
          }

          function cutFloat() {
            var match = str.match(re);
            var number = match[0];
            str = str.slice(number.length);
            return number.replace(/_/g, "");
          }

          // handles both floats and rationals
          function cutNumber() {
            if (isFloat()) {
              var numerator = parseFloat(cutFloat());

              if (str[0] === "/") {
                // rational real part
                str = str.slice(1);

                if (isFloat()) {
                  var denominator = parseFloat(cutFloat());
                  return self.$Rational(numerator, denominator);
                } else {
                  // reverting '/'
                  str = "/" + str;
                  return numerator;
                }
              } else {
                // float real part, no denominator
                return numerator;
              }
            } else {
              return null;
            }
          }

          real = cutNumber();

          if (!real) {
            if (str[0] === "i") {
              // i => Complex(0, 1)
              return self.$Complex(0, 1);
            }
            if (str[0] === "-" && str[1] === "i") {
              // -i => Complex(0, -1)
              return self.$Complex(0, -1);
            }
            if (str[0] === "+" && str[1] === "i") {
              // +i => Complex(0, 1)
              return self.$Complex(0, 1);
            }
            // anything => Complex(0, 0)
            return self.$Complex(0, 0);
          }

          imag = cutNumber();
          if (!imag) {
            if (str[0] === "i") {
              // 3i => Complex(0, 3)
              return self.$Complex(0, real);
            } else {
              // 3 => Complex(3, 0)
              return self.$Complex(real, 0);
            }
          } else {
            // 3+2i => Complex(3, 2)
            return self.$Complex(real, imag);
          }
        }),
        ($Complex_from_string$32.$$arity = 1)
      ),
      nil) && "from_string"
    );
  })($nesting[0], $$($nesting, "Numeric"), $nesting);
};

Opal.modules["corelib/rational/base"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass;

  Opal.add_stubs(["$convert", "$from_string"]);

  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_Rational$1;

    return (
      (Opal.def(
        self,
        "$Rational",
        ($Kernel_Rational$1 = function $$Rational(numerator, denominator) {
          var self = this;

          if (denominator == null) {
            denominator = 1;
          }
          return $$($nesting, "Rational").$convert(numerator, denominator);
        }),
        ($Kernel_Rational$1.$$arity = -2)
      ),
      nil) && "Rational"
    );
  })($nesting[0], $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String_to_r$2;

    return (
      (Opal.def(
        self,
        "$to_r",
        ($String_to_r$2 = function $$to_r() {
          var self = this;

          return $$($nesting, "Rational").$from_string(self);
        }),
        ($String_to_r$2.$$arity = 0)
      ),
      nil) && "to_r"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/rational"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_le(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs <= rhs
      : lhs["$<="](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$require",
    "$to_i",
    "$==",
    "$raise",
    "$<",
    "$-@",
    "$new",
    "$gcd",
    "$/",
    "$nil?",
    "$===",
    "$reduce",
    "$to_r",
    "$equal?",
    "$!",
    "$coerce_to!",
    "$to_f",
    "$numerator",
    "$denominator",
    "$<=>",
    "$-",
    "$*",
    "$__coerced__",
    "$+",
    "$Rational",
    "$>",
    "$**",
    "$abs",
    "$ceil",
    "$with_precision",
    "$floor",
    "$<=",
    "$truncate",
    "$send",
  ]);

  self.$require("corelib/numeric");
  self.$require("corelib/rational/base");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Rational");

    var $nesting = [self].concat($parent_nesting),
      $Rational_reduce$1,
      $Rational_convert$2,
      $Rational_initialize$3,
      $Rational_numerator$4,
      $Rational_denominator$5,
      $Rational_coerce$6,
      $Rational_$eq_eq$7,
      $Rational_$lt_eq_gt$8,
      $Rational_$plus$9,
      $Rational_$minus$10,
      $Rational_$$11,
      $Rational_$slash$12,
      $Rational_$$$13,
      $Rational_abs$14,
      $Rational_ceil$15,
      $Rational_floor$16,
      $Rational_hash$17,
      $Rational_inspect$18,
      $Rational_rationalize$19,
      $Rational_round$20,
      $Rational_to_f$21,
      $Rational_to_i$22,
      $Rational_to_r$23,
      $Rational_to_s$24,
      $Rational_truncate$25,
      $Rational_with_precision$26,
      $Rational_from_string$27;

    self.$$prototype.num = self.$$prototype.den = nil;

    Opal.defs(
      self,
      "$reduce",
      ($Rational_reduce$1 = function $$reduce(num, den) {
        var self = this,
          gcd = nil;

        num = num.$to_i();
        den = den.$to_i();
        if (den["$=="](0)) {
          self.$raise($$($nesting, "ZeroDivisionError"), "divided by 0");
        } else if ($truthy($rb_lt(den, 0))) {
          num = num["$-@"]();
          den = den["$-@"]();
        } else if (den["$=="](1)) {
          return self.$new(num, den);
        }
        gcd = num.$gcd(den);
        return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
      }),
      ($Rational_reduce$1.$$arity = 2)
    );
    Opal.defs(
      self,
      "$convert",
      ($Rational_convert$2 = function $$convert(num, den) {
        var self = this,
          $ret_or_1 = nil,
          $ret_or_2 = nil,
          $ret_or_3 = nil,
          $ret_or_4 = nil,
          $ret_or_5 = nil,
          $ret_or_6 = nil,
          $ret_or_7 = nil,
          $ret_or_8 = nil;

        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_1 = num["$nil?"]()))) {
                return $ret_or_1;
              } else {
                return den["$nil?"]();
              }
              return nil;
            })()
          )
        ) {
          self.$raise(
            $$($nesting, "TypeError"),
            "cannot convert nil into Rational"
          );
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_2 = $$($nesting, "Integer")["$==="](num)))) {
                return $$($nesting, "Integer")["$==="](den);
              } else {
                return $ret_or_2;
              }
              return nil;
            })()
          )
        ) {
          return self.$reduce(num, den);
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_3 = (function () {
                    if (
                      $truthy(($ret_or_4 = $$($nesting, "Float")["$==="](num)))
                    ) {
                      return $ret_or_4;
                    } else {
                      return $$($nesting, "String")["$==="](num);
                    }
                    return nil;
                  })())
                )
              ) {
                return $ret_or_3;
              } else {
                return $$($nesting, "Complex")["$==="](num);
              }
              return nil;
            })()
          )
        ) {
          num = num.$to_r();
        }
        if (
          $truthy(
            (function () {
              if (
                $truthy(
                  ($ret_or_5 = (function () {
                    if (
                      $truthy(($ret_or_6 = $$($nesting, "Float")["$==="](den)))
                    ) {
                      return $ret_or_6;
                    } else {
                      return $$($nesting, "String")["$==="](den);
                    }
                    return nil;
                  })())
                )
              ) {
                return $ret_or_5;
              } else {
                return $$($nesting, "Complex")["$==="](den);
              }
              return nil;
            })()
          )
        ) {
          den = den.$to_r();
        }
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_7 = den["$equal?"](1)))) {
                return $$($nesting, "Integer")["$==="](num)["$!"]();
              } else {
                return $ret_or_7;
              }
              return nil;
            })()
          )
        ) {
          return $$($nesting, "Opal")["$coerce_to!"](
            num,
            $$($nesting, "Rational"),
            "to_r"
          );
        } else if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_8 = $$($nesting, "Numeric")["$==="](num)))) {
                return $$($nesting, "Numeric")["$==="](den);
              } else {
                return $ret_or_8;
              }
              return nil;
            })()
          )
        ) {
          return $rb_divide(num, den);
        } else {
          return self.$reduce(num, den);
        }
      }),
      ($Rational_convert$2.$$arity = 2)
    );

    Opal.def(
      self,
      "$initialize",
      ($Rational_initialize$3 = function $$initialize(num, den) {
        var self = this;

        self.num = num;
        return (self.den = den);
      }),
      ($Rational_initialize$3.$$arity = 2)
    );

    Opal.def(
      self,
      "$numerator",
      ($Rational_numerator$4 = function $$numerator() {
        var self = this;

        return self.num;
      }),
      ($Rational_numerator$4.$$arity = 0)
    );

    Opal.def(
      self,
      "$denominator",
      ($Rational_denominator$5 = function $$denominator() {
        var self = this;

        return self.den;
      }),
      ($Rational_denominator$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$coerce",
      ($Rational_coerce$6 = function $$coerce(other) {
        var self = this,
          $case = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Rational")["$==="]($case)) {
            return [other, self];
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            return [other.$to_r(), self];
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return [other, self.$to_f()];
          } else {
            return nil;
          }
        })();
      }),
      ($Rational_coerce$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($Rational_$eq_eq$7 = function (other) {
        var self = this,
          $case = nil,
          $ret_or_9 = nil,
          $ret_or_10 = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Rational")["$==="]($case)) {
            if ($truthy(($ret_or_9 = self.num["$=="](other.$numerator())))) {
              return self.den["$=="](other.$denominator());
            } else {
              return $ret_or_9;
            }
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            if ($truthy(($ret_or_10 = self.num["$=="](other)))) {
              return self.den["$=="](1);
            } else {
              return $ret_or_10;
            }
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return self.$to_f()["$=="](other);
          } else {
            return other["$=="](self);
          }
        })();
      }),
      ($Rational_$eq_eq$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=>",
      ($Rational_$lt_eq_gt$8 = function (other) {
        var self = this,
          $case = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Rational")["$==="]($case)) {
            return $rb_minus(
              $rb_times(self.num, other.$denominator()),
              $rb_times(self.den, other.$numerator())
            )["$<=>"](0);
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            return $rb_minus(self.num, $rb_times(self.den, other))["$<=>"](0);
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return self.$to_f()["$<=>"](other);
          } else {
            return self.$__coerced__("<=>", other);
          }
        })();
      }),
      ($Rational_$lt_eq_gt$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$+",
      ($Rational_$plus$9 = function (other) {
        var self = this,
          $case = nil,
          num = nil,
          den = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Rational")["$==="]($case)) {
            num = $rb_plus(
              $rb_times(self.num, other.$denominator()),
              $rb_times(self.den, other.$numerator())
            );
            den = $rb_times(self.den, other.$denominator());
            return self.$Rational(num, den);
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            return self.$Rational(
              $rb_plus(self.num, $rb_times(other, self.den)),
              self.den
            );
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return $rb_plus(self.$to_f(), other);
          } else {
            return self.$__coerced__("+", other);
          }
        })();
      }),
      ($Rational_$plus$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$-",
      ($Rational_$minus$10 = function (other) {
        var self = this,
          $case = nil,
          num = nil,
          den = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Rational")["$==="]($case)) {
            num = $rb_minus(
              $rb_times(self.num, other.$denominator()),
              $rb_times(self.den, other.$numerator())
            );
            den = $rb_times(self.den, other.$denominator());
            return self.$Rational(num, den);
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            return self.$Rational(
              $rb_minus(self.num, $rb_times(other, self.den)),
              self.den
            );
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return $rb_minus(self.$to_f(), other);
          } else {
            return self.$__coerced__("-", other);
          }
        })();
      }),
      ($Rational_$minus$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$*",
      ($Rational_$$11 = function (other) {
        var self = this,
          $case = nil,
          num = nil,
          den = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Rational")["$==="]($case)) {
            num = $rb_times(self.num, other.$numerator());
            den = $rb_times(self.den, other.$denominator());
            return self.$Rational(num, den);
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            return self.$Rational($rb_times(self.num, other), self.den);
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return $rb_times(self.$to_f(), other);
          } else {
            return self.$__coerced__("*", other);
          }
        })();
      }),
      ($Rational_$$11.$$arity = 1)
    );

    Opal.def(
      self,
      "$/",
      ($Rational_$slash$12 = function (other) {
        var self = this,
          $case = nil,
          num = nil,
          den = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Rational")["$==="]($case)) {
            num = $rb_times(self.num, other.$denominator());
            den = $rb_times(self.den, other.$numerator());
            return self.$Rational(num, den);
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            if (other["$=="](0)) {
              return $rb_divide(self.$to_f(), 0.0);
            } else {
              return self.$Rational(self.num, $rb_times(self.den, other));
            }
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return $rb_divide(self.$to_f(), other);
          } else {
            return self.$__coerced__("/", other);
          }
        })();
      }),
      ($Rational_$slash$12.$$arity = 1)
    );

    Opal.def(
      self,
      "$**",
      ($Rational_$$$13 = function (other) {
        var self = this,
          $case = nil,
          $ret_or_11 = nil,
          $ret_or_12 = nil;

        return (function () {
          $case = other;
          if ($$($nesting, "Integer")["$==="]($case)) {
            if (
              $truthy(
                (function () {
                  if ($truthy(($ret_or_11 = self["$=="](0)))) {
                    return $rb_lt(other, 0);
                  } else {
                    return $ret_or_11;
                  }
                  return nil;
                })()
              )
            ) {
              return $$$($$($nesting, "Float"), "INFINITY");
            } else if ($truthy($rb_gt(other, 0))) {
              return self.$Rational(
                self.num["$**"](other),
                self.den["$**"](other)
              );
            } else if ($truthy($rb_lt(other, 0))) {
              return self.$Rational(
                self.den["$**"](other["$-@"]()),
                self.num["$**"](other["$-@"]())
              );
            } else {
              return self.$Rational(1, 1);
            }
          } else if ($$($nesting, "Float")["$==="]($case)) {
            return self.$to_f()["$**"](other);
          } else if ($$($nesting, "Rational")["$==="]($case)) {
            if (other["$=="](0)) {
              return self.$Rational(1, 1);
            } else if (other.$denominator()["$=="](1)) {
              if ($truthy($rb_lt(other, 0))) {
                return self.$Rational(
                  self.den["$**"](other.$numerator().$abs()),
                  self.num["$**"](other.$numerator().$abs())
                );
              } else {
                return self.$Rational(
                  self.num["$**"](other.$numerator()),
                  self.den["$**"](other.$numerator())
                );
              }
            } else if (
              $truthy(
                (function () {
                  if ($truthy(($ret_or_12 = self["$=="](0)))) {
                    return $rb_lt(other, 0);
                  } else {
                    return $ret_or_12;
                  }
                  return nil;
                })()
              )
            ) {
              return self.$raise(
                $$($nesting, "ZeroDivisionError"),
                "divided by 0"
              );
            } else {
              return self.$to_f()["$**"](other);
            }
          } else {
            return self.$__coerced__("**", other);
          }
        })();
      }),
      ($Rational_$$$13.$$arity = 1)
    );

    Opal.def(
      self,
      "$abs",
      ($Rational_abs$14 = function $$abs() {
        var self = this;

        return self.$Rational(self.num.$abs(), self.den.$abs());
      }),
      ($Rational_abs$14.$$arity = 0)
    );

    Opal.def(
      self,
      "$ceil",
      ($Rational_ceil$15 = function $$ceil(precision) {
        var self = this;

        if (precision == null) {
          precision = 0;
        }
        if (precision["$=="](0)) {
          return $rb_divide(self.num["$-@"](), self.den)["$-@"]().$ceil();
        } else {
          return self.$with_precision("ceil", precision);
        }
      }),
      ($Rational_ceil$15.$$arity = -1)
    );
    $alias(self, "divide", "/");

    Opal.def(
      self,
      "$floor",
      ($Rational_floor$16 = function $$floor(precision) {
        var self = this;

        if (precision == null) {
          precision = 0;
        }
        if (precision["$=="](0)) {
          return $rb_divide(self.num["$-@"](), self.den)["$-@"]().$floor();
        } else {
          return self.$with_precision("floor", precision);
        }
      }),
      ($Rational_floor$16.$$arity = -1)
    );

    Opal.def(
      self,
      "$hash",
      ($Rational_hash$17 = function $$hash() {
        var self = this;

        return "" + "Rational:" + self.num + ":" + self.den;
      }),
      ($Rational_hash$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$inspect",
      ($Rational_inspect$18 = function $$inspect() {
        var self = this;

        return "" + "(" + self + ")";
      }),
      ($Rational_inspect$18.$$arity = 0)
    );
    $alias(self, "quo", "/");

    Opal.def(
      self,
      "$rationalize",
      ($Rational_rationalize$19 = function $$rationalize(eps) {
        var self = this;

        if (arguments.length > 1) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + "wrong number of arguments (" + arguments.length + " for 0..1)"
          );
        }

        if (eps == null) {
          return self;
        }

        var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

        var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2,
          q2;

        var c, k, t;

        while (true) {
          c = a.$ceil();

          if ($rb_le(c, b)) {
            break;
          }

          k = c - 1;
          p2 = k * p1 + p0;
          q2 = k * q1 + q0;
          t = $rb_divide(1, $rb_minus(b, k));
          b = $rb_divide(1, $rb_minus(a, k));
          a = t;

          p0 = p1;
          q0 = q1;
          p1 = p2;
          q1 = q2;
        }

        return self.$Rational(c * p1 + p0, c * q1 + q0);
      }),
      ($Rational_rationalize$19.$$arity = -1)
    );

    Opal.def(
      self,
      "$round",
      ($Rational_round$20 = function $$round(precision) {
        var self = this,
          num = nil,
          den = nil,
          approx = nil;

        if (precision == null) {
          precision = 0;
        }
        if (precision["$=="](0)) {
        } else {
          return self.$with_precision("round", precision);
        }
        if (self.num["$=="](0)) {
          return 0;
        }
        if (self.den["$=="](1)) {
          return self.num;
        }
        num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
        den = $rb_times(self.den, 2);
        approx = $rb_divide(num, den).$truncate();
        if ($truthy($rb_lt(self.num, 0))) {
          return approx["$-@"]();
        } else {
          return approx;
        }
      }),
      ($Rational_round$20.$$arity = -1)
    );

    Opal.def(
      self,
      "$to_f",
      ($Rational_to_f$21 = function $$to_f() {
        var self = this;

        return $rb_divide(self.num, self.den);
      }),
      ($Rational_to_f$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_i",
      ($Rational_to_i$22 = function $$to_i() {
        var self = this;

        return self.$truncate();
      }),
      ($Rational_to_i$22.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_r",
      ($Rational_to_r$23 = function $$to_r() {
        var self = this;

        return self;
      }),
      ($Rational_to_r$23.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_s",
      ($Rational_to_s$24 = function $$to_s() {
        var self = this;

        return "" + self.num + "/" + self.den;
      }),
      ($Rational_to_s$24.$$arity = 0)
    );

    Opal.def(
      self,
      "$truncate",
      ($Rational_truncate$25 = function $$truncate(precision) {
        var self = this;

        if (precision == null) {
          precision = 0;
        }
        if (precision["$=="](0)) {
          if ($truthy($rb_lt(self.num, 0))) {
            return self.$ceil();
          } else {
            return self.$floor();
          }
        } else {
          return self.$with_precision("truncate", precision);
        }
      }),
      ($Rational_truncate$25.$$arity = -1)
    );

    Opal.def(
      self,
      "$with_precision",
      ($Rational_with_precision$26 = function $$with_precision(
        method,
        precision
      ) {
        var self = this,
          p = nil,
          s = nil;

        if ($truthy($$($nesting, "Integer")["$==="](precision))) {
        } else {
          self.$raise($$($nesting, "TypeError"), "not an Integer");
        }
        p = (10)["$**"](precision);
        s = $rb_times(self, p);
        if ($truthy($rb_lt(precision, 1))) {
          return $rb_divide(s.$send(method), p).$to_i();
        } else {
          return self.$Rational(s.$send(method), p);
        }
      }),
      ($Rational_with_precision$26.$$arity = 2)
    );
    return (
      (Opal.defs(
        self,
        "$from_string",
        ($Rational_from_string$27 = function $$from_string(string) {
          var self = this;

          var str = string.trimLeft(),
            re = /^[+-]?[\d_]+(\.[\d_]+)?/,
            match = str.match(re),
            numerator,
            denominator;

          function isFloat() {
            return re.test(str);
          }

          function cutFloat() {
            var match = str.match(re);
            var number = match[0];
            str = str.slice(number.length);
            return number.replace(/_/g, "");
          }

          if (isFloat()) {
            numerator = parseFloat(cutFloat());

            if (str[0] === "/") {
              // rational real part
              str = str.slice(1);

              if (isFloat()) {
                denominator = parseFloat(cutFloat());
                return self.$Rational(numerator, denominator);
              } else {
                return self.$Rational(numerator, 1);
              }
            } else {
              return self.$Rational(numerator, 1);
            }
          } else {
            return self.$Rational(0, 1);
          }
        }),
        ($Rational_from_string$27.$$arity = 1)
      ),
      nil) && "from_string"
    );
  })($nesting[0], $$($nesting, "Numeric"), $nesting);
};

Opal.modules["corelib/time"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_le(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs <= rhs
      : lhs["$<="](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $slice = Opal.slice,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $truthy = Opal.truthy,
    $range = Opal.range;

  Opal.add_stubs([
    "$require",
    "$include",
    "$===",
    "$raise",
    "$coerce_to!",
    "$respond_to?",
    "$to_str",
    "$to_i",
    "$new",
    "$<=>",
    "$to_f",
    "$nil?",
    "$>",
    "$<",
    "$strftime",
    "$year",
    "$month",
    "$day",
    "$+",
    "$round",
    "$/",
    "$-",
    "$copy_instance_variables",
    "$initialize_dup",
    "$is_a?",
    "$zero?",
    "$wday",
    "$utc?",
    "$mon",
    "$yday",
    "$hour",
    "$min",
    "$sec",
    "$rjust",
    "$ljust",
    "$zone",
    "$to_s",
    "$[]",
    "$cweek_cyear",
    "$isdst",
    "$<=",
    "$!=",
    "$==",
    "$ceil",
  ]);

  self.$require("corelib/comparable");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Time");

    var $nesting = [self].concat($parent_nesting),
      $Time_at$1,
      $Time_new$2,
      $Time_local$3,
      $Time_gm$4,
      $Time_now$5,
      $Time_$plus$6,
      $Time_$minus$7,
      $Time_$lt_eq_gt$8,
      $Time_$eq_eq$9,
      $Time_asctime$10,
      $Time_day$11,
      $Time_yday$12,
      $Time_isdst$13,
      $Time_dup$14,
      $Time_eql$ques$15,
      $Time_friday$ques$16,
      $Time_hash$17,
      $Time_hour$18,
      $Time_inspect$19,
      $Time_min$20,
      $Time_mon$21,
      $Time_monday$ques$22,
      $Time_saturday$ques$23,
      $Time_sec$24,
      $Time_succ$25,
      $Time_usec$26,
      $Time_zone$27,
      $Time_getgm$28,
      $Time_gmtime$29,
      $Time_gmt$ques$30,
      $Time_gmt_offset$31,
      $Time_strftime$32,
      $Time_sunday$ques$33,
      $Time_thursday$ques$34,
      $Time_to_a$35,
      $Time_to_f$36,
      $Time_to_i$37,
      $Time_tuesday$ques$38,
      $Time_wday$39,
      $Time_wednesday$ques$40,
      $Time_year$41,
      $Time_cweek_cyear$42;

    self.$include($$($nesting, "Comparable"));

    var days_of_week = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
      ],
      short_days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      short_months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      long_months = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ];
    Opal.defs(
      self,
      "$at",
      ($Time_at$1 = function $$at(seconds, frac) {
        var self = this;

        var result;

        if ($$($nesting, "Time")["$==="](seconds)) {
          if (frac !== undefined) {
            self.$raise(
              $$($nesting, "TypeError"),
              "can't convert Time into an exact number"
            );
          }
          result = new Date(seconds.getTime());
          result.is_utc = seconds.is_utc;
          return result;
        }

        if (!seconds.$$is_number) {
          seconds = $$($nesting, "Opal")["$coerce_to!"](
            seconds,
            $$($nesting, "Integer"),
            "to_int"
          );
        }

        if (frac === undefined) {
          return new Date(seconds * 1000);
        }

        if (!frac.$$is_number) {
          frac = $$($nesting, "Opal")["$coerce_to!"](
            frac,
            $$($nesting, "Integer"),
            "to_int"
          );
        }

        return new Date(seconds * 1000 + frac / 1000);
      }),
      ($Time_at$1.$$arity = -2)
    );

    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $$($nesting, "Opal")["$coerce_to!"](
          year,
          $$($nesting, "Integer"),
          "to_int"
        );
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if (month["$respond_to?"]("to_str")) {
          month = month.$to_str();
          switch (month.toLowerCase()) {
            case "jan":
              month = 1;
              break;
            case "feb":
              month = 2;
              break;
            case "mar":
              month = 3;
              break;
            case "apr":
              month = 4;
              break;
            case "may":
              month = 5;
              break;
            case "jun":
              month = 6;
              break;
            case "jul":
              month = 7;
              break;
            case "aug":
              month = 8;
              break;
            case "sep":
              month = 9;
              break;
            case "oct":
              month = 10;
              break;
            case "nov":
              month = 11;
              break;
            case "dec":
              month = 12;
              break;
            default:
              month = month.$to_i();
          }
        } else {
          month = $$($nesting, "Opal")["$coerce_to!"](
            month,
            $$($nesting, "Integer"),
            "to_int"
          );
        }
      }

      if (month < 1 || month > 12) {
        self.$raise(
          $$($nesting, "ArgumentError"),
          "" + "month out of range: " + month
        );
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $$($nesting, "Opal")["$coerce_to!"](
          day,
          $$($nesting, "Integer"),
          "to_int"
        );
      }

      if (day < 1 || day > 31) {
        self.$raise(
          $$($nesting, "ArgumentError"),
          "" + "day out of range: " + day
        );
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $$($nesting, "Opal")["$coerce_to!"](
          hour,
          $$($nesting, "Integer"),
          "to_int"
        );
      }

      if (hour < 0 || hour > 24) {
        self.$raise(
          $$($nesting, "ArgumentError"),
          "" + "hour out of range: " + hour
        );
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $$($nesting, "Opal")["$coerce_to!"](
          min,
          $$($nesting, "Integer"),
          "to_int"
        );
      }

      if (min < 0 || min > 59) {
        self.$raise(
          $$($nesting, "ArgumentError"),
          "" + "min out of range: " + min
        );
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $$($nesting, "Opal")["$coerce_to!"](
            sec,
            $$($nesting, "Integer"),
            "to_int"
          );
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise(
          $$($nesting, "ArgumentError"),
          "" + "sec out of range: " + sec
        );
      }

      return [year, month, day, hour, min, sec];
    }
    Opal.defs(
      self,
      "$new",
      ($Time_new$2 = function (year, month, day, hour, min, sec, utc_offset) {
        var self = this;

        if (month == null) {
          month = nil;
        }

        if (day == null) {
          day = nil;
        }

        if (hour == null) {
          hour = nil;
        }

        if (min == null) {
          min = nil;
        }

        if (sec == null) {
          sec = nil;
        }

        if (utc_offset == null) {
          utc_offset = nil;
        }

        var args, result;

        if (year === undefined) {
          return new Date();
        }

        if (utc_offset !== nil) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "Opal does not support explicitly specifying UTC offset for Time"
          );
        }

        args = time_params(year, month, day, hour, min, sec);
        year = args[0];
        month = args[1];
        day = args[2];
        hour = args[3];
        min = args[4];
        sec = args[5];

        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }),
      ($Time_new$2.$$arity = -1)
    );
    Opal.defs(
      self,
      "$local",
      ($Time_local$3 = function $$local(
        year,
        month,
        day,
        hour,
        min,
        sec,
        millisecond,
        _dummy1,
        _dummy2,
        _dummy3
      ) {
        var self = this;

        if (month == null) {
          month = nil;
        }

        if (day == null) {
          day = nil;
        }

        if (hour == null) {
          hour = nil;
        }

        if (min == null) {
          min = nil;
        }

        if (sec == null) {
          sec = nil;
        }

        if (millisecond == null) {
          millisecond = nil;
        }

        if (_dummy1 == null) {
          _dummy1 = nil;
        }

        if (_dummy2 == null) {
          _dummy2 = nil;
        }

        if (_dummy3 == null) {
          _dummy3 = nil;
        }

        var args, result;

        if (arguments.length === 10) {
          args = $slice.call(arguments);
          year = args[5];
          month = args[4];
          day = args[3];
          hour = args[2];
          min = args[1];
          sec = args[0];
        }

        args = time_params(year, month, day, hour, min, sec);
        year = args[0];
        month = args[1];
        day = args[2];
        hour = args[3];
        min = args[4];
        sec = args[5];

        result = new Date(year, month, day, hour, min, 0, sec * 1000);
        if (year < 100) {
          result.setFullYear(year);
        }
        return result;
      }),
      ($Time_local$3.$$arity = -2)
    );
    Opal.defs(
      self,
      "$gm",
      ($Time_gm$4 = function $$gm(
        year,
        month,
        day,
        hour,
        min,
        sec,
        millisecond,
        _dummy1,
        _dummy2,
        _dummy3
      ) {
        var self = this;

        if (month == null) {
          month = nil;
        }

        if (day == null) {
          day = nil;
        }

        if (hour == null) {
          hour = nil;
        }

        if (min == null) {
          min = nil;
        }

        if (sec == null) {
          sec = nil;
        }

        if (millisecond == null) {
          millisecond = nil;
        }

        if (_dummy1 == null) {
          _dummy1 = nil;
        }

        if (_dummy2 == null) {
          _dummy2 = nil;
        }

        if (_dummy3 == null) {
          _dummy3 = nil;
        }

        var args, result;

        if (arguments.length === 10) {
          args = $slice.call(arguments);
          year = args[5];
          month = args[4];
          day = args[3];
          hour = args[2];
          min = args[1];
          sec = args[0];
        }

        args = time_params(year, month, day, hour, min, sec);
        year = args[0];
        month = args[1];
        day = args[2];
        hour = args[3];
        min = args[4];
        sec = args[5];

        result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
        if (year < 100) {
          result.setUTCFullYear(year);
        }
        result.is_utc = true;
        return result;
      }),
      ($Time_gm$4.$$arity = -2)
    );
    (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(
      self,
      "$now",
      ($Time_now$5 = function $$now() {
        var self = this;

        return self.$new();
      }),
      ($Time_now$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$+",
      ($Time_$plus$6 = function (other) {
        var self = this;

        if ($truthy($$($nesting, "Time")["$==="](other))) {
          self.$raise($$($nesting, "TypeError"), "time + time?");
        }

        if (!other.$$is_number) {
          other = $$($nesting, "Opal")["$coerce_to!"](
            other,
            $$($nesting, "Integer"),
            "to_int"
          );
        }
        var result = new Date(self.getTime() + other * 1000);
        result.is_utc = self.is_utc;
        return result;
      }),
      ($Time_$plus$6.$$arity = 1)
    );

    Opal.def(
      self,
      "$-",
      ($Time_$minus$7 = function (other) {
        var self = this;

        if ($truthy($$($nesting, "Time")["$==="](other))) {
          return (self.getTime() - other.getTime()) / 1000;
        }

        if (!other.$$is_number) {
          other = $$($nesting, "Opal")["$coerce_to!"](
            other,
            $$($nesting, "Integer"),
            "to_int"
          );
        }
        var result = new Date(self.getTime() - other * 1000);
        result.is_utc = self.is_utc;
        return result;
      }),
      ($Time_$minus$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$<=>",
      ($Time_$lt_eq_gt$8 = function (other) {
        var self = this,
          r = nil;

        if ($truthy($$($nesting, "Time")["$==="](other))) {
          return self.$to_f()["$<=>"](other.$to_f());
        } else {
          r = other["$<=>"](self);
          if ($truthy(r["$nil?"]())) {
            return nil;
          } else if ($truthy($rb_gt(r, 0))) {
            return -1;
          } else if ($truthy($rb_lt(r, 0))) {
            return 1;
          } else {
            return 0;
          }
        }
      }),
      ($Time_$lt_eq_gt$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($Time_$eq_eq$9 = function (other) {
        var self = this,
          $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$($nesting, "Time")["$==="](other)))) {
          return self.$to_f() === other.$to_f();
        } else {
          return $ret_or_1;
        }
      }),
      ($Time_$eq_eq$9.$$arity = 1)
    );

    Opal.def(
      self,
      "$asctime",
      ($Time_asctime$10 = function $$asctime() {
        var self = this;

        return self.$strftime("%a %b %e %H:%M:%S %Y");
      }),
      ($Time_asctime$10.$$arity = 0)
    );
    $alias(self, "ctime", "asctime");

    Opal.def(
      self,
      "$day",
      ($Time_day$11 = function $$day() {
        var self = this;

        return self.is_utc ? self.getUTCDate() : self.getDate();
      }),
      ($Time_day$11.$$arity = 0)
    );

    Opal.def(
      self,
      "$yday",
      ($Time_yday$12 = function $$yday() {
        var self = this,
          start_of_year = nil,
          start_of_day = nil,
          one_day = nil;

        start_of_year = $$($nesting, "Time").$new(self.$year()).$to_i();
        start_of_day = $$($nesting, "Time")
          .$new(self.$year(), self.$month(), self.$day())
          .$to_i();
        one_day = 86400;
        return $rb_plus(
          $rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(),
          1
        );
      }),
      ($Time_yday$12.$$arity = 0)
    );

    Opal.def(
      self,
      "$isdst",
      ($Time_isdst$13 = function $$isdst() {
        var self = this;

        var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
        return (
          self.getTimezoneOffset() <
          Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset())
        );
      }),
      ($Time_isdst$13.$$arity = 0)
    );
    $alias(self, "dst?", "isdst");

    Opal.def(
      self,
      "$dup",
      ($Time_dup$14 = function $$dup() {
        var self = this,
          copy = nil;

        copy = new Date(self.getTime());
        copy.$copy_instance_variables(self);
        copy.$initialize_dup(self);
        return copy;
      }),
      ($Time_dup$14.$$arity = 0)
    );

    Opal.def(
      self,
      "$eql?",
      ($Time_eql$ques$15 = function (other) {
        var self = this,
          $ret_or_2 = nil;

        if ($truthy(($ret_or_2 = other["$is_a?"]($$($nesting, "Time"))))) {
          return self["$<=>"](other)["$zero?"]();
        } else {
          return $ret_or_2;
        }
      }),
      ($Time_eql$ques$15.$$arity = 1)
    );

    Opal.def(
      self,
      "$friday?",
      ($Time_friday$ques$16 = function () {
        var self = this;

        return self.$wday() == 5;
      }),
      ($Time_friday$ques$16.$$arity = 0)
    );

    Opal.def(
      self,
      "$hash",
      ($Time_hash$17 = function $$hash() {
        var self = this;

        return "Time:" + self.getTime();
      }),
      ($Time_hash$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$hour",
      ($Time_hour$18 = function $$hour() {
        var self = this;

        return self.is_utc ? self.getUTCHours() : self.getHours();
      }),
      ($Time_hour$18.$$arity = 0)
    );

    Opal.def(
      self,
      "$inspect",
      ($Time_inspect$19 = function $$inspect() {
        var self = this;

        if ($truthy(self["$utc?"]())) {
          return self.$strftime("%Y-%m-%d %H:%M:%S UTC");
        } else {
          return self.$strftime("%Y-%m-%d %H:%M:%S %z");
        }
      }),
      ($Time_inspect$19.$$arity = 0)
    );
    $alias(self, "mday", "day");

    Opal.def(
      self,
      "$min",
      ($Time_min$20 = function $$min() {
        var self = this;

        return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
      }),
      ($Time_min$20.$$arity = 0)
    );

    Opal.def(
      self,
      "$mon",
      ($Time_mon$21 = function $$mon() {
        var self = this;

        return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
      }),
      ($Time_mon$21.$$arity = 0)
    );

    Opal.def(
      self,
      "$monday?",
      ($Time_monday$ques$22 = function () {
        var self = this;

        return self.$wday() == 1;
      }),
      ($Time_monday$ques$22.$$arity = 0)
    );
    $alias(self, "month", "mon");

    Opal.def(
      self,
      "$saturday?",
      ($Time_saturday$ques$23 = function () {
        var self = this;

        return self.$wday() == 6;
      }),
      ($Time_saturday$ques$23.$$arity = 0)
    );

    Opal.def(
      self,
      "$sec",
      ($Time_sec$24 = function $$sec() {
        var self = this;

        return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
      }),
      ($Time_sec$24.$$arity = 0)
    );

    Opal.def(
      self,
      "$succ",
      ($Time_succ$25 = function $$succ() {
        var self = this;

        var result = new Date(self.getTime() + 1000);
        result.is_utc = self.is_utc;
        return result;
      }),
      ($Time_succ$25.$$arity = 0)
    );

    Opal.def(
      self,
      "$usec",
      ($Time_usec$26 = function $$usec() {
        var self = this;

        return self.getMilliseconds() * 1000;
      }),
      ($Time_usec$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$zone",
      ($Time_zone$27 = function $$zone() {
        var self = this;

        var string = self.toString(),
          result;

        if (string.indexOf("(") == -1) {
          result = string.match(/[A-Z]{3,4}/)[0];
        } else {
          result = string.match(/\((.+)\)(?:\s|$)/)[1];
        }

        if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
          return RegExp.$1;
        } else {
          return result;
        }
      }),
      ($Time_zone$27.$$arity = 0)
    );

    Opal.def(
      self,
      "$getgm",
      ($Time_getgm$28 = function $$getgm() {
        var self = this;

        var result = new Date(self.getTime());
        result.is_utc = true;
        return result;
      }),
      ($Time_getgm$28.$$arity = 0)
    );
    $alias(self, "getutc", "getgm");

    Opal.def(
      self,
      "$gmtime",
      ($Time_gmtime$29 = function $$gmtime() {
        var self = this;

        self.is_utc = true;
        return self;
      }),
      ($Time_gmtime$29.$$arity = 0)
    );
    $alias(self, "utc", "gmtime");

    Opal.def(
      self,
      "$gmt?",
      ($Time_gmt$ques$30 = function () {
        var self = this;

        return self.is_utc === true;
      }),
      ($Time_gmt$ques$30.$$arity = 0)
    );

    Opal.def(
      self,
      "$gmt_offset",
      ($Time_gmt_offset$31 = function $$gmt_offset() {
        var self = this;

        return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
      }),
      ($Time_gmt_offset$31.$$arity = 0)
    );

    Opal.def(
      self,
      "$strftime",
      ($Time_strftime$32 = function $$strftime(format) {
        var self = this;

        return format.replace(
          /%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g,
          function (full, flags, width, _, conv) {
            var result = "",
              zero = flags.indexOf("0") !== -1,
              pad = flags.indexOf("-") === -1,
              blank = flags.indexOf("_") !== -1,
              upcase = flags.indexOf("^") !== -1,
              invert = flags.indexOf("#") !== -1,
              colons = (flags.match(":") || []).length;

            width = parseInt(width, 10);

            if (zero && blank) {
              if (flags.indexOf("0") < flags.indexOf("_")) {
                zero = false;
              } else {
                blank = false;
              }
            }

            switch (conv) {
              case "Y":
                result += self.$year();
                break;

              case "C":
                zero = !blank;
                result += Math.round(self.$year() / 100);
                break;

              case "y":
                zero = !blank;
                result += self.$year() % 100;
                break;

              case "m":
                zero = !blank;
                result += self.$mon();
                break;

              case "B":
                result += long_months[self.$mon() - 1];
                break;

              case "b":
              case "h":
                blank = !zero;
                result += short_months[self.$mon() - 1];
                break;

              case "d":
                zero = !blank;
                result += self.$day();
                break;

              case "e":
                blank = !zero;
                result += self.$day();
                break;

              case "j":
                zero = !blank;
                width = isNaN(width) ? 3 : width;
                result += self.$yday();
                break;

              case "H":
                zero = !blank;
                result += self.$hour();
                break;

              case "k":
                blank = !zero;
                result += self.$hour();
                break;

              case "I":
                zero = !blank;
                result += self.$hour() % 12 || 12;
                break;

              case "l":
                blank = !zero;
                result += self.$hour() % 12 || 12;
                break;

              case "P":
                result += self.$hour() >= 12 ? "pm" : "am";
                break;

              case "p":
                result += self.$hour() >= 12 ? "PM" : "AM";
                break;

              case "M":
                zero = !blank;
                result += self.$min();
                break;

              case "S":
                zero = !blank;
                result += self.$sec();
                break;

              case "L":
                zero = !blank;
                width = isNaN(width) ? 3 : width;
                result += self.getMilliseconds();
                break;

              case "N":
                width = isNaN(width) ? 9 : width;
                result += self.getMilliseconds().toString().$rjust(3, "0");
                result = result.$ljust(width, "0");
                break;

              case "z":
                var offset = self.getTimezoneOffset(),
                  hours = Math.floor(Math.abs(offset) / 60),
                  minutes = Math.abs(offset) % 60;

                result += offset < 0 ? "+" : "-";
                result += hours < 10 ? "0" : "";
                result += hours;

                if (colons > 0) {
                  result += ":";
                }

                result += minutes < 10 ? "0" : "";
                result += minutes;

                if (colons > 1) {
                  result += ":00";
                }

                break;

              case "Z":
                result += self.$zone();
                break;

              case "A":
                result += days_of_week[self.$wday()];
                break;

              case "a":
                result += short_days[self.$wday()];
                break;

              case "u":
                result += self.$wday() + 1;
                break;

              case "w":
                result += self.$wday();
                break;

              case "V":
                result += self.$cweek_cyear()["$[]"](0).$to_s().$rjust(2, "0");
                break;

              case "G":
                result += self.$cweek_cyear()["$[]"](1);
                break;

              case "g":
                result += self
                  .$cweek_cyear()
                  ["$[]"](1)
                  ["$[]"]($range(-2, -1, false));
                break;

              case "s":
                result += self.$to_i();
                break;

              case "n":
                result += "\n";
                break;

              case "t":
                result += "\t";
                break;

              case "%":
                result += "%";
                break;

              case "c":
                result += self.$strftime("%a %b %e %T %Y");
                break;

              case "D":
              case "x":
                result += self.$strftime("%m/%d/%y");
                break;

              case "F":
                result += self.$strftime("%Y-%m-%d");
                break;

              case "v":
                result += self.$strftime("%e-%^b-%4Y");
                break;

              case "r":
                result += self.$strftime("%I:%M:%S %p");
                break;

              case "R":
                result += self.$strftime("%H:%M");
                break;

              case "T":
              case "X":
                result += self.$strftime("%H:%M:%S");
                break;

              default:
                return full;
            }

            if (upcase) {
              result = result.toUpperCase();
            }

            if (invert) {
              result = result
                .replace(/[A-Z]/, function (c) {
                  c.toLowerCase();
                })
                .replace(/[a-z]/, function (c) {
                  c.toUpperCase();
                });
            }

            if (pad && (zero || blank)) {
              result = result.$rjust(
                isNaN(width) ? 2 : width,
                blank ? " " : "0"
              );
            }

            return result;
          }
        );
      }),
      ($Time_strftime$32.$$arity = 1)
    );

    Opal.def(
      self,
      "$sunday?",
      ($Time_sunday$ques$33 = function () {
        var self = this;

        return self.$wday() == 0;
      }),
      ($Time_sunday$ques$33.$$arity = 0)
    );

    Opal.def(
      self,
      "$thursday?",
      ($Time_thursday$ques$34 = function () {
        var self = this;

        return self.$wday() == 4;
      }),
      ($Time_thursday$ques$34.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_a",
      ($Time_to_a$35 = function $$to_a() {
        var self = this;

        return [
          self.$sec(),
          self.$min(),
          self.$hour(),
          self.$day(),
          self.$month(),
          self.$year(),
          self.$wday(),
          self.$yday(),
          self.$isdst(),
          self.$zone(),
        ];
      }),
      ($Time_to_a$35.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_f",
      ($Time_to_f$36 = function $$to_f() {
        var self = this;

        return self.getTime() / 1000;
      }),
      ($Time_to_f$36.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_i",
      ($Time_to_i$37 = function $$to_i() {
        var self = this;

        return parseInt(self.getTime() / 1000, 10);
      }),
      ($Time_to_i$37.$$arity = 0)
    );
    $alias(self, "to_s", "inspect");

    Opal.def(
      self,
      "$tuesday?",
      ($Time_tuesday$ques$38 = function () {
        var self = this;

        return self.$wday() == 2;
      }),
      ($Time_tuesday$ques$38.$$arity = 0)
    );
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc?", "gmt?");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "utc_offset", "gmt_offset");

    Opal.def(
      self,
      "$wday",
      ($Time_wday$39 = function $$wday() {
        var self = this;

        return self.is_utc ? self.getUTCDay() : self.getDay();
      }),
      ($Time_wday$39.$$arity = 0)
    );

    Opal.def(
      self,
      "$wednesday?",
      ($Time_wednesday$ques$40 = function () {
        var self = this;

        return self.$wday() == 3;
      }),
      ($Time_wednesday$ques$40.$$arity = 0)
    );

    Opal.def(
      self,
      "$year",
      ($Time_year$41 = function $$year() {
        var self = this;

        return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
      }),
      ($Time_year$41.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$cweek_cyear",
        ($Time_cweek_cyear$42 = function $$cweek_cyear() {
          var self = this,
            jan01 = nil,
            jan01_wday = nil,
            first_monday = nil,
            year = nil,
            $ret_or_3 = nil,
            offset = nil,
            week = nil,
            dec31 = nil,
            dec31_wday = nil,
            $ret_or_4 = nil;

          jan01 = $$($nesting, "Time").$new(self.$year(), 1, 1);
          jan01_wday = jan01.$wday();
          first_monday = 0;
          year = self.$year();
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_3 = $rb_le(jan01_wday, 4)))) {
                  return jan01_wday["$!="](0);
                } else {
                  return $ret_or_3;
                }
                return nil;
              })()
            )
          ) {
            offset = $rb_minus(jan01_wday, 1);
          } else {
            offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
            if (offset["$=="](-8)) {
              offset = -1;
            }
          }
          week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
          if ($truthy($rb_le(week, 0))) {
            return $$($nesting, "Time")
              .$new($rb_minus(self.$year(), 1), 12, 31)
              .$cweek_cyear();
          } else if (week["$=="](53)) {
            dec31 = $$($nesting, "Time").$new(self.$year(), 12, 31);
            dec31_wday = dec31.$wday();
            if (
              $truthy(
                (function () {
                  if ($truthy(($ret_or_4 = $rb_le(dec31_wday, 3)))) {
                    return dec31_wday["$!="](0);
                  } else {
                    return $ret_or_4;
                  }
                  return nil;
                })()
              )
            ) {
              week = 1;
              year = $rb_plus(year, 1);
            }
          }
          return [week, year];
        }),
        ($Time_cweek_cyear$42.$$arity = 0)
      ),
      nil) && "cweek_cyear"
    );
  })($nesting[0], Date, $nesting);
};

Opal.modules["corelib/struct"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_gt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs > rhs
      : lhs["$>"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs < rhs
      : lhs["$<"](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $send = Opal.send,
    $alias = Opal.alias;

  Opal.add_stubs([
    "$require",
    "$include",
    "$==",
    "$class",
    "$!=",
    "$upcase",
    "$[]",
    "$unshift",
    "$const_name!",
    "$map",
    "$coerce_to!",
    "$new",
    "$each",
    "$define_struct_attribute",
    "$allocate",
    "$initialize",
    "$alias_method",
    "$module_eval",
    "$to_proc",
    "$const_set",
    "$raise",
    "$<<",
    "$members",
    "$define_method",
    "$instance_eval",
    "$last",
    "$>",
    "$length",
    "$-",
    "$keys",
    "$any?",
    "$join",
    "$[]=",
    "$each_with_index",
    "$hash",
    "$===",
    "$<",
    "$-@",
    "$size",
    "$>=",
    "$include?",
    "$to_sym",
    "$instance_of?",
    "$__id__",
    "$eql?",
    "$enum_for",
    "$name",
    "$+",
    "$each_pair",
    "$inspect",
    "$to_h",
    "$args",
    "$each_with_object",
    "$flatten",
    "$to_a",
    "$respond_to?",
    "$dig",
  ]);

  self.$require("corelib/enumerable");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Struct");

    var $nesting = [self].concat($parent_nesting),
      $Struct_new$1,
      $Struct_define_struct_attribute$6,
      $Struct_members$9,
      $Struct_inherited$10,
      $Struct_initialize$12,
      $Struct_initialize_copy$15,
      $Struct_members$16,
      $Struct_hash$17,
      $Struct_$$$18,
      $Struct_$$$eq$19,
      $Struct_$eq_eq$20,
      $Struct_eql$ques$21,
      $Struct_each$22,
      $Struct_each_pair$25,
      $Struct_length$28,
      $Struct_to_a$29,
      $Struct_inspect$31,
      $Struct_to_h$33,
      $Struct_values_at$35,
      $Struct_dig$37;

    self.$include($$($nesting, "Enumerable"));
    Opal.defs(
      self,
      "$new",
      ($Struct_new$1 = function (const_name, $a, $b) {
        var $iter = $Struct_new$1.$$p,
          block = $iter || nil,
          $post_args,
          $kwargs,
          args,
          keyword_init,
          $$2,
          $$3,
          self = this,
          $ret_or_1 = nil,
          klass = nil;

        if ($iter) $Struct_new$1.$$p = null;

        if ($iter) $Struct_new$1.$$p = null;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        $kwargs = Opal.extract_kwargs($post_args);

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        args = $post_args;

        keyword_init = $kwargs.$$smap["keyword_init"];
        if (keyword_init == null) {
          keyword_init = false;
        }
        if ($truthy(const_name)) {
          if (
            $truthy(
              (function () {
                if (
                  $truthy(
                    ($ret_or_1 = const_name
                      .$class()
                      ["$=="]($$($nesting, "String")))
                  )
                ) {
                  return const_name["$[]"](0)
                    .$upcase()
                    ["$!="](const_name["$[]"](0));
                } else {
                  return $ret_or_1;
                }
                return nil;
              })()
            )
          ) {
            args.$unshift(const_name);
            const_name = nil;
          } else {
            try {
              const_name = $$($nesting, "Opal")["$const_name!"](const_name);
            } catch ($err) {
              if (
                Opal.rescue($err, [
                  $$($nesting, "TypeError"),
                  $$($nesting, "NameError"),
                ])
              ) {
                try {
                  args.$unshift(const_name);
                  const_name = nil;
                } finally {
                  Opal.pop_exception();
                }
              } else {
                throw $err;
              }
            }
          }
        }
        $send(
          args,
          "map",
          [],
          (($$2 = function (arg) {
            var self = $$2.$$s == null ? this : $$2.$$s;

            if (arg == null) {
              arg = nil;
            }
            return $$($nesting, "Opal")["$coerce_to!"](
              arg,
              $$($nesting, "String"),
              "to_str"
            );
          }),
          ($$2.$$s = self),
          ($$2.$$arity = 1),
          $$2)
        );
        klass = $send(
          $$($nesting, "Class"),
          "new",
          [self],
          (($$3 = function () {
            var self = $$3.$$s == null ? this : $$3.$$s,
              $$4;

            $send(
              args,
              "each",
              [],
              (($$4 = function (arg) {
                var self = $$4.$$s == null ? this : $$4.$$s;

                if (arg == null) {
                  arg = nil;
                }
                return self.$define_struct_attribute(arg);
              }),
              ($$4.$$s = self),
              ($$4.$$arity = 1),
              $$4)
            );
            return (function (self, $parent_nesting) {
              var $nesting = [self].concat($parent_nesting),
                $new$5;

              Opal.def(
                self,
                "$new",
                ($new$5 = function ($a) {
                  var $post_args,
                    args,
                    self = this,
                    instance = nil;

                  $post_args = Opal.slice.call(arguments, 0, arguments.length);

                  args = $post_args;
                  instance = self.$allocate();
                  instance.$$data = {};
                  $send(instance, "initialize", Opal.to_a(args));
                  return instance;
                }),
                ($new$5.$$arity = -1)
              );
              return self.$alias_method("[]", "new");
            })(Opal.get_singleton_class(self), $nesting);
          }),
          ($$3.$$s = self),
          ($$3.$$arity = 0),
          $$3)
        );
        if ($truthy(block)) {
          $send(klass, "module_eval", [], block.$to_proc());
        }
        klass.$$keyword_init = keyword_init;
        if ($truthy(const_name)) {
          $$($nesting, "Struct").$const_set(const_name, klass);
        }
        return klass;
      }),
      ($Struct_new$1.$$arity = -2)
    );
    Opal.defs(
      self,
      "$define_struct_attribute",
      ($Struct_define_struct_attribute$6 = function $$define_struct_attribute(
        name
      ) {
        var $$7,
          $$8,
          self = this;

        if (self["$=="]($$($nesting, "Struct"))) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "you cannot define attributes to the Struct class"
          );
        }
        self.$members()["$<<"](name);
        $send(
          self,
          "define_method",
          [name],
          (($$7 = function () {
            var self = $$7.$$s == null ? this : $$7.$$s;

            return self.$$data[name];
          }),
          ($$7.$$s = self),
          ($$7.$$arity = 0),
          $$7)
        );
        return $send(
          self,
          "define_method",
          ["" + name + "="],
          (($$8 = function (value) {
            var self = $$8.$$s == null ? this : $$8.$$s;

            if (value == null) {
              value = nil;
            }
            return (self.$$data[name] = value);
          }),
          ($$8.$$s = self),
          ($$8.$$arity = 1),
          $$8)
        );
      }),
      ($Struct_define_struct_attribute$6.$$arity = 1)
    );
    Opal.defs(
      self,
      "$members",
      ($Struct_members$9 = function $$members() {
        var self = this,
          $ret_or_2 = nil;
        if (self.members == null) self.members = nil;

        if (self["$=="]($$($nesting, "Struct"))) {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "the Struct class has no members"
          );
        }
        return (self.members = (function () {
          if ($truthy(($ret_or_2 = self.members))) {
            return $ret_or_2;
          } else {
            return [];
          }
          return nil;
        })());
      }),
      ($Struct_members$9.$$arity = 0)
    );
    Opal.defs(
      self,
      "$inherited",
      ($Struct_inherited$10 = function $$inherited(klass) {
        var $$11,
          self = this,
          members = nil;
        if (self.members == null) self.members = nil;

        members = self.members;
        return $send(
          klass,
          "instance_eval",
          [],
          (($$11 = function () {
            var self = $$11.$$s == null ? this : $$11.$$s;

            return (self.members = members);
          }),
          ($$11.$$s = self),
          ($$11.$$arity = 0),
          $$11)
        );
      }),
      ($Struct_inherited$10.$$arity = 1)
    );

    Opal.def(
      self,
      "$initialize",
      ($Struct_initialize$12 = function $$initialize($a) {
        var $post_args,
          args,
          $$13,
          $$14,
          self = this,
          kwargs = nil,
          $ret_or_3 = nil,
          $ret_or_4 = nil,
          extra = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if ($truthy(self.$class().$$keyword_init)) {
          kwargs = (function () {
            if ($truthy(($ret_or_3 = args.$last()))) {
              return $ret_or_3;
            } else {
              return $hash2([], {});
            }
            return nil;
          })();
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_4 = $rb_gt(args.$length(), 1)))) {
                  return $ret_or_4;
                } else {
                  return args.length === 1 && !kwargs.$$is_hash;
                }
                return nil;
              })()
            )
          ) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" +
                "wrong number of arguments (given " +
                args.$length() +
                ", expected 0)"
            );
          }
          extra = $rb_minus(kwargs.$keys(), self.$class().$members());
          if ($truthy(extra["$any?"]())) {
            self.$raise(
              $$($nesting, "ArgumentError"),
              "" + "unknown keywords: " + extra.$join(", ")
            );
          }
          return $send(
            self.$class().$members(),
            "each",
            [],
            (($$13 = function (name) {
              var self = $$13.$$s == null ? this : $$13.$$s,
                $writer = nil;

              if (name == null) {
                name = nil;
              }
              $writer = [name, kwargs["$[]"](name)];
              $send(self, "[]=", Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            }),
            ($$13.$$s = self),
            ($$13.$$arity = 1),
            $$13)
          );
        } else {
          if (
            $truthy($rb_gt(args.$length(), self.$class().$members().$length()))
          ) {
            self.$raise($$($nesting, "ArgumentError"), "struct size differs");
          }
          return $send(
            self.$class().$members(),
            "each_with_index",
            [],
            (($$14 = function (name, index) {
              var self = $$14.$$s == null ? this : $$14.$$s,
                $writer = nil;

              if (name == null) {
                name = nil;
              }

              if (index == null) {
                index = nil;
              }
              $writer = [name, args["$[]"](index)];
              $send(self, "[]=", Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            }),
            ($$14.$$s = self),
            ($$14.$$arity = 2),
            $$14)
          );
        }
      }),
      ($Struct_initialize$12.$$arity = -1)
    );

    Opal.def(
      self,
      "$initialize_copy",
      ($Struct_initialize_copy$15 = function $$initialize_copy(from) {
        var self = this;

        self.$$data = {};
        var keys = Object.keys(from.$$data),
          i,
          max,
          name;
        for (i = 0, max = keys.length; i < max; i++) {
          name = keys[i];
          self.$$data[name] = from.$$data[name];
        }
      }),
      ($Struct_initialize_copy$15.$$arity = 1)
    );

    Opal.def(
      self,
      "$members",
      ($Struct_members$16 = function $$members() {
        var self = this;

        return self.$class().$members();
      }),
      ($Struct_members$16.$$arity = 0)
    );

    Opal.def(
      self,
      "$hash",
      ($Struct_hash$17 = function $$hash() {
        var self = this;

        return $$($nesting, "Hash").$new(self.$$data).$hash();
      }),
      ($Struct_hash$17.$$arity = 0)
    );

    Opal.def(
      self,
      "$[]",
      ($Struct_$$$18 = function (name) {
        var self = this;

        if ($truthy($$($nesting, "Integer")["$==="](name))) {
          if (
            $truthy($rb_lt(name, self.$class().$members().$size()["$-@"]()))
          ) {
            self.$raise(
              $$($nesting, "IndexError"),
              "" +
                "offset " +
                name +
                " too small for struct(size:" +
                self.$class().$members().$size() +
                ")"
            );
          }
          if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
            self.$raise(
              $$($nesting, "IndexError"),
              "" +
                "offset " +
                name +
                " too large for struct(size:" +
                self.$class().$members().$size() +
                ")"
            );
          }
          name = self.$class().$members()["$[]"](name);
        } else if ($truthy($$($nesting, "String")["$==="](name))) {
          if (!self.$$data.hasOwnProperty(name)) {
            self.$raise(
              $$($nesting, "NameError").$new(
                "" + "no member '" + name + "' in struct",
                name
              )
            );
          }
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "no implicit conversion of " + name.$class() + " into Integer"
          );
        }
        name = $$($nesting, "Opal")["$coerce_to!"](
          name,
          $$($nesting, "String"),
          "to_str"
        );
        return self.$$data[name];
      }),
      ($Struct_$$$18.$$arity = 1)
    );

    Opal.def(
      self,
      "$[]=",
      ($Struct_$$$eq$19 = function (name, value) {
        var self = this;

        if ($truthy($$($nesting, "Integer")["$==="](name))) {
          if (
            $truthy($rb_lt(name, self.$class().$members().$size()["$-@"]()))
          ) {
            self.$raise(
              $$($nesting, "IndexError"),
              "" +
                "offset " +
                name +
                " too small for struct(size:" +
                self.$class().$members().$size() +
                ")"
            );
          }
          if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
            self.$raise(
              $$($nesting, "IndexError"),
              "" +
                "offset " +
                name +
                " too large for struct(size:" +
                self.$class().$members().$size() +
                ")"
            );
          }
          name = self.$class().$members()["$[]"](name);
        } else if ($truthy($$($nesting, "String")["$==="](name))) {
          if ($truthy(self.$class().$members()["$include?"](name.$to_sym()))) {
          } else {
            self.$raise(
              $$($nesting, "NameError").$new(
                "" + "no member '" + name + "' in struct",
                name
              )
            );
          }
        } else {
          self.$raise(
            $$($nesting, "TypeError"),
            "" + "no implicit conversion of " + name.$class() + " into Integer"
          );
        }
        name = $$($nesting, "Opal")["$coerce_to!"](
          name,
          $$($nesting, "String"),
          "to_str"
        );
        return (self.$$data[name] = value);
      }),
      ($Struct_$$$eq$19.$$arity = 2)
    );

    Opal.def(
      self,
      "$==",
      ($Struct_$eq_eq$20 = function (other) {
        var self = this;

        if ($truthy(other["$instance_of?"](self.$class()))) {
        } else {
          return false;
        }

        var recursed1 = {},
          recursed2 = {};

        function _eqeq(struct, other) {
          var key, a, b;

          recursed1[struct.$__id__()] = true;
          recursed2[other.$__id__()] = true;

          for (key in struct.$$data) {
            a = struct.$$data[key];
            b = other.$$data[key];

            if ($$($nesting, "Struct")["$==="](a)) {
              if (
                !recursed1.hasOwnProperty(a.$__id__()) ||
                !recursed2.hasOwnProperty(b.$__id__())
              ) {
                if (!_eqeq(a, b)) {
                  return false;
                }
              }
            } else {
              if (!a["$=="](b)) {
                return false;
              }
            }
          }

          return true;
        }

        return _eqeq(self, other);
      }),
      ($Struct_$eq_eq$20.$$arity = 1)
    );

    Opal.def(
      self,
      "$eql?",
      ($Struct_eql$ques$21 = function (other) {
        var self = this;

        if ($truthy(other["$instance_of?"](self.$class()))) {
        } else {
          return false;
        }

        var recursed1 = {},
          recursed2 = {};

        function _eqeq(struct, other) {
          var key, a, b;

          recursed1[struct.$__id__()] = true;
          recursed2[other.$__id__()] = true;

          for (key in struct.$$data) {
            a = struct.$$data[key];
            b = other.$$data[key];

            if ($$($nesting, "Struct")["$==="](a)) {
              if (
                !recursed1.hasOwnProperty(a.$__id__()) ||
                !recursed2.hasOwnProperty(b.$__id__())
              ) {
                if (!_eqeq(a, b)) {
                  return false;
                }
              }
            } else {
              if (!a["$eql?"](b)) {
                return false;
              }
            }
          }

          return true;
        }

        return _eqeq(self, other);
      }),
      ($Struct_eql$ques$21.$$arity = 1)
    );

    Opal.def(
      self,
      "$each",
      ($Struct_each$22 = function $$each() {
        var $$23,
          $$24,
          $iter = $Struct_each$22.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Struct_each$22.$$p = null;

        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each"],
            (($$23 = function () {
              var self = $$23.$$s == null ? this : $$23.$$s;

              return self.$size();
            }),
            ($$23.$$s = self),
            ($$23.$$arity = 0),
            $$23)
          );
        }
        $send(
          self.$class().$members(),
          "each",
          [],
          (($$24 = function (name) {
            var self = $$24.$$s == null ? this : $$24.$$s;

            if (name == null) {
              name = nil;
            }
            return Opal.yield1($yield, self["$[]"](name));
          }),
          ($$24.$$s = self),
          ($$24.$$arity = 1),
          $$24)
        );
        return self;
      }),
      ($Struct_each$22.$$arity = 0)
    );

    Opal.def(
      self,
      "$each_pair",
      ($Struct_each_pair$25 = function $$each_pair() {
        var $$26,
          $$27,
          $iter = $Struct_each_pair$25.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Struct_each_pair$25.$$p = null;

        if ($yield !== nil) {
        } else {
          return $send(
            self,
            "enum_for",
            ["each_pair"],
            (($$26 = function () {
              var self = $$26.$$s == null ? this : $$26.$$s;

              return self.$size();
            }),
            ($$26.$$s = self),
            ($$26.$$arity = 0),
            $$26)
          );
        }
        $send(
          self.$class().$members(),
          "each",
          [],
          (($$27 = function (name) {
            var self = $$27.$$s == null ? this : $$27.$$s;

            if (name == null) {
              name = nil;
            }
            return Opal.yield1($yield, [name, self["$[]"](name)]);
          }),
          ($$27.$$s = self),
          ($$27.$$arity = 1),
          $$27)
        );
        return self;
      }),
      ($Struct_each_pair$25.$$arity = 0)
    );

    Opal.def(
      self,
      "$length",
      ($Struct_length$28 = function $$length() {
        var self = this;

        return self.$class().$members().$length();
      }),
      ($Struct_length$28.$$arity = 0)
    );
    $alias(self, "size", "length");

    Opal.def(
      self,
      "$to_a",
      ($Struct_to_a$29 = function $$to_a() {
        var $$30,
          self = this;

        return $send(
          self.$class().$members(),
          "map",
          [],
          (($$30 = function (name) {
            var self = $$30.$$s == null ? this : $$30.$$s;

            if (name == null) {
              name = nil;
            }
            return self["$[]"](name);
          }),
          ($$30.$$s = self),
          ($$30.$$arity = 1),
          $$30)
        );
      }),
      ($Struct_to_a$29.$$arity = 0)
    );
    $alias(self, "values", "to_a");

    Opal.def(
      self,
      "$inspect",
      ($Struct_inspect$31 = function $$inspect() {
        var $$32,
          self = this,
          result = nil,
          $ret_or_5 = nil;

        result = "#<struct ";
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_5 = $$($nesting, "Struct")["$==="](self)))) {
                return self.$class().$name();
              } else {
                return $ret_or_5;
              }
              return nil;
            })()
          )
        ) {
          result = $rb_plus(result, "" + self.$class() + " ");
        }
        result = $rb_plus(
          result,
          $send(
            self.$each_pair(),
            "map",
            [],
            (($$32 = function (name, value) {
              var self = $$32.$$s == null ? this : $$32.$$s;

              if (name == null) {
                name = nil;
              }

              if (value == null) {
                value = nil;
              }
              return "" + name + "=" + value.$inspect();
            }),
            ($$32.$$s = self),
            ($$32.$$arity = 2),
            $$32)
          ).$join(", ")
        );
        result = $rb_plus(result, ">");
        return result;
      }),
      ($Struct_inspect$31.$$arity = 0)
    );
    $alias(self, "to_s", "inspect");

    Opal.def(
      self,
      "$to_h",
      ($Struct_to_h$33 = function $$to_h() {
        var $iter = $Struct_to_h$33.$$p,
          block = $iter || nil,
          $$34,
          self = this;

        if ($iter) $Struct_to_h$33.$$p = null;

        if ($iter) $Struct_to_h$33.$$p = null;
        if (block !== nil) {
          return $send(
            $send(self, "map", [], block.$to_proc()),
            "to_h",
            Opal.to_a(self.$args())
          );
        }
        return $send(
          self.$class().$members(),
          "each_with_object",
          [$hash2([], {})],
          (($$34 = function (name, h) {
            var self = $$34.$$s == null ? this : $$34.$$s,
              $writer = nil;

            if (name == null) {
              name = nil;
            }

            if (h == null) {
              h = nil;
            }
            $writer = [name, self["$[]"](name)];
            $send(h, "[]=", Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }),
          ($$34.$$s = self),
          ($$34.$$arity = 2),
          $$34)
        );
      }),
      ($Struct_to_h$33.$$arity = 0)
    );

    Opal.def(
      self,
      "$values_at",
      ($Struct_values_at$35 = function $$values_at($a) {
        var $post_args,
          args,
          $$36,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        args = $send(
          args,
          "map",
          [],
          (($$36 = function (arg) {
            var self = $$36.$$s == null ? this : $$36.$$s;

            if (arg == null) {
              arg = nil;
            }
            return arg.$$is_range ? arg.$to_a() : arg;
          }),
          ($$36.$$s = self),
          ($$36.$$arity = 1),
          $$36)
        ).$flatten();

        var result = [];
        for (var i = 0, len = args.length; i < len; i++) {
          if (!args[i].$$is_number) {
            self.$raise(
              $$($nesting, "TypeError"),
              "" +
                "no implicit conversion of " +
                args[i].$class() +
                " into Integer"
            );
          }
          result.push(self["$[]"](args[i]));
        }
        return result;
      }),
      ($Struct_values_at$35.$$arity = -1)
    );
    return (
      (Opal.def(
        self,
        "$dig",
        ($Struct_dig$37 = function $$dig(key, $a) {
          var $post_args,
            keys,
            self = this,
            item = nil;

          $post_args = Opal.slice.call(arguments, 1, arguments.length);

          keys = $post_args;
          item = (function () {
            if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
              return self.$$data[key] || nil;
            } else {
              return nil;
            }
            return nil;
          })();

          if (item === nil || keys.length === 0) {
            return item;
          }
          if ($truthy(item["$respond_to?"]("dig"))) {
          } else {
            self.$raise(
              $$($nesting, "TypeError"),
              "" + item.$class() + " does not have #dig method"
            );
          }
          return $send(item, "dig", Opal.to_a(keys));
        }),
        ($Struct_dig$37.$$arity = -2)
      ),
      nil) && "dig"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/dir"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $truthy = Opal.truthy;

  Opal.add_stubs(["$[]"]);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Dir");

    var $nesting = [self].concat($parent_nesting);

    return (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $chdir$1,
        $pwd$2,
        $home$3;

      Opal.def(
        self,
        "$chdir",
        ($chdir$1 = function $$chdir(dir) {
          var $iter = $chdir$1.$$p,
            $yield = $iter || nil,
            self = this,
            prev_cwd = nil;

          if ($iter) $chdir$1.$$p = null;
          return (function () {
            try {
              prev_cwd = Opal.current_dir;
              Opal.current_dir = dir;
              return Opal.yieldX($yield, []);
            } finally {
              Opal.current_dir = prev_cwd;
            }
          })();
        }),
        ($chdir$1.$$arity = 1)
      );

      Opal.def(
        self,
        "$pwd",
        ($pwd$2 = function $$pwd() {
          var self = this;

          return Opal.current_dir || ".";
        }),
        ($pwd$2.$$arity = 0)
      );
      $alias(self, "getwd", "pwd");
      return (
        (Opal.def(
          self,
          "$home",
          ($home$3 = function $$home() {
            var self = this,
              $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = $$($nesting, "ENV")["$[]"]("HOME")))) {
              return $ret_or_1;
            } else {
              return ".";
            }
          }),
          ($home$3.$$arity = 0)
        ),
        nil) && "home"
      );
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/file"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $truthy = Opal.truthy,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $range = Opal.range,
    $send = Opal.send;

  Opal.add_stubs([
    "$respond_to?",
    "$to_path",
    "$pwd",
    "$split",
    "$sub",
    "$+",
    "$unshift",
    "$join",
    "$home",
    "$raise",
    "$start_with?",
    "$absolute_path",
    "$coerce_to!",
    "$basename",
    "$empty?",
    "$rindex",
    "$[]",
    "$nil?",
    "$==",
    "$-",
    "$length",
    "$gsub",
    "$find",
    "$=~",
    "$map",
    "$each_with_index",
    "$flatten",
    "$reject",
    "$to_proc",
    "$end_with?",
  ]);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "File");

    var $nesting = [self].concat($parent_nesting),
      windows_root_rx = nil;

    Opal.const_set(
      $nesting[0],
      "Separator",
      Opal.const_set($nesting[0], "SEPARATOR", "/")
    );
    Opal.const_set($nesting[0], "ALT_SEPARATOR", nil);
    Opal.const_set($nesting[0], "PATH_SEPARATOR", ":");
    Opal.const_set($nesting[0], "FNM_SYSCASE", 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function (self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting),
        $absolute_path$1,
        $expand_path$2,
        $dirname$3,
        $basename$4,
        $extname$5,
        $exist$ques$6,
        $directory$ques$7,
        $join$9,
        $split$12;

      Opal.def(
        self,
        "$absolute_path",
        ($absolute_path$1 = function $$absolute_path(path, basedir) {
          var self = this,
            sep = nil,
            sep_chars = nil,
            new_parts = nil,
            $ret_or_1 = nil,
            path_abs = nil,
            basedir_abs = nil,
            parts = nil,
            leading_sep = nil,
            abs = nil,
            new_path = nil;

          if (basedir == null) {
            basedir = nil;
          }
          sep = $$($nesting, "SEPARATOR");
          sep_chars = $sep_chars();
          new_parts = [];
          path = (function () {
            if ($truthy(path["$respond_to?"]("to_path"))) {
              return path.$to_path();
            } else {
              return path;
            }
            return nil;
          })();
          basedir = (function () {
            if ($truthy(($ret_or_1 = basedir))) {
              return $ret_or_1;
            } else {
              return $$($nesting, "Dir").$pwd();
            }
            return nil;
          })();
          path_abs =
            path.substr(0, sep.length) === sep || windows_root_rx.test(path);
          basedir_abs =
            basedir.substr(0, sep.length) === sep ||
            windows_root_rx.test(basedir);
          if ($truthy(path_abs)) {
            parts = path.$split(Opal.regexp(["[", sep_chars, "]"]));
            leading_sep = windows_root_rx.test(path)
              ? ""
              : path.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
            abs = true;
          } else {
            parts = $rb_plus(
              basedir.$split(Opal.regexp(["[", sep_chars, "]"])),
              path.$split(Opal.regexp(["[", sep_chars, "]"]))
            );
            leading_sep = windows_root_rx.test(basedir)
              ? ""
              : basedir.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
            abs = basedir_abs;
          }

          var part;
          for (var i = 0, ii = parts.length; i < ii; i++) {
            part = parts[i];

            if (
              part === nil ||
              (part === "" && (new_parts.length === 0 || abs)) ||
              (part === "." && (new_parts.length === 0 || abs))
            ) {
              continue;
            }
            if (part === "..") {
              new_parts.pop();
            } else {
              new_parts.push(part);
            }
          }

          if (!abs && parts[0] !== ".") {
            new_parts.$unshift(".");
          }
          new_path = new_parts.$join(sep);
          if ($truthy(abs)) {
            new_path = $rb_plus(leading_sep, new_path);
          }
          return new_path;
        }),
        ($absolute_path$1.$$arity = -2)
      );

      Opal.def(
        self,
        "$expand_path",
        ($expand_path$2 = function $$expand_path(path, basedir) {
          var self = this,
            sep = nil,
            sep_chars = nil,
            home = nil,
            leading_sep = nil,
            home_path_regexp = nil;

          if (basedir == null) {
            basedir = nil;
          }
          sep = $$($nesting, "SEPARATOR");
          sep_chars = $sep_chars();
          if ($truthy(path[0] === "~" || (basedir && basedir[0] === "~"))) {
            home = $$($nesting, "Dir").$home();
            if ($truthy(home)) {
            } else {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "couldn't find HOME environment -- expanding `~'"
              );
            }
            leading_sep = windows_root_rx.test(home)
              ? ""
              : home.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
            if ($truthy(home["$start_with?"](leading_sep))) {
            } else {
              self.$raise($$($nesting, "ArgumentError"), "non-absolute home");
            }
            home = $rb_plus(home, sep);
            home_path_regexp = Opal.regexp(["^\\~(?:", sep, "|$)"]);
            path = path.$sub(home_path_regexp, home);
            if ($truthy(basedir)) {
              basedir = basedir.$sub(home_path_regexp, home);
            }
          }
          return self.$absolute_path(path, basedir);
        }),
        ($expand_path$2.$$arity = -2)
      );
      $alias(self, "realpath", "expand_path");

      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy(path["$respond_to?"]("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, "Opal")["$coerce_to!"](
          path,
          $$($nesting, "String"),
          "to_str"
        );

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, "ALT_SEPARATOR") === nil) {
          return Opal.escape_regexp($$($nesting, "SEPARATOR"));
        } else {
          return Opal.escape_regexp(
            $rb_plus($$($nesting, "SEPARATOR"), $$($nesting, "ALT_SEPARATOR"))
          );
        }
      }
      Opal.def(
        self,
        "$dirname",
        ($dirname$3 = function $$dirname(path) {
          var self = this,
            sep_chars = nil;

          sep_chars = $sep_chars();
          path = $coerce_to_path(path);

          var absolute = path.match(new RegExp("" + "^[" + sep_chars + "]"));

          path = path.replace(new RegExp("" + "[" + sep_chars + "]+$"), ""); // remove trailing separators
          path = path.replace(new RegExp("" + "[^" + sep_chars + "]+$"), ""); // remove trailing basename
          path = path.replace(new RegExp("" + "[" + sep_chars + "]+$"), ""); // remove final trailing separators

          if (path === "") {
            return absolute ? "/" : ".";
          }

          return path;
        }),
        ($dirname$3.$$arity = 1)
      );

      Opal.def(
        self,
        "$basename",
        ($basename$4 = function $$basename(name, suffix) {
          var self = this,
            sep_chars = nil;

          if (suffix == null) {
            suffix = nil;
          }
          sep_chars = $sep_chars();
          name = $coerce_to_path(name);

          if (name.length == 0) {
            return name;
          }

          if (suffix !== nil) {
            suffix = $$($nesting, "Opal")["$coerce_to!"](
              suffix,
              $$($nesting, "String"),
              "to_str"
            );
          } else {
            suffix = null;
          }

          name = name.replace(
            new RegExp("" + "(.)[" + sep_chars + "]*$"),
            "$1"
          );
          name = name.replace(
            new RegExp(
              "" + "^(?:.*[" + sep_chars + "])?([^" + sep_chars + "]+)$"
            ),
            "$1"
          );

          if (suffix === ".*") {
            name = name.replace(/\.[^\.]+$/, "");
          } else if (suffix !== null) {
            suffix = Opal.escape_regexp(suffix);
            name = name.replace(new RegExp("" + suffix + "$"), "");
          }

          return name;
        }),
        ($basename$4.$$arity = -2)
      );

      Opal.def(
        self,
        "$extname",
        ($extname$5 = function $$extname(path) {
          var self = this,
            filename = nil,
            last_dot_idx = nil,
            $ret_or_2 = nil;

          path = $coerce_to_path(path);
          filename = self.$basename(path);
          if ($truthy(filename["$empty?"]())) {
            return "";
          }
          last_dot_idx = filename["$[]"]($range(1, -1, false)).$rindex(".");
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_2 = last_dot_idx["$nil?"]()))) {
                  return $ret_or_2;
                } else {
                  return $rb_plus(last_dot_idx, 1)["$=="](
                    $rb_minus(filename.$length(), 1)
                  );
                }
                return nil;
              })()
            )
          ) {
            return "";
          } else {
            return filename["$[]"](
              Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false)
            );
          }
        }),
        ($extname$5.$$arity = 1)
      );

      Opal.def(
        self,
        "$exist?",
        ($exist$ques$6 = function (path) {
          var self = this;

          return Opal.modules[path] != null;
        }),
        ($exist$ques$6.$$arity = 1)
      );
      $alias(self, "exists?", "exist?");

      Opal.def(
        self,
        "$directory?",
        ($directory$ques$7 = function (path) {
          var $$8,
            self = this,
            files = nil,
            file = nil;

          files = [];

          for (var key in Opal.modules) {
            files.push(key);
          }
          path = path.$gsub(
            Opal.regexp([
              "(^.",
              $$($nesting, "SEPARATOR"),
              "+|",
              $$($nesting, "SEPARATOR"),
              "+$)",
            ])
          );
          file = $send(
            files,
            "find",
            [],
            (($$8 = function (f) {
              var self = $$8.$$s == null ? this : $$8.$$s;

              if (f == null) {
                f = nil;
              }
              return f["$=~"](Opal.regexp(["^", path]));
            }),
            ($$8.$$s = self),
            ($$8.$$arity = 1),
            $$8)
          );
          return file;
        }),
        ($directory$ques$7.$$arity = 1)
      );

      Opal.def(
        self,
        "$join",
        ($join$9 = function $$join($a) {
          var $post_args,
            paths,
            $$10,
            $$11,
            self = this,
            result = nil;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          paths = $post_args;
          if ($truthy(paths["$empty?"]())) {
            return "";
          }
          result = "";
          paths = $send(
            paths.$flatten().$each_with_index(),
            "map",
            [],
            (($$10 = function (item, index) {
              var self = $$10.$$s == null ? this : $$10.$$s,
                $ret_or_3 = nil,
                $ret_or_4 = nil;

              if (item == null) {
                item = nil;
              }

              if (index == null) {
                index = nil;
              }
              if (
                $truthy(
                  (function () {
                    if ($truthy(($ret_or_3 = index["$=="](0)))) {
                      return item["$empty?"]();
                    } else {
                      return $ret_or_3;
                    }
                    return nil;
                  })()
                )
              ) {
                return $$($nesting, "SEPARATOR");
              } else if (
                $truthy(
                  (function () {
                    if (
                      $truthy(
                        ($ret_or_4 = paths.$length()["$=="]($rb_plus(index, 1)))
                      )
                    ) {
                      return item["$empty?"]();
                    } else {
                      return $ret_or_4;
                    }
                    return nil;
                  })()
                )
              ) {
                return $$($nesting, "SEPARATOR");
              } else {
                return item;
              }
            }),
            ($$10.$$s = self),
            ($$10.$$arity = 2),
            $$10)
          );
          paths = $send(paths, "reject", [], "empty?".$to_proc());
          $send(
            paths,
            "each_with_index",
            [],
            (($$11 = function (item, index) {
              var self = $$11.$$s == null ? this : $$11.$$s,
                next_item = nil,
                $ret_or_5 = nil,
                $ret_or_6 = nil;

              if (item == null) {
                item = nil;
              }

              if (index == null) {
                index = nil;
              }
              next_item = paths["$[]"]($rb_plus(index, 1));
              if ($truthy(next_item["$nil?"]())) {
                return (result = "" + result + item);
              } else {
                if (
                  $truthy(
                    (function () {
                      if (
                        $truthy(
                          ($ret_or_5 = item["$end_with?"](
                            $$($nesting, "SEPARATOR")
                          ))
                        )
                      ) {
                        return next_item["$start_with?"](
                          $$($nesting, "SEPARATOR")
                        );
                      } else {
                        return $ret_or_5;
                      }
                      return nil;
                    })()
                  )
                ) {
                  item = item.$sub(
                    Opal.regexp([$$($nesting, "SEPARATOR"), "+$"]),
                    ""
                  );
                }
                return (result = (function () {
                  if (
                    $truthy(
                      (function () {
                        if (
                          $truthy(
                            ($ret_or_6 = item["$end_with?"](
                              $$($nesting, "SEPARATOR")
                            ))
                          )
                        ) {
                          return $ret_or_6;
                        } else {
                          return next_item["$start_with?"](
                            $$($nesting, "SEPARATOR")
                          );
                        }
                        return nil;
                      })()
                    )
                  ) {
                    return "" + result + item;
                  } else {
                    return "" + result + item + $$($nesting, "SEPARATOR");
                  }
                  return nil;
                })());
              }
            }),
            ($$11.$$s = self),
            ($$11.$$arity = 2),
            $$11)
          );
          return result;
        }),
        ($join$9.$$arity = -1)
      );
      return (
        (Opal.def(
          self,
          "$split",
          ($split$12 = function $$split(path) {
            var self = this;

            return path.$split($$($nesting, "SEPARATOR"));
          }),
          ($split$12.$$arity = 1)
        ),
        nil) && "split"
      );
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, "IO"), $nesting);
};

Opal.modules["corelib/process/base"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass;

  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Signal");

    var $nesting = [self].concat($parent_nesting),
      $Signal_trap$1;

    return (
      (Opal.defs(
        self,
        "$trap",
        ($Signal_trap$1 = function $$trap($a) {
          var $post_args,
            $rest_arg,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          $rest_arg = $post_args;
          return nil;
        }),
        ($Signal_trap$1.$$arity = -1)
      ),
      nil) && "trap"
    );
  })($nesting[0], null, $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "GC");

    var $nesting = [self].concat($parent_nesting),
      $GC_start$2;

    return (
      (Opal.defs(
        self,
        "$start",
        ($GC_start$2 = function $$start() {
          var self = this;

          return nil;
        }),
        ($GC_start$2.$$arity = 0)
      ),
      nil) && "start"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/process"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $truthy = Opal.truthy;

  Opal.add_stubs([
    "$const_set",
    "$size",
    "$<<",
    "$__register_clock__",
    "$to_f",
    "$now",
    "$new",
    "$[]",
    "$raise",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Process");

    var $nesting = [self].concat($parent_nesting),
      $Process___register_clock__$1,
      $Process_pid$2,
      $Process_times$3,
      $Process_clock_gettime$4,
      monotonic = nil;

    self.__clocks__ = [];
    Opal.defs(
      self,
      "$__register_clock__",
      ($Process___register_clock__$1 = function $$__register_clock__(
        name,
        func
      ) {
        var self = this;
        if (self.__clocks__ == null) self.__clocks__ = nil;

        self.$const_set(name, self.__clocks__.$size());
        return self.__clocks__["$<<"](func);
      }),
      ($Process___register_clock__$1.$$arity = 2)
    );
    self.$__register_clock__("CLOCK_REALTIME", function () {
      return Date.now();
    });
    monotonic = false;

    if (Opal.global.performance) {
      monotonic = function () {
        return performance.now();
      };
    } else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function () {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return hrtime[0] * 1000 + us / 1000;
      };
    }
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic);
    }
    Opal.defs(
      self,
      "$pid",
      ($Process_pid$2 = function $$pid() {
        var self = this;

        return 0;
      }),
      ($Process_pid$2.$$arity = 0)
    );
    Opal.defs(
      self,
      "$times",
      ($Process_times$3 = function $$times() {
        var self = this,
          t = nil;

        t = $$($nesting, "Time").$now().$to_f();
        return $$$($$($nesting, "Benchmark"), "Tms").$new(t, t, t, t, t);
      }),
      ($Process_times$3.$$arity = 0)
    );
    return (
      (Opal.defs(
        self,
        "$clock_gettime",
        ($Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
          var self = this,
            $ret_or_1 = nil,
            clock = nil;
          if (self.__clocks__ == null) self.__clocks__ = nil;

          if (unit == null) {
            unit = "float_second";
          }
          if ($truthy(($ret_or_1 = clock = self.__clocks__["$[]"](clock_id)))) {
            $ret_or_1;
          } else {
            self.$raise(
              $$$($$($nesting, "Errno"), "EINVAL"),
              "" +
                "clock_gettime(" +
                clock_id +
                ") " +
                self.__clocks__["$[]"](clock_id)
            );
          }

          var ms = clock();
          switch (unit) {
            case "float_second":
              return ms / 1000; // number of seconds as a float (default)
            case "float_millisecond":
              return ms / 1; // number of milliseconds as a float
            case "float_microsecond":
              return ms * 1000; // number of microseconds as a float
            case "second":
              return (ms / 1000) | 0; // number of seconds as an integer
            case "millisecond":
              return (ms / 1) | 0; // number of milliseconds as an integer
            case "microsecond":
              return (ms * 1000) | 0; // number of microseconds as an integer
            case "nanosecond":
              return (ms * 1000000) | 0; // number of nanoseconds as an integer
            default:
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" + "unexpected unit: " + unit
              );
          }
        }),
        ($Process_clock_gettime$4.$$arity = -2)
      ),
      nil) && "clock_gettime"
    );
  })($nesting[0], $nesting);
};

Opal.modules["corelib/random/formatter"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs / rhs
      : lhs["$/"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $module = Opal.module,
    $send = Opal.send,
    $range = Opal.range;

  Opal.add_stubs([
    "$_verify_count",
    "$bytes",
    "$encode",
    "$strict_encode64",
    "$random_bytes",
    "$urlsafe_encode64",
    "$split",
    "$hex",
    "$[]=",
    "$-",
    "$[]",
    "$map",
    "$to_proc",
    "$join",
    "$times",
    "$<<",
    "$|",
    "$ord",
    "$/",
    "$abs",
    "$random_float",
    "$raise",
    "$coerce_to!",
    "$flatten",
    "$new",
    "$random_number",
    "$length",
    "$include",
    "$extend",
  ]);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Random");

    var $nesting = [self].concat($parent_nesting);

    (function ($base, $parent_nesting) {
      var self = $module($base, "Formatter");

      var $nesting = [self].concat($parent_nesting),
        $Formatter_hex$1,
        $Formatter_random_bytes$2,
        $Formatter_base64$3,
        $Formatter_urlsafe_base64$4,
        $Formatter_uuid$5,
        $Formatter_random_float$6,
        $Formatter_random_number$8,
        $Formatter_alphanumeric$9;

      Opal.def(
        self,
        "$hex",
        ($Formatter_hex$1 = function $$hex(count) {
          var self = this;

          if (count == null) {
            count = nil;
          }
          count = $$($nesting, "Random").$_verify_count(count);

          var bytes = self.$bytes(count);
          var out = "";
          for (var i = 0; i < count; i++) {
            out += bytes.charCodeAt(i).toString(16).padStart(2, "0");
          }
          return out.$encode("US-ASCII");
        }),
        ($Formatter_hex$1.$$arity = -1)
      );

      Opal.def(
        self,
        "$random_bytes",
        ($Formatter_random_bytes$2 = function $$random_bytes(count) {
          var self = this;

          if (count == null) {
            count = nil;
          }
          return self.$bytes(count);
        }),
        ($Formatter_random_bytes$2.$$arity = -1)
      );

      Opal.def(
        self,
        "$base64",
        ($Formatter_base64$3 = function $$base64(count) {
          var self = this;

          if (count == null) {
            count = nil;
          }
          return $$($nesting, "Base64")
            .$strict_encode64(self.$random_bytes(count))
            .$encode("US-ASCII");
        }),
        ($Formatter_base64$3.$$arity = -1)
      );

      Opal.def(
        self,
        "$urlsafe_base64",
        ($Formatter_urlsafe_base64$4 = function $$urlsafe_base64(
          count,
          padding
        ) {
          var self = this;

          if (count == null) {
            count = nil;
          }

          if (padding == null) {
            padding = false;
          }
          return $$($nesting, "Base64")
            .$urlsafe_encode64(self.$random_bytes(count), padding)
            .$encode("US-ASCII");
        }),
        ($Formatter_urlsafe_base64$4.$$arity = -1)
      );

      Opal.def(
        self,
        "$uuid",
        ($Formatter_uuid$5 = function $$uuid() {
          var self = this,
            str = nil,
            $writer = nil;

          str = self.$hex(16).$split("");

          $writer = [12, "4"];
          $send(str, "[]=", Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];

          $writer = [16, ((parseInt(str["$[]"](16), 16) & 3) | 8).toString(16)];
          $send(str, "[]=", Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
          str = [
            str["$[]"]($range(0, 8, true)),
            str["$[]"]($range(8, 12, true)),
            str["$[]"]($range(12, 16, true)),
            str["$[]"]($range(16, 20, true)),
            str["$[]"]($range(20, 32, true)),
          ];
          str = $send(str, "map", [], "join".$to_proc());
          return str.$join("-");
        }),
        ($Formatter_uuid$5.$$arity = 0)
      );

      Opal.def(
        self,
        "$random_float",
        ($Formatter_random_float$6 = function $$random_float() {
          var $$7,
            self = this,
            bs = nil,
            num = nil;

          bs = self.$bytes(4);
          num = 0;
          $send(
            4,
            "times",
            [],
            (($$7 = function (i) {
              var self = $$7.$$s == null ? this : $$7.$$s;

              if (i == null) {
                i = nil;
              }
              num = num["$<<"](8);
              return (num = num["$|"](bs["$[]"](i).$ord()));
            }),
            ($$7.$$s = self),
            ($$7.$$arity = 1),
            $$7)
          );
          return $rb_divide(num.$abs(), 2147483647);
        }),
        ($Formatter_random_float$6.$$arity = 0)
      );

      Opal.def(
        self,
        "$random_number",
        ($Formatter_random_number$8 = function $$random_number(limit) {
          var self = this;

          function randomFloat() {
            return self.$random_float();
          }

          function randomInt(max) {
            return Math.floor(randomFloat() * max);
          }

          function randomRange() {
            var min = limit.begin,
              max = limit.end;

            if (min === nil || max === nil) {
              return nil;
            }

            var length = max - min;

            if (length < 0) {
              return nil;
            }

            if (length === 0) {
              return min;
            }

            if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
              length++;
            }

            return randomInt(length) + min;
          }

          if (limit == null) {
            return randomFloat();
          } else if (limit.$$is_range) {
            return randomRange();
          } else if (limit.$$is_number) {
            if (limit <= 0) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" + "invalid argument - " + limit
              );
            }

            if (limit % 1 === 0) {
              // integer
              return randomInt(limit);
            } else {
              return randomFloat() * limit;
            }
          } else {
            limit = $$($nesting, "Opal")["$coerce_to!"](
              limit,
              $$($nesting, "Integer"),
              "to_int"
            );

            if (limit <= 0) {
              self.$raise(
                $$($nesting, "ArgumentError"),
                "" + "invalid argument - " + limit
              );
            }

            return randomInt(limit);
          }
        }),
        ($Formatter_random_number$8.$$arity = -1)
      );
      return (
        (Opal.def(
          self,
          "$alphanumeric",
          ($Formatter_alphanumeric$9 = function $$alphanumeric(count) {
            var $$10,
              self = this,
              map = nil;

            if (count == null) {
              count = nil;
            }
            count = $$($nesting, "Random").$_verify_count(count);
            map = $send(
              [
                $range("0", "9", false),
                $range("a", "z", false),
                $range("A", "Z", false),
              ],
              "map",
              [],
              "to_a".$to_proc()
            ).$flatten();
            return $send(
              $$($nesting, "Array"),
              "new",
              [count],
              (($$10 = function (i) {
                var self = $$10.$$s == null ? this : $$10.$$s;

                if (i == null) {
                  i = nil;
                }
                return map["$[]"](self.$random_number(map.$length()));
              }),
              ($$10.$$s = self),
              ($$10.$$arity = 1),
              $$10)
            ).$join();
          }),
          ($Formatter_alphanumeric$9.$$arity = -1)
        ),
        nil) && "alphanumeric"
      );
    })($nesting[0], $nesting);
    self.$include($$$($$($nesting, "Random"), "Formatter"));
    return self.$extend($$$($$($nesting, "Random"), "Formatter"));
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/random/mersenne_twister"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $send = Opal.send,
    mersenne_twister = nil;

  Opal.add_stubs(["$generator=", "$-"]);

  mersenne_twister = (function () {
    /* Period parameters */
    var N = 624;
    var M = 397;
    var MATRIX_A = 0x9908b0df; /* constant vector a */
    var UMASK = 0x80000000; /* most significant w-r bits */
    var LMASK = 0x7fffffff; /* least significant r bits */
    var MIXBITS = function (u, v) {
      return (u & UMASK) | (v & LMASK);
    };
    var TWIST = function (u, v) {
      return (MIXBITS(u, v) >>> 1) ^ (v & 0x1 ? MATRIX_A : 0x0);
    };

    function init(s) {
      var mt = { left: 0, next: N, state: new Array(N) };
      init_genrand(mt, s);
      return mt;
    }

    /* initializes mt[N] with a seed */
    function init_genrand(mt, s) {
      var j, i;
      mt.state[0] = s >>> 0;
      for (j = 1; j < N; j++) {
        mt.state[j] =
          1812433253 * (mt.state[j - 1] ^ ((mt.state[j - 1] >> 30) >>> 0)) + j;
        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
        /* In the previous versions, MSBs of the seed affect   */
        /* only MSBs of the array state[].                     */
        /* 2002/01/09 modified by Makoto Matsumoto             */
        mt.state[j] &= 0xffffffff; /* for >32 bit machines */
      }
      mt.left = 1;
      mt.next = N;
    }

    /* generate N words at one time */
    function next_state(mt) {
      var p = 0,
        _p = mt.state;
      var j;

      mt.left = N;
      mt.next = 0;

      for (j = N - M + 1; --j; p++)
        _p[p] = _p[p + M] ^ TWIST(_p[p + 0], _p[p + 1]);

      for (j = M; --j; p++)
        _p[p] = _p[p + (M - N)] ^ TWIST(_p[p + 0], _p[p + 1]);

      _p[p] = _p[p + (M - N)] ^ TWIST(_p[p + 0], _p[0]);
    }

    /* generates a random number on [0,0xffffffff]-interval */
    function genrand_int32(mt) {
      /* mt must be initialized */
      var y;

      if (--mt.left <= 0) next_state(mt);
      y = mt.state[mt.next++];

      /* Tempering */
      y ^= y >>> 11;
      y ^= (y << 7) & 0x9d2c5680;
      y ^= (y << 15) & 0xefc60000;
      y ^= y >>> 18;

      return y >>> 0;
    }

    function int_pair_to_real_exclusive(a, b) {
      a >>>= 5;
      b >>>= 6;
      return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
    }

    // generates a random number on [0,1) with 53-bit resolution
    function genrand_real(mt) {
      /* mt must be initialized */
      var a = genrand_int32(mt),
        b = genrand_int32(mt);
      return int_pair_to_real_exclusive(a, b);
    }

    return { genrand_real: genrand_real, init: init };
  })();
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Random");

    var $nesting = [self].concat($parent_nesting),
      $writer = nil;

    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    Opal.const_set($nesting[0], "MERSENNE_TWISTER_GENERATOR", {
      new_seed: function () {
        return Math.round(Math.random() * MAX_INT);
      },
      reseed: function (seed) {
        return mersenne_twister.init(seed);
      },
      rand: function (mt) {
        return mersenne_twister.genrand_real(mt);
      },
    });

    $writer = [$$($nesting, "MERSENNE_TWISTER_GENERATOR")];
    $send(self, "generator=", Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];
  })($nesting[0], null, $nesting);
};

Opal.modules["corelib/random"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $falsy = Opal.falsy,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $send = Opal.send;

  Opal.add_stubs([
    "$require",
    "$attr_reader",
    "$to_int",
    "$raise",
    "$new_seed",
    "$coerce_to!",
    "$reseed",
    "$rand",
    "$seed",
    "$bytes",
    "$===",
    "$==",
    "$state",
    "$_verify_count",
    "$encode",
    "$join",
    "$new",
    "$chr",
    "$random_number",
    "$random_float",
    "$const_defined?",
    "$const_set",
  ]);

  self.$require("corelib/random/formatter");
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Random");

    var $nesting = [self].concat($parent_nesting),
      $Random__verify_count$1,
      $Random_initialize$2,
      $Random_reseed$3,
      $Random_new_seed$4,
      $Random_rand$5,
      $Random_srand$6,
      $Random_urandom$7,
      $Random_$eq_eq$8,
      $Random_bytes$9,
      $Random_bytes$11,
      $Random_rand$12,
      $Random_random_float$13,
      $Random_random_float$14,
      $Random_generator$eq$15;

    self.$attr_reader("seed", "state");
    Opal.defs(
      self,
      "$_verify_count",
      ($Random__verify_count$1 = function $$_verify_count(count) {
        var self = this;

        if ($falsy(count)) count = 16;
        if (typeof count !== "number") count = count.$to_int();
        if (count < 0)
          self.$raise(
            $$($nesting, "ArgumentError"),
            "negative string size (or size too big)"
          );
        count = Math.floor(count);
        return count;
      }),
      ($Random__verify_count$1.$$arity = 1)
    );

    Opal.def(
      self,
      "$initialize",
      ($Random_initialize$2 = function $$initialize(seed) {
        var self = this;

        if (seed == null) {
          seed = $$($nesting, "Random").$new_seed();
        }
        seed = $$($nesting, "Opal")["$coerce_to!"](
          seed,
          $$($nesting, "Integer"),
          "to_int"
        );
        self.state = seed;
        return self.$reseed(seed);
      }),
      ($Random_initialize$2.$$arity = -1)
    );

    Opal.def(
      self,
      "$reseed",
      ($Random_reseed$3 = function $$reseed(seed) {
        var self = this;

        self.seed = seed;
        return (self.$rng = Opal.$$rand.reseed(seed));
      }),
      ($Random_reseed$3.$$arity = 1)
    );
    Opal.defs(
      self,
      "$new_seed",
      ($Random_new_seed$4 = function $$new_seed() {
        var self = this;

        return Opal.$$rand.new_seed();
      }),
      ($Random_new_seed$4.$$arity = 0)
    );
    Opal.defs(
      self,
      "$rand",
      ($Random_rand$5 = function $$rand(limit) {
        var self = this;

        return $$($nesting, "DEFAULT").$rand(limit);
      }),
      ($Random_rand$5.$$arity = -1)
    );
    Opal.defs(
      self,
      "$srand",
      ($Random_srand$6 = function $$srand(n) {
        var self = this,
          previous_seed = nil;

        if (n == null) {
          n = $$($nesting, "Random").$new_seed();
        }
        n = $$($nesting, "Opal")["$coerce_to!"](
          n,
          $$($nesting, "Integer"),
          "to_int"
        );
        previous_seed = $$($nesting, "DEFAULT").$seed();
        $$($nesting, "DEFAULT").$reseed(n);
        return previous_seed;
      }),
      ($Random_srand$6.$$arity = -1)
    );
    Opal.defs(
      self,
      "$urandom",
      ($Random_urandom$7 = function $$urandom(size) {
        var self = this;

        return $$$("::", "SecureRandom").$bytes(size);
      }),
      ($Random_urandom$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$==",
      ($Random_$eq_eq$8 = function (other) {
        var self = this,
          $ret_or_1 = nil;

        if ($truthy($$($nesting, "Random")["$==="](other))) {
        } else {
          return false;
        }
        if ($truthy(($ret_or_1 = self.$seed()["$=="](other.$seed())))) {
          return self.$state()["$=="](other.$state());
        } else {
          return $ret_or_1;
        }
      }),
      ($Random_$eq_eq$8.$$arity = 1)
    );

    Opal.def(
      self,
      "$bytes",
      ($Random_bytes$9 = function $$bytes(length) {
        var $$10,
          self = this;

        length = $$($nesting, "Random").$_verify_count(length);
        return $send(
          $$($nesting, "Array"),
          "new",
          [length],
          (($$10 = function () {
            var self = $$10.$$s == null ? this : $$10.$$s;

            return self.$rand(255).$chr();
          }),
          ($$10.$$s = self),
          ($$10.$$arity = 0),
          $$10)
        )
          .$join()
          .$encode("ASCII-8BIT");
      }),
      ($Random_bytes$9.$$arity = 1)
    );
    Opal.defs(
      self,
      "$bytes",
      ($Random_bytes$11 = function $$bytes(length) {
        var self = this;

        return $$($nesting, "DEFAULT").$bytes(length);
      }),
      ($Random_bytes$11.$$arity = 1)
    );

    Opal.def(
      self,
      "$rand",
      ($Random_rand$12 = function $$rand(limit) {
        var self = this;

        return self.$random_number(limit);
      }),
      ($Random_rand$12.$$arity = -1)
    );

    Opal.def(
      self,
      "$random_float",
      ($Random_random_float$13 = function $$random_float() {
        var self = this;

        self.state++;
        return Opal.$$rand.rand(self.$rng);
      }),
      ($Random_random_float$13.$$arity = 0)
    );
    Opal.defs(
      self,
      "$random_float",
      ($Random_random_float$14 = function $$random_float() {
        var self = this;

        return $$($nesting, "DEFAULT").$random_float();
      }),
      ($Random_random_float$14.$$arity = 0)
    );
    return (
      (Opal.defs(
        self,
        "$generator=",
        ($Random_generator$eq$15 = function (generator) {
          var self = this;

          Opal.$$rand = generator;
          if ($truthy(self["$const_defined?"]("DEFAULT"))) {
            return $$($nesting, "DEFAULT").$reseed();
          } else {
            return self.$const_set("DEFAULT", self.$new(self.$new_seed()));
          }
        }),
        ($Random_generator$eq$15.$$arity = 1)
      ),
      nil) && "generator="
    );
  })($nesting[0], null, $nesting);
  return self.$require("corelib/random/mersenne_twister");
};

Opal.modules["corelib/unsupported"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var $public$35,
    $private$36,
    self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $module = Opal.module,
    $alias = Opal.alias;

  Opal.add_stubs(["$raise", "$warn", "$%"]);

  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
      case "error":
        $$($nesting, "Kernel").$raise(
          $$($nesting, "NotImplementedError"),
          message
        );
        break;
      case "warning":
        warn(message);
        break;
      default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String_$lt$lt$1,
      $String_capitalize$excl$2,
      $String_chomp$excl$3,
      $String_chop$excl$4,
      $String_downcase$excl$5,
      $String_gsub$excl$6,
      $String_lstrip$excl$7,
      $String_next$excl$8,
      $String_reverse$excl$9,
      $String_slice$excl$10,
      $String_squeeze$excl$11,
      $String_strip$excl$12,
      $String_sub$excl$13,
      $String_succ$excl$14,
      $String_swapcase$excl$15,
      $String_tr$excl$16,
      $String_tr_s$excl$17,
      $String_upcase$excl$18,
      $String_prepend$19,
      $String_$$$eq$20,
      $String_clear$21,
      $String_encode$excl$22,
      $String_unicode_normalize$excl$23;

    var ERROR =
      "String#%s not supported. Mutable String methods are not supported in Opal.";

    Opal.def(
      self,
      "$<<",
      ($String_$lt$lt$1 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("<<")
        );
      }),
      ($String_$lt$lt$1.$$arity = -1)
    );

    Opal.def(
      self,
      "$capitalize!",
      ($String_capitalize$excl$2 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("capitalize!")
        );
      }),
      ($String_capitalize$excl$2.$$arity = -1)
    );

    Opal.def(
      self,
      "$chomp!",
      ($String_chomp$excl$3 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("chomp!")
        );
      }),
      ($String_chomp$excl$3.$$arity = -1)
    );

    Opal.def(
      self,
      "$chop!",
      ($String_chop$excl$4 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("chop!")
        );
      }),
      ($String_chop$excl$4.$$arity = -1)
    );

    Opal.def(
      self,
      "$downcase!",
      ($String_downcase$excl$5 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("downcase!")
        );
      }),
      ($String_downcase$excl$5.$$arity = -1)
    );

    Opal.def(
      self,
      "$gsub!",
      ($String_gsub$excl$6 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("gsub!")
        );
      }),
      ($String_gsub$excl$6.$$arity = -1)
    );

    Opal.def(
      self,
      "$lstrip!",
      ($String_lstrip$excl$7 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("lstrip!")
        );
      }),
      ($String_lstrip$excl$7.$$arity = -1)
    );

    Opal.def(
      self,
      "$next!",
      ($String_next$excl$8 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("next!")
        );
      }),
      ($String_next$excl$8.$$arity = -1)
    );

    Opal.def(
      self,
      "$reverse!",
      ($String_reverse$excl$9 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("reverse!")
        );
      }),
      ($String_reverse$excl$9.$$arity = -1)
    );

    Opal.def(
      self,
      "$slice!",
      ($String_slice$excl$10 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("slice!")
        );
      }),
      ($String_slice$excl$10.$$arity = -1)
    );

    Opal.def(
      self,
      "$squeeze!",
      ($String_squeeze$excl$11 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("squeeze!")
        );
      }),
      ($String_squeeze$excl$11.$$arity = -1)
    );

    Opal.def(
      self,
      "$strip!",
      ($String_strip$excl$12 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("strip!")
        );
      }),
      ($String_strip$excl$12.$$arity = -1)
    );

    Opal.def(
      self,
      "$sub!",
      ($String_sub$excl$13 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("sub!")
        );
      }),
      ($String_sub$excl$13.$$arity = -1)
    );

    Opal.def(
      self,
      "$succ!",
      ($String_succ$excl$14 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("succ!")
        );
      }),
      ($String_succ$excl$14.$$arity = -1)
    );

    Opal.def(
      self,
      "$swapcase!",
      ($String_swapcase$excl$15 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("swapcase!")
        );
      }),
      ($String_swapcase$excl$15.$$arity = -1)
    );

    Opal.def(
      self,
      "$tr!",
      ($String_tr$excl$16 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("tr!")
        );
      }),
      ($String_tr$excl$16.$$arity = -1)
    );

    Opal.def(
      self,
      "$tr_s!",
      ($String_tr_s$excl$17 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("tr_s!")
        );
      }),
      ($String_tr_s$excl$17.$$arity = -1)
    );

    Opal.def(
      self,
      "$upcase!",
      ($String_upcase$excl$18 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("upcase!")
        );
      }),
      ($String_upcase$excl$18.$$arity = -1)
    );

    Opal.def(
      self,
      "$prepend",
      ($String_prepend$19 = function $$prepend($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("prepend")
        );
      }),
      ($String_prepend$19.$$arity = -1)
    );

    Opal.def(
      self,
      "$[]=",
      ($String_$$$eq$20 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("[]=")
        );
      }),
      ($String_$$$eq$20.$$arity = -1)
    );

    Opal.def(
      self,
      "$clear",
      ($String_clear$21 = function $$clear($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("clear")
        );
      }),
      ($String_clear$21.$$arity = -1)
    );

    Opal.def(
      self,
      "$encode!",
      ($String_encode$excl$22 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self.$raise(
          $$($nesting, "NotImplementedError"),
          ERROR["$%"]("encode!")
        );
      }),
      ($String_encode$excl$22.$$arity = -1)
    );
    return (
      (Opal.def(
        self,
        "$unicode_normalize!",
        ($String_unicode_normalize$excl$23 = function ($a) {
          var $post_args,
            $rest_arg,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          $rest_arg = $post_args;
          return self.$raise(
            $$($nesting, "NotImplementedError"),
            ERROR["$%"]("unicode_normalize!")
          );
        }),
        ($String_unicode_normalize$excl$23.$$arity = -1)
      ),
      nil) && "unicode_normalize!"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_freeze$24,
      $Kernel_frozen$ques$25;

    var ERROR = "Object freezing is not supported by Opal";

    Opal.def(
      self,
      "$freeze",
      ($Kernel_freeze$24 = function $$freeze() {
        var self = this;

        handle_unsupported_feature(ERROR);
        return self;
      }),
      ($Kernel_freeze$24.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$frozen?",
        ($Kernel_frozen$ques$25 = function () {
          var self = this;

          handle_unsupported_feature(ERROR);
          return false;
        }),
        ($Kernel_frozen$ques$25.$$arity = 0)
      ),
      nil) && "frozen?"
    );
  })($nesting[0], $nesting);
  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_taint$26,
      $Kernel_untaint$27,
      $Kernel_tainted$ques$28;

    var ERROR = "Object tainting is not supported by Opal";

    Opal.def(
      self,
      "$taint",
      ($Kernel_taint$26 = function $$taint() {
        var self = this;

        handle_unsupported_feature(ERROR);
        return self;
      }),
      ($Kernel_taint$26.$$arity = 0)
    );

    Opal.def(
      self,
      "$untaint",
      ($Kernel_untaint$27 = function $$untaint() {
        var self = this;

        handle_unsupported_feature(ERROR);
        return self;
      }),
      ($Kernel_untaint$27.$$arity = 0)
    );
    return (
      (Opal.def(
        self,
        "$tainted?",
        ($Kernel_tainted$ques$28 = function () {
          var self = this;

          handle_unsupported_feature(ERROR);
          return false;
        }),
        ($Kernel_tainted$ques$28.$$arity = 0)
      ),
      nil) && "tainted?"
    );
  })($nesting[0], $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Module");

    var $nesting = [self].concat($parent_nesting),
      $Module_public$29,
      $Module_private_class_method$30,
      $Module_private_method_defined$ques$31,
      $Module_private_constant$32;

    Opal.def(
      self,
      "$public",
      ($Module_public$29 = function ($a) {
        var $post_args,
          methods,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        methods = $post_args;

        if (methods.length === 0) {
          self.$$module_function = false;
        }

        return nil;
      }),
      ($Module_public$29.$$arity = -1)
    );
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "nesting", "public");

    Opal.def(
      self,
      "$private_class_method",
      ($Module_private_class_method$30 = function $$private_class_method($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return self;
      }),
      ($Module_private_class_method$30.$$arity = -1)
    );
    $alias(self, "public_class_method", "private_class_method");

    Opal.def(
      self,
      "$private_method_defined?",
      ($Module_private_method_defined$ques$31 = function (obj) {
        var self = this;

        return false;
      }),
      ($Module_private_method_defined$ques$31.$$arity = 1)
    );

    Opal.def(
      self,
      "$private_constant",
      ($Module_private_constant$32 = function $$private_constant($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return nil;
      }),
      ($Module_private_constant$32.$$arity = -1)
    );
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_instance_methods", "instance_methods");
    $alias(self, "public_instance_method", "instance_method");
    return $alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_private_methods$33;

    Opal.def(
      self,
      "$private_methods",
      ($Kernel_private_methods$33 = function $$private_methods($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return [];
      }),
      ($Kernel_private_methods$33.$$arity = -1)
    );
    return $alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_eval$34;

    return (
      (Opal.def(
        self,
        "$eval",
        ($Kernel_eval$34 = function ($a) {
          var $post_args,
            $rest_arg,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          $rest_arg = $post_args;
          return self.$raise(
            $$($nesting, "NotImplementedError"),
            "" +
              "To use Kernel#eval, you must first require 'opal-parser'. " +
              ("" +
                "See https://github.com/opal/opal/blob/" +
                $$($nesting, "RUBY_ENGINE_VERSION") +
                "/docs/opal_parser.md for details.")
          );
        }),
        ($Kernel_eval$34.$$arity = -1)
      ),
      nil) && "eval"
    );
  })($nesting[0], $nesting);
  Opal.defs(
    self,
    "$public",
    ($public$35 = function ($a) {
      var $post_args,
        $rest_arg,
        self = this;

      $post_args = Opal.slice.call(arguments, 0, arguments.length);

      $rest_arg = $post_args;
      return nil;
    }),
    ($public$35.$$arity = -1)
  );
  return (
    (Opal.defs(
      self,
      "$private",
      ($private$36 = function ($a) {
        var $post_args,
          $rest_arg,
          self = this;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $rest_arg = $post_args;
        return nil;
      }),
      ($private$36.$$arity = -1)
    ),
    nil) && "private"
  );
};

Opal.queue(function (Opal) {
  /* Generated by Opal 1.3.1 */ var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.add_stubs(["$require", "$autoload"]);

  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/main");
  self.$require("corelib/kernel/format");
  self.$require("corelib/string/encoding");
  self.$autoload("Math", "corelib/math");
  self.$require("corelib/complex/base");
  self.$autoload("Complex", "corelib/complex");
  self.$require("corelib/rational/base");
  self.$autoload("Rational", "corelib/rational");
  self.$require("corelib/time");
  self.$autoload("Struct", "corelib/struct");
  self.$require("corelib/dir");
  self.$autoload("File", "corelib/file");
  self.$require("corelib/process/base");
  self.$autoload("Process", "corelib/process");
  self.$autoload("Random", "corelib/random");
  return self.$require("corelib/unsupported");
});

Opal.modules["string__"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $truthy = Opal.truthy,
    $send = Opal.send,
    $klass = Opal.klass;

  Opal.add_stubs([
    "$empty?",
    "$!",
    "$raise",
    "$each",
    "$include",
    "$shellescape",
    "$to_s",
    "$puts",
    "$print",
    "$include?",
    "$end_with?",
    "$==",
    "$[]",
    "$split",
    "$join",
    "$executable?",
    "$directory?",
    "$nil?",
    "$+",
    "$capitalize",
    "$slice",
    "$length",
  ]);

  (function ($base, $parent_nesting) {
    var self = $module($base, "Assert");

    var $nesting = [self].concat($parent_nesting),
      $Assert_assert$1;

    self.$require("./string__.rb" + "/../" + "string__");
    return (
      (Opal.def(
        self,
        "$assert",
        ($Assert_assert$1 = function $$assert($a) {
          var $post_args,
            args,
            $$2,
            self = this,
            $ret_or_1 = nil;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          args = $post_args;
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_1 = args["$empty?"]()))) {
                  return self["$!"]();
                } else {
                  return $ret_or_1;
                }
                return nil;
              })()
            )
          ) {
            self.$raise();
          }
          return $send(
            args,
            "each",
            [],
            (($$2 = function (i) {
              var self = $$2.$$s == null ? this : $$2.$$s;

              if (i == null) {
                i = nil;
              }
              if ($truthy(i)) {
                return nil;
              } else {
                return self.$raise(i);
              }
            }),
            ($$2.$$s = self),
            ($$2.$$arity = 1),
            $$2)
          );
        }),
        ($Assert_assert$1.$$arity = -1)
      ),
      nil) && "assert"
    );
  })($nesting[0], $nesting);
  self.$include($$($nesting, "Assert"));
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "TrueClass");

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, "Assert"));
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "FalseClass");

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, "Assert"));
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Object");

    var $nesting = [self].concat($parent_nesting),
      $Object_in$ques$3,
      $Object_shellescape$4;

    Opal.def(
      self,
      "$in?",
      ($Object_in$ques$3 = function (_array) {
        var self = this;

        return false;
      }),
      ($Object_in$ques$3.$$arity = 1)
    );
    return (
      (Opal.def(
        self,
        "$shellescape",
        ($Object_shellescape$4 = function $$shellescape() {
          var self = this;

          return self.$to_s().$shellescape();
        }),
        ($Object_shellescape$4.$$arity = 0)
      ),
      nil) && "shellescape"
    );
  })($nesting[0], null, $nesting);
  nil;
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String_puts$5,
      $String_print$6,
      $String_in$ques$7,
      $String_ends_with$ques$8,
      $String_add_period$9;

    Opal.def(
      self,
      "$puts",
      ($String_puts$5 = function $$puts() {
        var self = this;

        $$($nesting, "Kernel").$puts(self);
        return self;
      }),
      ($String_puts$5.$$arity = 0)
    );

    Opal.def(
      self,
      "$print",
      ($String_print$6 = function $$print() {
        var self = this;

        $$($nesting, "Kernel").$print(self);
        return self;
      }),
      ($String_print$6.$$arity = 0)
    );

    Opal.def(
      self,
      "$in?",
      ($String_in$ques$7 = function (a) {
        var self = this;

        return a["$include?"](self);
      }),
      ($String_in$ques$7.$$arity = 1)
    );

    Opal.def(
      self,
      "$ends_with?",
      ($String_ends_with$ques$8 = function (a) {
        var self = this;

        return self["$end_with?"](a);
      }),
      ($String_ends_with$ques$8.$$arity = 1)
    );
    return (
      (Opal.def(
        self,
        "$add_period",
        ($String_add_period$9 = function $$add_period() {
          var self = this;

          if (self["$[]"](-1)["$=="](".")) {
            return self;
          } else {
            return "" + self + ".";
          }
        }),
        ($String_add_period$9.$$arity = 0)
      ),
      nil) && "add_period"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Array");

    var $nesting = [self].concat($parent_nesting),
      $Array_which$10;

    return (
      (Opal.def(
        self,
        "$which",
        ($Array_which$10 = function $$which() {
          try {
            var $$11,
              self = this;

            return $send(
              self,
              "each",
              [],
              (($$11 = function (cmd) {
                var self = $$11.$$s == null ? this : $$11.$$s,
                  $$12,
                  exts = nil;

                if (cmd == null) {
                  cmd = nil;
                }
                exts = (function () {
                  if ($truthy($$($nesting, "ENV")["$[]"]("PATHEXT"))) {
                    return $$($nesting, "ENV")["$[]"]("PATHEXT").$split(";");
                  } else {
                    return [""];
                  }
                  return nil;
                })();
                $send(
                  $$($nesting, "ENV")
                    ["$[]"]("PATH")
                    .$split($$$($$($nesting, "File"), "PATH_SEPARATOR")),
                  "each",
                  [],
                  (($$12 = function (path) {
                    var self = $$12.$$s == null ? this : $$12.$$s,
                      $$13;

                    if (path == null) {
                      path = nil;
                    }
                    return $send(
                      exts,
                      "each",
                      [],
                      (($$13 = function (ext) {
                        var self = $$13.$$s == null ? this : $$13.$$s,
                          exe = nil,
                          $ret_or_2 = nil;

                        if (ext == null) {
                          ext = nil;
                        }
                        exe = $$($nesting, "File").$join(path, "" + cmd + ext);
                        if (
                          $truthy(
                            (function () {
                              if (
                                $truthy(
                                  ($ret_or_2 = $$($nesting, "File")[
                                    "$executable?"
                                  ](exe))
                                )
                              ) {
                                return $$($nesting, "File")
                                  ["$directory?"](exe)
                                  ["$!"]();
                              } else {
                                return $ret_or_2;
                              }
                              return nil;
                            })()
                          )
                        ) {
                          Opal.ret(exe);
                        } else {
                          return nil;
                        }
                      }),
                      ($$13.$$s = self),
                      ($$13.$$arity = 1),
                      $$13)
                    );
                  }),
                  ($$12.$$s = self),
                  ($$12.$$arity = 1),
                  $$12)
                );
                return nil;
              }),
              ($$11.$$s = self),
              ($$11.$$arity = 1),
              $$11)
            );
          } catch ($returner) {
            if ($returner === Opal.returner) {
              return $returner.$v;
            }
            throw $returner;
          }
        }),
        ($Array_which$10.$$arity = 0)
      ),
      nil) && "which"
    );
  })($nesting[0], null, $nesting);
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String_uppercase$14;

    return (
      (Opal.def(
        self,
        "$uppercase",
        ($String_uppercase$14 = function $$uppercase() {
          var self = this;

          if ($truthy(self["$[]"](0)["$nil?"]())) {
            return "";
          }
          return $rb_plus(
            self["$[]"](0).$capitalize(),
            self.$slice(1, self.$length())
          );
        }),
        ($String_uppercase$14.$$arity = 0)
      ),
      nil) && "uppercase"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["opal-platform"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $truthy = Opal.truthy,
    browser = nil,
    node = nil,
    nashorn = nil,
    headless_chrome = nil,
    gjs = nil,
    quickjs = nil,
    opal_miniracer = nil;

  /* global Java, GjsFileImporter */ browser = typeof document !== "undefined";
  node =
    typeof process !== "undefined" && process.versions && process.versions.node;
  nashorn = typeof Java !== "undefined" && Java.type;
  headless_chrome =
    typeof navigator !== "undefined" &&
    /\bHeadlessChrome\//.test(navigator.userAgent);
  gjs = typeof window !== "undefined" && typeof GjsFileImporter !== "undefined";
  quickjs =
    typeof window === "undefined" && typeof __loadScript !== "undefined";
  opal_miniracer = typeof opalminiracer !== "undefined";
  return Opal.const_set(
    $nesting[0],
    "OPAL_PLATFORM",
    (function () {
      if ($truthy(nashorn)) {
        return "nashorn";
      } else if ($truthy(node)) {
        return "nodejs";
      } else if ($truthy(headless_chrome)) {
        return "headless-chrome";
      } else if ($truthy(gjs)) {
        return "gjs";
      } else if ($truthy(quickjs)) {
        return "quickjs";
      } else if ($truthy(opal_miniracer)) {
        return "opal-miniracer";
      } else {
        return nil;
      }
      return nil;
    })()
  );
};

Opal.modules["nashorn/io"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $send = Opal.send,
    $gvars = Opal.gvars,
    $writer = nil;
  if ($gvars.stdout == null) $gvars.stdout = nil;
  if ($gvars.stderr == null) $gvars.stderr = nil;

  Opal.add_stubs(["$write_proc=", "$-"]);

  $writer = [
    function (s) {
      print(s);
    },
  ];
  $send($gvars.stdout, "write_proc=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [
    function (s) {
      print(s);
    },
  ];
  $send($gvars.stderr, "write_proc=", Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];
};

Opal.modules["nashorn/file"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass;

  Opal.add_stubs(["$require"]);

  /* global Java */ self.$require("corelib/file");
  return (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "File");

    var $nesting = [self].concat($parent_nesting),
      $File_read$1,
      $File_file$ques$2,
      $File_readable$ques$3;

    Opal.defs(
      self,
      "$read",
      ($File_read$1 = function $$read(path) {
        var self = this;

        var Paths = Java.type("java.nio.file.Paths");
        var Files = Java.type("java.nio.file.Files");
        var lines = Files.readAllLines(
          Paths.get(path),
          Java.type("java.nio.charset.StandardCharsets").UTF_8
        );
        var data = [];
        lines.forEach(function (line) {
          data.push(line);
        });
        return data.join("\n");
      }),
      ($File_read$1.$$arity = 1)
    );
    Opal.defs(
      self,
      "$file?",
      ($File_file$ques$2 = function (path) {
        var self = this;

        var Files = Java.type("java.nio.file.Files");
        return Files.exists(path) && Files.isRegularFile(path);
      }),
      ($File_file$ques$2.$$arity = 1)
    );
    return (
      (Opal.defs(
        self,
        "$readable?",
        ($File_readable$ques$3 = function (path) {
          var self = this;

          var Files = Java.type("java.nio.file.Files");
          return Files.exists(path) && Files.isReadable(path);
        }),
        ($File_readable$ques$3.$$arity = 1)
      ),
      nil) && "readable?"
    );
  })($nesting[0], null, $nesting);
};

Opal.modules["nashorn"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module;

  Opal.add_stubs(["$require"]);

  (function ($base, $parent_nesting) {
    var self = $module($base, "Nashorn");

    var $nesting = [self].concat($parent_nesting);

    return nil;
  })($nesting[0], $nesting);
  self.$require("nashorn/io");
  return self.$require("nashorn/file");
};

Opal.modules["gjs/io"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  /* global imports */ var GLib = imports.gi.GLib;
  var ByteArray = imports.byteArray;

  var stdin = GLib.IOChannel.unix_new(0);
  var stdout = GLib.IOChannel.unix_new(1);
  var stderr = GLib.IOChannel.unix_new(2);

  Opal.gvars.stdout.write_proc = function (s) {
    var buf = ByteArray.fromString(s);
    stdout.write_chars(buf, buf.length);
    stdout.flush();
  };

  Opal.gvars.stderr.write_proc = function (s) {
    var buf = ByteArray.fromString(s);
    stderr.write_chars(buf, buf.length);
    stderr.flush();
  };

  Opal.gvars.stdin.read_proc = function (_s) {
    var out = stdin.read_line();
    if (out[0] == GLib.IOStatus.EOF) return nil;
    return out[1].toString();
  };
};

Opal.modules["gjs/kernel"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  /* global ARGV */ Opal.const_set($nesting[0], "ARGV", ARGV);
  return (Opal.exit = imports.system.exit);
};

Opal.modules["gjs"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.add_stubs(["$require"]);

  self.$require("gjs/io");
  return self.$require("gjs/kernel");
};

Opal.modules["quickjs/io"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  /* global std */ Opal.gvars.stdout.write_proc = function (s) {
    std.out.printf("%s", s);
    std.out.flush();
  };

  Opal.gvars.stderr.write_proc = function (s) {
    std.err.printf("%s", s);
    std.err.flush();
  };

  Opal.gvars.stdin.read_proc = function (s) {
    if (std.in.eof()) {
      return nil;
    } else {
      return std.in.readAsString(s);
    }
  };
};

Opal.modules["quickjs/kernel"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  /* global std, scriptArgs */ Opal.const_set($nesting[0], "ARGV", scriptArgs);
  return (Opal.exit = std.exit);
};

Opal.modules["quickjs"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.add_stubs(["$require"]);

  self.$require("quickjs/io");
  return self.$require("quickjs/kernel");
};

Opal.modules["native"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $truthy = Opal.truthy,
    $send = Opal.send,
    $hash2 = Opal.hash2,
    $range = Opal.range,
    $alias = Opal.alias,
    $klass = Opal.klass,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $gvars = Opal.gvars;

  Opal.add_stubs([
    "$try_convert",
    "$native?",
    "$respond_to?",
    "$to_n",
    "$raise",
    "$inspect",
    "$Native",
    "$proc",
    "$map!",
    "$end_with?",
    "$define_method",
    "$[]",
    "$convert",
    "$call",
    "$to_proc",
    "$new",
    "$each",
    "$native_reader",
    "$native_writer",
    "$extend",
    "$warn",
    "$include",
    "$is_a?",
    "$map",
    "$to_a",
    "$_Array",
    "$method_missing",
    "$bind",
    "$instance_method",
    "$slice",
    "$-",
    "$length",
    "$[]=",
    "$enum_for",
    "$===",
    "$>=",
    "$<<",
    "$each_pair",
    "$method_defined?",
    "$_initialize",
    "$name",
    "$native_module",
  ]);

  (function ($base, $parent_nesting) {
    var self = $module($base, "Native");

    var $nesting = [self].concat($parent_nesting),
      $Native_is_a$ques$1,
      $Native_try_convert$2,
      $Native_convert$3,
      $Native_call$4,
      $Native_proc$5,
      $Native_included$22;

    Opal.defs(
      self,
      "$is_a?",
      ($Native_is_a$ques$1 = function (object, klass) {
        var self = this;

        try {
          return object instanceof self.$try_convert(klass);
        } catch (e) {
          return false;
        }
      }),
      ($Native_is_a$ques$1.$$arity = 2)
    );
    Opal.defs(
      self,
      "$try_convert",
      ($Native_try_convert$2 = function $$try_convert(value, default$) {
        var self = this;

        if (default$ == null) {
          default$ = nil;
        }

        if (self["$native?"](value)) {
          return value;
        } else if (value["$respond_to?"]("to_n")) {
          return value.$to_n();
        } else {
          return default$;
        }
      }),
      ($Native_try_convert$2.$$arity = -2)
    );
    Opal.defs(
      self,
      "$convert",
      ($Native_convert$3 = function $$convert(value) {
        var self = this;

        if (self["$native?"](value)) {
          return value;
        } else if (value["$respond_to?"]("to_n")) {
          return value.$to_n();
        } else {
          self.$raise(
            $$($nesting, "ArgumentError"),
            "" + value.$inspect() + " isn't native"
          );
        }
      }),
      ($Native_convert$3.$$arity = 1)
    );
    Opal.defs(
      self,
      "$call",
      ($Native_call$4 = function $$call(obj, key, $a) {
        var $iter = $Native_call$4.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this;

        if ($iter) $Native_call$4.$$p = null;

        if ($iter) $Native_call$4.$$p = null;

        $post_args = Opal.slice.call(arguments, 2, arguments.length);

        args = $post_args;

        var prop = obj[key];

        if (prop instanceof Function) {
          var converted = new Array(args.length);

          for (var i = 0, l = args.length; i < l; i++) {
            var item = args[i],
              conv = self.$try_convert(item);

            converted[i] = conv === nil ? item : conv;
          }

          if (block !== nil) {
            converted.push(block);
          }

          return self.$Native(prop.apply(obj, converted));
        } else {
          return self.$Native(prop);
        }
      }),
      ($Native_call$4.$$arity = -3)
    );
    Opal.defs(
      self,
      "$proc",
      ($Native_proc$5 = function $$proc() {
        var $iter = $Native_proc$5.$$p,
          block = $iter || nil,
          $$6,
          self = this;

        if ($iter) $Native_proc$5.$$p = null;

        if ($iter) $Native_proc$5.$$p = null;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, "LocalJumpError"), "no block given");
        }
        return $send(
          $$$("::", "Kernel"),
          "proc",
          [],
          (($$6 = function ($a) {
            var self = $$6.$$s == null ? this : $$6.$$s,
              $post_args,
              args,
              $$7,
              instance = nil;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            args = $post_args;
            $send(
              args,
              "map!",
              [],
              (($$7 = function (arg) {
                var self = $$7.$$s == null ? this : $$7.$$s;

                if (arg == null) {
                  arg = nil;
                }
                return self.$Native(arg);
              }),
              ($$7.$$s = self),
              ($$7.$$arity = 1),
              $$7)
            );
            instance = self.$Native(this);

            // if global is current scope, run the block in the scope it was defined
            if (this === Opal.global) {
              return block.apply(self, args);
            }

            var self_ = block.$$s;
            block.$$s = null;

            try {
              return block.apply(instance, args);
            } finally {
              block.$$s = self_;
            }
          }),
          ($$6.$$s = self),
          ($$6.$$arity = -1),
          $$6)
        );
      }),
      ($Native_proc$5.$$arity = 0)
    );
    (function ($base, $parent_nesting) {
      var self = $module($base, "Helpers");

      var $nesting = [self].concat($parent_nesting),
        $Helpers_alias_native$8,
        $Helpers_native_reader$12,
        $Helpers_native_writer$15,
        $Helpers_native_accessor$18;

      Opal.def(
        self,
        "$alias_native",
        ($Helpers_alias_native$8 = function $$alias_native(new$, $a, $b) {
          var $post_args,
            $kwargs,
            old,
            as,
            $$9,
            $$10,
            $$11,
            $iter = $Helpers_alias_native$8.$$p,
            $yield = $iter || nil,
            self = this;

          if ($iter) $Helpers_alias_native$8.$$p = null;

          $post_args = Opal.slice.call(arguments, 1, arguments.length);

          $kwargs = Opal.extract_kwargs($post_args);

          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new("expected kwargs");
          }

          if ($post_args.length > 0) {
            old = $post_args[0];
            $post_args.splice(0, 1);
          }
          if (old == null) {
            old = new$;
          }

          as = $kwargs.$$smap["as"];
          if (as == null) {
            as = nil;
          }
          if ($truthy(old["$end_with?"]("="))) {
            return $send(
              self,
              "define_method",
              [new$],
              (($$9 = function (value) {
                var self = $$9.$$s == null ? this : $$9.$$s;
                if (self["native"] == null) self["native"] = nil;

                if (value == null) {
                  value = nil;
                }
                self["native"][old["$[]"]($range(0, -2, false))] = $$(
                  $nesting,
                  "Native"
                ).$convert(value);
                return value;
              }),
              ($$9.$$s = self),
              ($$9.$$arity = 1),
              $$9)
            );
          } else if ($truthy(as)) {
            return $send(
              self,
              "define_method",
              [new$],
              (($$10 = function ($c) {
                var self = $$10.$$s == null ? this : $$10.$$s,
                  $iter = $$10.$$p,
                  block = $iter || nil,
                  $post_args,
                  args,
                  value = nil;
                if (self["native"] == null) self["native"] = nil;

                if ($iter) $$10.$$p = null;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                args = $post_args;
                value = $send(
                  $$($nesting, "Native"),
                  "call",
                  [self["native"], old].concat(Opal.to_a(args)),
                  block.$to_proc()
                );
                if ($truthy(value)) {
                  return as.$new(value.$to_n());
                } else {
                  return nil;
                }
              }),
              ($$10.$$s = self),
              ($$10.$$arity = -1),
              $$10)
            );
          } else {
            return $send(
              self,
              "define_method",
              [new$],
              (($$11 = function ($c) {
                var self = $$11.$$s == null ? this : $$11.$$s,
                  $iter = $$11.$$p,
                  block = $iter || nil,
                  $post_args,
                  args;
                if (self["native"] == null) self["native"] = nil;

                if ($iter) $$11.$$p = null;

                $post_args = Opal.slice.call(arguments, 0, arguments.length);

                args = $post_args;
                return $send(
                  $$($nesting, "Native"),
                  "call",
                  [self["native"], old].concat(Opal.to_a(args)),
                  block.$to_proc()
                );
              }),
              ($$11.$$s = self),
              ($$11.$$arity = -1),
              $$11)
            );
          }
        }),
        ($Helpers_alias_native$8.$$arity = -2)
      );

      Opal.def(
        self,
        "$native_reader",
        ($Helpers_native_reader$12 = function $$native_reader($a) {
          var $post_args,
            names,
            $$13,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          names = $post_args;
          return $send(
            names,
            "each",
            [],
            (($$13 = function (name) {
              var self = $$13.$$s == null ? this : $$13.$$s,
                $$14;

              if (name == null) {
                name = nil;
              }
              return $send(
                self,
                "define_method",
                [name],
                (($$14 = function () {
                  var self = $$14.$$s == null ? this : $$14.$$s;
                  if (self["native"] == null) self["native"] = nil;

                  return self.$Native(self["native"][name]);
                }),
                ($$14.$$s = self),
                ($$14.$$arity = 0),
                $$14)
              );
            }),
            ($$13.$$s = self),
            ($$13.$$arity = 1),
            $$13)
          );
        }),
        ($Helpers_native_reader$12.$$arity = -1)
      );

      Opal.def(
        self,
        "$native_writer",
        ($Helpers_native_writer$15 = function $$native_writer($a) {
          var $post_args,
            names,
            $$16,
            self = this;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          names = $post_args;
          return $send(
            names,
            "each",
            [],
            (($$16 = function (name) {
              var self = $$16.$$s == null ? this : $$16.$$s,
                $$17;

              if (name == null) {
                name = nil;
              }
              return $send(
                self,
                "define_method",
                ["" + name + "="],
                (($$17 = function (value) {
                  var self = $$17.$$s == null ? this : $$17.$$s;
                  if (self["native"] == null) self["native"] = nil;

                  if (value == null) {
                    value = nil;
                  }
                  return self.$Native((self["native"][name] = value));
                }),
                ($$17.$$s = self),
                ($$17.$$arity = 1),
                $$17)
              );
            }),
            ($$16.$$s = self),
            ($$16.$$arity = 1),
            $$16)
          );
        }),
        ($Helpers_native_writer$15.$$arity = -1)
      );
      return (
        (Opal.def(
          self,
          "$native_accessor",
          ($Helpers_native_accessor$18 = function $$native_accessor($a) {
            var $post_args,
              names,
              self = this;

            $post_args = Opal.slice.call(arguments, 0, arguments.length);

            names = $post_args;
            $send(self, "native_reader", Opal.to_a(names));
            return $send(self, "native_writer", Opal.to_a(names));
          }),
          ($Helpers_native_accessor$18.$$arity = -1)
        ),
        nil) && "native_accessor"
      );
    })($nesting[0], $nesting);
    (function ($base, $parent_nesting) {
      var self = $module($base, "Wrapper");

      var $nesting = [self].concat($parent_nesting),
        $Wrapper_initialize$19,
        $Wrapper_to_n$20,
        $Wrapper_included$21;

      Opal.def(
        self,
        "$initialize",
        ($Wrapper_initialize$19 = function $$initialize(native$) {
          var self = this;

          if ($truthy($$$("::", "Kernel")["$native?"](native$))) {
          } else {
            $$$("::", "Kernel").$raise(
              $$($nesting, "ArgumentError"),
              "" + native$.$inspect() + " isn't native"
            );
          }
          return (self["native"] = native$);
        }),
        ($Wrapper_initialize$19.$$arity = 1)
      );

      Opal.def(
        self,
        "$to_n",
        ($Wrapper_to_n$20 = function $$to_n() {
          var self = this;
          if (self["native"] == null) self["native"] = nil;

          return self["native"];
        }),
        ($Wrapper_to_n$20.$$arity = 0)
      );
      return (
        (Opal.defs(
          self,
          "$included",
          ($Wrapper_included$21 = function $$included(klass) {
            var self = this;

            return klass.$extend($$($nesting, "Helpers"));
          }),
          ($Wrapper_included$21.$$arity = 1)
        ),
        nil) && "included"
      );
    })($nesting[0], $nesting);
    return (
      (Opal.defs(
        self,
        "$included",
        ($Native_included$22 = function $$included(base) {
          var self = this;

          self.$warn(
            "Including ::Native is deprecated. Please include Native::Wrapper instead."
          );
          return base.$include($$($nesting, "Wrapper"));
        }),
        ($Native_included$22.$$arity = 1)
      ),
      nil) && "included"
    );
  })($nesting[0], $nesting);
  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_native$ques$23,
      $Kernel_Native$24,
      $Kernel_Array$27;

    Opal.def(
      self,
      "$native?",
      ($Kernel_native$ques$23 = function (value) {
        var self = this;

        return value == null || !value.$$class;
      }),
      ($Kernel_native$ques$23.$$arity = 1)
    );

    Opal.def(
      self,
      "$Native",
      ($Kernel_Native$24 = function $$Native(obj) {
        var $$25,
          $$26,
          $iter = $Kernel_Native$24.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Kernel_Native$24.$$p = null;
        if ($truthy(obj == null)) {
          return nil;
        } else if ($truthy(self["$native?"](obj))) {
          return $$$($$($nesting, "Native"), "Object").$new(obj);
        } else if ($truthy(obj["$is_a?"]($$($nesting, "Array")))) {
          return $send(
            obj,
            "map",
            [],
            (($$25 = function (o) {
              var self = $$25.$$s == null ? this : $$25.$$s;

              if (o == null) {
                o = nil;
              }
              return self.$Native(o);
            }),
            ($$25.$$s = self),
            ($$25.$$arity = 1),
            $$25)
          );
        } else if ($truthy(obj["$is_a?"]($$($nesting, "Proc")))) {
          return $send(
            self,
            "proc",
            [],
            (($$26 = function ($a) {
              var self = $$26.$$s == null ? this : $$26.$$s,
                $iter = $$26.$$p,
                block = $iter || nil,
                $post_args,
                args;

              if ($iter) $$26.$$p = null;

              $post_args = Opal.slice.call(arguments, 0, arguments.length);

              args = $post_args;
              return self.$Native(
                $send(obj, "call", Opal.to_a(args), block.$to_proc())
              );
            }),
            ($$26.$$s = self),
            ($$26.$$arity = -1),
            $$26)
          );
        } else {
          return obj;
        }
      }),
      ($Kernel_Native$24.$$arity = 1)
    );
    $alias(self, "_Array", "Array");
    return (
      (Opal.def(
        self,
        "$Array",
        ($Kernel_Array$27 = function $$Array(object, $a) {
          var $iter = $Kernel_Array$27.$$p,
            block = $iter || nil,
            $post_args,
            args,
            self = this;

          if ($iter) $Kernel_Array$27.$$p = null;

          if ($iter) $Kernel_Array$27.$$p = null;

          $post_args = Opal.slice.call(arguments, 1, arguments.length);

          args = $post_args;
          if ($truthy(self["$native?"](object))) {
            return $send(
              $$$($$($nesting, "Native"), "Array"),
              "new",
              [object].concat(Opal.to_a(args)),
              block.$to_proc()
            ).$to_a();
          }
          return self.$_Array(object);
        }),
        ($Kernel_Array$27.$$arity = -2)
      ),
      nil) && "Array"
    );
  })($nesting[0], $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Object");

    var $nesting = [self].concat($parent_nesting),
      $Object_$eq_eq$28,
      $Object_has_key$ques$29,
      $Object_each$30,
      $Object_$$$31,
      $Object_$$$eq$32,
      $Object_merge$excl$33,
      $Object_respond_to$ques$34,
      $Object_respond_to_missing$ques$35,
      $Object_method_missing$36,
      $Object_nil$ques$37,
      $Object_is_a$ques$38,
      $Object_instance_of$ques$39,
      $Object_class$40,
      $Object_to_a$41,
      $Object_inspect$42;

    self.$$prototype["native"] = nil;

    self.$include($$$($$$("::", "Native"), "Wrapper"));

    Opal.def(
      self,
      "$==",
      ($Object_$eq_eq$28 = function (other) {
        var self = this;

        return self["native"] === $$$("::", "Native").$try_convert(other);
      }),
      ($Object_$eq_eq$28.$$arity = 1)
    );

    Opal.def(
      self,
      "$has_key?",
      ($Object_has_key$ques$29 = function (name) {
        var self = this;

        return Opal.hasOwnProperty.call(self["native"], name);
      }),
      ($Object_has_key$ques$29.$$arity = 1)
    );
    $alias(self, "key?", "has_key?");
    $alias(self, "include?", "has_key?");
    $alias(self, "member?", "has_key?");

    Opal.def(
      self,
      "$each",
      ($Object_each$30 = function $$each($a) {
        var $post_args,
          args,
          $iter = $Object_each$30.$$p,
          $yield = $iter || nil,
          self = this;

        if ($iter) $Object_each$30.$$p = null;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        args = $post_args;
        if ($yield !== nil) {
          for (var key in self["native"]) {
            Opal.yieldX($yield, [key, self["native"][key]]);
          }
          return self;
        } else {
          return $send(
            self,
            "method_missing",
            ["each"].concat(Opal.to_a(args))
          );
        }
      }),
      ($Object_each$30.$$arity = -1)
    );

    Opal.def(
      self,
      "$[]",
      ($Object_$$$31 = function (key) {
        var self = this;

        var prop = self["native"][key];

        if (prop instanceof Function) {
          return prop;
        } else {
          return $$$("::", "Native").$call(self["native"], key);
        }
      }),
      ($Object_$$$31.$$arity = 1)
    );

    Opal.def(
      self,
      "$[]=",
      ($Object_$$$eq$32 = function (key, value) {
        var self = this,
          native$ = nil;

        native$ = $$$("::", "Native").$try_convert(value);
        if ($truthy(native$ === nil)) {
          return (self["native"][key] = value);
        } else {
          return (self["native"][key] = native$);
        }
      }),
      ($Object_$$$eq$32.$$arity = 2)
    );

    Opal.def(
      self,
      "$merge!",
      ($Object_merge$excl$33 = function (other) {
        var self = this;

        other = $$$("::", "Native").$convert(other);

        for (var prop in other) {
          self["native"][prop] = other[prop];
        }
        return self;
      }),
      ($Object_merge$excl$33.$$arity = 1)
    );

    Opal.def(
      self,
      "$respond_to?",
      ($Object_respond_to$ques$34 = function (name, include_all) {
        var self = this;

        if (include_all == null) {
          include_all = false;
        }
        return $$$("::", "Kernel")
          .$instance_method("respond_to?")
          .$bind(self)
          .$call(name, include_all);
      }),
      ($Object_respond_to$ques$34.$$arity = -2)
    );

    Opal.def(
      self,
      "$respond_to_missing?",
      ($Object_respond_to_missing$ques$35 = function (name, include_all) {
        var self = this;

        if (include_all == null) {
          include_all = false;
        }
        return Opal.hasOwnProperty.call(self["native"], name);
      }),
      ($Object_respond_to_missing$ques$35.$$arity = -2)
    );

    Opal.def(
      self,
      "$method_missing",
      ($Object_method_missing$36 = function $$method_missing(mid, $a) {
        var $iter = $Object_method_missing$36.$$p,
          block = $iter || nil,
          $post_args,
          args,
          self = this,
          $writer = nil;

        if ($iter) $Object_method_missing$36.$$p = null;

        if ($iter) $Object_method_missing$36.$$p = null;

        $post_args = Opal.slice.call(arguments, 1, arguments.length);

        args = $post_args;

        if (mid.charAt(mid.length - 1) === "=") {
          return (
            ($writer = [
              mid.$slice(0, $rb_minus(mid.$length(), 1)),
              args["$[]"](0),
            ]),
            $send(self, "[]=", Opal.to_a($writer)),
            $writer[$rb_minus($writer["length"], 1)]
          );
        } else {
          return $send(
            $$$("::", "Native"),
            "call",
            [self["native"], mid].concat(Opal.to_a(args)),
            block.$to_proc()
          );
        }
      }),
      ($Object_method_missing$36.$$arity = -2)
    );

    Opal.def(
      self,
      "$nil?",
      ($Object_nil$ques$37 = function () {
        var self = this;

        return false;
      }),
      ($Object_nil$ques$37.$$arity = 0)
    );

    Opal.def(
      self,
      "$is_a?",
      ($Object_is_a$ques$38 = function (klass) {
        var self = this;

        return Opal.is_a(self, klass);
      }),
      ($Object_is_a$ques$38.$$arity = 1)
    );
    $alias(self, "kind_of?", "is_a?");

    Opal.def(
      self,
      "$instance_of?",
      ($Object_instance_of$ques$39 = function (klass) {
        var self = this;

        return self.$$class === klass;
      }),
      ($Object_instance_of$ques$39.$$arity = 1)
    );

    Opal.def(
      self,
      "$class",
      ($Object_class$40 = function () {
        var self = this;

        return self.$$class;
      }),
      ($Object_class$40.$$arity = 0)
    );

    Opal.def(
      self,
      "$to_a",
      ($Object_to_a$41 = function $$to_a(options) {
        var $iter = $Object_to_a$41.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Object_to_a$41.$$p = null;

        if ($iter) $Object_to_a$41.$$p = null;

        if (options == null) {
          options = $hash2([], {});
        }
        return $send(
          $$$($$$("::", "Native"), "Array"),
          "new",
          [self["native"], options],
          block.$to_proc()
        ).$to_a();
      }),
      ($Object_to_a$41.$$arity = -1)
    );
    return (
      (Opal.def(
        self,
        "$inspect",
        ($Object_inspect$42 = function $$inspect() {
          var self = this;

          return "" + "#<Native:" + String(self["native"]) + ">";
        }),
        ($Object_inspect$42.$$arity = 0)
      ),
      nil) && "inspect"
    );
  })($$($nesting, "Native"), $$($nesting, "BasicObject"), $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Array");

    var $nesting = [self].concat($parent_nesting),
      $Array_initialize$43,
      $Array_each$44,
      $Array_$$$45,
      $Array_$$$eq$46,
      $Array_last$47,
      $Array_length$48,
      $Array_inspect$49;

    self.$$prototype.named =
      self.$$prototype["native"] =
      self.$$prototype.get =
      self.$$prototype.block =
      self.$$prototype.set =
      self.$$prototype.length =
        nil;

    self.$include($$$($$($nesting, "Native"), "Wrapper"));
    self.$include($$($nesting, "Enumerable"));

    Opal.def(
      self,
      "$initialize",
      ($Array_initialize$43 = function $$initialize(native$, options) {
        var $iter = $Array_initialize$43.$$p,
          block = $iter || nil,
          self = this,
          $ret_or_1 = nil,
          $ret_or_2 = nil,
          $ret_or_3 = nil;

        if ($iter) $Array_initialize$43.$$p = null;

        if ($iter) $Array_initialize$43.$$p = null;

        if (options == null) {
          options = $hash2([], {});
        }
        $send2(
          self,
          $find_super(self, "initialize", $Array_initialize$43, false, true),
          "initialize",
          [native$],
          null
        );
        self.get = (function () {
          if ($truthy(($ret_or_1 = options["$[]"]("get")))) {
            return $ret_or_1;
          } else {
            return options["$[]"]("access");
          }
          return nil;
        })();
        self.named = options["$[]"]("named");
        self.set = (function () {
          if ($truthy(($ret_or_2 = options["$[]"]("set")))) {
            return $ret_or_2;
          } else {
            return options["$[]"]("access");
          }
          return nil;
        })();
        self.length = (function () {
          if ($truthy(($ret_or_3 = options["$[]"]("length")))) {
            return $ret_or_3;
          } else {
            return "length";
          }
          return nil;
        })();
        self.block = block;
        if ($truthy(self.$length() == null)) {
          return self.$raise(
            $$($nesting, "ArgumentError"),
            "no length found on the array-like object"
          );
        } else {
          return nil;
        }
      }),
      ($Array_initialize$43.$$arity = -2)
    );

    Opal.def(
      self,
      "$each",
      ($Array_each$44 = function $$each() {
        var $iter = $Array_each$44.$$p,
          block = $iter || nil,
          self = this;

        if ($iter) $Array_each$44.$$p = null;

        if ($iter) $Array_each$44.$$p = null;
        if ($truthy(block)) {
        } else {
          return self.$enum_for("each");
        }

        for (var i = 0, length = self.$length(); i < length; i++) {
          Opal.yield1(block, self["$[]"](i));
        }
        return self;
      }),
      ($Array_each$44.$$arity = 0)
    );

    Opal.def(
      self,
      "$[]",
      ($Array_$$$45 = function (index) {
        var self = this,
          result = nil,
          $case = nil;

        result = (function () {
          $case = index;
          if (
            $$($nesting, "String")["$==="]($case) ||
            $$($nesting, "Symbol")["$==="]($case)
          ) {
            if ($truthy(self.named)) {
              return self["native"][self.named](index);
            } else {
              return self["native"][index];
            }
          } else if ($$($nesting, "Integer")["$==="]($case)) {
            if ($truthy(self.get)) {
              return self["native"][self.get](index);
            } else {
              return self["native"][index];
            }
          } else {
            return nil;
          }
        })();
        if ($truthy(result)) {
          if ($truthy(self.block)) {
            return self.block.$call(result);
          } else {
            return self.$Native(result);
          }
        } else {
          return nil;
        }
      }),
      ($Array_$$$45.$$arity = 1)
    );

    Opal.def(
      self,
      "$[]=",
      ($Array_$$$eq$46 = function (index, value) {
        var self = this;

        if ($truthy(self.set)) {
          return self["native"][self.set](
            index,
            $$($nesting, "Native").$convert(value)
          );
        } else {
          return (self["native"][index] = $$($nesting, "Native").$convert(
            value
          ));
        }
      }),
      ($Array_$$$eq$46.$$arity = 2)
    );

    Opal.def(
      self,
      "$last",
      ($Array_last$47 = function $$last(count) {
        var $a,
          self = this,
          index = nil,
          result = nil;

        if (count == null) {
          count = nil;
        }
        if ($truthy(count)) {
          index = $rb_minus(self.$length(), 1);
          result = [];
          while ($truthy($rb_ge(index, 0))) {
            result["$<<"](self["$[]"](index));
            index = $rb_minus(index, 1);
          }
          return result;
        } else {
          return self["$[]"]($rb_minus(self.$length(), 1));
        }
      }),
      ($Array_last$47.$$arity = -1)
    );

    Opal.def(
      self,
      "$length",
      ($Array_length$48 = function $$length() {
        var self = this;

        return self["native"][self.length];
      }),
      ($Array_length$48.$$arity = 0)
    );
    $alias(self, "to_ary", "to_a");
    return (
      (Opal.def(
        self,
        "$inspect",
        ($Array_inspect$49 = function $$inspect() {
          var self = this;

          return self.$to_a().$inspect();
        }),
        ($Array_inspect$49.$$arity = 0)
      ),
      nil) && "inspect"
    );
  })($$($nesting, "Native"), null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Numeric");

    var $nesting = [self].concat($parent_nesting),
      $Numeric_to_n$50;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($Numeric_to_n$50 = function $$to_n() {
          var self = this;

          return self.valueOf();
        }),
        ($Numeric_to_n$50.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Proc");

    var $nesting = [self].concat($parent_nesting),
      $Proc_to_n$51;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($Proc_to_n$51 = function $$to_n() {
          var self = this;

          return self;
        }),
        ($Proc_to_n$51.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "String");

    var $nesting = [self].concat($parent_nesting),
      $String_to_n$52;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($String_to_n$52 = function $$to_n() {
          var self = this;

          return self.valueOf();
        }),
        ($String_to_n$52.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Regexp");

    var $nesting = [self].concat($parent_nesting),
      $Regexp_to_n$53;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($Regexp_to_n$53 = function $$to_n() {
          var self = this;

          return self.valueOf();
        }),
        ($Regexp_to_n$53.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "MatchData");

    var $nesting = [self].concat($parent_nesting),
      $MatchData_to_n$54;

    self.$$prototype.matches = nil;
    return (
      (Opal.def(
        self,
        "$to_n",
        ($MatchData_to_n$54 = function $$to_n() {
          var self = this;

          return self.matches;
        }),
        ($MatchData_to_n$54.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Struct");

    var $nesting = [self].concat($parent_nesting),
      $Struct_to_n$55;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($Struct_to_n$55 = function $$to_n() {
          var $$56,
            self = this,
            result = nil;

          result = {};
          $send(
            self,
            "each_pair",
            [],
            (($$56 = function (name, value) {
              var self = $$56.$$s == null ? this : $$56.$$s;

              if (name == null) {
                name = nil;
              }

              if (value == null) {
                value = nil;
              }
              return (result[name] = $$($nesting, "Native").$try_convert(
                value,
                value
              ));
            }),
            ($$56.$$s = self),
            ($$56.$$arity = 2),
            $$56)
          );
          return result;
        }),
        ($Struct_to_n$55.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Array");

    var $nesting = [self].concat($parent_nesting),
      $Array_to_n$57;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($Array_to_n$57 = function $$to_n() {
          var self = this;

          var result = [];

          for (var i = 0, length = self.length; i < length; i++) {
            var obj = self[i];

            result.push($$($nesting, "Native").$try_convert(obj, obj));
          }

          return result;
        }),
        ($Array_to_n$57.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Boolean");

    var $nesting = [self].concat($parent_nesting),
      $Boolean_to_n$58;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($Boolean_to_n$58 = function $$to_n() {
          var self = this;

          return self.valueOf();
        }),
        ($Boolean_to_n$58.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Time");

    var $nesting = [self].concat($parent_nesting),
      $Time_to_n$59;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($Time_to_n$59 = function $$to_n() {
          var self = this;

          return self;
        }),
        ($Time_to_n$59.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "NilClass");

    var $nesting = [self].concat($parent_nesting),
      $NilClass_to_n$60;

    return (
      (Opal.def(
        self,
        "$to_n",
        ($NilClass_to_n$60 = function $$to_n() {
          var self = this;

          return null;
        }),
        ($NilClass_to_n$60.$$arity = 0)
      ),
      nil) && "to_n"
    );
  })($nesting[0], null, $nesting);
  if ($truthy($$($nesting, "Hash")["$method_defined?"]("_initialize"))) {
  } else {
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Hash");

      var $nesting = [self].concat($parent_nesting),
        $Hash_initialize$61,
        $Hash_to_n$62;

      $alias(self, "_initialize", "initialize");

      Opal.def(
        self,
        "$initialize",
        ($Hash_initialize$61 = function $$initialize(defaults) {
          var $iter = $Hash_initialize$61.$$p,
            block = $iter || nil,
            self = this;

          if ($iter) $Hash_initialize$61.$$p = null;

          if ($iter) $Hash_initialize$61.$$p = null;
          if (
            defaults != null &&
            (defaults.constructor === undefined ||
              defaults.constructor === Object)
          ) {
            var smap = self.$$smap,
              keys = self.$$keys,
              key,
              value;

            for (key in defaults) {
              value = defaults[key];

              if (
                value &&
                (value.constructor === undefined ||
                  value.constructor === Object)
              ) {
                smap[key] = $$($nesting, "Hash").$new(value);
              } else if (value && value.$$is_array) {
                value = value.map(function (item) {
                  if (
                    item &&
                    (item.constructor === undefined ||
                      item.constructor === Object)
                  ) {
                    return $$($nesting, "Hash").$new(item);
                  }

                  return self.$Native(item);
                });
                smap[key] = value;
              } else {
                smap[key] = self.$Native(value);
              }

              keys.push(key);
            }

            return self;
          }

          return $send(self, "_initialize", [defaults], block.$to_proc());
        }),
        ($Hash_initialize$61.$$arity = -1)
      );
      return (
        (Opal.def(
          self,
          "$to_n",
          ($Hash_to_n$62 = function $$to_n() {
            var self = this;

            var result = {},
              keys = self.$$keys,
              smap = self.$$smap,
              key,
              value;

            for (var i = 0, length = keys.length; i < length; i++) {
              key = keys[i];

              if (key.$$is_string) {
                value = smap[key];
              } else {
                key = key.key;
                value = key.value;
              }

              result[key] = $$($nesting, "Native").$try_convert(value, value);
            }

            return result;
          }),
          ($Hash_to_n$62.$$arity = 0)
        ),
        nil) && "to_n"
      );
    })($nesting[0], null, $nesting);
  }
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Module");

    var $nesting = [self].concat($parent_nesting),
      $Module_native_module$63;

    return (
      (Opal.def(
        self,
        "$native_module",
        ($Module_native_module$63 = function $$native_module() {
          var self = this;

          return (Opal.global[self.$name()] = self);
        }),
        ($Module_native_module$63.$$arity = 0)
      ),
      nil) && "native_module"
    );
  })($nesting[0], null, $nesting);
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "Class");

    var $nesting = [self].concat($parent_nesting),
      $Class_native_alias$64,
      $Class_native_class$65;

    Opal.def(
      self,
      "$native_alias",
      ($Class_native_alias$64 = function $$native_alias(
        new_jsid,
        existing_mid
      ) {
        var self = this;

        var aliased = self.prototype["$" + existing_mid];
        if (!aliased) {
          self.$raise(
            $$($nesting, "NameError").$new(
              "" +
                "undefined method `" +
                existing_mid +
                "' for class `" +
                self.$inspect() +
                "'",
              existing_mid
            )
          );
        }
        self.prototype[new_jsid] = aliased;
      }),
      ($Class_native_alias$64.$$arity = 2)
    );
    return (
      (Opal.def(
        self,
        "$native_class",
        ($Class_native_class$65 = function $$native_class() {
          var self = this;

          self.$native_module();
          return (self["new"] = self.$new);
        }),
        ($Class_native_class$65.$$arity = 0)
      ),
      nil) && "native_class"
    );
  })($nesting[0], null, $nesting);
  return ($gvars.$ = $gvars.global = self.$Native(Opal.global));
};

Opal.modules["nodejs/kernel"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $gvars = Opal.gvars,
    $klass = Opal.klass;

  Opal.add_stubs([
    "$require",
    "$warn",
    "$to_str",
    "$is_a?",
    "$first",
    "$shift",
    "$to_n",
    "$merge",
    "$empty?",
    "$===",
    "$[]",
    "$new",
    "$!=",
    "$raise",
    "$==",
    "$encode",
    "$to_s",
    "$attr_reader",
  ]);

  self.$require("native");
  Opal.exit = process.exit;
  (function ($base, $parent_nesting) {
    var self = $module($base, "Kernel");

    var $nesting = [self].concat($parent_nesting),
      $Kernel_node_require$1,
      $Kernel_system$2,
      $Kernel_$$3;
    if (self.__child_process__ == null) self.__child_process__ = nil;

    Opal.const_set($nesting[0], "NODE_REQUIRE", require);
    self.__child_process__ = require("child_process");
    var __child_process__ = self.__child_process__;

    Opal.def(
      self,
      "$node_require",
      ($Kernel_node_require$1 = function $$node_require(path) {
        var self = this;

        self.$warn(
          "[DEPRECATION] node_require is deprecated. Please use `require('module')` instead."
        );
        return $$($nesting, "NODE_REQUIRE")(path.$to_str());
      }),
      ($Kernel_node_require$1.$$arity = 1)
    );

    Opal.def(
      self,
      "$system",
      ($Kernel_system$2 = function $$system($a, $b) {
        var $post_args,
          $kwargs,
          argv,
          exception,
          self = this,
          env = nil,
          cmdname = nil,
          out = nil,
          status = nil,
          pid = nil,
          $ret_or_1 = nil;

        $post_args = Opal.slice.call(arguments, 0, arguments.length);

        $kwargs = Opal.extract_kwargs($post_args);

        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new("expected kwargs");
        }

        argv = $post_args;

        exception = $kwargs.$$smap["exception"];
        if (exception == null) {
          exception = false;
        }
        env = $hash2([], {});
        if ($truthy(argv.$first()["$is_a?"]($$($nesting, "Hash")))) {
          env = argv.$shift();
        }
        env = $$($nesting, "ENV").$merge(env).$to_n();
        cmdname = argv.$shift();
        out = (function () {
          if ($truthy(argv["$empty?"]())) {
            return __child_process__.spawnSync(cmdname, {
              shell: true,
              stdio: "inherit",
              env: env,
            });
          } else if ($truthy($$($nesting, "Array")["$==="](cmdname))) {
            return __child_process__.spawnSync(cmdname["$[]"](0), argv, {
              argv0: cmdname["$[]"](1),
              stdio: "inherit",
              env: env,
            });
          } else {
            return __child_process__.spawnSync(cmdname, argv, {
              stdio: "inherit",
              env: env,
            });
          }
          return nil;
        })();
        status = out["status"];
        if ($truthy(status === null)) {
          status = 127;
        }
        pid = out["pid"];
        $gvars["?"] = $$$($$($nesting, "Process"), "Status").$new(status, pid);
        if (
          $truthy(
            (function () {
              if ($truthy(($ret_or_1 = exception))) {
                return status["$!="](0);
              } else {
                return $ret_or_1;
              }
              return nil;
            })()
          )
        ) {
          self.$raise(
            "" + "Command failed with exit " + status + ": " + cmdname
          );
        }
        return status["$=="](0);
      }),
      ($Kernel_system$2.$$arity = -1)
    );
    return (
      (Opal.def(
        self,
        "$`",
        ($Kernel_$$3 = function (cmdline) {
          var self = this;

          return $$($nesting, "Buffer")
            .$new(__child_process__.execSync(cmdline))
            .$to_s()
            .$encode("UTF-8");
        }),
        ($Kernel_$$3.$$arity = 1)
      ),
      nil) && "`"
    );
  })($nesting[0], $nesting);
  (function ($base, $parent_nesting) {
    var self = $module($base, "Process");

    var $nesting = [self].concat($parent_nesting);

    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Status");

      var $nesting = [self].concat($parent_nesting),
        $Status_initialize$4,
        $Status_exitstatus$5,
        $Status_success$ques$6,
        $Status_inspect$7;

      self.$$prototype.status = self.$$prototype.pid = nil;

      Opal.def(
        self,
        "$initialize",
        ($Status_initialize$4 = function $$initialize(status, pid) {
          var $a,
            self = this;

          return (
            ($a = [status, pid]), (self.status = $a[0]), (self.pid = $a[1]), $a
          );
        }),
        ($Status_initialize$4.$$arity = 2)
      );

      Opal.def(
        self,
        "$exitstatus",
        ($Status_exitstatus$5 = function $$exitstatus() {
          var self = this;

          return self.status;
        }),
        ($Status_exitstatus$5.$$arity = 0)
      );
      self.$attr_reader("pid");

      Opal.def(
        self,
        "$success?",
        ($Status_success$ques$6 = function () {
          var self = this;

          return self.status["$=="](0);
        }),
        ($Status_success$ques$6.$$arity = 0)
      );
      return (
        (Opal.def(
          self,
          "$inspect",
          ($Status_inspect$7 = function $$inspect() {
            var self = this;

            return (
              "" +
              "#<Process::Status: pid " +
              self.pid +
              " exit " +
              self.status +
              ">"
            );
          }),
          ($Status_inspect$7.$$arity = 0)
        ),
        nil) && "inspect"
      );
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
  Opal.const_set($nesting[0], "ARGV", process.argv.slice(2));
  if ($$($nesting, "ARGV").$first()["$=="]("--")) {
    return $$($nesting, "ARGV").$shift();
  } else {
    return nil;
  }
};

Opal.modules["nodejs/io"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_minus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs - rhs
      : lhs["$-"](rhs);
  }
  var $$5,
    $$6,
    self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $klass = Opal.klass,
    $alias = Opal.alias,
    $lambda = Opal.lambda,
    $send = Opal.send,
    $writer = nil;

  Opal.add_stubs([
    "$attr_reader",
    "$initialize_before_node_io",
    "$write",
    "$read",
    "$write_proc=",
    "$-",
    "$read_proc=",
    "$tty=",
  ]);

  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (
        error.code === "EACCES" ||
        error.code === "EISDIR" ||
        error.code === "EMFILE" ||
        error.code === "ENOENT" ||
        error.code === "EPERM"
      ) {
        throw Opal.IOError.$new(error.message);
      }
      throw error;
    }
  }
  var __fs__ = require("fs");
  (function ($base, $super, $parent_nesting) {
    var self = $klass($base, $super, "IO");

    var $nesting = [self].concat($parent_nesting),
      $IO_initialize$1,
      $IO_write$2,
      $IO_read$3,
      $IO_binread$4;

    self.__fs__ = __fs__;
    self.$attr_reader("lineno");
    $alias(self, "initialize_before_node_io", "initialize");

    Opal.def(
      self,
      "$initialize",
      ($IO_initialize$1 = function $$initialize(fd, flags) {
        var self = this;

        if (flags == null) {
          flags = "r";
        }
        self.lineno = 0;
        return self.$initialize_before_node_io(fd, flags);
      }),
      ($IO_initialize$1.$$arity = -2)
    );
    Opal.defs(
      self,
      "$write",
      ($IO_write$2 = function $$write(path, data) {
        var self = this;

        return $$($nesting, "File").$write(path, data);
      }),
      ($IO_write$2.$$arity = 2)
    );
    Opal.defs(
      self,
      "$read",
      ($IO_read$3 = function $$read(path) {
        var self = this;

        return $$($nesting, "File").$read(path);
      }),
      ($IO_read$3.$$arity = 1)
    );
    return (
      (Opal.defs(
        self,
        "$binread",
        ($IO_binread$4 = function $$binread(path) {
          var self = this;

          return executeIOAction(function () {
            return __fs__.readFileSync(path).toString("binary");
          });
        }),
        ($IO_binread$4.$$arity = 1)
      ),
      nil) && "binread"
    );
  })($nesting[0], null, $nesting);

  $writer = [
    $lambda(
      (($$5 = function (string) {
        var self = $$5.$$s == null ? this : $$5.$$s;

        if (string == null) {
          string = nil;
        }
        return process.stdout.write(string);
      }),
      ($$5.$$s = self),
      ($$5.$$arity = 1),
      $$5)
    ),
  ];
  $send($$($nesting, "STDOUT"), "write_proc=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [
    $lambda(
      (($$6 = function (string) {
        var self = $$6.$$s == null ? this : $$6.$$s;

        if (string == null) {
          string = nil;
        }
        return process.stderr.write(string);
      }),
      ($$6.$$s = self),
      ($$6.$$arity = 1),
      $$6)
    ),
  ];
  $send($$($nesting, "STDERR"), "write_proc=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [
    function (_count) {
      // Ignore count, return as much as we can get
      var buf = Buffer.alloc(65536),
        count;
      try {
        count = __fs__.readSync(this.fd, buf, 0, 65536, null);
      } catch (e) {
        // Windows systems may raise EOF
        return nil;
      }
      if (count == 0) return nil;
      return buf.toString("utf8", 0, count);
    },
  ];
  $send($$($nesting, "STDIN"), "read_proc=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [true];
  $send($$($nesting, "STDIN"), "tty=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [true];
  $send($$($nesting, "STDOUT"), "tty=", Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];

  $writer = [true];
  $send($$($nesting, "STDERR"), "tty=", Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];
};

Opal.modules["headless_chrome"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.exit = function (code) {
    // You can't exit from the browser.
    // The first call to Opal.exit should save an exit code.
    // All next invocations must be ignored.

    if (typeof window.OPAL_EXIT_CODE === "undefined") {
      window.OPAL_EXIT_CODE = code;
    }
  };
};

Opal.modules["opal/miniracer"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.const_set($nesting[0], "ARGV", opalminiracer.argv);
  return (Opal.exit = opalminiracer.exit);
};

Opal.modules["opal/platform"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $case = nil;

  Opal.add_stubs(["$require", "$==="]);

  self.$require("opal-platform");
  return (function () {
    $case = $$($nesting, "OPAL_PLATFORM");
    if ("nashorn"["$==="]($case)) {
      return self.$require("nashorn");
    } else if ("gjs"["$==="]($case)) {
      return self.$require("gjs");
    } else if ("quickjs"["$==="]($case)) {
      return self.$require("quickjs");
    } else if ("nodejs"["$==="]($case)) {
      self.$require("nodejs/kernel");
      return self.$require("nodejs/io");
    } else if ("headless-chrome"["$==="]($case)) {
      return self.$require("headless_chrome");
    } else if ("opal-miniracer"["$==="]($case)) {
      return self.$require("opal/miniracer");
    } else {
      return nil;
    }
  })();
};

Opal.modules["inputreceiver"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $hash2 = Opal.hash2,
    $truthy = Opal.truthy,
    $send = Opal.send,
    $gvars = Opal.gvars;

  Opal.add_stubs([
    "$which",
    "$basename",
    "$+",
    "$[]",
    "$spawn",
    "$in?",
    "$puts",
    "$bold",
    "$join",
    "$map",
    "$sort",
    "$exit",
    "$speak_input",
    "$browser_js?",
    "$==",
    "$get_input_from_browser",
    "$!=",
    "$open",
    "$system",
    "$shellescape",
    "$to_path",
    "$read",
    "$require",
    "$split",
    "$readline",
    "$to_s",
    "$first",
    "$strip",
    "$get_democracy_bar_input",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Inputreceiver");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./inputreceiver.rb" + "/../" + "string__");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Inputreceiver");

      var $nesting = [self].concat($parent_nesting),
        $Inputreceiver_initialize$1,
        $Inputreceiver_to_s$2,
        $Inputreceiver_mode$3,
        $Inputreceiver_speak_input$4,
        $Inputreceiver_which$5,
        $Inputreceiver_receive_input$6,
        $Inputreceiver_get_input_from_browser$9,
        $Inputreceiver_browser_js$ques$10,
        $Inputreceiver_node$ques$11,
        $Inputreceiver_ruby$ques$12;

      self.$$prototype.text =
        self.$$prototype.prompt =
        self.$$prototype.title =
          nil;

      Opal.def(
        self,
        "$initialize",
        ($Inputreceiver_initialize$1 = function $$initialize(t) {
          var self = this;

          if (t == null) {
            t = "Enter text";
          }
          return (self.title = self.prompt = t);
        }),
        ($Inputreceiver_initialize$1.$$arity = -1)
      );

      Opal.def(
        self,
        "$to_s",
        ($Inputreceiver_to_s$2 = function $$to_s() {
          var self = this;

          return self.text;
        }),
        ($Inputreceiver_to_s$2.$$arity = 0)
      );

      Opal.def(
        self,
        "$mode",
        ($Inputreceiver_mode$3 = function $$mode() {
          var self = this;

          return "zenity";
        }),
        ($Inputreceiver_mode$3.$$arity = 0)
      );

      Opal.def(
        self,
        "$speak_input",
        ($Inputreceiver_speak_input$4 = function $$speak_input() {
          var self = this,
            a = nil,
            voice = nil,
            b = nil;

          return nil;
          a =
            "" +
            "echo " +
            self.prompt +
            " | " +
            (voice = ["flite", "espeak", "festival", "cat"].$which()) +
            "  ";
          voice = $$($nesting, "File").$basename(voice);
          b = $hash2(["festival", "flite", "espeak"], {
            festival: "--tts",
            flite: "-voice slt",
            espeak: "",
          });
          a = $rb_plus(a, b["$[]"](voice));
          return self.$spawn(a);
        }),
        ($Inputreceiver_speak_input$4.$$arity = 0)
      );

      Opal.def(
        self,
        "$which",
        ($Inputreceiver_which$5 = function $$which(a) {
          var self = this;

          return [a].$which();
        }),
        ($Inputreceiver_which$5.$$arity = 1)
      );

      Opal.def(
        self,
        "$receive_input",
        ($Inputreceiver_receive_input$6 = function $$receive_input() {
          var $$7,
            $a,
            $$8,
            $b,
            self = this,
            n = nil,
            $ret_or_1 = nil,
            $ret_or_2 = nil,
            $ret_or_3 = nil,
            $ret_or_4 = nil,
            $ret_or_5 = nil,
            $ret_or_6 = nil,
            $ret_or_7 = nil,
            text = nil,
            $ret_or_8 = nil,
            q = nil;
          if ($gvars.stdin == null) $gvars.stdin = nil;

          if (
            $truthy($$($nesting, "ARGV")["$[]"](0)["$in?"](["mode", "modes"]))
          ) {
            n = 0;
            self.$puts("Input modes\n".$bold());
            self.$puts(
              $send(
                [
                  "browser-input",
                  "stdin",
                  "zenity",
                  "dialog",
                  "kdialog",
                  "readline",
                ].$sort(),
                "map",
                [],
                (($$7 = function (_1) {
                  var self = $$7.$$s == null ? this : $$7.$$s;

                  if (_1 == null) {
                    _1 = nil;
                  }
                  return "" + "  " + (n = $rb_plus(n, 1)) + ". " + _1;
                }),
                ($$7.$$s = self),
                ($$7.$$arity = 1),
                $$7)
              ).$join("\n")
            );
            self.$puts();
            self.$exit();
          }
          self.$speak_input();
          if (
            $truthy(
              (function () {
                if ($truthy(($ret_or_1 = self["$browser_js?"]()))) {
                  return $ret_or_1;
                } else {
                  return $$($nesting, "ARGV")["$[]"](0)["$=="]("browser-js");
                }
                return nil;
              })()
            )
          ) {
            return self.$get_input_from_browser();
          } else if (
            $truthy(
              (function () {
                if (
                  $truthy(
                    ($ret_or_2 = (function () {
                      if (
                        $truthy(
                          ($ret_or_3 = $$($nesting, "ARGV")
                            ["$[]"](0)
                            ["$!="]("stdin"))
                        )
                      ) {
                        return $$($nesting, "ARGV")["$[]"](0)["$=="]("kdialog");
                      } else {
                        return $ret_or_3;
                      }
                      return nil;
                    })())
                  )
                ) {
                  return self.$which("kdialog");
                } else {
                  return $ret_or_2;
                }
                return nil;
              })()
            )
          ) {
            return nil;
          } else if (
            $truthy(
              (function () {
                if (
                  $truthy(
                    ($ret_or_4 = (function () {
                      if (
                        $truthy(
                          ($ret_or_5 = $$($nesting, "ARGV")
                            ["$[]"](0)
                            ["$!="]("stdin"))
                        )
                      ) {
                        return $$($nesting, "ARGV")["$[]"](0)["$=="]("zenity");
                      } else {
                        return $ret_or_5;
                      }
                      return nil;
                    })())
                  )
                ) {
                  return self.$which("zenity");
                } else {
                  return $ret_or_4;
                }
                return nil;
              })()
            )
          ) {
            return nil;
          } else if (
            $truthy(
              (function () {
                if (
                  $truthy(
                    ($ret_or_6 = (function () {
                      if (
                        $truthy(
                          ($ret_or_7 = $$($nesting, "ARGV")
                            ["$[]"](0)
                            ["$!="]("stdin"))
                        )
                      ) {
                        return $$($nesting, "ARGV")["$[]"](0)["$=="]("dialog");
                      } else {
                        return $ret_or_7;
                      }
                      return nil;
                    })())
                  )
                ) {
                  return self.$which("dialog");
                } else {
                  return $ret_or_6;
                }
                return nil;
              })()
            )
          ) {
            ($a = 'require "tempfile"'),
              typeof Opal.compile === "function"
                ? eval(
                    Opal.compile($a, {
                      scope_variables: [
                        "n",
                        "$ret_or_1",
                        "$ret_or_2",
                        "$ret_or_3",
                        "$ret_or_4",
                        "$ret_or_5",
                        "$ret_or_6",
                        "$ret_or_7",
                      ],
                      arity_check: false,
                      file: "(eval)",
                      eval: true,
                    })
                  )
                : self.$eval($a);
            text = "";
            $send(
              $$($nesting, "Tempfile"),
              "open",
              [],
              (($$8 = function (file) {
                var self = $$8.$$s == null ? this : $$8.$$s;
                if (self.title == null) self.title = nil;

                if (file == null) {
                  file = nil;
                }
                self.$system(
                  "" +
                    "dialog --inputbox " +
                    self.title.$shellescape() +
                    " 0 0 2> " +
                    file.$to_path().$shellescape()
                );
                return (text = $$($nesting, "File").$read(file));
              }),
              ($$8.$$s = self),
              ($$8.$$arity = 1),
              $$8)
            );
            return text;
          } else if (
            $truthy(
              (function () {
                if (
                  $truthy(
                    ($ret_or_8 = $$($nesting, "ARGV")["$[]"](0)["$=="]("stdin"))
                  )
                ) {
                  return $ret_or_8;
                } else {
                  return $$($nesting, "RUBY_ENGINE")["$=="]("opal");
                }
                return nil;
              })()
            )
          ) {
            true;
            self.$require("opal/platform");
            self.$puts(self.title);
            q = $gvars.stdin.$readline().$split("\n");
            return q.$first().$to_s();
          } else if (
            $truthy($$($nesting, "ARGV")["$[]"](0)["$in?"](["foo", "bar"]))
          ) {
            return "foo".$puts();
          } else {
            self.$puts(self.title);
            ($b = 'require "readline"'),
              typeof Opal.compile === "function"
                ? eval(
                    Opal.compile($b, {
                      scope_variables: [
                        "n",
                        "$ret_or_1",
                        "$ret_or_2",
                        "$ret_or_3",
                        "$ret_or_4",
                        "$ret_or_5",
                        "$ret_or_6",
                        "$ret_or_7",
                        "text",
                        "$ret_or_8",
                        "q",
                      ],
                      arity_check: false,
                      file: "(eval)",
                      eval: true,
                    })
                  )
                : self.$eval($b);
            return $$($nesting, "Readline").$readline().$strip();
          }
        }),
        ($Inputreceiver_receive_input$6.$$arity = 0)
      );

      Opal.def(
        self,
        "$get_input_from_browser",
        ($Inputreceiver_get_input_from_browser$9 =
          function $$get_input_from_browser() {
            var self = this;
            if ($gvars.$ == null) $gvars.$ = nil;

            true;
            self.$require("native");
            self.$puts("Democracy barr");
            return $gvars.$.$get_democracy_bar_input();
          }),
        ($Inputreceiver_get_input_from_browser$9.$$arity = 0)
      );

      Opal.def(
        self,
        "$browser_js?",
        ($Inputreceiver_browser_js$ques$10 = function () {
          var self = this;

          try {
            document;
            return true;
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, "Exception")])) {
              try {
                return false;
              } finally {
                Opal.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        }),
        ($Inputreceiver_browser_js$ques$10.$$arity = 0)
      );

      Opal.def(
        self,
        "$node?",
        ($Inputreceiver_node$ques$11 = function () {
          var self = this;

          try {
            process;
            return true;
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, "Exception")])) {
              try {
                return false;
              } finally {
                Opal.pop_exception();
              }
            } else {
              throw $err;
            }
          }
        }),
        ($Inputreceiver_node$ques$11.$$arity = 0)
      );
      return (
        (Opal.def(
          self,
          "$ruby?",
          ($Inputreceiver_ruby$ques$12 = function () {
            var self = this;

            return true;
          }),
          ($Inputreceiver_ruby$ques$12.$$arity = 0)
        ),
        nil) && "ruby?"
      );
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["itemlist"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send = Opal.send;

  Opal.add_stubs([
    "$assert",
    "$!",
    "$include?",
    "$to_s",
    "$add_period",
    "$uppercase",
    "$starting_to_s",
    "$first",
    "$each",
    "$[]",
    "$length",
    "$+",
    "$rstrip",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "ItemList");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./itemlist.rb" + "/../" + "string__");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "ItemList");

      var $nesting = [self].concat($parent_nesting),
        $ItemList_initialize$1,
        $ItemList_process$2,
        $ItemList_to_s$3,
        $ItemList_inspect$5;

      self.$$prototype.list = nil;

      Opal.def(
        self,
        "$initialize",
        ($ItemList_initialize$1 = function $$initialize(list) {
          var self = this;

          self.list = list;
          return self.$assert(list.$to_s()["$include?"](" i ")["$!"]());
        }),
        ($ItemList_initialize$1.$$arity = 1)
      );

      Opal.def(
        self,
        "$process",
        ($ItemList_process$2 = function $$process() {
          var self = this;

          return nil;
        }),
        ($ItemList_process$2.$$arity = 0)
      );

      Opal.def(
        self,
        "$to_s",
        ($ItemList_to_s$3 = function $$to_s() {
          var $$4,
            self = this,
            text = nil;

          text =
            "" +
            self.list.$first().$starting_to_s().$uppercase().$add_period() +
            " ";
          $send(
            self.list["$[]"](Opal.Range.$new(1, self.list.$length(), false)),
            "each",
            [],
            (($$4 = function (i) {
              var self = $$4.$$s == null ? this : $$4.$$s,
                q = nil;

              if (i == null) {
                i = nil;
              }
              return (text = $rb_plus(
                text,
                "" + (q = i.$to_s().$uppercase().$add_period()) + " "
              ));
            }),
            ($$4.$$s = self),
            ($$4.$$arity = 1),
            $$4)
          );
          return (text = text.$rstrip());
        }),
        ($ItemList_to_s$3.$$arity = 0)
      );
      return (
        (Opal.def(
          self,
          "$inspect",
          ($ItemList_inspect$5 = function $$inspect() {
            var self = this;

            return self.$to_s();
          }),
          ($ItemList_inspect$5.$$arity = 0)
        ),
        nil) && "inspect"
      );
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["conjunction"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass;

  Opal.add_stubs(["$sample", "$l", "$_to_s", "$protected", "$+", "$to_s"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Conjunction");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./conjunction.rb" + "/../" + "string__");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Conjunction");

      var $nesting = [self].concat($parent_nesting),
        $Conjunction_initialize$1,
        $Conjunction_inspect$2,
        $Conjunction_to_s$3,
        $Conjunction__to_s$4;

      self.$$prototype.value = self.$$prototype.a = nil;

      Opal.def(
        self,
        "$initialize",
        ($Conjunction_initialize$1 = function $$initialize(a) {
          var self = this;

          self.a = a;
          return (self.value = self.$l().$sample());
        }),
        ($Conjunction_initialize$1.$$arity = 1)
      );

      Opal.def(
        self,
        "$inspect",
        ($Conjunction_inspect$2 = function $$inspect() {
          var self = this;

          return self.$_to_s();
        }),
        ($Conjunction_inspect$2.$$arity = 0)
      );

      Opal.def(
        self,
        "$to_s",
        ($Conjunction_to_s$3 = function $$to_s() {
          var self = this;

          return self.$_to_s();
        }),
        ($Conjunction_to_s$3.$$arity = 0)
      );
      self.$protected();
      return (
        (Opal.def(
          self,
          "$_to_s",
          ($Conjunction__to_s$4 = function $$_to_s() {
            var self = this;

            return $rb_plus(self.value.$to_s(), self.a.$to_s());
          }),
          ($Conjunction__to_s$4.$$arity = 0)
        ),
        nil) && "_to_s"
      );
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["because"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send = Opal.send,
    $truthy = Opal.truthy;

  Opal.add_stubs(["$map", "$start_with?"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Because");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./because.rb" + "/../" + "string__");
    self.$require("./because.rb" + "/../" + "./conjunction");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Because");

      var $nesting = [self].concat($parent_nesting),
        $Because_l$1;

      return (
        (Opal.def(
          self,
          "$l",
          ($Because_l$1 = function $$l() {
            var $$2,
              self = this;

            return $send(
              [
                "because",
                "since",
                "; the reason being that",
                "due to the fact that",
                "inasmuch as",
                "; for the reason that",
              ],
              "map",
              [],
              (($$2 = function (i) {
                var self = $$2.$$s == null ? this : $$2.$$s;

                if (i == null) {
                  i = nil;
                }
                if ($truthy(i["$start_with?"](";"))) {
                  return i;
                } else {
                  return "" + " " + i;
                }
              }),
              ($$2.$$s = self),
              ($$2.$$arity = 1),
              $$2)
            );
          }),
          ($Because_l$1.$$arity = 0)
        ),
        nil) && "l"
      );
    })($nesting[0], $$$($$($nesting, "Conjunction"), "Conjunction"), $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["evidence"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send = Opal.send;

  Opal.add_stubs(["$map"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Evidence");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./evidence.rb" + "/../" + "string__");
    self.$require("./evidence.rb" + "/../" + "./conjunction");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Evidence");

      var $nesting = [self].concat($parent_nesting),
        $Evidence_l$1;

      return (
        (Opal.def(
          self,
          "$l",
          ($Evidence_l$1 = function $$l() {
            var $$2,
              self = this;

            return $send(
              [
                "as evidenced by",
                "as shown by",
                "which is indicated by",
                "as made apparent by",
                "as made clear by",
                "as made plain by",
                "as demonstrated by",
                "as made plain by",
                "as becomes observable by",
              ],
              "map",
              [],
              (($$2 = function (i) {
                var self = $$2.$$s == null ? this : $$2.$$s;

                if (i == null) {
                  i = nil;
                }
                return "" + " " + i;
              }),
              ($$2.$$s = self),
              ($$2.$$arity = 1),
              $$2)
            );
          }),
          ($Evidence_l$1.$$arity = 0)
        ),
        nil) && "l"
      );
    })($nesting[0], $$$($$($nesting, "Conjunction"), "Conjunction"), $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["however"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send = Opal.send;

  Opal.add_stubs(["$map"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "However");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./however.rb" + "/../" + "string__");
    self.$require("./however.rb" + "/../" + "./conjunction");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "However");

      var $nesting = [self].concat($parent_nesting),
        $However_l$1;

      return (
        (Opal.def(
          self,
          "$l",
          ($However_l$1 = function $$l() {
            var $$2,
              self = this;

            return $send(
              [
                "one interesting point though",
                "however",
                "though",
                "although",
                "that being said",
                "with that said",
                "on the other hand though",
              ],
              "map",
              [],
              (($$2 = function (i) {
                var self = $$2.$$s == null ? this : $$2.$$s;

                if (i == null) {
                  i = nil;
                }
                return "" + i + " ";
              }),
              ($$2.$$s = self),
              ($$2.$$arity = 1),
              $$2)
            );
          }),
          ($However_l$1.$$arity = 0)
        ),
        nil) && "l"
      );
    })($nesting[0], $$$($$($nesting, "Conjunction"), "Conjunction"), $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["item"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_times(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs * rhs
      : lhs["$*"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send = Opal.send,
    $truthy = Opal.truthy;

  Opal.add_stubs([
    "$each_with_index",
    "$start_with?",
    "$send",
    "$[]",
    "$+",
    "$*",
    "$length",
    "$sample",
    "$new",
    "$join",
    "$to_s",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Item");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./item.rb" + "/../" + "string__");
    self.$require("./item.rb" + "/../" + "./because");
    self.$require("./item.rb" + "/../" + "./evidence");
    self.$require("./item.rb" + "/../" + "./however");
    Opal.const_set(
      $nesting[0],
      "Because",
      $$$($$($nesting, "Because"), "Because")
    );
    Opal.const_set(
      $nesting[0],
      "However",
      $$$($$($nesting, "However"), "However")
    );
    Opal.const_set(
      $nesting[0],
      "Evidence",
      $$$($$($nesting, "Evidence"), "Evidence")
    );
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Item");

      var $nesting = [self].concat($parent_nesting),
        $Item_initialize$1,
        $Item_personally$3,
        $Item_however$4,
        $Item_because$5,
        $Item_evidence$6,
        $Item_starting_to_s$7,
        $Item_to_s$8,
        $Item_inspect$9;

      self.$$prototype.personally =
        self.$$prototype.sentiment =
        self.$$prototype.because =
        self.$$prototype.evidence =
        self.$$prototype.however =
          nil;

      Opal.def(
        self,
        "$initialize",
        ($Item_initialize$1 = function $$initialize(functions, inputs) {
          var $$2,
            self = this;

          return $send(
            inputs,
            "each_with_index",
            [],
            (($$2 = function (in_, i) {
              var self = $$2.$$s == null ? this : $$2.$$s;

              if (in_ == null) {
                in_ = nil;
              }

              if (i == null) {
                i = nil;
              }
              if ($truthy(in_["$start_with?"]("that"))) {
              }
              return self.$send(functions["$[]"](i), in_);
            }),
            ($$2.$$s = self),
            ($$2.$$arity = 2),
            $$2)
          );
        }),
        ($Item_initialize$1.$$arity = 2)
      );

      Opal.def(
        self,
        "$personally",
        ($Item_personally$3 = function $$personally(_argument) {
          var self = this,
            list = nil;

          list = [
            "I personally",
            "personally, I",
            "I think I",
            "in my opinion, I",
            "to me, I",
          ];
          list = $rb_plus(list, $rb_times(["I"], list.$length()));
          return (self.personally = "" + list.$sample() + " ");
        }),
        ($Item_personally$3.$$arity = 1)
      );

      Opal.def(
        self,
        "$however",
        ($Item_however$4 = function $$however(a) {
          var self = this;

          return (self.however = $$($nesting, "However").$new(a));
        }),
        ($Item_however$4.$$arity = 1)
      );

      Opal.def(
        self,
        "$because",
        ($Item_because$5 = function $$because(a) {
          var self = this;

          return (self.because = $$($nesting, "Because").$new(a));
        }),
        ($Item_because$5.$$arity = 1)
      );

      Opal.def(
        self,
        "$evidence",
        ($Item_evidence$6 = function $$evidence(a) {
          var self = this;

          return (self.evidence = $$($nesting, "Evidence").$new(a));
        }),
        ($Item_evidence$6.$$arity = 1)
      );

      Opal.def(
        self,
        "$starting_to_s",
        ($Item_starting_to_s$7 = function $$starting_to_s() {
          var self = this;

          return [
            self.personally,
            self.sentiment,
            self.because,
            self.evidence,
          ].$join();
        }),
        ($Item_starting_to_s$7.$$arity = 0)
      );

      Opal.def(
        self,
        "$to_s",
        ($Item_to_s$8 = function $$to_s() {
          var self = this,
            a = nil;

          return (a = [
            self.however,
            self.personally,
            self.sentiment,
            self.because,
            self.evidence,
          ].$join());
        }),
        ($Item_to_s$8.$$arity = 0)
      );
      return (
        (Opal.def(
          self,
          "$inspect",
          ($Item_inspect$9 = function $$inspect() {
            var self = this;

            return self.$to_s();
          }),
          ($Item_inspect$9.$$arity = 0)
        ),
        nil) && "inspect"
      );
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["negative"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $class_variable_get = Opal.class_variable_get,
    $class_variable_set = Opal.class_variable_set;

  Opal.add_stubs(["$sample"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Negative");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./negative.rb" + "/../" + "string__");
    self.$require("./negative.rb" + "/../" + "./item");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Negative");

      var $nesting = [self].concat($parent_nesting),
        $Negative_initialize$1,
        $Negative_however$2,
        $Negative_disagree$3;

      Opal.def(
        self,
        "$initialize",
        ($Negative_initialize$1 = function $$initialize($a) {
          var $post_args,
            args,
            $iter = $Negative_initialize$1.$$p,
            $yield = $iter || nil,
            self = this,
            b = nil;

          if ($iter) $Negative_initialize$1.$$p = null;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          args = $post_args;
          b = ["however", "personally", "disagree", "because", "evidence"];
          return $send2(
            self,
            $find_super(
              self,
              "initialize",
              $Negative_initialize$1,
              false,
              true
            ),
            "initialize",
            [b, args],
            null
          );
        }),
        ($Negative_initialize$1.$$arity = -1)
      );

      Opal.def(
        self,
        "$however",
        ($Negative_however$2 = function $$however(argument) {
          var self = this;

          return nil;
        }),
        ($Negative_however$2.$$arity = 1)
      );

      Opal.def(
        self,
        "$disagree",
        ($Negative_disagree$3 = function $$disagree(argument) {
          var self = this;

          return (self.sentiment =
            "" +
            $class_variable_get($nesting[0], "@@list", false).$sample() +
            argument);
        }),
        ($Negative_disagree$3.$$arity = 1)
      );
      return $class_variable_set($nesting[0], "@@list", [
        "disagree",
        "don't agree",
        "do not agree",
        "do not agree with the statement that",
      ]);
    })($nesting[0], $$$($$($nesting, "Item"), "Item"), $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["neutral"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $class_variable_set = Opal.class_variable_set,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $class_variable_get = Opal.class_variable_get;

  Opal.add_stubs(["$+", "$sample"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Neutral");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./neutral.rb" + "/../" + "string__");
    self.$require("./neutral.rb" + "/../" + "./item");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Neutral");

      var $nesting = [self].concat($parent_nesting),
        $Neutral_initialize$1,
        $Neutral_nop$2,
        $Neutral_state$3;

      $class_variable_set($nesting[0], "@@list", [
        "I think we can all agree",
        "Everyone knows",
        "Everybody knows",
        "We all know",
      ]);

      Opal.def(
        self,
        "$initialize",
        ($Neutral_initialize$1 = function $$initialize($a) {
          var $post_args,
            args,
            $iter = $Neutral_initialize$1.$$p,
            $yield = $iter || nil,
            self = this;

          if ($iter) $Neutral_initialize$1.$$p = null;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          args = $post_args;
          return $send2(
            self,
            $find_super(self, "initialize", $Neutral_initialize$1, false, true),
            "initialize",
            [["nop", "nop", "nop", "state", "nop"], args],
            null
          );
        }),
        ($Neutral_initialize$1.$$arity = -1)
      );

      Opal.def(
        self,
        "$nop",
        ($Neutral_nop$2 = function $$nop(_argument) {
          var self = this;

          return "";
        }),
        ($Neutral_nop$2.$$arity = 1)
      );
      return (
        (Opal.def(
          self,
          "$state",
          ($Neutral_state$3 = function $$state(argument) {
            var self = this;

            return (self.sentiment = $rb_plus(
              $class_variable_get($nesting[0], "@@list", false).$sample(),
              argument
            ));
          }),
          ($Neutral_state$3.$$arity = 1)
        ),
        nil) && "state"
      );
    })($nesting[0], $$$($$($nesting, "Item"), "Item"), $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["outputter"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $truthy = Opal.truthy,
    $send = Opal.send,
    $gvars = Opal.gvars;

  Opal.add_stubs([
    "$nil?",
    "$raise",
    "$new",
    "$send",
    "$respond_to?",
    "$popen",
    "$puts",
    "$_stdout",
    "$print",
    "$require",
    "$copyTextToClipboard",
    "$appendChild",
    "$querySelector",
    "$document",
    "$createTextNode",
    "$to_s",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Outputter");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./outputter.rb" + "/../" + "string__");
    self.$require("./outputter.rb" + "/../" + "./inputreceiver");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Outputter");

      var $nesting = [self].concat($parent_nesting),
        $Outputter_initialize$1,
        $Outputter_copy$2,
        $Outputter__stdout$4;

      self.$$prototype.item_list = nil;

      Opal.def(
        self,
        "$initialize",
        ($Outputter_initialize$1 = function $$initialize(mode, item_list) {
          var self = this;

          if ($truthy(mode["$nil?"]())) {
            self.$raise("");
          }
          self.ir = $$$($$($nesting, "Inputreceiver"), "Inputreceiver").$new(
            "stdout"
          );
          self.item_list = item_list;
          return self.$send(mode);
        }),
        ($Outputter_initialize$1.$$arity = 2)
      );

      Opal.def(
        self,
        "$copy",
        ($Outputter_copy$2 = function $$copy() {
          var $$3,
            self = this;
          if ($gvars.$ == null) $gvars.$ = nil;

          if ($truthy($$($nesting, "IO")["$respond_to?"]("popen"))) {
            return $send(
              $$($nesting, "IO"),
              "popen",
              ["xclip -selection c", "w"],
              (($$3 = function (f) {
                var self = $$3.$$s == null ? this : $$3.$$s;

                if (f == null) {
                  f = nil;
                }
                self.$puts(self.$_stdout());
                return f.$print(self.$_stdout());
              }),
              ($$3.$$s = self),
              ($$3.$$arity = 1),
              $$3)
            );
          } else {
            true;
            self.$require("native");
            $gvars.$.$copyTextToClipboard(self.$_stdout());
            $gvars.$.$document()
              .$querySelector("sensibleness")
              .$appendChild(
                $gvars.$.$document().$createTextNode(self.$_stdout())
              );
            return self.$puts(self.$_stdout());
          }
        }),
        ($Outputter_copy$2.$$arity = 0)
      );
      return (
        (Opal.def(
          self,
          "$_stdout",
          ($Outputter__stdout$4 = function $$_stdout() {
            var self = this;

            return self.item_list.$to_s();
          }),
          ($Outputter__stdout$4.$$arity = 0)
        ),
        nil) && "_stdout"
      );
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["positive"] = function (Opal) {
  /* Generated by Opal 1.3.1 */
  function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send2 = Opal.send2,
    $find_super = Opal.find_super,
    $class_variable_get = Opal.class_variable_get,
    $class_variable_set = Opal.class_variable_set;

  Opal.add_stubs(["$+", "$sample"]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "Positive");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./positive.rb" + "/../" + "string__");
    self.$require("./positive.rb" + "/../" + "./item");
    return (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "Positive");

      var $nesting = [self].concat($parent_nesting),
        $Positive_initialize$1,
        $Positive_agree$2;

      Opal.def(
        self,
        "$initialize",
        ($Positive_initialize$1 = function $$initialize($a) {
          var $post_args,
            args,
            $iter = $Positive_initialize$1.$$p,
            $yield = $iter || nil,
            self = this;

          if ($iter) $Positive_initialize$1.$$p = null;

          $post_args = Opal.slice.call(arguments, 0, arguments.length);

          args = $post_args;
          return $send2(
            self,
            $find_super(
              self,
              "initialize",
              $Positive_initialize$1,
              false,
              true
            ),
            "initialize",
            [["however", "personally", "agree", "because", "evidence"], args],
            null
          );
        }),
        ($Positive_initialize$1.$$arity = -1)
      );

      Opal.def(
        self,
        "$agree",
        ($Positive_agree$2 = function $$agree(argument) {
          var self = this;

          return (self.sentiment = $rb_plus(
            $class_variable_get($nesting[0], "@@list", false).$sample(),
            argument
          ));
        }),
        ($Positive_agree$2.$$arity = 1)
      );
      return $class_variable_set($nesting[0], "@@list", [
        "agree",
        "agree with the statement that",
        "do agree",
      ]);
    })($nesting[0], $$$($$($nesting, "Item"), "Item"), $nesting);
  })($nesting[0], $nesting);
};

Opal.queue(function (Opal) {
  /* Generated by Opal 1.3.1 */ function $rb_plus(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs + rhs
      : lhs["$+"](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return typeof lhs === "number" && typeof rhs === "number"
      ? lhs >= rhs
      : lhs["$>="](rhs);
  }
  var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$,
    $module = Opal.module,
    $klass = Opal.klass,
    $send = Opal.send;

  Opal.add_stubs([
    "$new",
    "$reverse_each",
    "$+",
    "$shuffle",
    "$i",
    "$receive_input",
    "$pop",
    "$concat",
    "$assert",
    "$instance_of?",
    "$>=",
    "$length",
    "$to_s",
  ]);
  return (function ($base, $parent_nesting) {
    var self = $module($base, "MainClass");

    var $nesting = [self].concat($parent_nesting);

    self.$require("./p.rb" + "/../" + "string__");
    self.$require("./p.rb" + "/../" + "./inputreceiver");
    self.$require("./p.rb" + "/../" + "./itemlist");
    self.$require("./p.rb" + "/../" + "./negative");
    self.$require("./p.rb" + "/../" + "./neutral");
    self.$require("./p.rb" + "/../" + "./outputter");
    self.$require("./p.rb" + "/../" + "./positive");
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "MainClass");

      var $nesting = [self].concat($parent_nesting),
        $MainClass_initialize$1;

      return (
        (Opal.def(
          self,
          "$initialize",
          ($MainClass_initialize$1 = function $$initialize() {
            var self = this,
              item_list = nil,
              outputter = nil;

            item_list = $$($nesting, "ItemMaker").$new();
            return (outputter = $$$(
              $$($nesting, "Outputter"),
              "Outputter"
            ).$new("copy", item_list));
          }),
          ($MainClass_initialize$1.$$arity = 0)
        ),
        nil) && "initialize"
      );
    })($nesting[0], null, $nesting);
    (function ($base, $super, $parent_nesting) {
      var self = $klass($base, $super, "ItemMaker");

      var $nesting = [self].concat($parent_nesting),
        $ItemMaker_initialize$2,
        $ItemMaker_i$4,
        $ItemMaker_to_s$5;

      self.$$prototype.list =
        self.$$prototype.neg =
        self.$$prototype.pos =
        self.$$prototype.neut =
          nil;

      Opal.def(
        self,
        "$initialize",
        ($ItemMaker_initialize$2 = function $$initialize() {
          var $$3,
            $a,
            $b,
            self = this,
            however1 = nil,
            however2 = nil;

          self.list = [];
          $send(
            ["negative", "positive", "neutral"],
            "reverse_each",
            [],
            (($$3 = function (i) {
              var self = $$3.$$s == null ? this : $$3.$$s;
              if (self.list == null) self.list = nil;

              if (i == null) {
                i = nil;
              }
              return (self.list = $rb_plus(self.list, [
                "" + "Enter " + i + " feeling",
                "" + "Enter " + i + " reason",
                "" + "Enter " + i + " evidence",
              ]));
            }),
            ($$3.$$s = self),
            ($$3.$$arity = 1),
            $$3)
          );
          ($b = ["", ""].$shuffle()),
            ($a = Opal.to_ary($b)),
            (however1 = $a[0] == null ? nil : $a[0]),
            (however2 = $a[1] == null ? nil : $a[1]),
            $b;
          self.neg = $$$($$($nesting, "Negative"), "Negative").$new(
            "",
            however1,
            self.$i(),
            self.$i(),
            self.$i()
          );
          self.pos = $$$($$($nesting, "Positive"), "Positive").$new(
            "",
            however2,
            self.$i(),
            self.$i(),
            self.$i()
          );
          return (self.neut = $$$($$($nesting, "Neutral"), "Neutral").$new(
            "",
            "",
            self.$i(),
            self.$i(),
            self.$i()
          ));
        }),
        ($ItemMaker_initialize$2.$$arity = 0)
      );

      Opal.def(
        self,
        "$i",
        ($ItemMaker_i$4 = function $$i() {
          var self = this,
            t = nil;

          t = $$$($$($nesting, "Inputreceiver"), "Inputreceiver")
            .$new(self.list.$pop())
            .$receive_input();
          return "" + " " + t;
        }),
        ($ItemMaker_i$4.$$arity = 0)
      );
      return (
        (Opal.def(
          self,
          "$to_s",
          ($ItemMaker_to_s$5 = function $$to_s() {
            var self = this,
              list = nil;

            list = [self.neg, self.pos].$shuffle().$concat([self.neut]);
            self.$assert(list["$instance_of?"]($$($nesting, "Array")));
            self.$assert($rb_ge(list.$length(), 2));
            return $$$($$($nesting, "ItemList"), "ItemList").$new(list).$to_s();
          }),
          ($ItemMaker_to_s$5.$$arity = 0)
        ),
        nil) && "to_s"
      );
    })($nesting[0], null, $nesting);
    return $$($nesting, "MainClass").$new();
  })($nesting[0], $nesting);
});

Opal.queue(function (Opal) {
  /* Generated by Opal 1.3.1 */ var self = Opal.top,
    $nesting = [],
    nil = Opal.nil,
    $$$ = Opal.$$$,
    $$ = Opal.$$;

  Opal.add_stubs(["$exit"]);
  return $$($nesting, "Kernel").$exit();
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKHR5cGVvZihnbG9iYWxfb2JqZWN0LmNvbnNvbGUpID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGU7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsX29iamVjdC5jb25zb2xlID09IG51bGwpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9O1xuICB9XG5cbiAgaWYgKCEoJ2xvZycgaW4gY29uc29sZSkpIHsgY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTsgfVxuICBpZiAoISgnd2FybicgaW4gY29uc29sZSkpIHsgY29uc29sZS53YXJuID0gY29uc29sZS5sb2c7IH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuT3BhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdPcGFsIGFscmVhZHkgbG9hZGVkLiBMb2FkaW5nIHR3aWNlIGNhbiBjYXVzZSB0cm91YmxlcywgcGxlYXNlIGZpeCB5b3VyIHNldHVwLicpO1xuICAgIHJldHVybiBnbG9iYWxfb2JqZWN0Lk9wYWw7XG4gIH1cblxuICB2YXIgbmlsO1xuXG4gIC8vIFRoZSBhY3R1YWwgY2xhc3MgZm9yIEJhc2ljT2JqZWN0XG4gIHZhciBCYXNpY09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE9iamVjdCBjbGFzcy5cbiAgLy8gVGhlIGxlYWRpbmcgdW5kZXJzY29yZSBpcyB0byBhdm9pZCBjb25mdXNpb24gd2l0aCB3aW5kb3cuT2JqZWN0KClcbiAgdmFyIF9PYmplY3Q7XG5cbiAgLy8gVGhlIGFjdHVhbCBNb2R1bGUgY2xhc3NcbiAgdmFyIE1vZHVsZTtcblxuICAvLyBUaGUgYWN0dWFsIENsYXNzIGNsYXNzXG4gIHZhciBDbGFzcztcblxuICAvLyBUaGUgT3BhbCBvYmplY3QgdGhhdCBpcyBleHBvc2VkIGdsb2JhbGx5XG4gIHZhciBPcGFsID0gZ2xvYmFsX29iamVjdC5PcGFsID0ge307XG5cbiAgLy8gVGhpcyBpcyBhIHVzZWZ1bCByZWZlcmVuY2UgdG8gZ2xvYmFsIG9iamVjdCBpbnNpZGUgcnVieSBmaWxlc1xuICBPcGFsLmdsb2JhbCA9IGdsb2JhbF9vYmplY3Q7XG4gIGdsb2JhbF9vYmplY3QuT3BhbCA9IE9wYWw7XG5cbiAgLy8gQ29uZmlndXJlIHJ1bnRpbWUgYmVoYXZpb3Igd2l0aCByZWdhcmRzIHRvIHJlcXVpcmUgYW5kIHVuc3VwcG9ydGVkIGZlYXR1cmVzXG4gIE9wYWwuY29uZmlnID0ge1xuICAgIG1pc3NpbmdfcmVxdWlyZV9zZXZlcml0eTogJ2Vycm9yJywgICAgICAgIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICB1bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLCAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgZXhwZXJpbWVudGFsX2ZlYXR1cmVzX3NldmVyaXR5OiAnd2FybmluZycsLy8gd2FybmluZywgaWdub3JlXG4gICAgZW5hYmxlX3N0YWNrX3RyYWNlOiB0cnVlICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2VcbiAgfTtcblxuICAvLyBNaW5pZnkgY29tbW9uIGZ1bmN0aW9uIGNhbGxzXG4gIHZhciAkaGFzX293biAgID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgJGJpbmQgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICB2YXIgJHNldF9wcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiAgdmFyICRzbGljZSAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHZhciAkc3BsaWNlICAgID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcblxuICAvLyBOaWwgb2JqZWN0IGlkIGlzIGFsd2F5cyA0XG4gIHZhciBuaWxfaWQgPSA0O1xuXG4gIC8vIEdlbmVyYXRlcyBldmVuIHNlcXVlbnRpYWwgbnVtYmVycyBncmVhdGVyIHRoYW4gNFxuICAvLyAobmlsX2lkKSB0byBzZXJ2ZSBhcyB1bmlxdWUgaWRzIGZvciBydWJ5IG9iamVjdHNcbiAgdmFyIHVuaXF1ZV9pZCA9IG5pbF9pZDtcblxuICAvLyBSZXR1cm4gbmV4dCB1bmlxdWUgaWRcbiAgT3BhbC51aWQgPSBmdW5jdGlvbigpIHtcbiAgICB1bmlxdWVfaWQgKz0gMjtcbiAgICByZXR1cm4gdW5pcXVlX2lkO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmouJCRpZDtcbiAgICB9XG4gICAgJGRlZmluZVByb3BlcnR5KG9iaiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICBPcGFsLmd2YXJzID0ge307XG5cbiAgLy8gRXhpdCBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgLy8gKFNlZSBub2RlanMgYW5kIGNocm9tZSBmb3IgZXhhbXBsZXMpXG4gIE9wYWwuZXhpdCA9IGZ1bmN0aW9uKHN0YXR1cykgeyBpZiAoT3BhbC5ndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKTtcbiAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICBPcGFsLmd2YXJzW1wiIVwiXSA9IGV4Y2VwdGlvbjtcbiAgICAgIE9wYWwuZ3ZhcnNbXCJAXCJdID0gZXhjZXB0aW9uLiRiYWNrdHJhY2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBPcGFsLmd2YXJzW1wiIVwiXSA9IE9wYWwuZ3ZhcnNbXCJAXCJdID0gbmlsO1xuICAgIH1cbiAgfTtcblxuICAvLyBJbnNwZWN0IGFueSBraW5kIG9mIG9iamVjdCwgaW5jbHVkaW5nIG5vbiBSdWJ5IG9uZXNcbiAgT3BhbC5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmouJCRjbGFzcykge1xuICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvYmouJGluc3BlY3QoKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gJGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZihvYmplY3QpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yOlxuICAgICAgLy8gICBzID0gXCJzdHJpbmdcIlxuICAgICAgLy8gICBkZWYgcy5tOyBlbmRcbiAgICAgIC8vIFN0cmluZyBjbGFzcyBpcyB0aGUgb25seSBjbGFzcyB0aGF0OlxuICAgICAgLy8gKyBjb21waWxlcyB0byBKUyBwcmltaXRpdmVcbiAgICAgIC8vICsgYWxsb3dzIG1ldGhvZCBkZWZpbml0aW9uIGRpcmVjdGx5IG9uIGluc3RhbmNlc1xuICAgICAgLy8gbnVtYmVycywgdHJ1ZSwgZmFsc2UgYW5kIG51bGwgZG8gbm90IHN1cHBvcnQgaXQuXG4gICAgICBvYmplY3RbbmFtZV0gPSBpbml0aWFsVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSAkZGVmaW5lUHJvcGVydHk7XG5cbiAgT3BhbC5zbGljZSA9ICRzbGljZTtcblxuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS1cblxuICBPcGFsLnRydXRoeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodmFsICE9PSBuaWwgJiYgdmFsICE9IG51bGwgJiYgKCF2YWwuJCRpc19ib29sZWFuIHx8IHZhbCA9PSB0cnVlKSk7XG4gIH07XG5cbiAgT3BhbC5mYWxzeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodmFsID09PSBuaWwgfHwgdmFsID09IG51bGwgfHwgKHZhbC4kJGlzX2Jvb2xlYW4gJiYgdmFsID09IGZhbHNlKSlcbiAgfTtcblxuICBPcGFsLnR5cGVfZXJyb3IgPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZCkge1xuICAgIG9iamVjdCA9IG9iamVjdC4kJGNsYXNzO1xuXG4gICAgaWYgKGNvZXJjZWQgJiYgbWV0aG9kKSB7XG4gICAgICBjb2VyY2VkID0gY29lcmNlZC4kJGNsYXNzO1xuICAgICAgcmV0dXJuIE9wYWwuVHlwZUVycm9yLiRuZXcoXG4gICAgICAgIFwiY2FuJ3QgY29udmVydCBcIiArIG9iamVjdCArIFwiIGludG8gXCIgKyB0eXBlICtcbiAgICAgICAgXCIgKFwiICsgb2JqZWN0ICsgXCIjXCIgKyBtZXRob2QgKyBcIiBnaXZlcyBcIiArIGNvZXJjZWQgKyBcIilcIlxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGVcbiAgICAgIClcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5jb2VyY2VfdG8gPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncykge1xuICAgIGlmICh0eXBlWyckPT09J10ob2JqZWN0KSkgcmV0dXJuIG9iamVjdDtcblxuICAgIGlmICghb2JqZWN0WyckcmVzcG9uZF90bz8nXShtZXRob2QpKSB7XG4gICAgICB0aHJvdyBPcGFsLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncyA9PSBudWxsKSBhcmdzID0gW107XG4gICAgcmV0dXJuIE9wYWwuc2VuZChvYmplY3QsIG1ldGhvZCwgYXJncyk7XG4gIH1cblxuICBPcGFsLnJlc3BvbmRfdG8gPSBmdW5jdGlvbihvYmosIGpzaWQsIGluY2x1ZGVfYWxsKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8ICFvYmouJCRjbGFzcykgcmV0dXJuIGZhbHNlO1xuICAgIGluY2x1ZGVfYWxsID0gISFpbmNsdWRlX2FsbDtcbiAgICB2YXIgYm9keSA9IG9ialtqc2lkXTtcblxuICAgIGlmIChvYmpbJyRyZXNwb25kX3RvPyddLiQkcHJpc3RpbmUpIHtcbiAgICAgIGlmIChvYmpbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuc2VuZChvYmosIG9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90bz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNlUG9pbnQgc3VwcG9ydFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gU3VwcG9ydCBmb3IgYFRyYWNlUG9pbnQudHJhY2UoOmNsYXNzKSBkbyAuLi4gZW5kYFxuICBPcGFsLnRyYWNlX2NsYXNzID0gZmFsc2U7XG4gIE9wYWwudHJhY2Vyc19mb3JfY2xhc3MgPSBbXTtcblxuICBmdW5jdGlvbiBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3Nfb3JfbW9kdWxlKSB7XG4gICAgdmFyIGksIGlpLCB0cmFjZXI7XG5cbiAgICBmb3IoaSA9IDAsIGlpID0gT3BhbC50cmFjZXJzX2Zvcl9jbGFzcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB0cmFjZXIgPSBPcGFsLnRyYWNlcnNfZm9yX2NsYXNzW2ldO1xuICAgICAgdHJhY2VyLnRyYWNlX29iamVjdCA9IGtsYXNzX29yX21vZHVsZTtcbiAgICAgIHRyYWNlci5ibG9jay4kY2FsbCh0cmFjZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZV9hdXRvbG9hZChjcmVmLCBuYW1lKSB7XG4gICAgaWYgKCFjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkKSB7XG4gICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIE9wYWwuS2VybmVsLiRyZXF1aXJlKGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5wYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY3JlZi4kJGF1dG9sb2FkW25hbWVdLmV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0ucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSkge1xuICAgICAgICBjcmVmLiQkYXV0b2xvYWRbbmFtZV0uc3VjY2VzcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjcmVmLiQkYXV0b2xvYWRbbmFtZV0ubG9hZGVkICYmICFjcmVmLiQkYXV0b2xvYWRbbmFtZV0ucmVxdWlyZWQpIHtcbiAgICAgIGlmIChjcmVmLiQkYXV0b2xvYWRbbmFtZV0uZXhjZXB0aW9uKSB7IHRocm93IGNyZWYuJCRhdXRvbG9hZFtuYW1lXS5leGNlcHRpb247IH1cbiAgICB9XG4gIH1cblxuICAvLyBDb25zdGFudHNcbiAgLy8gLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAvLyAtIFRoZSBSYWlscyBhdXRvbG9hZGluZyBndWlkZSAoaHR0cDovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvdjUuMC9hdXRvbG9hZGluZ19hbmRfcmVsb2FkaW5nX2NvbnN0YW50cy5odG1sKVxuICAvLyAtIEBDb25yYWRJcndpbidzIDIwMTIgcG9zdCBvbiDigJxFdmVyeXRoaW5nIHlvdSBldmVyIHdhbnRlZCB0byBrbm93IGFib3V0IGNvbnN0YW50IGxvb2t1cCBpbiBSdWJ54oCdIChodHRwOi8vY2lydy5pbi9ibG9nL2NvbnN0YW50LWxvb2t1cC5odG1sKVxuICAvL1xuICAvLyBMZWdlbmQgb2YgTVJJIGNvbmNlcHRzL25hbWVzOlxuICAvLyAtIGNvbnN0YW50IHJlZmVyZW5jZSAoY3JlZik6IHRoZSBtb2R1bGUvY2xhc3MgdGhhdCBhY3RzIGFzIGEgbmFtZXNwYWNlXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcbiAgLy8gICAgICAgICAgICBgbW9kdWxlIEE7IG1vZHVsZSBCOjpDOyBlbmQ7IGVuZGAgaXMgYFtCOjpDLCBBXWBcblxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXG4gIGZ1bmN0aW9uIGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZikge1xuICAgICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSkgeyByZXR1cm4gY3JlZi4kJGNvbnN0W25hbWVdOyB9XG4gICAgICBpZiAoY3JlZi4kJGF1dG9sb2FkICYmIGNyZWYuJCRhdXRvbG9hZFtuYW1lXSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlX2F1dG9sb2FkKGNyZWYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGNvbnN0YW50O1xuXG4gICAgaWYgKG5lc3RpbmcubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGUgbmVzdGluZyBpcyBub3QgZW1wdHkgdGhlIGNvbnN0YW50IGlzIGxvb2tlZCB1cCBpbiBpdHMgZWxlbWVudHNcbiAgICAvLyBhbmQgaW4gb3JkZXIuIFRoZSBhbmNlc3RvcnMgb2YgdGhvc2UgZWxlbWVudHMgYXJlIGlnbm9yZWQuXG4gICAgZm9yIChpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0YW50ID0gbmVzdGluZ1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgaWYgKGNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgICAgfSBlbHNlIGlmIChuZXN0aW5nW2ldLiQkYXV0b2xvYWQgJiYgbmVzdGluZ1tpXS4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVfYXV0b2xvYWQobmVzdGluZ1tpXSwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudFxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGFuY2VzdG9ycztcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKGNyZWYpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKGFuY2VzdG9yc1tpXS4kJGNvbnN0ICYmICRoYXNfb3duLmNhbGwoYW5jZXN0b3JzW2ldLiQkY29uc3QsIG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcnNbaV0uJCRjb25zdFtuYW1lXTtcbiAgICAgIH0gZWxzZSBpZiAoYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWQgJiYgYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZV9hdXRvbG9hZChhbmNlc3RvcnNbaV0sIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgT2JqZWN0J3MgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudCxcbiAgLy8gYnV0IG9ubHkgaWYgY3JlZiBpcyBtaXNzaW5nIG9yIGEgbW9kdWxlLlxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYuJCRpc19tb2R1bGUpIHtcbiAgICAgIHJldHVybiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKF9PYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgY29uc3RfbWlzc2luZyBpZiBub3RoaW5nIGVsc2Ugd29ya2VkXG4gIGZ1bmN0aW9uIGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgaWYgKCFza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiAoY3JlZiB8fCBfT2JqZWN0KS4kY29uc3RfbWlzc2luZyhuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxuICBPcGFsLmNvbnN0X2dldF9sb2NhbCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAoIWNyZWYuJCRpc19tb2R1bGUgJiYgIWNyZWYuJCRpc19jbGFzcykge1xuICAgICAgdGhyb3cgbmV3IE9wYWwuVHlwZUVycm9yKGNyZWYudG9TdHJpbmcoKSArIFwiIGlzIG5vdCBhIGNsYXNzL21vZHVsZVwiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKTsgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXN1bHQgPSBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZyk7IGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgcmVsYXRpdmUgdG8gYSBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGVcbiAgLy8gY29uc3RhbnQgaXMgcHJlZml4ZWQgYnkgYDo6YCkuXG4gIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQsIGNhY2hlLCBjYWNoZWQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgT3BhbC5UeXBlRXJyb3IoY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIGlmICgoY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKTtcbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIE9wYWwuY29uc3Rfc2V0ID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKHZhbHVlLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGlmICh2YWx1ZS4kJG5hbWUgPT0gbnVsbCB8fCB2YWx1ZS4kJG5hbWUgPT09IG5pbCkgdmFsdWUuJCRuYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkZGVmaW5lUHJvcGVydHkoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoT3BhbC5PYmplY3QpKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAvLyBEbyBub3Qgc2hvdyBPYmplY3RzIGNvbnN0YW50cyB1bmxlc3Mgd2UncmUgcXVlcnlpbmcgT2JqZWN0IGl0c2VsZlxuICAgICAgaWYgKGNyZWYgIT09IF9PYmplY3QgJiYgbW9kdWxlID09IF9PYmplY3QpIGJyZWFrO1xuXG4gICAgICBmb3IgKGNvbnN0YW50IGluIG1vZHVsZS4kJGNvbnN0KSB7XG4gICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vZHVsZS4kJGF1dG9sb2FkKSB7XG4gICAgICAgIGZvciAoY29uc3RhbnQgaW4gbW9kdWxlLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgICBjb25zdGFudHNbY29uc3RhbnRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBhIGNvbnN0YW50IGZyb20gYSBjcmVmLlxuICBPcGFsLmNvbnN0X3JlbW92ZSA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUpIHtcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgdmFyIG9sZCA9IGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICByZXR1cm4gb2xkO1xuICAgIH1cblxuICAgIGlmIChjcmVmLiQkYXV0b2xvYWQgJiYgY3JlZi4kJGF1dG9sb2FkW25hbWVdKSB7XG4gICAgICBkZWxldGUgY3JlZi4kJGF1dG9sb2FkW25hbWVdO1xuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG5cbiAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwiY29uc3RhbnQgXCIrY3JlZitcIjo6XCIrY3JlZi4kbmFtZSgpK1wiIG5vdCBkZWZpbmVkXCIpO1xuICB9O1xuXG4gIC8vIFNldHVwIHNvbWUgc2hvcnRjdXRzIHRvIHJlZHVjZSBjb21waWxlZCBzaXplXG4gIE9wYWwuJCQgPSBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZTtcbiAgT3BhbC4kJCQgPSBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQ7XG5cblxuICAvLyBNb2R1bGVzICYgQ2xhc3Nlc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgYGNsYXNzIEZvbzsgZW5kYCBleHByZXNzaW9uIGluIHJ1YnkgaXMgY29tcGlsZWQgdG8gY2FsbCB0aGlzIHJ1bnRpbWVcbiAgLy8gbWV0aG9kIHdoaWNoIGVpdGhlciByZXR1cm5zIGFuIGV4aXN0aW5nIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lLCBvciBjcmVhdGVzXG4gIC8vIGEgbmV3IGNsYXNzIGluIHRoZSBnaXZlbiBgYmFzZWAgc2NvcGUuXG4gIC8vXG4gIC8vIElmIGEgY29uc3RhbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMsIHRoZW4gd2UgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXRcbiAgLy8gaXQgaXMgYSBjbGFzcyBhbmQgYWxzbyB0aGF0IHRoZSBzdXBlcmNsYXNzZXMgbWF0Y2guIElmIGVpdGhlciBvZiB0aGVzZVxuICAvLyBmYWlsLCB0aGVuIHdlIHJhaXNlIGEgYFR5cGVFcnJvcmAuIE5vdGUsIGBzdXBlcmNsYXNzYCBtYXkgYmUgbnVsbCBpZiBvbmVcbiAgLy8gd2FzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHJ1YnkgY29kZS5cbiAgLy9cbiAgLy8gV2UgcGFzcyBhIGNvbnN0cnVjdG9yIHRvIHRoaXMgbWV0aG9kIG9mIHRoZSBmb3JtIGBmdW5jdGlvbiBDbGFzc05hbWUoKSB7fWBcbiAgLy8gc2ltcGx5IHNvIHRoYXQgY2xhc3NlcyBzaG93IHVwIHdpdGggbmljZWx5IGZvcm1hdHRlZCBuYW1lcyBpbnNpZGUgZGVidWdnZXJzXG4gIC8vIGluIHRoZSB3ZWIgYnJvd3NlciAob3Igbm9kZS9zcHJvY2tldHMpLlxuICAvL1xuICAvLyBUaGUgYHNjb3BlYCBpcyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgd2hlcmUgdGhlIGNsYXNzIGlzIGJlaW5nIGNyZWF0ZWRcbiAgLy8gZnJvbS4gV2UgdXNlIHRoaXMgdG8gZ2V0IHRoZSBzY29wZSBmb3Igd2hlcmUgdGhlIGNsYXNzIHNob3VsZCBiZSBjcmVhdGVkLlxuICAvLyBJZiBgc2NvcGVgIGlzIGFuIG9iamVjdCAobm90IGEgY2xhc3MvbW9kdWxlKSwgd2Ugc2ltcGxlIGdldCBpdHMgY2xhc3MgYW5kXG4gIC8vIHVzZSB0aGF0IGFzIHRoZSBzY29wZSBpbnN0ZWFkLlxuICAvL1xuICAvLyBAcGFyYW0gc2NvcGUgICAgICAgIFtPYmplY3RdIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIEBwYXJhbSBzdXBlcmNsYXNzICBbQ2xhc3MsbnVsbF0gc3VwZXJjbGFzcyBvZiB0aGUgbmV3IGNsYXNzIChtYXkgYmUgbnVsbClcbiAgLy8gQHBhcmFtIGlkICAgICAgICAgIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBiZSBjcmVhdGVkXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIGZ1bmN0aW9uIHRvIHVzZSBhcyBjb25zdHJ1Y3RvclxuICAvL1xuICAvLyBAcmV0dXJuIG5ldyBbQ2xhc3NdICBvciBleGlzdGluZyBydWJ5IGNsYXNzXG4gIC8vXG4gIE9wYWwuYWxsb2NhdGVfY2xhc3MgPSBmdW5jdGlvbihuYW1lLCBzdXBlcmNsYXNzKSB7XG4gICAgdmFyIGtsYXNzLCBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwgJiYgc3VwZXJjbGFzcy4kJGJyaWRnZSkge1xuICAgICAgLy8gSW5oZXJpdGFuY2UgZnJvbSBicmlkZ2VkIGNsYXNzZXMgcmVxdWlyZXNcbiAgICAgIC8vIGNhbGxpbmcgb3JpZ2luYWwgSlMgY29uc3RydWN0b3JzXG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBzZWxmID0gbmV3ICgkYmluZC5hcHBseShzdXBlcmNsYXNzLiQkY29uc3RydWN0b3IsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuXG4gICAgICAgIC8vIGFuZCByZXBsYWNpbmcgYSBfX3Byb3RvX18gbWFudWFsbHlcbiAgICAgICAgJHNldF9wcm90byhzZWxmLCBrbGFzcy4kJHByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCAnOjonK25hbWUpO1xuICAgIH1cblxuICAgIGtsYXNzID0gY29uc3RydWN0b3I7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0cnVjdG9yJywgY29uc3RydWN0b3IpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkaXNfY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRzdXBlcicsIHN1cGVyY2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9ycycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuXG4gICAgLy8gQnkgZGVmYXVsdCBpZiB0aGVyZSBhcmUgbm8gc2luZ2xldG9uIGNsYXNzIG1ldGhvZHNcbiAgICAvLyBfX3Byb3RvX18gaXMgQ2xhc3MucHJvdG90eXBlXG4gICAgLy8gTGF0ZXIgc2luZ2xldG9uIG1ldGhvZHMgZ2VuZXJhdGUgYSBzaW5nbGV0b25fY2xhc3NcbiAgICAvLyBhbmQgaW5qZWN0IGl0IGludG8gYW5jZXN0b3JzIGNoYWluXG4gICAgaWYgKE9wYWwuQ2xhc3MpIHtcbiAgICAgICRzZXRfcHJvdG8oa2xhc3MsIE9wYWwuQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsKSB7XG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLiQkcHJvdG90eXBlLCBzdXBlcmNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgaWYgKHN1cGVyY2xhc3MuJCRtZXRhKSB7XG4gICAgICAgIC8vIElmIHN1cGVyY2xhc3MgaGFzIG1ldGFjbGFzcyB0aGVuIHdlIGhhdmUgZXhwbGljaXRlbHkgaW5oZXJpdCBpdC5cbiAgICAgICAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3Moa2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpIHtcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgY2xhc3MgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICB2YXIga2xhc3MgPSBjb25zdF9nZXRfbmFtZShzY29wZSwgbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgY2xhc3MgZXhpc3RzIGluIHRoZSBzY29wZSwgdGhlbiB3ZSBtdXN0IHVzZSB0aGF0XG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGV4aXN0aW5nIGNvbnN0YW50IGlzIGEgY2xhc3MsIG9yIHJhaXNlIGVycm9yXG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgY2xhc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBpZiAoa2xhc3MuJCRzdXBlciAhPT0gc3VwZXJjbGFzcykge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbWlzbWF0Y2ggZm9yIGNsYXNzIFwiICsga2xhc3MuJCRuYW1lKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmtsYXNzID0gZnVuY3Rpb24oc2NvcGUsIHN1cGVyY2xhc3MsIG5hbWUpIHtcbiAgICB2YXIgYnJpZGdlZDtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc3VwZXJjbGFzcyBpcyBub3QgYW4gT3BhbC1nZW5lcmF0ZWQgY2xhc3MgdGhlbiB3ZSdyZSBicmlkZ2luZyBhIG5hdGl2ZSBKUyBjbGFzc1xuICAgIGlmIChcbiAgICAgIHN1cGVyY2xhc3MgIT0gbnVsbCAmJiAoIXN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkgfHwgKFxuICAgICAgICBzdXBlcmNsYXNzLmhhc093blByb3BlcnR5ICYmICFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJylcbiAgICAgICkpXG4gICAgKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcy5jb25zdHJ1Y3RvciAmJiBzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgPT0gXCJGdW5jdGlvblwiKSB7XG4gICAgICAgIGJyaWRnZWQgPSBzdXBlcmNsYXNzO1xuICAgICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzcyAoXCIgKyAoXG4gICAgICAgICAgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IubmFtZSB8fCBzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLiQkbmFtZSkpIHx8XG4gICAgICAgICAgdHlwZW9mKHN1cGVyY2xhc3MpXG4gICAgICAgICkgKyBcIiBnaXZlbilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtsYXNzID0gZmluZF9leGlzdGluZ19jbGFzcyhzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAoa2xhc3MpIHtcbiAgICAgIGlmIChzdXBlcmNsYXNzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBleGlzdGluZyBjbGFzcyBoYXMgc2FtZSBzdXBlcmNsYXNzXG4gICAgICAgIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzcyk7IH1cblxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8vIENsYXNzIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCBnaXZlbiBzdXBlcmNsYXNzLi4uXG5cbiAgICAvLyBOb3Qgc3BlY2lmeWluZyBhIHN1cGVyY2xhc3MgbWVhbnMgd2UgY2FuIGFzc3VtZSBpdCB0byBiZSBPYmplY3RcbiAgICBpZiAoc3VwZXJjbGFzcyA9PSBudWxsKSB7XG4gICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIGNsYXNzIG9iamVjdCAoaW5zdGFuY2Ugb2YgQ2xhc3MpXG4gICAga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5hbWUsIHN1cGVyY2xhc3MpO1xuICAgIE9wYWwuY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBrbGFzcyk7XG5cbiAgICAvLyBDYWxsIC5pbmhlcml0ZWQoKSBob29rIHdpdGggbmV3IGNsYXNzIG9uIHRoZSBzdXBlcmNsYXNzXG4gICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgT3BhbC5icmlkZ2UoYnJpZGdlZCwga2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzcyk7IH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICAvLyBEZWZpbmUgbmV3IG1vZHVsZSAob3IgcmV0dXJuIGV4aXN0aW5nIG1vZHVsZSkuIFRoZSBnaXZlbiBgc2NvcGVgIGlzIGJhc2ljYWxseVxuICAvLyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgdGhlIGBtb2R1bGVgIHN0YXRlbWVudCB3YXMgZGVmaW5lZCBpbi4gSWYgdGhpcyBpc1xuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XG4gIC8vIG9iamVjdCB0aGVuIHRoYXQgb2JqZWN0cyByZWFsIHJ1YnkgY2xhc3MgaXMgdXNlZCAoZS5nLiBpZiB0aGUgc2NvcGUgaXMgdGhlXG4gIC8vIG1haW4gb2JqZWN0LCB0aGVuIHRoZSB0b3AgbGV2ZWwgYE9iamVjdGAgY2xhc3MgaXMgdXNlZCBhcyB0aGUgc2NvcGUpLlxuICAvL1xuICAvLyBJZiBhIG1vZHVsZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjb3BlLCB0aGVuIHRoYXRcbiAgLy8gaW5zdGFuY2UgaXMganVzdCByZXR1cm5lZC5cbiAgLy9cbiAgLy8gSWYgdGhlcmUgaXMgYSBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgc2NvcGUsIHRoZW4gYW4gZXJyb3IgaXNcbiAgLy8gZ2VuZXJhdGVkIGluc3RlYWQgKGNhbm5vdCBoYXZlIGEgY2xhc3MgYW5kIG1vZHVsZSBvZiBzYW1lIG5hbWUgaW4gc2FtZSBzY29wZSkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSwgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQgaW4gdGhlIHNjb3BlIHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGF0XG4gIC8vIG5ldyBpbnN0YW5jZSBpcyByZXR1cm5lZCBiYWNrICh0byBiZSByZWZlcmVuY2VkIGF0IHJ1bnRpbWUpLlxuICAvL1xuICAvLyBAcGFyYW0gIHNjb3BlIFtNb2R1bGUsIENsYXNzXSBjbGFzcyBvciBtb2R1bGUgdGhpcyBkZWZpbml0aW9uIGlzIGluc2lkZVxuICAvLyBAcGFyYW0gIGlkICAgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyAob3IgZXhpc3RpbmcpIG1vZHVsZVxuICAvL1xuICAvLyBAcmV0dXJuIFtNb2R1bGVdXG4gIE9wYWwuYWxsb2NhdGVfbW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuJCRjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChuYW1lKVxuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuY29uc3RydWN0b3InKTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaWNsYXNzZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGFuY2VzdG9ycycsIFttb2R1bGVdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJHNldF9wcm90byhtb2R1bGUsIE9wYWwuTW9kdWxlLnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcbiAgICBpZiAobW9kdWxlID09IG51bGwgJiYgc2NvcGUgPT09IF9PYmplY3QpIG1vZHVsZSA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBpZiAoIW1vZHVsZS4kJGlzX21vZHVsZSAmJiBtb2R1bGUgIT09IF9PYmplY3QpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgbW9kdWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZTtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG5cbiAgICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhtb2R1bGUpOyB9XG5cbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuXG4gICAgLy8gTW9kdWxlIGRvZXNudCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZS4uLlxuICAgIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5hbWUpO1xuICAgIE9wYWwuY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBtb2R1bGUpO1xuXG4gICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKG1vZHVsZSk7IH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBzdXBlcmNsYXNzLCBtZXRhO1xuXG4gICAgaWYgKGtsYXNzLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIGtsYXNzLiQkbWV0YTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2luZ2xldG9uX2NsYXNzIHN1cGVyY2xhc3MgaXMgdGhlIHNpbmdsZXRvbl9jbGFzcyBvZiBpdHMgc3VwZXJjbGFzcztcbiAgICAvLyBidXQgQmFzaWNPYmplY3QgaGFzIG5vIHN1cGVyY2xhc3MgKGl0cyBgJCRzdXBlcmAgaXMgbnVsbCksIHRodXMgd2VcbiAgICAvLyBmYWxsYmFjayBvbiBgQ2xhc3NgLlxuICAgIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIG1ldGEgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIGZ1bmN0aW9uKCl7fSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG1ldGEnLCBtZXRhKTtcbiAgICAkc2V0X3Byb3RvKGtsYXNzLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjbGFzcycsIE9wYWwuQ2xhc3MpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgaWYgKG1vZC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBtb2QuJCRtZXRhO1xuICAgIH1cblxuICAgIHZhciBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgZnVuY3Rpb24oKXt9KTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgJHNldF9wcm90byhtb2QsIG1ldGEuJCRwcm90b3R5cGUpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZCwgJyQkY2xhc3MnLCBPcGFsLk1vZHVsZSk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICAvLyBCdWlsZCB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciBhIFJ1YnkgKG5vbiBjbGFzcykgT2JqZWN0LlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdXG4gIC8vIEByZXR1cm4gW0NsYXNzXVxuICBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgc3VwZXJjbGFzcyA9IG9iamVjdC4kJGNsYXNzLFxuICAgICAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCBmdW5jdGlvbigpe30pO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICckJG1ldGEnLCBrbGFzcyk7XG5cbiAgICAkc2V0X3Byb3RvKG9iamVjdCwgb2JqZWN0LiQkbWV0YS4kJHByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgZXhjbHVkZSA9IFtdLCByZXN1bHRzID0gW10sIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaikpO1xuICB9O1xuXG4gIE9wYWwub3duX21ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSk7XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGFuY2VzdG9yLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS4kJGN2YXJzW25hbWVdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gR2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgZnJvbSBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0ID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lLCB0b2xlcmFudCkge1xuICAgIGlmICgkaGFzX293bi5jYWxsKG1vZHVsZS4kJGN2YXJzLCBuYW1lKSlcbiAgICAgIHJldHVybiBtb2R1bGUuJCRjdmFyc1tuYW1lXTtcblxuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24uY2FsbChhbmNlc3Rvci4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRvbGVyYW50KVxuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldygndW5pbml0aWFsaXplZCBjbGFzcyB2YXJpYWJsZSAnK25hbWUrJyBpbiAnK21vZHVsZS4kbmFtZSgpKTtcblxuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsICckJGluY2x1ZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuICAgIHZhciBpbmNsdWRlcl9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhpbmNsdWRlciksXG4gICAgICAgIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGluY2x1ZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcblxuICAgICAgLy8gaW5jbHVkZXIgLT4gY2hhaW4uZmlyc3QgLT4gLi4uY2hhaW4uLi4gLT4gY2hhaW4ubGFzdCAtPiBpbmNsdWRlci5wYXJlbnRcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHB1dCBpdCBpbnRvIHRoZSBhbmNlc3RvcnMgY2hhaW4gYWdhaW4sXG4gICAgICAvLyBidXQgdGhpcyBtb2R1bGUgbWF5IGhhdmUgbmV3IGluY2x1ZGVkIG1vZHVsZXMuXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHNpbXBsZXN0IHdheSBpcyB0byByZXBsYWNlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnByZXZpb3MgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXMgLi4uXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIHRvXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5yZWdlbmVyYXRlZCBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlc1xuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbm8gaW50ZXJtZWRpYXRlIGNsYXNzZXMgYmV0d2VlbiBgcGFyZW50YCBhbmQgYG5leHQgYW5jZXN0b3JgLlxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxuXG4gICAgICB2YXIgcGFyZW50ID0gaW5jbHVkZXIuJCRwcm90b3R5cGUsIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcblxuICAgICAgd2hpbGUgKG1vZHVsZV9pY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAobW9kdWxlX2ljbGFzcy4kJG1vZHVsZSA9PT0gbW9kdWxlICYmIGlzUm9vdChtb2R1bGVfaWNsYXNzKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcbiAgICAgICAgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZHVsZV9pY2xhc3MpIHtcbiAgICAgICAgLy8gbW9kdWxlIGhhcyBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkXG4gICAgICAgIHZhciBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xuXG4gICAgICAgIC8vIHNraXAgbm9uLXJvb3QgaWNsYXNzZXMgKHRoYXQgd2VyZSByZWN1cnNpdmVseSBpbmNsdWRlZClcbiAgICAgICAgd2hpbGUgKG5leHRfYW5jZXN0b3IuaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgIWlzUm9vdChuZXh0X2FuY2VzdG9yKSkge1xuICAgICAgICAgIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV4dF9hbmNlc3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IHBhcmVudDtcbiAgICAgICAgZW5kX2NoYWluX29uID0gbmV4dF9hbmNlc3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgbm90IGJlZW4gZGlyZWN0bHkgaW5jbHVkZWQgYnV0IHdhcyBpbiBhbmNlc3RvciBjaGFpbiBiZWNhdXNlIGl0IHdhcyBpbmNsdWRlZCBieSBhbm90aGVyIG1vZHVsZVxuICAgICAgICAvLyBpbmNsdWRlIGl0IGRpcmVjdGx5XG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9pbmNsdWRlZF9tb2R1bGVzIGNhY2hlXG4gICAgaW5jbHVkZXIuJCRvd25faW5jbHVkZWRfbW9kdWxlcyA9IG93bl9pbmNsdWRlZF9tb2R1bGVzKGluY2x1ZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIE9wYWwucHJlcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgcHJlcGVuZGVyKSB7XG4gICAgLy8gSGVyZSB3ZSBjaGFuZ2UgdGhlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgLy9cbiAgICAvLyAgIHByZXBlbmRlclxuICAgIC8vICAgICAgfFxuICAgIC8vICAgIHBhcmVudFxuICAgIC8vXG4gICAgLy8gdG86XG4gICAgLy9cbiAgICAvLyBkdW1teShwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gIGljbGFzcyhtb2R1bGUpXG4gICAgLy8gICAgICB8XG4gICAgLy8gaWNsYXNzKHByZXBlbmRlcilcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRwcmVwZW5kZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXG4gICAgICAgIGR1bW15X3ByZXBlbmRlciA9IHByZXBlbmRlci4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJldmlvdXNfcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlciksXG4gICAgICAgIHByZXBlbmRlcl9pY2xhc3MsXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyLFxuICAgICAgICBlbmRfY2hhaW5fb247XG5cbiAgICBpZiAoZHVtbXlfcHJlcGVuZGVyLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIC8vIFRoZSBtb2R1bGUgYWxyZWFkeSBoYXMgc29tZSBwcmVwZW5kZWQgbW9kdWxlc1xuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIG1ha2UgaXQgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gZHVtbXlfcHJlcGVuZGVyLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2luZyB0aGUgbW9kdWxlIFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MocHJlcGVuZGVyKTtcbiAgICAgIGZsdXNoX21ldGhvZHNfaW4ocHJlcGVuZGVyKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShkdW1teV9wcmVwZW5kZXIsICckJGR1bW15JywgdHJ1ZSk7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMocHJlcGVuZGVyKTtcblxuICAgIGlmIChwcmVwZW5kZXJfYW5jZXN0b3JzLmluZGV4T2YobW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgcHJlcGVuZFxuXG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGR1bW15X3ByZXBlbmRlcjtcblxuICAgICAgLy8gbmV4dCAkJHJvb3Qgb3IgcHJlcGVuZGVyX2ljbGFzcyBvciBub24tJCRpY2xhc3NcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpO1xuICAgICAgd2hpbGUgKGVuZF9jaGFpbl9vbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpIHx8XG4gICAgICAgICAgZW5kX2NoYWluX29uID09PSBwcmVwZW5kZXJfaWNsYXNzIHx8XG4gICAgICAgICAgIWVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKVxuICAgICAgICApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlbmRfY2hhaW5fb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiUHJlcGVuZGluZyBhIG1vZHVsZSBtdWx0aXBsZSB0aW1lcyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25fcHJlcGVuZGVkX21vZHVsZXMgY2FjaGVcbiAgICBwcmVwZW5kZXIuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMgPSBvd25fcHJlcGVuZGVkX21vZHVsZXMocHJlcGVuZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZsdXNoX21ldGhvZHNfaW4obW9kdWxlKSB7XG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlLFxuICAgICAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgZGVsZXRlIHByb3RvW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKTtcblxuICAgIGlmIChtb2R1bGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIG1vZHVsZS4kJGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgLy8gRHVtbXkgaWNsYXNzIGRvZXNuJ3QgcmVjZWl2ZSB1cGRhdGVzIHdoZW4gdGhlIG1vZHVsZSBnZXRzIGEgbmV3IG1ldGhvZC5cbiAgZnVuY3Rpb24gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0ge30sXG4gICAgICAgIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIHByb3AsIHByb3RvW3Byb3BdKTtcbiAgICB9XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRtb2R1bGUnLCBtb2R1bGUpO1xuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aCwgZmlyc3QgPSBpY2xhc3Nlc1swXTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShmaXJzdCwgJyQkcm9vdCcsIHRydWUpO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBmaXJzdCB9O1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IGZpcnN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpY2xhc3Nlc1tpXTtcbiAgICAgICRzZXRfcHJvdG8ocHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHsgZmlyc3Q6IGljbGFzc2VzWzBdLCBsYXN0OiBpY2xhc3Nlc1tsZW5ndGggLSAxXSB9O1xuICB9XG5cbiAgLy8gRm9yIHBlcmZvcm1hbmNlLCBzb21lIGNvcmUgUnVieSBjbGFzc2VzIGFyZSB0b2xsLWZyZWUgYnJpZGdlZCB0byB0aGVpclxuICAvLyBuYXRpdmUgSmF2YVNjcmlwdCBjb3VudGVycGFydHMgKGUuZy4gYSBSdWJ5IEFycmF5IGlzIGEgSmF2YVNjcmlwdCBBcnJheSkuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0dXAgYSBuYXRpdmUgY29uc3RydWN0b3IgKGUuZy4gQXJyYXkpLCB0byBoYXZlXG4gIC8vIGl0cyBwcm90b3R5cGUgYWN0IGxpa2UgYSBub3JtYWwgUnVieSBjbGFzcy4gRmlyc3RseSwgYSBuZXcgUnVieSBjbGFzcyBpc1xuICAvLyBjcmVhdGVkIHVzaW5nIHRoZSBuYXRpdmUgY29uc3RydWN0b3Igc28gdGhhdCBpdHMgcHJvdG90eXBlIGlzIHNldCBhcyB0aGVcbiAgLy8gdGFyZ2V0IGZvciB0aGUgbmV3IGNsYXNzLiBOb3RlOiBhbGwgYnJpZGdlZCBjbGFzc2VzIGFyZSBzZXQgdG8gaW5oZXJpdFxuICAvLyBmcm9tIE9iamVjdC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgT3BhbC5icmlkZ2Uoc2VsZiwgRnVuY3Rpb24pO1xuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgICAgICAgW0NsYXNzXSB0aGUgUnVieSBjbGFzcyB0byBicmlkZ2VcbiAgLy8gQHBhcmFtIGNvbnN0cnVjdG9yIFtKUy5GdW5jdGlvbl0gbmF0aXZlIEphdmFTY3JpcHQgY29uc3RydWN0b3IgdG8gdXNlXG4gIC8vIEByZXR1cm4gW0NsYXNzXSByZXR1cm5zIHRoZSBwYXNzZWQgUnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmJyaWRnZSA9IGZ1bmN0aW9uKG5hdGl2ZV9rbGFzcywga2xhc3MpIHtcbiAgICBpZiAobmF0aXZlX2tsYXNzLmhhc093blByb3BlcnR5KCckJGJyaWRnZScpKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcImFscmVhZHkgYnJpZGdlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkZGVmaW5lUHJvcGVydHkobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgbmF0aXZlX2tsYXNzLnByb3RvdHlwZSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkbW9kdWxlO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3duX2FuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzLmNvbmNhdChbbW9kdWxlXSkuY29uY2F0KG1vZHVsZS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzKTtcbiAgfVxuXG4gIC8vIFRoZSBBcnJheSBvZiBhbmNlc3RvcnMgZm9yIGEgZ2l2ZW4gbW9kdWxlL2NsYXNzXG4gIE9wYWwuYW5jZXN0b3JzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHsgcmV0dXJuIFtdOyB9XG5cbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xuICAgICAgcmV0dXJuIG1vZHVsZS4kJGFuY2VzdG9ycztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sIGksIG1vZHMsIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUuJCRzdXBlcikge1xuICAgICAgZm9yIChpID0gMCwgbW9kcyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhbXCIkZm9vXCIsIFwiJGJhclwiLCBcIiRiYXo9XCJdKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuICAgIHZhciBzdHViLCBleGlzdGluZ19tZXRob2Q7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3R1YnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0dWIgPSBzdHVic1tpXSwgZXhpc3RpbmdfbWV0aG9kID0gcHJvdG9bc3R1Yl07XG5cbiAgICAgIGlmIChleGlzdGluZ19tZXRob2QgPT0gbnVsbCB8fCBleGlzdGluZ19tZXRob2QuJCRzdHViKSB7XG4gICAgICAgIE9wYWwuYWRkX3N0dWJfZm9yKHByb3RvLCBzdHViKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIGEgbWV0aG9kX21pc3Npbmcgc3R1YiBmdW5jdGlvbiB0byB0aGUgZ2l2ZW4gcHJvdG90eXBlIGZvciB0aGVcbiAgLy8gZ2l2ZW4gbmFtZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHByb3RvdHlwZSBbUHJvdG90eXBlXSB0aGUgdGFyZ2V0IHByb3RvdHlwZVxuICAvLyBAcGFyYW0gc3R1YiBbU3RyaW5nXSBzdHViIG5hbWUgdG8gYWRkIChlLmcuIFwiJGZvb1wiKVxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJfZm9yID0gZnVuY3Rpb24ocHJvdG90eXBlLCBzdHViKSB7XG4gICAgLy8gT3BhbC5zdHViX2ZvcihzdHViKSBpcyB0aGUgbWV0aG9kX21pc3Npbmdfc3R1YlxuICAgICRkZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHN0dWIsIE9wYWwuc3R1Yl9mb3Ioc3R1YikpO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIHRoZSBtZXRob2RfbWlzc2luZyBzdHViIGZvciBhIGdpdmVuIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gbWV0aG9kX25hbWUgW1N0cmluZ10gVGhlIGpzLW5hbWUgb2YgdGhlIG1ldGhvZCB0byBzdHViIChlLmcuIFwiJGZvb1wiKVxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuc3R1Yl9mb3IgPSBmdW5jdGlvbihtZXRob2RfbmFtZSkge1xuXG4gICAgZnVuY3Rpb24gbWV0aG9kX21pc3Npbmdfc3R1YigpIHtcbiAgICAgIC8vIENvcHkgYW55IGdpdmVuIGJsb2NrIG9udG8gdGhlIG1ldGhvZF9taXNzaW5nIGRpc3BhdGNoZXJcbiAgICAgIHRoaXMuJG1ldGhvZF9taXNzaW5nLiQkcCA9IG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwO1xuXG4gICAgICAvLyBTZXQgYmxvY2sgcHJvcGVydHkgdG8gbnVsbCByZWFkeSBmb3IgdGhlIG5leHQgY2FsbCAoc3RvcCBmYWxzZS1wb3NpdGl2ZXMpXG4gICAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkcCA9IG51bGw7XG5cbiAgICAgIC8vIGNhbGwgbWV0aG9kIG1pc3Npbmcgd2l0aCBjb3JyZWN0IGFyZ3MgKHJlbW92ZSAnJCcgcHJlZml4IG9uIG1ldGhvZCBuYW1lKVxuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3VtZW50c1tpXTsgfVxuXG4gICAgICByZXR1cm4gdGhpcy4kbWV0aG9kX21pc3NpbmcuYXBwbHkodGhpcywgW21ldGhvZF9uYW1lLnNsaWNlKDEpXS5jb25jYXQoYXJnc19hcnkpKTtcbiAgICB9XG5cbiAgICBtZXRob2RfbWlzc2luZ19zdHViLiQkc3R1YiA9IHRydWU7XG5cbiAgICByZXR1cm4gbWV0aG9kX21pc3Npbmdfc3R1YjtcbiAgfTtcblxuXG4gIC8vIE1ldGhvZHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIG1ldGhvZHNcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIG1ldGhvZFxuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIG93bmVyIG9mIHRoZSBtZXRob2QgK21ldGgrXG4gIC8vIEBwYXJhbSBtZXRoIFtTdHJpbmddIG1ldGhvZCBuYW1lIHRoYXQgZ290IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmFjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgb2JqZWN0LCBtZXRoKSB7XG4gICAgdmFyIGluc3BlY3QgPSAnJztcbiAgICBpZiAob2JqZWN0LiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkbmFtZSArICcuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJGNsYXNzLiQkbmFtZSArICcjJztcbiAgICB9XG4gICAgaW5zcGVjdCArPSBtZXRoO1xuXG4gICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoJ1snICsgaW5zcGVjdCArICddIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMoJyArIGFjdHVhbCArICcgZm9yICcgKyBleHBlY3RlZCArICcpJyk7XG4gIH07XG5cbiAgLy8gQXJpdHkgY291bnQgZXJyb3IgZGlzcGF0Y2hlciBmb3IgYmxvY2tzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBibG9ja1xuICAvLyBAcGFyYW0gZXhwZWN0ZWQgW0ZpeG51bV0gZXhwZWN0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcGFyYW0gY29udGV4dCBbT2JqZWN0XSBjb250ZXh0IG9mIHRoZSBibG9jayBkZWZpbml0aW9uXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5ibG9ja19hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zcGVjdCA9IFwiYGJsb2NrIGluIFwiICsgY29udGV4dCArIFwiJ1wiO1xuXG4gICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoaW5zcGVjdCArICc6IHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCcgKyBhY3R1YWwgKyAnIGZvciAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIFN1cGVyIGRpc3BhdGNoZXJcbiAgT3BhbC5maW5kX3N1cGVyID0gZnVuY3Rpb24ob2JqLCBtaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGFsbG93X3N0dWJzKSB7XG4gICAgdmFyIGpzaWQgPSAnJCcgKyBtaWQsIGFuY2VzdG9ycywgc3VwZXJfbWV0aG9kO1xuXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykpIHtcbiAgICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iai4kJG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRjbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRfaW5kZXggPSBhbmNlc3RvcnMuaW5kZXhPZihjdXJyZW50X2Z1bmMuJCRvd25lcik7XG5cbiAgICBmb3IgKHZhciBpID0gY3VycmVudF9pbmRleCArIDE7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShqc2lkKSkge1xuICAgICAgICBzdXBlcl9tZXRob2QgPSBwcm90b1tqc2lkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkZWZjaGVjayAmJiBzdXBlcl9tZXRob2QgJiYgc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiBvYmouJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIC8vIG1ldGhvZF9taXNzaW5nIGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgdGhyb3cgT3BhbC5Ob01ldGhvZEVycm9yLiRuZXcoJ3N1cGVyOiBubyBzdXBlcmNsYXNzIG1ldGhvZCBgJyttaWQrXCInIGZvciBcIitvYmosIG1pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChzdXBlcl9tZXRob2QuJCRzdHViICYmICFhbGxvd19zdHVicykgPyBudWxsIDogc3VwZXJfbWV0aG9kO1xuICB9O1xuXG4gIC8vIEl0ZXIgZGlzcGF0Y2hlciBmb3Igc3VwZXIgaW4gYSBibG9ja1xuICBPcGFsLmZpbmRfYmxvY2tfc3VwZXIgPSBmdW5jdGlvbihvYmosIGpzaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGltcGxpY2l0KSB7XG4gICAgdmFyIGNhbGxfanNpZCA9IGpzaWQ7XG5cbiAgICBpZiAoIWN1cnJlbnRfZnVuYykge1xuICAgICAgdGhyb3cgT3BhbC5SdW50aW1lRXJyb3IuJG5ldyhcInN1cGVyIGNhbGxlZCBvdXRzaWRlIG9mIG1ldGhvZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoaW1wbGljaXQgJiYgY3VycmVudF9mdW5jLiQkZGVmaW5lX21ldGgpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJpbXBsaWNpdCBhcmd1bWVudCBwYXNzaW5nIG9mIHN1cGVyIGZyb20gbWV0aG9kIGRlZmluZWQgYnkgZGVmaW5lX21ldGhvZCgpIGlzIG5vdCBzdXBwb3J0ZWQuIFNwZWNpZnkgYWxsIGFyZ3VtZW50cyBleHBsaWNpdGx5XCIpO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50X2Z1bmMuJCRkZWYpIHtcbiAgICAgIGNhbGxfanNpZCA9IGN1cnJlbnRfZnVuYy4kJGpzaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuZmluZF9zdXBlcl9kaXNwYXRjaGVyKG9iaiwgY2FsbF9qc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrKTtcbiAgfTtcblxuICAvLyBAZGVwcmVjYXRlZFxuICBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlciA9IE9wYWwuZmluZF9zdXBlcjtcblxuICAvLyBAZGVwcmVjYXRlZFxuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gT3BhbC5maW5kX2Jsb2NrX3N1cGVyO1xuXG4gIC8vIFVzZWQgdG8gcmV0dXJuIGFzIGFuIGV4cHJlc3Npb24uIFNvbWV0aW1lcywgd2UgY2FuJ3Qgc2ltcGx5IHJldHVybiBmcm9tXG4gIC8vIGEgamF2YXNjcmlwdCBmdW5jdGlvbiBhcyBpZiB3ZSB3ZXJlIGEgbWV0aG9kLCBhcyB0aGUgcmV0dXJuIGlzIHVzZWQgYXNcbiAgLy8gYW4gZXhwcmVzc2lvbiwgb3IgZXZlbiBpbnNpZGUgYSBibG9jayB3aGljaCBtdXN0IFwicmV0dXJuXCIgdG8gdGhlIG91dGVyXG4gIC8vIG1ldGhvZC4gVGhpcyBoZWxwZXIgc2ltcGx5IHRocm93cyBhbiBlcnJvciB3aGljaCBpcyB0aGVuIGNhdWdodCBieSB0aGVcbiAgLy8gbWV0aG9kLiBUaGlzIGFwcHJvYWNoIGlzIGV4cGVuc2l2ZSwgc28gaXQgaXMgb25seSB1c2VkIHdoZW4gYWJzb2x1dGVseVxuICAvLyBuZWVkZWQuXG4gIC8vXG4gIE9wYWwucmV0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgT3BhbC5yZXR1cm5lci4kdiA9IHZhbDtcbiAgICB0aHJvdyBPcGFsLnJldHVybmVyO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gYnJlYWsgb3V0IG9mIGEgYmxvY2suXG4gIE9wYWwuYnJrID0gZnVuY3Rpb24odmFsLCBicmVha2VyKSB7XG4gICAgYnJlYWtlci4kdiA9IHZhbDtcbiAgICB0aHJvdyBicmVha2VyO1xuICB9O1xuXG4gIC8vIEJ1aWxkcyBhIG5ldyB1bmlxdWUgYnJlYWtlciwgdGhpcyBpcyB0byBhdm9pZCBtdWx0aXBsZSBuZXN0ZWQgYnJlYWtzIHRvIGdldFxuICAvLyBpbiB0aGUgd2F5IG9mIGVhY2ggb3RoZXIuXG4gIE9wYWwubmV3X2JyayA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJlYWsnKTtcbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGNhbGxzIGZvciAxIHlpZWxkZWQgYXJnXG4gIE9wYWwueWllbGQxID0gZnVuY3Rpb24oYmxvY2ssIGFyZykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIHZhciBoYXNfbWxocyA9IGJsb2NrLiQkaGFzX3RvcF9sZXZlbF9tbGhzX2FyZyxcbiAgICAgICAgaGFzX3RyYWlsaW5nX2NvbW1hID0gYmxvY2suJCRoYXNfdHJhaWxpbmdfY29tbWFfaW5fYXJncztcblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxIHx8ICgoaGFzX21saHMgfHwgaGFzX3RyYWlsaW5nX2NvbW1hKSAmJiBibG9jay5sZW5ndGggPT09IDEpKSB7XG4gICAgICBhcmcgPSBPcGFsLnRvX2FyeShhcmcpO1xuICAgIH1cblxuICAgIGlmICgoYmxvY2subGVuZ3RoID4gMSB8fCAoaGFzX3RyYWlsaW5nX2NvbW1hICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpICYmIGFyZy4kJGlzX2FycmF5KSB7XG4gICAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYmxvY2soYXJnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGFuZGxlcyB5aWVsZCBmb3IgPiAxIHlpZWxkZWQgYXJnXG4gIE9wYWwueWllbGRYID0gZnVuY3Rpb24oYmxvY2ssIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mKGJsb2NrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoXCJubyBibG9jayBnaXZlblwiKTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2subGVuZ3RoID4gMSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGFyZ3NbMF0uJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJnc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJnc19hcnkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGFyZ3NfYXJ5W2ldID0gYXJnc1tpXTsgfVxuXG4gICAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJnc19hcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICAvLyBGaW5kcyB0aGUgY29ycmVzcG9uZGluZyBleGNlcHRpb24gbWF0Y2ggaW4gY2FuZGlkYXRlcy4gIEVhY2ggY2FuZGlkYXRlIGNhblxuICAvLyBiZSBhIHZhbHVlLCBvciBhbiBhcnJheSBvZiB2YWx1ZXMuICBSZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kLlxuICBPcGFsLnJlc2N1ZSA9IGZ1bmN0aW9uKGV4Y2VwdGlvbiwgY2FuZGlkYXRlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbaV07XG5cbiAgICAgIGlmIChjYW5kaWRhdGUuJCRpc19hcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gT3BhbC5yZXNjdWUoZXhjZXB0aW9uLCBjYW5kaWRhdGUpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjYW5kaWRhdGUgPT09IE9wYWwuSlMuRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZVsnJD09PSddKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBPcGFsLmlzX2EgPSBmdW5jdGlvbihvYmplY3QsIGtsYXNzKSB7XG4gICAgaWYgKGtsYXNzICE9IG51bGwgJiYgb2JqZWN0LiQkbWV0YSA9PT0ga2xhc3MgfHwgb2JqZWN0LiQkY2xhc3MgPT09IGtsYXNzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyICYmIGtsYXNzLiQkaXNfbnVtYmVyX2NsYXNzKSB7XG4gICAgICByZXR1cm4gKGtsYXNzLiQkaXNfaW50ZWdlcl9jbGFzcykgPyAob2JqZWN0ICUgMSkgPT09IDAgOiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpLCBsZW5ndGgsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iamVjdC4kJGlzX2NsYXNzID8gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iamVjdCkgOiAob2JqZWN0LiQkbWV0YSB8fCBvYmplY3QuJCRjbGFzcykpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBrbGFzcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgZXh0cmFjdGluZyBrd3NwbGF0c1xuICAvLyBVc2VkIGZvcjogeyAqKmggfVxuICBPcGFsLnRvX2hhc2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBoYXNoID0gdmFsdWUuJHRvX2hhc2goKTtcbiAgICAgIGlmIChoYXNoLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEhhc2ggKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2hhc2ggZ2l2ZXMgXCIgKyBoYXNoLiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIgaW50byBIYXNoXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBpbXBsZW1lbnRpbmcgbXVsdGlwbGUgYXNzaWdubWVudFxuICAvLyBPdXIgY29kZSBmb3IgZXh0cmFjdGluZyB0aGUgdmFsdWVzIGFuZCBhc3NpZ25pbmcgdGhlbSBvbmx5IHdvcmtzIGlmIHRoZVxuICAvLyByZXR1cm4gdmFsdWUgaXMgYSBKUyBhcnJheS5cbiAgLy8gU28gaWYgd2UgZ2V0IGFuIEFycmF5IHN1YmNsYXNzLCBleHRyYWN0IHRoZSB3cmFwcGVkIEpTIGFycmF5IGZyb20gaXRcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9IHNvbWV0aGluZyAobm8gc3BsYXQpXG4gIE9wYWwudG9fYXJ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2FyeScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2FyeSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hcnkgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSAqc29tZXRoaW5nICh3aXRoIHNwbGF0KVxuICBPcGFsLnRvX2EgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAvLyBBIHNwbGF0dGVkIGFycmF5IG11c3QgYmUgY29waWVkXG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hIGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yIGV4dHJhY3Rpbmcga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gIC8vIEpTIGZ1bmN0aW9uLiBJZiBwcm92aWRlZCArYXJndW1lbnRzKyBsaXN0IGRvZXNuJ3QgaGF2ZSBhIEhhc2hcbiAgLy8gYXMgYSBsYXN0IGl0ZW0sIHJldHVybnMgYSBibGFuayBIYXNoLlxuICAvL1xuICAvLyBAcGFyYW0gcGFyYW1ldGVycyBbQXJyYXldXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwuZXh0cmFjdF9rd2FyZ3MgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIGt3YXJncyA9IHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoa3dhcmdzICE9IG51bGwgJiYgT3BhbC5yZXNwb25kX3RvKGt3YXJncywgJyR0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgICRzcGxpY2UuY2FsbChwYXJhbWV0ZXJzLCBwYXJhbWV0ZXJzLmxlbmd0aCAtIDEsIDEpO1xuICAgICAgcmV0dXJuIGt3YXJncy4kdG9faGFzaCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmhhc2gyKFtdLCB7fSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gZ2V0IGEgbGlzdCBvZiByZXN0IGtleXdvcmQgYXJndW1lbnRzLiBNZXRob2QgdGFrZXMgdGhlIGdpdmVuXG4gIC8vIGtleXdvcmQgYXJncywgaS5lLiB0aGUgaGFzaCBsaXRlcmFsIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNvbnRhaW5pbmcgYWxsXG4gIC8vIGtleXdvcmQgYXJndWVtbnRzIHBhc3NlZCB0byBtZXRob2QsIGFzIHdlbGwgYXMgdGhlIHVzZWQgYXJncyB3aGljaCBhcmVcbiAgLy8gdGhlIG5hbWVzIG9mIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgZGVmaW5lZC4gVGhpcyBtZXRob2QgdGhlblxuICAvLyBqdXN0IHJldHVybnMgYWxsIGtleS92YWx1ZSBwYWlycyB3aGljaCBoYXZlIG5vdCBiZWVuIHVzZWQsIGluIGEgbmV3XG4gIC8vIGhhc2ggbGl0ZXJhbC5cbiAgLy9cbiAgLy8gQHBhcmFtIGdpdmVuX2FyZ3MgW0hhc2hdIGFsbCBrd2FyZ3MgZ2l2ZW4gdG8gbWV0aG9kXG4gIC8vIEBwYXJhbSB1c2VkX2FyZ3MgW09iamVjdDxTdHJpbmc6IHRydWU+XSBhbGwga2V5cyB1c2VkIGFzIG5hbWVkIGt3YXJnc1xuICAvLyBAcmV0dXJuIFtIYXNoXVxuICAvL1xuICBPcGFsLmt3cmVzdGFyZ3MgPSBmdW5jdGlvbihnaXZlbl9hcmdzLCB1c2VkX2FyZ3MpIHtcbiAgICB2YXIga2V5cyAgICAgID0gW10sXG4gICAgICAgIG1hcCAgICAgICA9IHt9LFxuICAgICAgICBrZXkgICAgICAgICAgICxcbiAgICAgICAgZ2l2ZW5fbWFwID0gZ2l2ZW5fYXJncy4kJHNtYXA7XG5cbiAgICBmb3IgKGtleSBpbiBnaXZlbl9tYXApIHtcbiAgICAgIGlmICghdXNlZF9hcmdzW2tleV0pIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIG1hcFtrZXldID0gZ2l2ZW5fbWFwW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuaGFzaDIoa2V5cywgbWFwKTtcbiAgfTtcblxuICAvLyBDYWxscyBwYXNzZWQgbWV0aG9kIG9uIGEgcnVieSBvYmplY3Qgd2l0aCBhcmd1bWVudHMgYW5kIGJsb2NrOlxuICAvL1xuICAvLyBDYW4gdGFrZSBhIG1ldGhvZCBvciBhIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyAxLiBXaGVuIG1ldGhvZCBuYW1lIGdldHMgcGFzc2VkIGl0IGludm9rZXMgaXQgYnkgaXRzIG5hbWVcbiAgLy8gICAgYW5kIGNhbGxzICdtZXRob2RfbWlzc2luZycgd2hlbiBvYmplY3QgZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgbWV0aG9kIHRoYXQgdGFrZXMgYSBibG9jayBvciBhIHNwbGF0LlxuICAvLyAyLiBXaGVuIG1ldGhvZCAoaS5lLiBtZXRob2QgYm9keSkgZ2V0cyBwYXNzZWQsIGl0IGRvZXNuJ3QgdHJpZ2dlciAnbWV0aG9kX21pc3NpbmcnXG4gIC8vICAgIGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IHRoZSBuYW1lIG9mIHRoZSBhY3R1YWwgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgJ3N1cGVyJy5cbiAgLy9cbiAgLy8gQGV4YW1wbGVcbiAgLy8gICB2YXIgbXlfYXJyYXkgPSBbMSwgMiwgMywgNF1cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksICdsZW5ndGgnKSAgICAgICAgICAgICAgICAgICAgIyA9PiA0XG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheS4kbGVuZ3RoKSAgICAgICAgICAgICMgPT4gNFxuICAvL1xuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ3JldmVyc2UhJykgICAgICAgICAgICAgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXlbJyRyZXZlcnNlISddJykgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvL1xuICAvLyBAcGFyYW0gcmVjdiBbT2JqZWN0XSBydWJ5IG9iamVjdFxuICAvLyBAcGFyYW0gbWV0aG9kIFtGdW5jdGlvbiwgU3RyaW5nXSBtZXRob2QgYm9keSBvciBuYW1lIG9mIHRoZSBtZXRob2RcbiAgLy8gQHBhcmFtIGFyZ3MgW0FycmF5XSBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGxcbiAgLy8gQHBhcmFtIGJsb2NrIFtGdW5jdGlvbl0gcnVieSBibG9ja1xuICAvLyBAcmV0dXJuIFtPYmplY3RdIHJldHVybmluZyB2YWx1ZSBvZiB0aGUgbWV0aG9kIGNhbGxcbiAgT3BhbC5zZW5kID0gZnVuY3Rpb24ocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaykge1xuICAgIHZhciBib2R5O1xuXG4gICAgaWYgKHR5cGVvZihtZXRob2QpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib2R5ID0gbWV0aG9kO1xuICAgICAgbWV0aG9kID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihtZXRob2QpID09PSAnc3RyaW5nJykge1xuICAgICAgYm9keSA9IHJlY3ZbJyQnK21ldGhvZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJQYXNzZWQgbWV0aG9kIHNob3VsZCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQyKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spO1xuICB9O1xuXG4gIE9wYWwuc2VuZDIgPSBmdW5jdGlvbihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrKSB7XG4gICAgaWYgKGJvZHkgPT0gbnVsbCAmJiBtZXRob2QgIT0gbnVsbCAmJiByZWN2LiRtZXRob2RfbWlzc2luZykge1xuICAgICAgYm9keSA9IHJlY3YuJG1ldGhvZF9taXNzaW5nO1xuICAgICAgYXJncyA9IFttZXRob2RdLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSBib2R5LiQkcCA9IGJsb2NrO1xuICAgIHJldHVybiBib2R5LmFwcGx5KHJlY3YsIGFyZ3MpO1xuICB9O1xuXG4gIE9wYWwucmVmaW5lZF9zZW5kID0gZnVuY3Rpb24ocmVmaW5lbWVudF9ncm91cHMsIHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2spIHtcbiAgICB2YXIgaSwgaiwgaywgYW5jZXN0b3JzLCBhbmNlc3RvciwgcmVmaW5lbWVudHMsIHJlZmluZW1lbnQsIHJlZmluZV9tb2R1bGVzLCByZWZpbmVfbW9kdWxlLCBib2R5O1xuXG4gICAgaWYgKHJlY3YuaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhyZWN2LiQkbWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHJlY3YuJCRjbGFzcyk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGFsbCBhbmNlc3RvcnMgdGhhdCB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3QgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgZm9yIChpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgYW5jZXN0b3IgPSBPcGFsLmlkKGFuY2VzdG9yc1tpXSk7XG4gICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnQgZ3JvdXBzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgY2xvc2VzdCBzY29wZSB0byB0aGUgZnVydGhlc3QuLi5cbiAgICAgIGZvciAoaiA9IDA7IGogPCByZWZpbmVtZW50X2dyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICByZWZpbmVtZW50cyA9IHJlZmluZW1lbnRfZ3JvdXBzW2pdO1xuICAgICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnRzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBgdXNpbmdgIGNhbGwgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICAgIGZvciAoayA9IHJlZmluZW1lbnRzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgcmVmaW5lbWVudCA9IHJlZmluZW1lbnRzW2tdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzID09PSAndW5kZWZpbmVkJykgY29udGludWU7XG4gICAgICAgICAgLy8gQSBzaW5nbGUgbW9kdWxlIGJlaW5nIGdpdmVuIGFzIGFuIGFyZ3VtZW50IG9mIHRoZSBgdXNpbmdgIGNhbGwgY29udGFpbnMgbXVsdGlwbGVcbiAgICAgICAgICAvLyByZWZpbmVtZW50IG1vZHVsZXNcbiAgICAgICAgICByZWZpbmVfbW9kdWxlcyA9IHJlZmluZW1lbnQuJCRyZWZpbmVfbW9kdWxlcztcbiAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIHJlZmluZSBhIGdpdmVuIGNhbGwgZm9yIGEgZ2l2ZW4gYW5jZXN0b3IgbW9kdWxlP1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lX21vZHVsZXNbYW5jZXN0b3JdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVmaW5lX21vZHVsZSA9IHJlZmluZV9tb2R1bGVzW2FuY2VzdG9yXTtcbiAgICAgICAgICAgIC8vIERvZXMgdGhpcyBtb2R1bGUgZGVmaW5lIGEgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbD9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lX21vZHVsZS4kJHByb3RvdHlwZVsnJCcrbWV0aG9kXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYm9keSA9IHJlZmluZV9tb2R1bGUuJCRwcm90b3R5cGVbJyQnK21ldGhvZF07XG4gICAgICAgICAgICAgIHJldHVybiBPcGFsLnNlbmQyKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jayk7XG4gIH07XG5cbiAgT3BhbC5sYW1iZGEgPSBmdW5jdGlvbihibG9jaykge1xuICAgIGJsb2NrLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEByZXR1cm4gW251bGxdXG4gIC8vXG4gIE9wYWwuZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5KSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIG1ldGhvZCBkZWZpbml0aW9uIGluIHRoZVxuICAgIC8vIHRvcC1sZXZlbCBuYW1lc3BhY2VcbiAgICBpZiAob2JqID09PSBPcGFsLnRvcCkge1xuICAgICAgT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KVxuICAgIH1cbiAgICAvLyBpZiBpbnN0YW5jZV9ldmFsIGlzIGludm9rZWQgb24gYSBtb2R1bGUvY2xhc3MsIGl0IHNldHMgaW5zdF9ldmFsX21vZFxuICAgIGVsc2UgaWYgKCFvYmouJCRldmFsICYmIG9iai4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBPcGFsLmRlZm4ob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuICAgICRkZWZpbmVQcm9wZXJ0eShwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIGpzaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaW5nbGV0b25fb2YgPSBtb2R1bGUuJCRzaW5nbGV0b25fb2Y7XG4gICAgaWYgKG1vZHVsZS4kbWV0aG9kX2FkZGVkICYmICFtb2R1bGUuJG1ldGhvZF9hZGRlZC4kJHN0dWIgJiYgIXNpbmdsZXRvbl9vZikge1xuICAgICAgbW9kdWxlLiRtZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkICYmICFzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQuJCRzdHViKSB7XG4gICAgICBzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgYSBzaW5nbGV0b24gbWV0aG9kIG9uIHRoZSBnaXZlbiBvYmplY3QgKHNlZSBPcGFsLmRlZikuXG4gIE9wYWwuZGVmcyA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSkge1xuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgT3BhbC5kZWZuKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBqc2lkLCBib2R5KVxuICB9O1xuXG4gIC8vIENhbGxlZCBmcm9tICNyZW1vdmVfbWV0aG9kLlxuICBPcGFsLnJkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoISRoYXNfb3duLmNhbGwob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBvbGRfaWQgPSAnJCcgKyBvbGQsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGFsaWFzO1xuXG4gICAgLy8gQWxpYXNpbmcgb24gbWFpbiBtZWFucyBhbGlhc2luZyBvbiBPYmplY3QuLi5cbiAgICBpZiAodHlwZW9mIG9iai4kJHByb3RvdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9iaiA9IE9wYWwuT2JqZWN0O1xuICAgIH1cblxuICAgIGJvZHkgPSBvYmouJCRwcm90b3R5cGVbJyQnICsgb2xkXTtcblxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxuICAgIGlmIChvYmouJCRldmFsKSB7XG4gICAgICByZXR1cm4gT3BhbC5hbGlhcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwgbmFtZSwgb2xkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcblxuICAgICAgd2hpbGUgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiICYmIGFuY2VzdG9yKSB7XG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci4kJHN1cGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpICYmIG9iai4kJGlzX21vZHVsZSkge1xuICAgICAgICAvLyB0cnkgdG8gbG9vayBpbnRvIE9iamVjdFxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBcIiArIG9sZCArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYm9keSBpcyBpdHNlbGYgYW4gYWxpYXMgdXNlIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXG4gICAgaWYgKGJvZHkuJCRhbGlhc19vZikgYm9keSA9IGJvZHkuJCRhbGlhc19vZjtcblxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcbiAgICAvLyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBvbiB0aGUgb3JpZ2luYWwgYm9keS5cbiAgICBhbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsb2NrID0gYWxpYXMuJCRwLCBhcmdzLCBpLCBpaTtcblxuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT0gbnVsbCkgeyBhbGlhcy4kJHAgPSBudWxsIH1cblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gaW4gc3RyaWN0IG1vZGUgdGhlIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICAvLyBJdCBkb2Vzbid0IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDM4KSwgd2hlcmVcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFsaWFzLCAnbGVuZ3RoJywgeyB2YWx1ZTogYm9keS5sZW5ndGggfSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG5cbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19ndmFyID0gZnVuY3Rpb24obmV3X25hbWUsIG9sZF9uYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wYWwuZ3ZhcnMsIG5ld19uYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuZ3ZhcnNbb2xkX25hbWVdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24obmV3X3ZhbHVlKSB7XG4gICAgICAgIE9wYWwuZ3ZhcnNbb2xkX25hbWVdID0gbmV3X3ZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBPcGFsLmFsaWFzX25hdGl2ZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgbmF0aXZlX25hbWUpIHtcbiAgICB2YXIgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgIGJvZHkgPSBvYmouJCRwcm90b3R5cGVbbmF0aXZlX25hbWVdO1xuXG4gICAgaWYgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiIHx8IGJvZHkuJCRzdHViKSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwidW5kZWZpbmVkIG5hdGl2ZSBtZXRob2QgYFwiICsgbmF0aXZlX25hbWUgKyBcIicgZm9yIGNsYXNzIGBcIiArIG9iai4kbmFtZSgpICsgXCInXCIpXG4gICAgfVxuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGJvZHkpO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuXG4gIC8vIEhhc2hlc1xuICAvLyAtLS0tLS1cblxuICBPcGFsLmhhc2hfaW5pdCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLiQkc21hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaGFzaC4kJG1hcCAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRrZXlzID0gW107XG4gIH07XG5cbiAgT3BhbC5oYXNoX2Nsb25lID0gZnVuY3Rpb24oZnJvbV9oYXNoLCB0b19oYXNoKSB7XG4gICAgdG9faGFzaC4kJG5vbmUgPSBmcm9tX2hhc2guJCRub25lO1xuICAgIHRvX2hhc2guJCRwcm9jID0gZnJvbV9oYXNoLiQkcHJvYztcblxuICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gZnJvbV9oYXNoLiQka2V5cywgc21hcCA9IGZyb21faGFzaC4kJHNtYXAsIGxlbiA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgdmFsdWUgPSBzbWFwW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5oYXNoX3B1dCh0b19oYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3B1dCA9IGZ1bmN0aW9uKGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgaGFzaC4kJGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgaGFzaC4kJHNtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDtcbiAgICBrZXlfaGFzaCA9IGhhc2guJCRieV9pZGVudGl0eSA/IE9wYWwuaWQoa2V5KSA6IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0ge2tleToga2V5LCBrZXlfaGFzaDoga2V5X2hhc2gsIHZhbHVlOiB2YWx1ZX07XG4gICAgICBoYXNoLiQka2V5cy5wdXNoKGJ1Y2tldCk7XG4gICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBidWNrZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgIH1cblxuICAgIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgYnVja2V0ID0ge2tleToga2V5LCBrZXlfaGFzaDoga2V5X2hhc2gsIHZhbHVlOiB2YWx1ZX07XG4gICAgICBoYXNoLiQka2V5cy5wdXNoKGJ1Y2tldCk7XG4gICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0O1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZ2V0ID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGhhc2guJCRzbWFwW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleV9oYXNoLCBidWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgICByZXR1cm4gYnVja2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZGVsZXRlID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgdmFyIGksIGtleXMgPSBoYXNoLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIHZhbHVlLCBrZXlfdG1wO1xuXG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIGtleSA9IGtleS52YWx1ZU9mKCk7XG5cbiAgICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkc21hcCwga2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXlfdG1wID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5X3RtcC4kJGlzX3N0cmluZyAmJiB0eXBlb2Yga2V5X3RtcCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGtleV90bXAgPSBrZXlfdG1wLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlfdG1wID09PSBrZXkpIHtcbiAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGhhc2guJCRzbWFwW2tleV07XG4gICAgICBkZWxldGUgaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2ggPSBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF0sIGxhc3RfYnVja2V0O1xuXG4gICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBidWNrZXQudmFsdWU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGtleXNbaV0gPT09IGJ1Y2tldCkge1xuICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICBkZWxldGUgbGFzdF9idWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2guJCRtYXBba2V5X2hhc2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3JlaGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaGFzaC4kJGtleXMubGVuZ3RoLCBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIGlmIChoYXNoLiQka2V5c1tpXS4kJGlzX3N0cmluZykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAga2V5X2hhc2ggPSBoYXNoLiQka2V5c1tpXS5rZXkuJGhhc2goKTtcblxuICAgICAgaWYgKGtleV9oYXNoID09PSBoYXNoLiQka2V5c1tpXS5rZXlfaGFzaCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0ID09PSBoYXNoLiQka2V5c1tpXSkge1xuICAgICAgICAgIGlmIChsYXN0X2J1Y2tldCAmJiBidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBoYXNoLiQka2V5c1tpXS5rZXlfaGFzaCA9IGtleV9oYXNoO1xuXG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICAgIGhhc2guJCRtYXBba2V5X2hhc2hdID0gaGFzaC4kJGtleXNbaV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQgPT09IGhhc2guJCRrZXlzW2ldKSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJndW1lbnRzX2xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MsIGhhc2gsIGksIGxlbmd0aCwga2V5LCB2YWx1ZTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcbiAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXS4kJGlzX2FycmF5KSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnc1tpXS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInZhbHVlIG5vdCBvZiBsZW5ndGggMjogXCIgKyBhcmdzW2ldLiRpbnNwZWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gYXJnc1tpXVswXTtcbiAgICAgICAgdmFsdWUgPSBhcmdzW2ldWzFdO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoID09PSAxKSB7XG4gICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yIChrZXkgaW4gYXJncykge1xuICAgICAgICBpZiAoJGhhc19vd24uY2FsbChhcmdzLCBrZXkpKSB7XG4gICAgICAgICAgdmFsdWUgPSBhcmdzW2tleV07XG5cbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNfbGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaFwiKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzX2xlbmd0aDsgaSArPSAyKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLy8gQSBmYXN0ZXIgSGFzaCBjcmVhdG9yIGZvciBoYXNoZXMgdGhhdCBqdXN0IHVzZSBzeW1ib2xzIGFuZFxuICAvLyBzdHJpbmdzIGFzIGtleXMuIFRoZSBtYXAgYW5kIGtleXMgYXJyYXkgY2FuIGJlIGNvbnN0cnVjdGVkIGF0XG4gIC8vIGNvbXBpbGUgdGltZSwgc28gdGhleSBhcmUganVzdCBhZGRlZCBoZXJlIGJ5IHRoZSBjb25zdHJ1Y3RvclxuICAvLyBmdW5jdGlvbi5cbiAgLy9cbiAgT3BhbC5oYXNoMiA9IGZ1bmN0aW9uKGtleXMsIHNtYXApIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBPcGFsLkhhc2goKTtcblxuICAgIGhhc2guJCRzbWFwID0gc21hcDtcbiAgICBoYXNoLiQkbWFwICA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaGFzaC4kJGtleXMgPSBrZXlzO1xuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJhbmdlIGluc3RhbmNlIHdpdGggZmlyc3QgYW5kIGxhc3QgdmFsdWVzLCBhbmQgd2hldGhlciB0aGVcbiAgLy8gcmFuZ2UgZXhjbHVkZXMgdGhlIGxhc3QgdmFsdWUuXG4gIC8vXG4gIE9wYWwucmFuZ2UgPSBmdW5jdGlvbihmaXJzdCwgbGFzdCwgZXhjKSB7XG4gICAgdmFyIHJhbmdlICAgICAgICAgPSBuZXcgT3BhbC5SYW5nZSgpO1xuICAgICAgICByYW5nZS5iZWdpbiAgID0gZmlyc3Q7XG4gICAgICAgIHJhbmdlLmVuZCAgICAgPSBsYXN0O1xuICAgICAgICByYW5nZS5leGNsICAgID0gZXhjO1xuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgaXZhciBuYW1lIGZvciBhIGdpdmVuIG5hbWUuXG4gIC8vIE1vc3RseSBhZGRzIGEgdHJhaWxpbmcgJCB0byByZXNlcnZlZCBuYW1lcy5cbiAgLy9cbiAgT3BhbC5pdmFyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChcbiAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICBuYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJkaXNwbGF5TmFtZVwiIHx8XG4gICAgICAgIG5hbWUgPT09IFwiX19jb3VudF9fXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX25vU3VjaE1ldGhvZF9fXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX3BhcmVudF9fXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fFxuXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgbmFtZSA9PT0gXCJoYXNPd25Qcm9wZXJ0eVwiIHx8XG4gICAgICAgIG5hbWUgPT09IFwidmFsdWVPZlwiXG4gICAgICAgKVxuICAgIHtcbiAgICAgIHJldHVybiBuYW1lICsgXCIkXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cblxuICAvLyBSZWdleHBzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBFc2NhcGUgUmVnZXhwIHNwZWNpYWwgY2hhcnMgbGV0dGluZyB0aGUgcmVzdWx0aW5nIHN0cmluZyBiZSB1c2VkIHRvIGJ1aWxkXG4gIC8vIGEgbmV3IFJlZ2V4cC5cbiAgLy9cbiAgT3BhbC5lc2NhcGVfcmVnZXhwID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy1bXFxdXFwve30oKSorPy5eJFxcXFx8IF0pL2csICdcXFxcJDEnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcbl0vZywgJ1xcXFxuJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHJdL2csICdcXFxccicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxmXS9nLCAnXFxcXGYnKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdF0vZywgJ1xcXFx0Jyk7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZ2xvYmFsIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnIGF0dHJpYnV0ZSkuXG4gIC8vXG4gIE9wYWwuZ2xvYmFsX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICBpZiAocGF0dGVybi5nbG9iYWwpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBmbGFnXG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLiQkZyA9PSBudWxsKSB7XG4gICAgICBwYXR0ZXJuLiQkZyA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsIChwYXR0ZXJuLm11bHRpbGluZSA/ICdnbScgOiAnZycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4uJCRnLmxhc3RJbmRleCA9IG51bGw7IC8vIHJlc2V0IGxhc3RJbmRleCBwcm9wZXJ0eVxuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybi4kJGc7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZ2xvYmFsIG11bHRpbGluZSBSZWdleHAgZnJvbSBhIFJlZ0V4cCBvYmplY3QgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgLy8gb24gdGhlIG9iamVjdCBpdHNlbGYgKCQkZ20gb3IgJCRnIGF0dHJpYnV0ZSkuXG4gIC8vXG4gIE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAocGF0dGVybi5tdWx0aWxpbmUpIHtcbiAgICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgICByZXR1cm4gcGF0dGVybjsgLy8gUmVnRXhwIGFscmVhZHkgaGFzIHRoZSBnbG9iYWwgYW5kIG11bHRpbGluZSBmbGFnXG4gICAgICB9XG4gICAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlICQkZyBhdHRyaWJ1dGUgYmVjYXVzZSB0aGUgUmVnZXhwIGlzIGFscmVhZHkgbXVsdGlsaW5lXG4gICAgICBpZiAocGF0dGVybi4kJGcgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgJ2dtJyArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0dGVybi4kJGdtICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgJ2dtJyArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJykpO1xuICAgIH1cbiAgICByZXN1bHQubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb21iaW5lIG11bHRpcGxlIHJlZ2V4cCBwYXJ0cyB0b2dldGhlclxuICBPcGFsLnJlZ2V4cCA9IGZ1bmN0aW9uKHBhcnRzLCBmbGFncykge1xuICAgIHZhciBwYXJ0O1xuICAgIHZhciBpZ25vcmVDYXNlID0gdHlwZW9mIGZsYWdzICE9PSAndW5kZWZpbmVkJyAmJiBmbGFncyAmJiBmbGFncy5pbmRleE9mKCdpJykgPj0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmIChwYXJ0Lmlnbm9yZUNhc2UgIT09IGlnbm9yZUNhc2UpXG4gICAgICAgICAgT3BhbC5LZXJuZWwuJHdhcm4oXG4gICAgICAgICAgICBcImlnbm9yZSBjYXNlIGRvZXNuJ3QgbWF0Y2ggZm9yIFwiICsgcGFydC5zb3VyY2UuJGluc3BlY3QoKSxcbiAgICAgICAgICAgIE9wYWwuaGFzaCh7dXBsZXZlbDogMX0pXG4gICAgICAgICAgKVxuXG4gICAgICAgIHBhcnQgPSBwYXJ0LnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0ID09PSAnJykgcGFydCA9ICcoPzonICsgcGFydCArICcpJztcbiAgICAgIHBhcnRzW2ldID0gcGFydDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpLCBmbGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJycpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVxdWlyZSBzeXN0ZW1cbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICBPcGFsLm1vZHVsZXMgICAgICAgICA9IHt9O1xuICBPcGFsLmxvYWRlZF9mZWF0dXJlcyA9IFsnY29yZWxpYi9ydW50aW1lJ107XG4gIE9wYWwuY3VycmVudF9kaXIgICAgID0gJy4nO1xuICBPcGFsLnJlcXVpcmVfdGFibGUgICA9IHsnY29yZWxpYi9ydW50aW1lJzogdHJ1ZX07XG5cbiAgT3BhbC5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHBhcnRzLCBwYXJ0LCBuZXdfcGFydHMgPSBbXSwgU0VQQVJBVE9SID0gJy8nO1xuXG4gICAgaWYgKE9wYWwuY3VycmVudF9kaXIgIT09ICcuJykge1xuICAgICAgcGF0aCA9IE9wYWwuY3VycmVudF9kaXIucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGF0aDtcbiAgICB9XG5cbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwuXFwvLywgJycpO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLihyYnxvcGFsfGpzKSQvLCAnJyk7XG4gICAgcGFydHMgPSBwYXRoLnNwbGl0KFNFUEFSQVRPUik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgKHBhcnQgPT09ICcuLicpID8gbmV3X3BhcnRzLnBvcCgpIDogbmV3X3BhcnRzLnB1c2gocGFydClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3X3BhcnRzLmpvaW4oU0VQQVJBVE9SKTtcbiAgfTtcblxuICBPcGFsLmxvYWRlZCA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgdmFyIGksIGwsIHBhdGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aHNbaV0pO1xuXG4gICAgICBpZiAoT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBPcGFsLmxvYWRlZF9mZWF0dXJlcy5wdXNoKHBhdGgpO1xuICAgICAgT3BhbC5yZXF1aXJlX3RhYmxlW3BhdGhdID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5sb2FkID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIE9wYWwubG9hZGVkKFtwYXRoXSk7XG5cbiAgICB2YXIgbW9kdWxlID0gT3BhbC5tb2R1bGVzW3BhdGhdO1xuXG4gICAgaWYgKG1vZHVsZSkge1xuICAgICAgdmFyIHJldHZhbCA9IG1vZHVsZShPcGFsKTtcbiAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmV0dmFsIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAvLyBBIHNwZWNpYWwgY2FzZSBvZiByZXF1aXJlIGhhdmluZyBhbiBhc3luYyB0b3A6XG4gICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBhd2FpdCBpdC5cbiAgICAgICAgcmV0dXJuIHJldHZhbC50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNldmVyaXR5ID0gT3BhbC5jb25maWcubWlzc2luZ19yZXF1aXJlX3NldmVyaXR5O1xuICAgICAgdmFyIG1lc3NhZ2UgID0gJ2Nhbm5vdCBsb2FkIHN1Y2ggZmlsZSAtLSAnICsgcGF0aDtcblxuICAgICAgaWYgKHNldmVyaXR5ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgaWYgKE9wYWwuTG9hZEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgT3BhbC5Mb2FkRXJyb3IuJG5ldyhtZXNzYWdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2V2ZXJpdHkgPT09IFwid2FybmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTG9hZEVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkKHBhdGgpO1xuICB9O1xuXG5cbiAgLy8gU3RyaW5nc1xuICAvLyAtLS0tLS0tXG5cbiAgT3BhbC5lbmNvZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIFNldHMgdGhlIGVuY29kaW5nIG9uIGEgc3RyaW5nLCB3aWxsIHRyZWF0IHN0cmluZyBsaXRlcmFscyBhcyBmcm96ZW4gc3RyaW5nc1xuICAvLyByYWlzaW5nIGEgRnJvemVuRXJyb3IuXG4gIC8vXG4gIC8vIEBwYXJhbSBzdHIgW1N0cmluZ10gdGhlIHN0cmluZyBvbiB3aGljaCB0aGUgZW5jb2Rpbmcgc2hvdWxkIGJlIHNldFxuICAvLyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgY2Fub25pY2FsIG5hbWUgb2YgdGhlIGVuY29kaW5nXG4gIC8vIEBwYXJhbSB0eXBlIFtTdHJpbmddIHBvc3NpYmxlIHZhbHVlcyBhcmUgZWl0aGVyIGBcImVuY29kaW5nXCJgLCBgXCJpbnRlcm5hbF9lbmNvZGluZ1wiYCwgb3IgYHVuZGVmaW5lZFxuICBPcGFsLnNldF9lbmNvZGluZyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJ1bmRlZmluZWRcIikgdHlwZSA9IFwiZW5jb2RpbmdcIjtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyLiQkZnJvemVuID09PSB0cnVlKVxuICAgICAgdGhyb3cgT3BhbC5Gcm96ZW5FcnJvci4kbmV3KFwiY2FuJ3QgbW9kaWZ5IGZyb3plbiBTdHJpbmdcIik7XG5cbiAgICB2YXIgZW5jb2RpbmcgPSBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSk7XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09IHN0clt0eXBlXSkgeyByZXR1cm4gc3RyOyB9XG5cbiAgICBzdHJbdHlwZV0gPSBlbmNvZGluZztcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLy8gRmV0Y2hlcyB0aGUgZW5jb2RpbmcgZm9yIHRoZSBnaXZlbiBuYW1lIG9yIHJhaXNlcyBBcmd1bWVudEVycm9yLlxuICBPcGFsLmZpbmRfZW5jb2RpbmcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2lzdGVyID0gT3BhbC5lbmNvZGluZ3M7XG4gICAgdmFyIGVuY29kaW5nID0gcmVnaXN0ZXJbbmFtZV0gfHwgcmVnaXN0ZXJbbmFtZS50b1VwcGVyQ2FzZSgpXTtcbiAgICBpZiAoIWVuY29kaW5nKSB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInVua25vd24gZW5jb2RpbmcgbmFtZSAtIFwiICsgbmFtZSk7XG4gICAgcmV0dXJuIGVuY29kaW5nO1xuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGVuY29kaW5nIHNldCBmcm9tIGEgc3RyaW5nIGxpdGVyYWxcbiAgT3BhbC5lbmMgPSBmdW5jdGlvbihzdHIsIG5hbWUpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIGR1cCA9IE9wYWwuc2V0X2VuY29kaW5nKGR1cCwgbmFtZSk7XG4gICAgZHVwLmludGVybmFsX2VuY29kaW5nID0gZHVwLmVuY29kaW5nO1xuICAgIHJldHVybiBkdXBcbiAgfVxuXG4gIC8vIEByZXR1cm5zIGEgU3RyaW5nIG9iamVjdCB3aXRoIHRoZSBpbnRlcm5hbCBlbmNvZGluZyBzZXQgdG8gQmluYXJ5XG4gIE9wYWwuYmluYXJ5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGR1cCA9IG5ldyBTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBcImJpbmFyeVwiLCBcImludGVybmFsX2VuY29kaW5nXCIpO1xuICB9XG5cbiAgT3BhbC5sYXN0X3Byb21pc2UgPSBudWxsO1xuICBPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbiA9IGZhbHNlO1xuXG4gIC8vIFJ1biBhIGJsb2NrIG9mIGNvZGUsIGJ1dCBpZiBpdCByZXR1cm5zIGEgUHJvbWlzZSwgZG9uJ3QgcnVuIHRoZSBuZXh0XG4gIC8vIG9uZSwgYnV0IHF1ZXVlIGl0LlxuICBPcGFsLnF1ZXVlID0gZnVuY3Rpb24ocHJvYykge1xuICAgIGlmIChPcGFsLmxhc3RfcHJvbWlzZSkge1xuICAgICAgLy8gVGhlIGFzeW5jIHBhdGggaXMgdGFrZW4gb25seSBpZiBhbnl0aGluZyBiZWZvcmUgcmV0dXJuZWQgYVxuICAgICAgLy8gUHJvbWlzZShWMikuXG4gICAgICBPcGFsLmxhc3RfcHJvbWlzZSA9IE9wYWwubGFzdF9wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghT3BhbC5wcm9taXNlX3VuaGFuZGxlZF9leGNlcHRpb24pIHJldHVybiBwcm9jKE9wYWwpO1xuICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKE9wYWwucmVzcG9uZF90byhlcnJvciwgJyRmdWxsX21lc3NhZ2UnKSkge1xuICAgICAgICAgIGVycm9yID0gZXJyb3IuJGZ1bGxfbWVzc2FnZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAvLyBBYm9ydCBmdXJ0aGVyIGV4ZWN1dGlvblxuICAgICAgICBPcGFsLnByb21pc2VfdW5oYW5kbGVkX2V4Y2VwdGlvbiA9IHRydWU7XG4gICAgICAgIE9wYWwuZXhpdCgxKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIE9wYWwubGFzdF9wcm9taXNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZXQgPSBwcm9jKE9wYWwpO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmIHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgT3BhbC5sYXN0X3Byb21pc2UgPSByZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gSW5pdGlhbGl6YXRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gJEJhc2ljT2JqZWN0KCkge31cbiAgZnVuY3Rpb24gJE9iamVjdCgpIHt9XG4gIGZ1bmN0aW9uICRNb2R1bGUoKSB7fVxuICBmdW5jdGlvbiAkQ2xhc3MoKSB7fVxuXG4gIE9wYWwuQmFzaWNPYmplY3QgPSBCYXNpY09iamVjdCA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ0Jhc2ljT2JqZWN0JywgbnVsbCwgJEJhc2ljT2JqZWN0KTtcbiAgT3BhbC5PYmplY3QgICAgICA9IF9PYmplY3QgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnT2JqZWN0JywgT3BhbC5CYXNpY09iamVjdCwgJE9iamVjdCk7XG4gIE9wYWwuTW9kdWxlICAgICAgPSBNb2R1bGUgICAgICA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ01vZHVsZScsIE9wYWwuT2JqZWN0LCAkTW9kdWxlKTtcbiAgT3BhbC5DbGFzcyAgICAgICA9IENsYXNzICAgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnQ2xhc3MnLCBPcGFsLk1vZHVsZSwgJENsYXNzKTtcblxuICAkc2V0X3Byb3RvKE9wYWwuQmFzaWNPYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuT2JqZWN0LCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLk1vZHVsZSwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5DbGFzcywgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgLy8gQmFzaWNPYmplY3QgY2FuIHJlYWNoIGl0c2VsZiwgYXZvaWQgY29uc3Rfc2V0IHRvIHNraXAgdGhlICQkYmFzZV9tb2R1bGUgbG9naWNcbiAgQmFzaWNPYmplY3QuJCRjb25zdFtcIkJhc2ljT2JqZWN0XCJdID0gQmFzaWNPYmplY3Q7XG5cbiAgLy8gQXNzaWduIGJhc2ljIGNvbnN0YW50c1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCBcIkJhc2ljT2JqZWN0XCIsICBCYXNpY09iamVjdCk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiT2JqZWN0XCIsICAgICAgIF9PYmplY3QpO1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCBcIk1vZHVsZVwiLCAgICAgICBNb2R1bGUpO1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCBcIkNsYXNzXCIsICAgICAgICBDbGFzcyk7XG5cbiAgLy8gRml4IGJvb3RlZCBjbGFzc2VzIHRvIGhhdmUgY29ycmVjdCAuY2xhc3MgdmFsdWVcbiAgQmFzaWNPYmplY3QuJCRjbGFzcyA9IENsYXNzO1xuICBfT2JqZWN0LiQkY2xhc3MgICAgID0gQ2xhc3M7XG4gIE1vZHVsZS4kJGNsYXNzICAgICAgPSBDbGFzcztcbiAgQ2xhc3MuJCRjbGFzcyAgICAgICA9IENsYXNzO1xuXG4gIC8vIEZvcndhcmQgLnRvU3RyaW5nKCkgdG8gI3RvX3NcbiAgJGRlZmluZVByb3BlcnR5KF9PYmplY3QuJCRwcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b19zID0gdGhpcy4kdG9fcygpO1xuICAgIGlmICh0b19zLiQkaXNfc3RyaW5nICYmIHR5cGVvZih0b19zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIGEgc3RyaW5nIGNyZWF0ZWQgdXNpbmcgbmV3IFN0cmluZygnc3RyaW5nJylcbiAgICAgIHJldHVybiB0b19zLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRvX3M7XG4gICAgfVxuICB9KTtcblxuICAvLyBNYWtlIEtlcm5lbCNyZXF1aXJlIGltbWVkaWF0ZWx5IGF2YWlsYWJsZSBhcyBpdCdzIG5lZWRlZCB0byByZXF1aXJlIGFsbCB0aGVcbiAgLy8gb3RoZXIgY29yZWxpYiBmaWxlcy5cbiAgJGRlZmluZVByb3BlcnR5KF9PYmplY3QuJCRwcm90b3R5cGUsICckcmVxdWlyZScsIE9wYWwucmVxdWlyZSk7XG5cbiAgLy8gSW5zdGFudGlhdGUgdGhlIG1haW4gb2JqZWN0XG4gIE9wYWwudG9wID0gbmV3IF9PYmplY3QoKTtcbiAgT3BhbC50b3AuJHRvX3MgPSBPcGFsLnRvcC4kaW5zcGVjdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ21haW4nIH07XG4gIE9wYWwudG9wLiRkZWZpbmVfbWV0aG9kID0gdG9wX2RlZmluZV9tZXRob2Q7XG5cbiAgLy8gRm93YXJkIGNhbGxzIHRvIGRlZmluZV9tZXRob2Qgb24gdGhlIHRvcCBvYmplY3QgdG8gT2JqZWN0XG4gIGZ1bmN0aW9uIHRvcF9kZWZpbmVfbWV0aG9kKCkge1xuICAgIHZhciBhcmdzID0gT3BhbC5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdmFyIGJsb2NrID0gdG9wX2RlZmluZV9tZXRob2QuJCRwO1xuICAgIHRvcF9kZWZpbmVfbWV0aG9kLiQkcCA9IG51bGw7XG4gICAgcmV0dXJuIE9wYWwuc2VuZChfT2JqZWN0LCAnZGVmaW5lX21ldGhvZCcsIGFyZ3MsIGJsb2NrKVxuICB9O1xuXG5cbiAgLy8gTmlsXG4gIGZ1bmN0aW9uICROaWxDbGFzcygpIHt9XG4gIE9wYWwuTmlsQ2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdOaWxDbGFzcycsIE9wYWwuT2JqZWN0LCAkTmlsQ2xhc3MpO1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCAnTmlsQ2xhc3MnLCBPcGFsLk5pbENsYXNzKTtcbiAgbmlsID0gT3BhbC5uaWwgPSBuZXcgT3BhbC5OaWxDbGFzcygpO1xuICBuaWwuJCRpZCA9IG5pbF9pZDtcbiAgbmlsLmNhbGwgPSBuaWwuYXBwbHkgPSBmdW5jdGlvbigpIHsgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KCdubyBibG9jayBnaXZlbicpOyB9O1xuXG4gIC8vIEVycm9yc1xuICBPcGFsLmJyZWFrZXIgID0gbmV3IEVycm9yKCd1bmV4cGVjdGVkIGJyZWFrIChvbGQpJyk7XG4gIE9wYWwucmV0dXJuZXIgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcmV0dXJuJyk7XG4gIFR5cGVFcnJvci4kJHN1cGVyID0gRXJyb3I7XG59KS5jYWxsKHRoaXMpO1xuT3BhbC5sb2FkZWQoW1wiY29yZWxpYi9ydW50aW1lLmpzXCJdKTsiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBOztBQUVFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7O0FBRUY7QUFDRTs7QUFFRjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUY7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFSjtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNGOztBQUVBO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVFO0FBQ0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDSjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUU7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7QUFDQTs7QUFFSjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDtBQUNIO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDVTtBQUNBO0FBQ0E7QUFDQTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNGOztBQUVGO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzc2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvciwgY29lcmNlX3RvXG5cbm1vZHVsZSBPcGFsXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXG4gICAgYE9wYWwuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90byEob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvPyhvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG5cbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxuXG4gICAgcmV0dXJuIGlmIGNvZXJjZWQubmlsP1xuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuICAgIHJldHVybiBvYmplY3QgaWYgdHlwZSA9PT0gb2JqZWN0XG5cbiAgICBpZiBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICBvYmplY3QuX19zZW5kX18gbWV0aG9kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcbiAgICBjb21wYXJlID0gYSA8PT4gYlxuXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2EuY2xhc3N9IHdpdGggI3tiLmNsYXNzfSBmYWlsZWRcIlxuICAgIGVuZFxuXG4gICAgY29tcGFyZVxuICBlbmRcblxuICBkZWYgc2VsZi5kZXN0cnVjdHVyZShhcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgICByZXR1cm4gYXJnc19hcnk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZXNwb25kX3RvPyhvYmosIG1ldGhvZCwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5yZXNwb25kX3RvPyhtZXRob2QsIGluY2x1ZGVfYWxsKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgdW5sZXNzIGAvXkBbYS16QS1aX11bYS16QS1aMC05X10qPyQvLnRlc3QobmFtZSlgXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGBuYW1lLmxlbmd0aCA8IDMgfHwgbmFtZS5zbGljZSgwLDIpICE9PSAnQEAnYFxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcImAje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZT8oY29uc3RfbmFtZSlcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2YgY29uc3RfbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgI3tjb25zdF9uYW1lID0gT3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIFN0cmluZywgOnRvX3N0cil9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2NvbnN0X25hbWV9WzBdID09PSAje2NvbnN0X25hbWV9WzBdLnRvVXBwZXJDYXNlKClcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXG4gICAgY29uc3RfbmFtZSA9IE9wYWwuY29lcmNlX3RvIShjb25zdF9uYW1lLCBTdHJpbmcsIDp0b19zdHIpXG5cbiAgICBpZiBjb25zdF9uYW1lWzBdICE9IGNvbnN0X25hbWVbMF0udXBjYXNlXG4gICAgICByYWlzZSBOYW1lRXJyb3IsIFwid3JvbmcgY29uc3RhbnQgbmFtZSAje2NvbnN0X25hbWV9XCJcbiAgICBlbmRcblxuICAgIGNvbnN0X25hbWVcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICAjIE1hcmsgc29tZSBtZXRob2RzIGFzIHByaXN0aW5lIGluIG9yZGVyIHRvIGFwcGx5IG9wdGltaXphdGlvbnMgd2hlbiB0aGV5XG4gICMgYXJlIHN0aWxsIGluIHRoZWlyIG9yaWdpbmFsIGZvcm0uIFRoaXMgY291bGQgcHJvYmFibHkgYmUgbW92ZWQgdG9cbiAgIyB0aGUgYE9wYWwuZGVmKClgIEpTIEFQSSwgYnV0IGZvciBub3cgaXQgd2lsbCBzdGF5IG1hbnVhbC5cbiAgI1xuICAjIEBleGFtcGxlXG4gICNcbiAgIyAgIE9wYWwucHJpc3RpbmUgQXJyYXksIDphbGxvY2F0ZSwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcbiAgI1xuICAjICAgY2xhc3MgQXJyYXlcbiAgIyAgICAgZGVmIGR1cFxuICAjICAgICAgICV4e1xuICAjICAgICAgICAgaWYgKFxuICAjICAgICAgICAgICBzZWxmLiRhbGxvY2F0ZS4kJHByaXN0aW5lICYmXG4gICMgICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZVxuICAjICAgICAgICAgKSByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgIyAgICAgICB9XG4gICNcbiAgIyAgICAgICBzdXBlclxuICAjICAgICBlbmRcbiAgIyAgIGVuZFxuICAjXG4gICMgQHBhcmFtIG93bmVyX2NsYXNzIFtDbGFzc10gdGhlIGNsYXNzIG93bmluZyB0aGUgbWV0aG9kc1xuICAjIEBwYXJhbSBtZXRob2RfbmFtZXMgW0FycmF5PFN5bWJvbD5dIHRoZSBsaXN0IG9mIG1ldGhvZHMgbmFtZXMgdG8gbWFya1xuICAjIEByZXR1cm4gW25pbF1cbiAgZGVmIHNlbGYucHJpc3RpbmUob3duZXJfY2xhc3MsICptZXRob2RfbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aG9kX25hbWUsIG1ldGhvZDtcbiAgICAgIGZvciAodmFyIGkgPSBtZXRob2RfbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbWV0aG9kX25hbWUgPSBtZXRob2RfbmFtZXNbaV07XG4gICAgICAgIG1ldGhvZCA9IG93bmVyX2NsYXNzLiQkcHJvdG90eXBlWyckJyttZXRob2RfbmFtZV07XG5cbiAgICAgICAgaWYgKG1ldGhvZCAmJiAhbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIG1ldGhvZC4kJHByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsImJyaWRnZSIsInNlbGYiLCJjb25zdHJ1Y3RvciIsImtsYXNzIiwiY29lcmNlX3RvISIsIm9iamVjdCIsInR5cGUiLCJtZXRob2QiLCJjb2VyY2VkIiwiPT09IiwicmFpc2UiLCJjb2VyY2VfdG8/IiwicmVzcG9uZF90bz8iLCJuaWw/IiwidHJ5X2NvbnZlcnQiLCJfX3NlbmRfXyIsImNvbXBhcmUiLCJhIiwiYiIsIjw9PiIsIkFyZ3VtZW50RXJyb3IiLCJjbGFzcyIsImRlc3RydWN0dXJlIiwiYXJncyIsIm9iaiIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwiT3BhbCIsIlN0cmluZyIsIk5hbWVFcnJvciIsIm5ldyIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY29uc3RfbmFtZT8iLCJjb25zdF9uYW1lIiwiY29uc3RfbmFtZSEiLCJbXSIsIjAiLCIhPSIsInVwY2FzZSIsInByaXN0aW5lIiwib3duZXJfY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQSxrREFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDLFVBQUlDLElBQUpELGFBQUFBLGlCQUFBQSxrQkFBZ0JFLFdBQUQsRUFBY0MsS0FBN0JIO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSwrQkFBREE7SUFERkEsQ0FBQUEsNEJBQUFBO0lBSUFJLFVBQUlILElBQUpHLGlCQUFBQSx5QkFBQUEsU0FBb0JDLE1BQUQsRUFBU0MsSUFBVCxFQUFlQyxNQUFmLEVBUHJCLEVBT0VIO0FBQUFBLE1BQUFBOzs7O01BUEY7O01BTzRDO01BQ3hDSSxVQUFXSjtNQUVYLElBQUEsUUFBT0UsSUFBS0csUUFBQUEsQ0FBSUQsT0FBSkMsQ0FBWixDQUFBO01BQUE7UUFDRVIsSUFBQVMsT0FBQUEsQ0FBT04sMENBQVBNO01BREY7TUFJQU4sT0FBQUk7SUFQRkosQ0FBQUEscUNBQUFBO0lBVUFPLFVBQUlWLElBQUpVLGlCQUFBQSx5QkFBQUEsU0FBb0JOLE1BQUQsRUFBU0MsSUFBVCxFQUFlQyxNQUFmLEVBakJyQixFQWlCRUk7QUFBQUEsTUFBQUE7Ozs7TUFqQkY7O01BaUI0QztNQUN4QyxJQUFBLFFBQWNOLE1BQU1PLGdCQUFBQSxDQUFhTCxNQUFiSyxDQUFwQixDQUFBO01BQUE7UUFBQSxPQUFBO01BQUE7TUFFQUosVUFBV0c7TUFFWCxJQUFBLFFBQVVILE9BQU9LLFNBQUFBLENBQUFBLENBQWpCLENBQUE7UUFBQSxPQUFBLEdBQUE7TUFFQSxJQUFBLFFBQU9QLElBQUtHLFFBQUFBLENBQUlELE9BQUpDLENBQVosQ0FBQTtNQUFBO1FBQ0VSLElBQUFTLE9BQUFBLENBQU9DLDBDQUFQRDtNQURG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QUFlQyxVQUFXRCxRQUFVQyxVQUFXRDtBQUMvQ0E7SUFQRUEsQ0FBQUEsc0NBQUFBO0lBVUFFLFVBQUlsQyxJQUFKa0Msa0JBQUFBLDJCQUFBQSxTQUFxQkQsVUFBckJDO0FBQUFBLE1BQUFBOzs7TUFDRUQsYUFBYU4sb0JBQUl4QixlQUFBQSxDQUFZOEIsVUFBaEIsRUFBNEJMLHNCQUE1QixFQUFvQyxRQUFoQ3pCO01BRWpCLElBQUEsUUFBRzhCLFVBQVVFLE9BQUFBLENBQUNDLENBQURELENBQUlFLE9BQUFBLENBQUdKLFVBQVVFLE9BQUFBLENBQUNDLENBQURELENBQUdHLFFBQUFBLENBQUFBLENBQWhCRCxDQUFqQixDQUFBO1FBQ0VyQyxJQUFBUyxPQUFBQSxDQUFNb0IseUJBQU4sRUFBaUIsRUFBQSxHQUFDSyxzQkFBRCxHQUFBLENBQXVCRCxVQUF2QixDQUFqQnhCLENBREY7TUFJQXlCLE9BQUFEO0lBUEZDLENBQUFBLHNDQUFBQTtJQW9DQXBDLE9BQUF5QyxDQUFBQSxVQUFJdkMsSUFBSnVDLGVBQUFBLG9CQUFBQSxvQkFBa0JDLFdBQUQsRUE5SW5CLEVBOElFRDtBQUFBQSxNQUFBQTs7OztNQTlJRjs7TUE4SWlDOztBQUVqQ0E7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BQ0lBLE9BQUE7SUFaRkEsQ0FBQUEsZ0NBQUFBLENBQUFBO0VBNUlGekMsR0FBQUEsV0FBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5NDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21vZHVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvXG5cbmNsYXNzIE1vZHVsZVxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5pbCwgZnVuY3Rpb24oKXt9KTtcbiAgICAgIC8vIExpbmsgdGhlIHByb3RvdHlwZSBvZiBNb2R1bGUgc3ViY2xhc3Nlc1xuICAgICAgaWYgKHNlbGYgIT09IE9wYWwuTW9kdWxlKSBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kdWxlLCBzZWxmLiQkcHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgbW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgZW5kXG5cbiAgZGVmID09PShvYmplY3QpXG4gICAgcmV0dXJuIGZhbHNlIGlmIGBvYmplY3QgPT0gbnVsbGBcblxuICAgIGBPcGFsLmlzX2Eob2JqZWN0LCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgICMgY2xhc3MgY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiBpdHNlbGZcbiAgICAleHtcbiAgICAgIHZhciB3b3JraW5nID0gc2VsZixcbiAgICAgICAgICBhbmNlc3RvcnMsXG4gICAgICAgICAgaSwgbGVuZ3RoO1xuXG4gICAgICBpZiAod29ya2luZyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob3RoZXIpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gc2VsZikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA8IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIHVubGVzcyBNb2R1bGUgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICBvdGhlciA8IHNlbGZcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBuaWxcbiAgICBlbmRcblxuICAgIGx0ID0gc2VsZiA8IG90aGVyXG4gICAgcmV0dXJuIG5pbCBpZiBsdC5uaWw/XG4gICAgbHQgPyAtMSA6IDFcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX21ldGhvZChuZXduYW1lLCBvbGRuYW1lKVxuICAgIG5ld25hbWUgPSBgJGNvZXJjZV90byhuZXduYW1lLCAje1N0cmluZ30sICd0b19zdHInKWBcbiAgICBvbGRuYW1lID0gYCRjb2VyY2VfdG8ob2xkbmFtZSwgI3tTdHJpbmd9LCAndG9fc3RyJylgXG4gICAgYE9wYWwuYWxpYXMoc2VsZiwgbmV3bmFtZSwgb2xkbmFtZSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19uYXRpdmUobWlkLCBqc2lkID0gbWlkKVxuICAgIGBPcGFsLmFsaWFzX25hdGl2ZShzZWxmLCBtaWQsIGpzaWQpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JzXG4gICAgYE9wYWwuYW5jZXN0b3JzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYXBwZW5kX2ZlYXR1cmVzKGluY2x1ZGVyKVxuICAgIGBPcGFsLmFwcGVuZF9mZWF0dXJlcyhzZWxmLCBpbmNsdWRlcilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYXR0cl9hY2Nlc3NvcigqbmFtZXMpXG4gICAgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgZW5kXG5cbiAgZGVmIGF0dHIoKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMiAmJiAoYXJnc1sxXSA9PT0gdHJ1ZSB8fCBhcmdzWzFdID09PSBmYWxzZSkpIHtcbiAgICAgICAgI3t3YXJuICdvcHRpb25hbCBib29sZWFuIGFyZ3VtZW50IGlzIG9ic29sZXRlZCcsIHVwbGV2ZWw6IDF9XG5cbiAgICAgICAgYXJnc1sxXSA/ICN7YXR0cl9hY2Nlc3NvcihgYXJnc1swXWApfSA6ICN7YXR0cl9yZWFkZXIoYGFyZ3NbMF1gKX07XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cl9yZWFkZXIoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3JlYWRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICAgICAgaXZhciA9IE9wYWwuaXZhcihuYW1lKTtcblxuICAgICAgICAvLyB0aGUgY2xvc3VyZSBoZXJlIGlzIG5lZWRlZCBiZWNhdXNlIG5hbWUgd2lsbCBjaGFuZ2UgYXQgdGhlIG5leHRcbiAgICAgICAgLy8gY3ljbGUsIEkgd2lzaCB3ZSBjb3VsZCB1c2UgbGV0LlxuICAgICAgICB2YXIgYm9keSA9IChmdW5jdGlvbihpdmFyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaXZhcl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzW2l2YXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKGl2YXIpO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHZhcmlhYmxlIGFzIG5pbFxuICAgICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDA7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUgKyAnPScsXG4gICAgICAgICAgICBpdmFyID0gT3BhbC5pdmFyKG5hbWUpO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zdXJlIGhlcmUgaXMgbmVlZGVkIGJlY2F1c2UgbmFtZSB3aWxsIGNoYW5nZSBhdCB0aGUgbmV4dFxuICAgICAgICAvLyBjeWNsZSwgSSB3aXNoIHdlIGNvdWxkIHVzZSBsZXQuXG4gICAgICAgIHZhciBib2R5ID0gKGZ1bmN0aW9uKGl2YXIpe1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbaXZhcl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKGl2YXIpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW1sncmVxJ11dO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAxO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHZhcmlhYmxlIGFzIG5pbFxuICAgICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZChjb25zdCwgcGF0aClcbiAgICAleHtcbiAgICAgIGlmICghI3tPcGFsLmNvbnN0X25hbWU/KGNvbnN0KX0pIHtcbiAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IsIFwiYXV0b2xvYWQgbXVzdCBiZSBjb25zdGFudCBuYW1lOiAje2NvbnN0fVwifVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0aCA9PSBcIlwiKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2VtcHR5IGZpbGUgbmFtZSd9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi4kJGNvbnN0Lmhhc093blByb3BlcnR5KCN7Y29uc3R9KSkge1xuICAgICAgICBpZiAoIXNlbGYuJCRhdXRvbG9hZCkge1xuICAgICAgICAgIHNlbGYuJCRhdXRvbG9hZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICAgICAgICBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dID0geyBwYXRoOiAje3BhdGh9LCBsb2FkZWQ6IGZhbHNlLCByZXF1aXJlZDogZmFsc2UsIHN1Y2Nlc3M6IGZhbHNlLCBleGNlcHRpb246IGZhbHNlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF1dG9sb2FkPyhjb25zdClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQgJiYgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSAmJiAhc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XS5yZXF1aXJlZCAmJiAhc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XS5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkYXV0b2xvYWRbI3tjb25zdH1dLnBhdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNlc3RvcnMgPSBzZWxmLiRhbmNlc3RvcnMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWQgJiYgYW5jZXN0b3JzW2ldLiQkYXV0b2xvYWRbI3tjb25zdH1dICYmICFhbmNlc3RvcnNbaV0uJCRhdXRvbG9hZFsje2NvbnN0fV0ucmVxdWlyZWQgJiYgIWFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XS5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGF1dG9sb2FkWyN7Y29uc3R9XS5wYXRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlc1xuICAgIGBPYmplY3Qua2V5cyhPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0KHNlbGYsIG5hbWUsIGZhbHNlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKS5oYXNPd25Qcm9wZXJ0eShuYW1lKWBcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jbGFzc192YXJpYWJsZShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLCBcImNhbm5vdCByZW1vdmUgI3tuYW1lfSBmb3IgI3tzZWxmfVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0YW50cyhpbmhlcml0ID0gdHJ1ZSlcbiAgICBgT3BhbC5jb25zdGFudHMoc2VsZiwgaW5oZXJpdClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0YW50cyhpbmhlcml0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgbmVzdGluZyA9IChzZWxmLiQkbmVzdGluZyB8fCBbXSkuY29uY2F0KE9wYWwuT2JqZWN0KSxcbiAgICAgICAgICAgIGNvbnN0YW50LCBjb25zdGFudHMgPSB7fSxcbiAgICAgICAgICAgIGksIGlpO1xuXG4gICAgICAgIGZvcihpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGNvbnN0YW50IGluIG5lc3RpbmdbaV0uJCRjb25zdCkge1xuICAgICAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXN0aW5nXG4gICAgYHNlbGYuJCRuZXN0aW5nIHx8IFtdYFxuICBlbmRcblxuICAjIGNoZWNrIGZvciBjb25zdGFudCB3aXRoaW4gY3VycmVudCBzY29wZVxuICAjIGlmIGluaGVyaXQgaXMgdHJ1ZSBvciBzZWxmIGlzIE9iamVjdCwgd2lsbCBhbHNvIGNoZWNrIGFuY2VzdG9yc1xuICBkZWYgY29uc3RfZGVmaW5lZD8obmFtZSwgaW5oZXJpdCA9IHRydWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtzZWxmXSwgbW9kdWxlX2NvbnN0YW50cywgaSwgaWk7XG5cbiAgICAgIC8vIEFkZCB1cCBhbmNlc3RvcnMgaWYgaW5oZXJpdCBpcyB0cnVlXG4gICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoc2VsZikpO1xuXG4gICAgICAgIC8vIEFkZCBPYmplY3QncyBhbmNlc3RvcnMgaWYgaXQncyBhIG1vZHVsZSDigJMgbW9kdWxlcyBoYXZlIG5vIGFuY2VzdG9ycyBvdGhlcndpc2VcbiAgICAgICAgaWYgKHNlbGYuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoW09wYWwuT2JqZWN0XSkuY29uY2F0KE9wYWwuYW5jZXN0b3JzKE9wYWwuT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICAgICAgaWYgKG1vZHVsZS4kJGNvbnN0WyN7bmFtZX1dICE9IG51bGwpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1vZHVsZS4kJGF1dG9sb2FkICYmXG4gICAgICAgICAgbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0gJiZcbiAgICAgICAgICAhbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0ucmVxdWlyZWQgJiZcbiAgICAgICAgICAhbW9kdWxlLiQkYXV0b2xvYWRbI3tuYW1lfV0uc3VjY2Vzc1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfZ2V0KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJzo6JykgPT09IDAgJiYgbmFtZSAhPT0gJzo6Jyl7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBuYW1lLmluZGV4T2YoJzo6JykgIT0gLTEgJiYgbmFtZSAhPSAnOjonYFxuICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJzo6JykuaW5qZWN0KHNlbGYpIHsgfG8sIGN8IG8uY29uc3RfZ2V0KGMpIH1cbiAgICBlbmRcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgcmV0dXJuICQkKFtzZWxmXSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfbG9jYWwoc2VsZiwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfbWlzc2luZyhuYW1lKVxuICAgIGZ1bGxfY29uc3RfbmFtZSA9IHNlbGYgPT0gT2JqZWN0ID8gbmFtZSA6IFwiI3tzZWxmfTo6I3tuYW1lfVwiXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwidW5pbml0aWFsaXplZCBjb25zdGFudCAje2Z1bGxfY29uc3RfbmFtZX1cIiwgbmFtZSlcbiAgZW5kXG5cbiAgZGVmIGNvbnN0X3NldChuYW1lLCB2YWx1ZSlcbiAgICBuYW1lID0gT3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgaWYgbmFtZSAhfiBPcGFsOjpDT05TVF9OQU1FX1JFR0VYUCB8fCBuYW1lLnN0YXJ0X3dpdGg/KCc6OicpXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpXG4gICAgZW5kXG5cbiAgICBgT3BhbC5jb25zdF9zZXQoc2VsZiwgbmFtZSwgdmFsdWUpYFxuXG4gICAgdmFsdWVcbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19jb25zdGFudChjb25zdF9uYW1lKVxuICBlbmRcblxuICBkZWYgZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgbWV0aG9kID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgYSBQcm9jIG9iamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgZW5kXG5cbiAgICBibG9jayB8fD0gY2FzZSBtZXRob2RcbiAgICAgICAgICAgICAgd2hlbiBQcm9jXG4gICAgICAgICAgICAgICAgbWV0aG9kXG5cbiAgICAgICAgICAgICAgd2hlbiBNZXRob2RcbiAgICAgICAgICAgICAgICBgI3ttZXRob2QudG9fcHJvY30uJCR1bmJvdW5kYFxuXG4gICAgICAgICAgICAgIHdoZW4gVW5ib3VuZE1ldGhvZFxuICAgICAgICAgICAgICAgIC0+KCphcmdzKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZCA9IG1ldGhvZC5iaW5kKHNlbGYpXG4gICAgICAgICAgICAgICAgICBib3VuZC5jYWxsKCphcmdzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tibG9jay5jbGFzc30gKGV4cGVjdGVkIFByb2MvTWV0aG9kKVwiXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgaWQgPSAnJCcgKyBuYW1lO1xuXG4gICAgICBibG9jay4kJGpzaWQgICAgICAgID0gbmFtZTtcbiAgICAgIGJsb2NrLiQkcyAgICAgICAgICAgPSBudWxsO1xuICAgICAgYmxvY2suJCRkZWYgICAgICAgICA9IGJsb2NrO1xuICAgICAgYmxvY2suJCRkZWZpbmVfbWV0aCA9IHRydWU7XG5cbiAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYmxvY2spO1xuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfbWV0aG9kKCpuYW1lcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBPcGFsLnJkZWYoc2VsZiwgXCIkXCIgKyBuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzP1xuICAgIGAhIXNlbGYuJCRpc19zaW5nbGV0b25gXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlKCptb2RzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5hcHBlbmRfZmVhdHVyZXMgc2VsZn07XG4gICAgICAgICN7YG1vZGAuaW5jbHVkZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5jbHVkZWRfbW9kdWxlc1xuICAgIGBPcGFsLmluY2x1ZGVkX21vZHVsZXMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhtb2QpXG4gICAgJXh7XG4gICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaWksIG1vZDIsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZDIgPSBhbmNlc3RvcnNbaV07XG4gICAgICAgIGlmIChtb2QyID09PSBtb2QgJiYgbW9kMiAhPT0gc2VsZikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9tZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZi4kJHByb3RvdHlwZVsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKCFtZXRoIHx8IG1ldGguJCRzdHViKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLm5hbWV9J1wiLCBuYW1lKX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje1VuYm91bmRNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZHMoaW5jbHVkZV9zdXBlciA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2luY2x1ZGVfc3VwZXJ9KSkge1xuICAgICAgICByZXR1cm4gT3BhbC5pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5jbHVkZWQobW9kKVxuICBlbmRcblxuICBkZWYgZXh0ZW5kZWQobW9kKVxuICBlbmRcblxuICBkZWYgZXh0ZW5kX29iamVjdChvYmplY3QpXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfYWRkZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfdW5kZWZpbmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZXZhbCgqYXJncywgJmJsb2NrKVxuICAgIGlmIGJsb2NrLm5pbD8gJiYgYCEhT3BhbC5jb21waWxlYFxuICAgICAgS2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSBPcGFsLmNvbXBpbGUgc3RyaW5nLCBjb21waWxpbmdfb3B0aW9uc1xuICAgICAgYmxvY2sgPSBLZXJuZWwucHJvYyBkb1xuICAgICAgICAleHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsKGNvbXBpbGVkKTtcbiAgICAgICAgICB9KShzZWxmKVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNpZiBhcmdzLmFueT9cbiAgICAgIEtlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXFxuICBOT1RFOklmIHlvdSB3YW50IHRvIGVuYWJsZSBwYXNzaW5nIGEgU3RyaW5nIGFyZ3VtZW50IHBsZWFzZSBhZGQgXFxcInJlcXVpcmUgJ29wYWwtcGFyc2VyJ1xcXCIgdG8geW91ciBzY3JpcHRcXG5cIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIFtzZWxmXSk7XG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbGFzc19ldmFsIG1vZHVsZV9ldmFsXG5cbiAgZGVmIG1vZHVsZV9leGVjKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIExvY2FsSnVtcEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2tfc2VsZiA9IGJsb2NrLiQkcywgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICBibG9jay4kJHMgPSBibG9ja19zZWxmO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgY2xhc3NfZXhlYyBtb2R1bGVfZXhlY1xuXG4gIGRlZiBtZXRob2RfZGVmaW5lZD8obWV0aG9kKVxuICAgICV4e1xuICAgICAgdmFyIGJvZHkgPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG1ldGhvZF07XG4gICAgICByZXR1cm4gKCEhYm9keSkgJiYgIWJvZHkuJCRzdHViO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9mdW5jdGlvbigqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtZXRoID0gbWV0aG9kc1tpXSxcbiAgICAgICAgICAgICAgaWQgICA9ICckJyArIG1ldGgsXG4gICAgICAgICAgICAgIGZ1bmMgPSBzZWxmLiQkcHJvdG90eXBlW2lkXTtcblxuICAgICAgICAgIE9wYWwuZGVmcyhzZWxmLCBpZCwgZnVuYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmFtZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRmdWxsX25hbWUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRmdWxsX25hbWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSwgYmFzZSA9IHNlbGY7XG5cbiAgICAgIHdoaWxlIChiYXNlKSB7XG4gICAgICAgIC8vIEdpdmUgdXAgaWYgYW55IG9mIHRoZSBhbmNlc3RvcnMgaXMgdW5uYW1lZFxuICAgICAgICBpZiAoYmFzZS4kJG5hbWUgPT09IG5pbCB8fCBiYXNlLiQkbmFtZSA9PSBudWxsKSByZXR1cm4gbmlsO1xuXG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGJhc2UuJCRuYW1lKTtcblxuICAgICAgICBiYXNlID0gYmFzZS4kJGJhc2VfbW9kdWxlO1xuXG4gICAgICAgIGlmIChiYXNlID09PSBPcGFsLk9iamVjdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lID0gcmVzdWx0LmpvaW4oJzo6Jyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIGlmIChtb2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAwLCBleHBlY3RlZCAxKyknfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLnByZXBlbmRfZmVhdHVyZXMgc2VsZn07XG4gICAgICAgICN7YG1vZGAucHJlcGVuZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmRfZmVhdHVyZXMocHJlcGVuZGVyKVxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tzZWxmLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5wcmVwZW5kX2ZlYXR1cmVzKHNlbGYsIHByZXBlbmRlcilcbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jb25zdChuYW1lKVxuICAgIGBPcGFsLmNvbnN0X3JlbW92ZShzZWxmLCBuYW1lKWBcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgT3BhbC5Nb2R1bGUuJG5hbWUuY2FsbChzZWxmKWAgfHwgXCIjPCN7YHNlbGYuJCRpc19tb2R1bGUgPyAnTW9kdWxlJyA6ICdDbGFzcydgfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBhbGlhcyBpbnNwZWN0IHRvX3NcblxuICBkZWYgdW5kZWZfbWV0aG9kKCpuYW1lcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBPcGFsLnVkZWYoc2VsZiwgXCIkXCIgKyBuYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgY29uc3RzID0gY29uc3RhbnRzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnICYmIG5hbWUgIT09ICdjb25zdHJ1Y3RvcicgJiYgISN7Y29uc3RzLmluY2x1ZGU/KGBuYW1lYCl9KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gc3VwZXJcbiAgICBjb3B5LmNvcHlfY2xhc3NfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X2NvbnN0YW50cyhzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGNvcHlfY2xhc3NfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvdGhlci4kJGN2YXJzKSB7XG4gICAgICAgIHNlbGYuJCRjdmFyc1tuYW1lXSA9IG90aGVyLiQkY3ZhcnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9jb25zdGFudHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgbmFtZSwgb3RoZXJfY29uc3RhbnRzID0gb3RoZXIuJCRjb25zdDtcblxuICAgICAgZm9yIChuYW1lIGluIG90aGVyX2NvbnN0YW50cykge1xuICAgICAgICBPcGFsLmNvbnN0X3NldChzZWxmLCBuYW1lLCBvdGhlcl9jb25zdGFudHNbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlZmluZShtb2QsICZibG9jaylcbiAgICBzLCBtLCBtb2RfaWQgPSBzZWxmLCBuaWwsIG5pbFxuICAgICV4e1xuICAgICAgbW9kX2lkID0gT3BhbC5pZChtb2QpO1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLiQkcmVmaW5lX21vZHVsZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2VsZi4kJHJlZmluZV9tb2R1bGVzID0ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlbGYuJCRyZWZpbmVfbW9kdWxlc1ttb2RfaWRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG0gPSBzZWxmLiQkcmVmaW5lX21vZHVsZXNbbW9kX2lkXSA9ICN7OjpNb2R1bGUubmV3fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW21vZF9pZF07XG4gICAgICB9XG4gICAgfVxuICAgIG0uZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QgOmluc3BlY3QgZG9cbiAgICAgIFwiIzxyZWZpbmVtZW50OiN7bW9kLmluc3BlY3R9QCN7cy5pbnNwZWN0fT5cIlxuICAgIGVuZFxuICAgIG0uY2xhc3NfZXhlYygmYmxvY2spXG4gICAgbVxuICBlbmRcblxuICAjIENvbXBpbGVyIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxuICBkZWYgdXNpbmcobW9kKVxuICAgIHJhaXNlICdNb2R1bGUjdXNpbmcgaXMgbm90IHBlcm1pdHRlZCBpbiBtZXRob2RzJ1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TW9kdWxlPiIsImFsbG9jYXRlIiwic2VsZiIsImluaXRpYWxpemUiLCJibG9ja19naXZlbj8iLCJtb2R1bGVfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsIj09PSIsIm9iamVjdCIsIjwiLCJvdGhlciIsIk1vZHVsZSIsInJhaXNlIiwiVHlwZUVycm9yIiwiPD0iLCIkcmV0X29yXzEiLCJlcXVhbD8iLCI+IiwiPj0iLCIkcmV0X29yXzIiLCI8PT4iLCJsdCIsIm5pbD8iLCItMSIsIjEiLCJhbGlhc19tZXRob2QiLCJuZXduYW1lIiwib2xkbmFtZSIsIlN0cmluZyIsImFsaWFzX25hdGl2ZSIsIm1pZCIsImpzaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJpbmNsdWRlciIsImF0dHJfYWNjZXNzb3IiLCJhdHRyX3JlYWRlciIsIm5hbWVzIiwiYXR0cl93cml0ZXIiLCJhdHRyIiwid2FybiIsImFyZ3MiLCJhdXRvbG9hZCIsImNvbnN0JCIsInBhdGgiLCJPcGFsIiwiY29uc3RfbmFtZT8iLCJOYW1lRXJyb3IiLCJBcmd1bWVudEVycm9yIiwiYXV0b2xvYWQ/IiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY2xhc3NfdmFyaWFibGVfc2V0IiwidmFsdWUiLCJjbGFzc192YXJpYWJsZV9kZWZpbmVkPyIsInJlbW92ZV9jbGFzc192YXJpYWJsZSIsImNvbnN0YW50cyIsImluaGVyaXQiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwiT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAiLCJuZXciLCJjb25zdF9nZXQiLCJpbmplY3QiLCJzcGxpdCIsImJsb2NrIGluIGNvbnN0X2dldCIsIm8iLCJjIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25zdF9nZXQiLCJjb25zdF9taXNzaW5nIiwiZnVsbF9jb25zdF9uYW1lIiwiPT0iLCJPYmplY3QiLCJjb25zdF9zZXQiLCIkcmV0X29yXzMiLCIhfiIsInN0YXJ0X3dpdGg/IiwicHVibGljX2NvbnN0YW50IiwiY29uc3RfbmFtZSIsImRlZmluZV9tZXRob2QiLCJtZXRob2QiLCIkcmV0X29yXzQiLCJQcm9jIiwiTWV0aG9kIiwiVW5ib3VuZE1ldGhvZCIsImJsb2NrIGluIGRlZmluZV9tZXRob2QiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9tZXRob2QiLCJib3VuZCIsImJpbmQiLCJjYWxsIiwiY2xhc3MiLCJyZW1vdmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzPyIsImluY2x1ZGUiLCJpbmNsdWRlZCIsImluY2x1ZGVkX21vZHVsZXMiLCJpbmNsdWRlPyIsIm1vZCIsImluc3RhbmNlX21ldGhvZCIsImluc3RhbmNlX21ldGhvZHMiLCJpbmNsdWRlX3N1cGVyIiwiZXh0ZW5kZWQiLCJleHRlbmRfb2JqZWN0IiwibWV0aG9kX2FkZGVkIiwibWV0aG9kX3JlbW92ZWQiLCJtZXRob2RfdW5kZWZpbmVkIiwiJHJldF9vcl81IiwiMyIsImNvdmVyPyIsInNpemUiLCJLZXJuZWwiLCJzdHJpbmciLCJmaWxlIiwiX2xpbmVubyIsImRlZmF1bHRfZXZhbF9vcHRpb25zIiwiJHJldF9vcl82IiwiY29tcGlsaW5nX29wdGlvbnMiLCJfX09QQUxfQ09NUElMRVJfQ09ORklHX18iLCJtZXJnZSIsImNvbXBpbGVkIiwiY29tcGlsZSIsInByb2MiLCJibG9jayBpbiBtb2R1bGVfZXZhbCIsImJsb2NrICgyIGxldmVscykgaW4gbW9kdWxlX2V2YWwiLCJhbnk/IiwibW9kdWxlX2V4ZWMiLCJMb2NhbEp1bXBFcnJvciIsIm1ldGhvZF9kZWZpbmVkPyIsIm1vZHVsZV9mdW5jdGlvbiIsInByZXBlbmQiLCJwcmVwZW5kX2ZlYXR1cmVzIiwicHJlcGVuZGVkIiwicHJlcGVuZGVyIiwicmVtb3ZlX2NvbnN0IiwidG9fcyIsIiRyZXRfb3JfNyIsIl9faWRfXyIsIjE2IiwidW5kZWZfbWV0aG9kIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiY29uc3RzIiwiZHVwIiwiY29weSIsImNvcHlfY2xhc3NfdmFyaWFibGVzIiwiY29weV9jb25zdGFudHMiLCJyZWZpbmUiLCJzIiwibSIsIm1vZF9pZCIsImRlZmluZV9zaW5nbGV0b25fbWV0aG9kIiwiYmxvY2sgaW4gcmVmaW5lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWZpbmUiLCJpbnNwZWN0IiwiY2xhc3NfZXhlYyIsInVzaW5nIl0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQyxVQUFJQyxJQUFKRCxlQUFBQSxxQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFORUEsQ0FBQUEsZ0NBQUFBOztBQVNBRSxJQUFBQSw4QkFBQUEsdUJBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFlO01BQ2IsSUFBdUJDLGVBQXZCO1FBQUFELE9BQUFFLE1BQUFILElBQUFHLGVBQUFBLEVBQUFBLEVBQUFBLEVBQWFDLEtBQURDLFNBQUFBLENBQUFBLENBQVpGO01BQUE7UUFiSkYsT0FBQTtNQWFJO0lBREZBLENBQUFBLGtDQUFBQTs7QUFJQUssSUFBQUEsdUJBQUFBLHNCQUFBQSxTQUFRQyxNQUFSRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFpQkEsY0FBakIsQ0FBQTtRQUFBLE9BQU8sS0FBUDtNQUVBQSxPQUFDQSx1QkFBREE7SUFIRkEsQ0FBQUEsaUNBQUFBOztBQU1BRSxJQUFBQSxxQkFBQUEsZ0JBQUFBLFNBQU1DLEtBQU5EO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFBLFFBQU9FLHNCQUFPSixRQUFBQSxDQUFJRyxLQUFKSCxDQUFkLENBQUE7TUFBQTtRQUNFTixJQUFBVyxPQUFBQSxDQUFNQyx5QkFBTixFQUFpQkosZ0NBQWpCRztNQURGOztBQU1KSDtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtB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QUFBQSxDQUF5QixTQUF6QkEsQ0FBQUEsRUFBa0NDLGlCQUFBQSxFQUFBQzs7UUFDakNBLE9BQUEsRUFBQSxHQUFDQSxlQUFELEdBQUEsQ0FBZ0J0RCxHQUFHdUQsU0FBQUEsQ0FBQUEsQ0FBbkIsQ0FBQSxHQUE0QkQsR0FBNUIsR0FBQSxDQUErQkwsQ0FBQ00sU0FBQUEsQ0FBQUEsQ0FBaEMsQ0FBQSxHQUF5Q0QsR0FEUkQsbUJBQUFBLGtCQUFBQSxNQUFsQ0Q7TUFHQUksTUFBRE4sQ0FBQ00sY0FBQUEsRUFBQUEsRUFBQUEsRUFBYXhKLEtBQURDLFNBQUFBLENBQUFBLENBQVp1SjtNQUNEUixPQUFBRTtJQWxCRkYsQ0FBQUEsK0JBQUFBO0lBc0JBdEosT0FBQStKLENBQUFBLHlCQUFBQSxtQkFBQUEsaUJBQVV6RCxHQUFWeUQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE3SixJQUFBVyxPQUFBQSxDQUFNa0osMENBQU5sSjtJQURGa0osQ0FBQUEsOEJBQUFBLENBQUFBO0VBdHRCRi9KLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTcyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jbGFzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL21vZHVsZSdcblxuY2xhc3MgQ2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmhlcml0ZWQoY2xzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3JpZ2luYWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG9yaWdpbmFsKVxuICAgICV4e1xuICAgICAgc2VsZi4kJG5hbWUgPSBudWxsO1xuICAgICAgc2VsZi4kJGZ1bGxfbmFtZSA9IG51bGw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV3KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XG4gICAgICBPcGFsLnNlbmQob2JqZWN0LCBvYmplY3QuJGluaXRpYWxpemUsIGFyZ3MsIGJsb2NrKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VwZXJjbGFzc1xuICAgIGBzZWxmLiQkc3VwZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XG5cbiAgICAgIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiN7YHNpbmdsZXRvbl9vZmAubmFtZX0+XCJ9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2luZ2xldG9uX29mKSB7XG4gICAgICAgIC8vIGEgc2luZ2xldG9uIGNsYXNzIGNyZWF0ZWQgZnJvbSBhbiBvYmplY3RcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiM8I3tgc2luZ2xldG9uX29mLiQkY2xhc3NgLm5hbWV9OjB4I3tgT3BhbC5pZChzaW5nbGV0b25fb2YpYC50b19zKDE2KX0+PlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c3VwZXIoKX07XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbnNwZWN0IHRvX3NcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDbGFzcz4iLCJuZXciLCJzdXBlcmNsYXNzIiwiT2JqZWN0IiwiYmxvY2tfZ2l2ZW4/IiwiY2xhc3NfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImFsbG9jYXRlIiwiaW5oZXJpdGVkIiwiY2xzIiwiaW5pdGlhbGl6ZV9kdXAiLCJvcmlnaW5hbCIsImluaXRpYWxpemVfY29weSIsInRvX3MiLCJuYW1lIiwiMTYiXSwibWFwcGluZ3MiOiJBQUFBQSxnREFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUMsVUFBSUgsSUFBSkcsVUFBQUEsZUFBQUEsU0FBYUMsVUFBYkQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBa0M7O01BQXJCO01BQUEsZUFBYUUsc0JBQWI7TUFBQTs7QUFFZkY7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLE1BQVEsYUFBQSxJQUE4QkcsZUFBOUI7UUFBQUgsT0FBT0ksTUFBUEosQ0FBQ0EsS0FBREEsQ0FBT0ksY0FBQUEsRUFBQUEsRUFBQUEsRUFBYUMsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBWkY7TUFBUDtRQUFBSixPQUFBO01BQUEsQ0FBQTtBQUNSQTtBQUNBQTtJQVZFQSxDQUFBQSwyQkFBQUE7O0FBYUFPLElBQUFBLDRCQUFBQSxvQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsK0JBQUFBOztBQVFBQyxJQUFBQSw2QkFBQUEscUJBQUFBLHFCQUFjQyxHQUFkRDtBQUFBQSxNQUFBQTs7TUF4QkZBLE9BQUE7SUF3QkVBLENBQUFBLGdDQUFBQTs7QUFHQUUsSUFBQUEsa0NBQUFBLDBCQUFBQSwwQkFBbUJDLFFBQW5CRDtBQUFBQSxNQUFBQTs7O01BQ0ViLElBQUFlLGlCQUFBQSxDQUFnQkQsUUFBaEJDOztBQUVKRjtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSxxQ0FBQUE7O0FBUUFWLElBQUFBLHVCQUFBQSxlQUFBQSxTQW5DRixFQW1DRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBZTs7TUFuQ2pCOztNQW1DVTs7QUFFVkEsbUJBQXFCSCxJQUFBVSxVQUFBQSxDQUFBQSxDQUFTUDtBQUM5QkE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsMkJBQUFBOztBQVFBQyxJQUFBQSw4QkFBQUEsc0JBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsbUJBQURBO0lBREZBLENBQUFBLGlDQUFBQTs7QUFJQVksSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOztBQUVGQTs7QUFFQUE7QUFDQUEsZUFBaUIsRUFBQSxHQUFDQSxVQUFELEdBQUEsQ0FBV0EsQ0FBQ0EsWUFBREEsQ0FBY0MsTUFBQUEsQ0FBQUEsQ0FBekIsQ0FBQSxHQUErQkQsR0FBR0E7QUFDbkRBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWlCLEVBQUEsR0FBQ0EsWUFBRCxHQUFBLENBQWFBLENBQUNBLG9CQUFEQSxDQUFzQkMsTUFBQUEsQ0FBQUEsQ0FBbkMsQ0FBQSxHQUF5Q0QsS0FBekMsR0FBQSxDQUE4Q0EsQ0FBQ0EscUJBQURBLENBQXVCQSxNQUFBQSxDQUFNRSxFQUFORixDQUFyRSxDQUFBLEdBQStFQSxJQUFJQTtBQUNwR0E7O0FBRUFBLGFBQWUsT0FBQWhCLElBQUEsRUFBQSxxREFBQSxRQUFBLEVBQUEsRUFBQSxFQUFBLElBQUEsQ0FBUWdCO0FBQ3ZCQTtJQWJFQSxDQUFBQSwyQkFBQUE7SUFnQkFkLE9BQUEsYUFBTSxTQUFOLEVBQWMsTUFBZDtFQTdERkEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQwODQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jhc2ljX29iamVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBCYXNpY09iamVjdFxuICBkZWYgaW5pdGlhbGl6ZSgqKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYHNlbGYgPT09IG90aGVyYFxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuXG4gIGRlZiBfX2lkX19cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaWQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgICAgfVxuICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLCAnJCRpZCcsIE9wYWwudWlkKCkpO1xuICAgICAgcmV0dXJuIHNlbGYuJCRpZDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBfX3NlbmRfXyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgZnVuYyA9IHNlbGZbJyQnICsgc3ltYm9sXVxuXG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGZ1bmMuJCRwID0gYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kbWV0aG9kX21pc3NpbmcuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRtZXRob2RfbWlzc2luZy5hcHBseShzZWxmLCBbc3ltYm9sXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICFcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIT0ob3RoZXIpXG4gICAgIShzZWxmID09IG90aGVyKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXZhbCgqYXJncywgJmJsb2NrKVxuICAgIGlmIGJsb2NrLm5pbD8gJiYgYCEhT3BhbC5jb21waWxlYFxuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gOjpPcGFsLmNvbXBpbGUgc3RyaW5nLCBjb21waWxpbmdfb3B0aW9uc1xuICAgICAgYmxvY2sgPSA6Oktlcm5lbC5wcm9jIGRvXG4gICAgICAgICV4e1xuICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWwoY29tcGlsZWQpO1xuICAgICAgICAgIH0pKHNlbGYpXG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5zaXplfSBmb3IgMClcIlxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgb2xkID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgLy8gTmVlZCB0byBwYXNzICQkZXZhbCBzbyB0aGF0IG1ldGhvZCBkZWZpbml0aW9ucyBrbm93IGlmIHRoaXMgaXNcbiAgICAgIC8vIGJlaW5nIGRvbmUgb24gYSBjbGFzcy9tb2R1bGUuIENhbm5vdCBiZSBjb21waWxlciBkcml2ZW4gc2luY2VcbiAgICAgIC8vIHNlbmQoOmluc3RhbmNlX2V2YWwpIG5lZWRzIHRvIHdvcmsuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBvbGQ7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfZXhlYygqYXJncywgJmJsb2NrKVxuICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICAgIHNlbGYuJCRldmFsID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX21pc3Npbmcoc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgIG1lc3NhZ2UgPSBpZiBgc2VsZi4kaW5zcGVjdCAmJiAhc2VsZi4kaW5zcGVjdC4kJHN0dWJgXG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3R9OiN7YHNlbGYuJCRjbGFzc2B9XCJcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIFwidW5kZWZpbmVkIG1ldGhvZCBgI3tzeW1ib2x9JyBmb3IgI3tgc2VsZi4kJGNsYXNzYH1cIlxuICAgICAgICAgICAgICBlbmRcblxuICAgIDo6S2VybmVsLnJhaXNlIDo6Tm9NZXRob2RFcnJvci5uZXcobWVzc2FnZSwgc3ltYm9sKVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2RfbmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6QmFzaWNPYmplY3Q+IiwiaW5pdGlhbGl6ZSIsIj09Iiwib3RoZXIiLCJlcWw/Iiwic2VsZiIsIl9faWRfXyIsIl9fc2VuZF9fIiwic3ltYm9sIiwiISIsIiE9IiwiaW5zdGFuY2VfZXZhbCIsIiRyZXRfb3JfMSIsImJsb2NrIiwibmlsPyIsIjEiLCIzIiwiY292ZXI/IiwiYXJncyIsInNpemUiLCJLZXJuZWwiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJzdHJpbmciLCJmaWxlIiwiX2xpbmVubyIsImRlZmF1bHRfZXZhbF9vcHRpb25zIiwiJHJldF9vcl8yIiwiY29tcGlsaW5nX29wdGlvbnMiLCJfX09QQUxfQ09NUElMRVJfQ09ORklHX18iLCJtZXJnZSIsImNvbXBpbGVkIiwiT3BhbCIsImNvbXBpbGUiLCJwcm9jIiwiYmxvY2sgaW4gaW5zdGFuY2VfZXZhbCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zdGFuY2VfZXZhbCIsImFueT8iLCJpbnN0YW5jZV9leGVjIiwic2luZ2xldG9uX21ldGhvZF9hZGRlZCIsInNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCIsInNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkIiwibWV0aG9kX21pc3NpbmciLCJtZXNzYWdlIiwiaW5zcGVjdCIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJyZXNwb25kX3RvX21pc3Npbmc/IiwibWV0aG9kX25hbWUiLCJpbmNsdWRlX2FsbCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVEQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7O0FBQ0VDLElBQUFBLDhCQUFBQSw0QkFBQUEsc0JBREYsRUFDRUE7QUFBQUEsTUFBQUE7Ozs7TUFERjs7TUFDaUI7TUFEakJBLE9BQUE7SUFDRUEsQ0FBQUEsd0NBQUFBOztBQUdBQyxJQUFBQSxzQkFBQUEsd0JBQUFBLFNBQU9DLEtBQVBEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxjQUFEQTtJQURGQSxDQUFBQSxtQ0FBQUE7O0FBSUFFLElBQUFBLHdCQUFBQSwwQkFBQUEsU0FBU0QsS0FBVEM7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFDLElBQUtILE9BQUFBLENBQUdDLEtBQUhEO0lBRFBFLENBQUFBLHFDQUFB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QSxvQkFBRCxHQUFBLENBQXFCbEMsTUFBckIsQ0FBQSxHQUE0QmtDLFFBQTVCLEdBQUEsQ0FBcUNBLFlBQXJDO01BSEYsQ0FBQTtNQU1WQSxPQUFBdEIsSUFBQSxJQUFBQSxXQUFRQyxPQUFBQSxDQUFPd0IsSUFBQSxJQUFBQSxrQkFBZUMsS0FBQUEsQ0FBS0gsT0FBcEIsRUFBNkJuQyxNQUFkc0MsQ0FBdEJ6QjtJQVBWcUIsQ0FBQUEsNkNBQUFBO0lBVUExQyxPQUFBK0MsQ0FBQUEsdUNBQUFBLDBDQUFBQSxTQUF3QkMsV0FBRCxFQUFjQyxXQUFyQ0Y7QUFBQUEsTUFBQUE7Ozs7TUFBcUM7TUFBQSxnQkFBYyxLQUFkO01BQUE7TUFDbkNBLE9BQUE7SUFERkEsQ0FBQUEsc0RBQUFBLENBQUFBO0VBbEpGL0MsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjQzNDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvLCByZXNwb25kX3RvXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIG1ldGhvZF9taXNzaW5nKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICByYWlzZSBOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdH1cIiwgc3ltYm9sLCBhcmdzKSwgbmlsLCBjYWxsZXIoMSlcbiAgZW5kXG5cbiAgZGVmID1+KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIX4ob2JqKVxuICAgICEoc2VsZiA9fiBvYmopXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgb2JqZWN0X2lkID09IG90aGVyLm9iamVjdF9pZCB8fCBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICAvLyBzZXQgZ3VhcmQgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgc2VsZi4kJGNvbXBhcmFibGUgPSB0cnVlO1xuXG4gICAgICB2YXIgeCA9ICN7c2VsZiA9PSBvdGhlcn07XG5cbiAgICAgIGlmICh4ICYmIHggIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKCFtZXRoIHx8IG1ldGguJCRzdHViKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmLmNsYXNzfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19tZXRob2RzKGFsbCA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2FsbH0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hKX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIHJldHVybiBbb2JqZWN0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdF9leGl0KCZibG9jaylcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG4gICAgJF9fYXRfZXhpdF9fIDw8IGJsb2NrXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGxlcihzdGFydCA9IDEsIGxlbmd0aCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBzdGFjaywgcmVzdWx0O1xuXG4gICAgICBzdGFjayA9IG5ldyBFcnJvcigpLiRiYWNrdHJhY2UoKTtcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gI3tzdGFydH0gKyAxLCBpaSA9IHN0YWNrLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgaWYgKCFzdGFja1tpXS5tYXRjaCgvcnVudGltZVxcLmpzLykpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzdGFja1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggIT0gbmlsKSByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xhc3NcbiAgICBgc2VsZi4kJGNsYXNzYFxuICBlbmRcblxuICBkZWYgY29weV9pbnN0YW5jZV92YXJpYWJsZXMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKSwgaSwgaWksIG5hbWU7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApICE9PSAnJCcgJiYgb3RoZXIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBzZWxmW25hbWVdID0gb3RoZXJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3B5X3NpbmdsZXRvbl9tZXRob2RzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGksIG5hbWUsIG5hbWVzLCBsZW5ndGg7XG5cbiAgICAgIGlmIChvdGhlci5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykpIHtcbiAgICAgICAgdmFyIG90aGVyX3NpbmdsZXRvbl9jbGFzcyA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvdGhlcik7XG4gICAgICAgIHZhciBzZWxmX3NpbmdsZXRvbl9jbGFzcyA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKTtcbiAgICAgICAgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChuYW1lKSkge1xuICAgICAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGVbbmFtZV0gPSBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGVbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCA9IE9iamVjdC5hc3NpZ24oe30sIG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJGNvbnN0KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFxuICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlLFxuICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXIpLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gJyQnICYmIG5hbWUuY2hhckF0KDEpICE9PSAnJCcgJiYgb3RoZXIuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBzZWxmW25hbWVdID0gb3RoZXJbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgY29weSA9IHNlbGYuY2xhc3MuYWxsb2NhdGVcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmNvcHlfc2luZ2xldG9uX21ldGhvZHMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfY2xvbmUoc2VsZilcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY2xvbmUob3RoZXIpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICBlbmRcblxuICBkZWYgZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QobmFtZSwgbWV0aG9kID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgc2luZ2xldG9uX2NsYXNzLmRlZmluZV9tZXRob2QobmFtZSwgbWV0aG9kLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfZHVwKG90aGVyKVxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGVudW1fZm9yKG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgIEVudW1lcmF0b3IuZm9yKHNlbGYsIG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgYWxpYXMgdG9fZW51bSBlbnVtX2ZvclxuXG4gIGRlZiBlcXVhbD8ob3RoZXIpXG4gICAgYHNlbGYgPT09IG90aGVyYFxuICBlbmRcblxuICBkZWYgZXhpdChzdGF0dXMgPSB0cnVlKVxuICAgICRfX2F0X2V4aXRfXyB8fD0gW11cblxuICAgIHVudGlsICRfX2F0X2V4aXRfXy5lbXB0eT9cbiAgICAgIGJsb2NrID0gJF9fYXRfZXhpdF9fLnBvcFxuICAgICAgYmxvY2suY2FsbFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc3RhdHVzLiQkaXNfYm9vbGVhbikge1xuICAgICAgICBzdGF0dXMgPSBzdGF0dXMgPyAwIDogMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9ICRjb2VyY2VfdG8oc3RhdHVzLCAje0ludGVnZXJ9LCAndG9faW50JylcbiAgICAgIH1cblxuICAgICAgT3BhbC5leGl0KHN0YXR1cyk7XG4gICAgfVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZXh0ZW5kKCptb2RzKVxuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbiA9ICN7c2luZ2xldG9uX2NsYXNzfTtcblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5hcHBlbmRfZmVhdHVyZXMgYHNpbmdsZXRvbmB9O1xuICAgICAgICAje2Btb2RgLmV4dGVuZF9vYmplY3Qgc2VsZn07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZ2V0cygqYXJncylcbiAgICAkc3RkaW4uZ2V0cygqYXJncylcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBfX2lkX19cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpdnMgPSAnJ1xuICAgIGluc3RhbmNlX3ZhcmlhYmxlcy5lYWNoIGRvIHxpfFxuICAgICAgaXZzICs9IFwiICN7aX09I3tpbnN0YW5jZV92YXJpYWJsZV9nZXQoaSkuaW5zcGVjdH1cIlxuICAgIGVuZFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OjB4I3tfX2lkX18udG9fcygxNil9I3tpdnN9PlwiXG4gIHJlc2N1ZVxuICAgIFwiIzwje3NlbGYuY2xhc3N9OjB4I3tfX2lkX18udG9fcygxNil9PlwiXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgJXh7XG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MgJiYgIWtsYXNzLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnY2xhc3Mgb3IgbW9kdWxlIHJlcXVpcmVkJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2xhc3MgPT09IGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZiwgbmFtZS5zdWJzdHIoMSkpYFxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGl2YXIgPSBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldO1xuXG4gICAgICByZXR1cm4gaXZhciA9PSBudWxsID8gbmlsIDogaXZhcjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBzZWxmW09wYWwuaXZhcihuYW1lLnN1YnN0cigxKSldID0gdmFsdWVgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gT3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICB2YXIga2V5ID0gT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKSxcbiAgICAgICAgICB2YWw7XG4gICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhbCA9IHNlbGZba2V5XTtcbiAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBOYW1lRXJyb3IsIFwiaW5zdGFuY2UgdmFyaWFibGUgI3tuYW1lfSBub3QgZGVmaW5lZFwiXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaXZhcjtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUuY2hhckF0KDApICE9PSAnJCcpIHtcbiAgICAgICAgICBpZiAobmFtZS5zdWJzdHIoLTEpID09PSAnJCcpIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl2YXIgPSBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCgnQCcgKyBpdmFyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEludGVnZXIodmFsdWUsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc3RyLCBiYXNlX2RpZ2l0cztcblxuICAgICAgaWYgKCF2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAoYmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnYmFzZSBzcGVjaWZpZWQgZm9yIG5vbiBzdHJpbmcgdmFsdWUnfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBuaWwgaW50byBJbnRlZ2VyXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgI3tyYWlzZSBGbG9hdERvbWFpbkVycm9yLCB2YWx1ZX1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgje3ZhbHVlLnJlc3BvbmRfdG8/KDp0b19pbnQpfSkge1xuICAgICAgICAgIGkgPSAje3ZhbHVlLnRvX2ludH07XG4gICAgICAgICAgaWYgKGkgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje09wYWwuY29lcmNlX3RvISh2YWx1ZSwgSW50ZWdlciwgOnRvX2kpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSBcIjBcIikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYXNlID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2UgPSAkY29lcmNlX3RvKGJhc2UsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKGJhc2UgPT09IDEgfHwgYmFzZSA8IDAgfHwgYmFzZSA+IDM2KSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0ciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KS8sIGZ1bmN0aW9uIChfLCBoZWFkLCBmbGFnKSB7XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMikge1xuICAgICAgICAgICAgYmFzZSA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8tYnJlYWtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSA4KSB7XG4gICAgICAgICAgICBiYXNlID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTApIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIGJhc2UgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICB9XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH0pO1xuXG4gICAgICBiYXNlID0gKGJhc2UgPT09IDAgPyAxMCA6IGJhc2UpO1xuXG4gICAgICBiYXNlX2RpZ2l0cyA9ICcwLScgKyAoYmFzZSA8PSAxMCA/IGJhc2UgLSAxIDogJzlhLScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgKGJhc2UgLSAxMSkpKTtcblxuICAgICAgaWYgKCEobmV3IFJlZ0V4cCgnXlxcXFxzKlsrLV0/WycgKyBiYXNlX2RpZ2l0cyArICddK1xcXFxzKiQnKSkudGVzdChzdHIpKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgaSA9IHBhcnNlSW50KHN0ciwgYmFzZSk7XG5cbiAgICAgIGlmIChpc05hTihpKSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgSW50ZWdlcigpOiBcXFwiI3t2YWx1ZX1cXFwiXCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEZsb2F0KHZhbHVlKVxuICAgICV4e1xuICAgICAgdmFyIHN0cjtcblxuICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBuaWwgaW50byBGbG9hdFwifVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgICAvL1NwZWNpYWwgY2FzZSBmb3IgaGV4IHN0cmluZ3Mgb25seTpcbiAgICAgICAgaWYgKC9eXFxzKlstK10/MFt4WF1bMC05YS1mQS1GXStcXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgcmV0dXJuICN7SW50ZWdlcihgc3RyYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEvXlxccypbLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT9cXHMqJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEZsb2F0KCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje09wYWwuY29lcmNlX3RvISh2YWx1ZSwgRmxvYXQsIDp0b19mKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgSGFzaChhcmcpXG4gICAgcmV0dXJuIHt9IGlmIGFyZy5uaWw/IHx8IGFyZyA9PSBbXVxuICAgIHJldHVybiBhcmcgaWYgSGFzaCA9PT0gYXJnXG4gICAgT3BhbC5jb2VyY2VfdG8hKGFyZywgSGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICAleHtcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdjbGFzcyBvciBtb2R1bGUgcmVxdWlyZWQnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9wYWwuaXNfYShzZWxmLCBrbGFzcyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaXRzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBraW5kX29mPyBpc19hP1xuXG4gIGRlZiBsYW1iZGEoJmJsb2NrKVxuICAgIGBPcGFsLmxhbWJkYShibG9jaylgXG4gIGVuZFxuXG4gIGRlZiBsb2FkKGZpbGUpXG4gICAgZmlsZSA9IE9wYWwuY29lcmNlX3RvIShmaWxlLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwubG9hZCgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIGxvb3BcbiAgICByZXR1cm4gZW51bV9mb3IoOmxvb3ApIHsgRmxvYXQ6OklORklOSVRZIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgd2hpbGUgdHJ1ZVxuICAgICAgYmVnaW5cbiAgICAgICAgeWllbGRcbiAgICAgIHJlc2N1ZSBTdG9wSXRlcmF0aW9uID0+IGVcbiAgICAgICAgcmV0dXJuIGUucmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmIHByaW50ZigqYXJncylcbiAgICBpZiBhcmdzLmFueT9cbiAgICAgIHByaW50IGZvcm1hdCgqYXJncylcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcHJvYygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGBibG9jay4kJGlzX2xhbWJkYSA9IGZhbHNlYFxuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBwdXRzKCpzdHJzKVxuICAgICRzdGRvdXQucHV0cygqc3RycylcbiAgZW5kXG5cbiAgZGVmIHAoKmFyZ3MpXG4gICAgYXJncy5lYWNoIHsgfG9ianwgJHN0ZG91dC5wdXRzIG9iai5pbnNwZWN0IH1cblxuICAgIGFyZ3MubGVuZ3RoIDw9IDEgPyBhcmdzWzBdIDogYXJnc1xuICBlbmRcblxuICBkZWYgcHJpbnQoKnN0cnMpXG4gICAgJHN0ZG91dC5wcmludCgqc3RycylcbiAgZW5kXG5cbiAgZGVmIHJlYWRsaW5lKCphcmdzKVxuICAgICRzdGRpbi5yZWFkbGluZSgqYXJncylcbiAgZW5kXG5cbiAgZGVmIHdhcm4oKnN0cnMsIHVwbGV2ZWw6IG5pbClcbiAgICBpZiB1cGxldmVsXG4gICAgICB1cGxldmVsID0gT3BhbC5jb2VyY2VfdG8hKHVwbGV2ZWwsIEludGVnZXIsIDp0b19zdHIpXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIm5lZ2F0aXZlIGxldmVsICgje3VwbGV2ZWx9KVwiIGlmIHVwbGV2ZWwgPCAwXG4gICAgICBsb2NhdGlvbiA9IGNhbGxlcih1cGxldmVsICsgMSwgMSkuZmlyc3QmLnNwbGl0KCc6aW4gYCcpJi5maXJzdFxuICAgICAgbG9jYXRpb24gPSBcIiN7bG9jYXRpb259OiBcIiBpZiBsb2NhdGlvblxuICAgICAgc3RycyA9IHN0cnMubWFwIHsgfHN8IFwiI3tsb2NhdGlvbn13YXJuaW5nOiAje3N9XCIgfVxuICAgIGVuZFxuXG4gICAgJHN0ZGVyci5wdXRzKCpzdHJzKSB1bmxlc3MgJFZFUkJPU0UubmlsPyB8fCBzdHJzLmVtcHR5P1xuICBlbmRcblxuICBkZWYgcmFpc2UoZXhjZXB0aW9uID0gdW5kZWZpbmVkLCBzdHJpbmcgPSBuaWwsIGJhY2t0cmFjZSA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCAmJiAjeyQhfSAhPT0gbmlsKSB7XG4gICAgICAgIHRocm93ICN7JCF9O1xuICAgICAgfVxuICAgICAgaWYgKGV4Y2VwdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7UnVudGltZUVycm9yLm5ldyAnJ307XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgkcmVzcG9uZF90byhleGNlcHRpb24sICckdG9fc3RyJykpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3tSdW50aW1lRXJyb3IubmV3IGV4Y2VwdGlvbi50b19zdHJ9O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgJHJlc3BvbmRfdG8oZXhjZXB0aW9uLCAnJGV4Y2VwdGlvbicpKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfZXhjZXB0aW9uKSB7XG4gICAgICAgIC8vIGV4Y2VwdGlvbiBpcyBmaW5lXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3tUeXBlRXJyb3IubmV3ICdleGNlcHRpb24gY2xhc3Mvb2JqZWN0IGV4cGVjdGVkJ307XG4gICAgICB9XG5cbiAgICAgIGlmIChiYWNrdHJhY2UgIT09IG5pbCkge1xuICAgICAgICBleGNlcHRpb24uJHNldF9iYWNrdHJhY2UoYmFja3RyYWNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgT3BhbC5leGNlcHRpb25zLnB1c2goI3skIX0pO1xuICAgICAgfVxuXG4gICAgICAjeyQhfSA9IGV4Y2VwdGlvbjtcbiAgICAgICN7JEB9ID0gI3tgZXhjZXB0aW9uYC5iYWNrdHJhY2V9O1xuXG4gICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmYWlsIHJhaXNlXG5cbiAgZGVmIHJhbmQobWF4ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAje1JhbmRvbTo6REVGQVVMVC5yYW5kfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAobWF4IDwgMCkge1xuICAgICAgICAgIG1heCA9IE1hdGguYWJzKG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ICUgMSAhPT0gMCkge1xuICAgICAgICAgIG1heCA9IG1heC4kdG9faSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgICAgIG1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBSYW5kb206OkRFRkFVTFQucmFuZChtYXgpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvPyhuYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgICV4e1xuICAgICAgdmFyIGJvZHkgPSBzZWxmWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZlsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXS4kJHByaXN0aW5lID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAje3Jlc3BvbmRfdG9fbWlzc2luZz8obmFtZSwgaW5jbHVkZV9hbGwpfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIE9wYWwucHJpc3RpbmUoc2VsZiwgOnJlc3BvbmRfdG8/LCA6cmVzcG9uZF90b19taXNzaW5nPylcblxuICBkZWYgcmVxdWlyZShmaWxlKVxuICAgICV4e1xuICAgICAgLy8gQXMgT2JqZWN0LnJlcXVpcmUgcmVmZXJzIHRvIEtlcm5lbC5yZXF1aXJlIG9uY2UgS2VybmVsIGhhcyBiZWVuIGxvYWRlZCB0aGUgU3RyaW5nXG4gICAgICAvLyBjbGFzcyBtYXkgbm90IGJlIGF2YWlsYWJsZSB5ZXQsIHRoZSBjb2VyY2lvbiByZXF1aXJlcyBib3RoICBTdHJpbmcgYW5kIEFycmF5IHRvIGJlIGxvYWRlZC5cbiAgICAgIGlmICh0eXBlb2YgI3tmaWxlfSAhPT0gJ3N0cmluZycgJiYgT3BhbC5TdHJpbmcgJiYgT3BhbC5BcnJheSkge1xuICAgICAgICAje2ZpbGUgPSBPcGFsLmNvZXJjZV90byEoZmlsZSwgU3RyaW5nLCA6dG9fc3RyKSB9XG4gICAgICB9XG4gICAgICByZXR1cm4gT3BhbC5yZXF1aXJlKCN7ZmlsZX0pXG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVxdWlyZV9yZWxhdGl2ZShmaWxlKVxuICAgIE9wYWwudHJ5X2NvbnZlcnQhKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gRmlsZS5leHBhbmRfcGF0aCBGaWxlLmpvaW4oYE9wYWwuY3VycmVudF9maWxlYCwgJy4uJywgZmlsZSlcblxuICAgIGBPcGFsLnJlcXVpcmUoI3tmaWxlfSlgXG4gIGVuZFxuXG4gICMgYHBhdGhgIHNob3VsZCBiZSB0aGUgZnVsbCBwYXRoIHRvIGJlIGZvdW5kIGluIHJlZ2lzdGVyZWQgbW9kdWxlcyAoYE9wYWwubW9kdWxlc2ApXG4gIGRlZiByZXF1aXJlX3RyZWUocGF0aCwgYXV0b2xvYWQ6IGZhbHNlKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBwYXRoID0gI3tGaWxlLmV4cGFuZF9wYXRoKHBhdGgpfVxuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuICAgICAgaWYgKHBhdGggPT09ICcuJykgcGF0aCA9ICcnO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgaWYgKCN7YG5hbWVgLnN0YXJ0X3dpdGg/KHBhdGgpfSkge1xuICAgICAgICAgIGlmKCEje2F1dG9sb2FkfSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW25hbWUsIE9wYWwucmVxdWlyZShuYW1lKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgdHJ1ZV0pOyAvLyBkbyBub3RoaW5nLCBkZWxlZ2F0ZWQgdG8gYSBhdXRvbG9hZGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2VuZCAgICAgICAgX19zZW5kX19cbiAgYWxpYXMgcHVibGljX3NlbmQgX19zZW5kX19cblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIHNsZWVwKHNlY29uZHMgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc2Vjb25kcyA9PT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgTmlsQ2xhc3MgaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje3NlY29uZHMuY2xhc3N9IGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKHNlY29uZHMgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RpbWUgaW50ZXJ2YWwgbXVzdCBiZSBwb3NpdGl2ZSd9XG4gICAgICB9XG4gICAgICB2YXIgZ2V0X3RpbWUgPSBPcGFsLmdsb2JhbC5wZXJmb3JtYW5jZSA/XG4gICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX0gOlxuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gbmV3IERhdGUoKX1cblxuICAgICAgdmFyIHQgPSBnZXRfdGltZSgpO1xuICAgICAgd2hpbGUgKGdldF90aW1lKCkgLSB0IDw9IHNlY29uZHMgKiAxMDAwKTtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNyYW5kKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXG4gICAgUmFuZG9tLnNyYW5kKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiBTdHJpbmcoc3RyKVxuICAgIE9wYWwuY29lcmNlX3RvPyhzdHIsIFN0cmluZywgOnRvX3N0cikgfHxcbiAgICAgIE9wYWwuY29lcmNlX3RvIShzdHIsIFN0cmluZywgOnRvX3MpXG4gIGVuZFxuXG4gIGRlZiB0YXAoJmJsb2NrKVxuICAgIHlpZWxkIHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiIzwje3NlbGYuY2xhc3N9OjB4I3tfX2lkX18udG9fcygxNil9PlwiXG4gIGVuZFxuXG4gIGRlZiBjYXRjaCh0YWcgPSBuaWwpXG4gICAgdGFnIHx8PSBPYmplY3QubmV3XG4gICAgeWllbGQodGFnKVxuICByZXNjdWUgVW5jYXVnaHRUaHJvd0Vycm9yID0+IGVcbiAgICByZXR1cm4gZS52YWx1ZSBpZiBlLnRhZyA9PSB0YWdcbiAgICByYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3codGFnLCBvYmogPSBuaWwpXG4gICAgcmFpc2UgVW5jYXVnaHRUaHJvd0Vycm9yLm5ldyh0YWcsIG9iailcbiAgZW5kXG5cbiAgIyBiYXNpYyBpbXBsZW1lbnRhdGlvbiBvZiBvcGVuLCBkZWxlZ2F0ZSB0byBGaWxlLm9wZW5cbiAgZGVmIG9wZW4oKmFyZ3MsICZibG9jaylcbiAgICBGaWxlLm9wZW4oKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHlpZWxkX3NlbGZcbiAgICByZXR1cm4gZW51bV9mb3IoOnlpZWxkX3NlbGYpIHsgMSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICB5aWVsZCBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIHRoZW4geWllbGRfc2VsZlxuXG4gIE9wYWwucHJpc3RpbmUoc2VsZiwgOm1ldGhvZF9taXNzaW5nKVxuZW5kXG5cbmNsYXNzIE9iamVjdFxuICAjIE9iamVjdC5yZXF1aXJlIGhhcyBiZWVuIHNldCB0byBydW50aW1lLmpzIE9wYWwucmVxdWlyZVxuICAjIE5vdyB3ZSBoYXZlIEtlcm5lbCBsb2FkZWQsIG1ha2Ugc3VyZSBPYmplY3QucmVxdWlyZSByZWZlcnMgdG8gS2VybmVsLnJlcXVpcmVcbiAgIyB3aGljaCBpcyB3aGF0IHJ1YnkgZG9lcyBhbmQgYWxsb3dzIGZvciBvdmVyd3JpdGluZyBieSBhdXRvbG9hZGVyc1xuICBgZGVsZXRlIE9wYWwuT2JqZWN0LiQkcHJvdG90eXBlLiRyZXF1aXJlYFxuICBpbmNsdWRlIEtlcm5lbFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIm1ldGhvZF9taXNzaW5nIiwic3ltYm9sIiwic2VsZiIsInJhaXNlIiwiTm9NZXRob2RFcnJvciIsIm5ldyIsImluc3BlY3QiLCJhcmdzIiwiY2FsbGVyIiwiMSIsIj1+Iiwib2JqIiwiIX4iLCIhIiwiPT09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJvYmplY3RfaWQiLCI9PSIsIjw9PiIsIm1ldGhvZCIsIm5hbWUiLCJOYW1lRXJyb3IiLCJjbGFzcyIsIk1ldGhvZCIsIm1ldGhvZHMiLCJhbGwiLCJwdWJsaWNfbWV0aG9kcyIsIkFycmF5Iiwib2JqZWN0IiwiT3BhbCIsImNvZXJjZV90bz8iLCJhdF9leGl0IiwiJF9fYXRfZXhpdF9fIiwiJHJldF9vcl8yIiwiPDwiLCJibG9jayIsInN0YXJ0IiwibGVuZ3RoIiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwiY2xvbmUiLCIka3dhcmdzIiwiY29weSIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZV9jbG9uZSIsImluaXRpYWxpemVfY29weSIsImRlZmluZV9zaW5nbGV0b25fbWV0aG9kIiwiZGVmaW5lX21ldGhvZCIsInNpbmdsZXRvbl9jbGFzcyIsInRvX3Byb2MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiRW51bWVyYXRvciIsImVxdWFsPyIsImV4aXQiLCJzdGF0dXMiLCIkcmV0X29yXzMiLCJlbXB0eT8iLCJwb3AiLCJjYWxsIiwiSW50ZWdlciIsImV4dGVuZCIsIlR5cGVFcnJvciIsImFwcGVuZF9mZWF0dXJlcyIsImV4dGVuZF9vYmplY3QiLCJleHRlbmRlZCIsImdldHMiLCIkc3RkaW4iLCJoYXNoIiwiX19pZF9fIiwiaXZzIiwiZWFjaCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsImJsb2NrIGluIGluc3BlY3QiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnNwZWN0IiwiKyIsImluc3RhbmNlX3ZhcmlhYmxlX2dldCIsInRvX3MiLCIxNiIsIlN0YW5kYXJkRXJyb3IiLCJpbnN0YW5jZV9vZj8iLCJrbGFzcyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJ2YWx1ZSIsInJlbW92ZV9pbnN0YW5jZV92YXJpYWJsZSIsImJhc2UiLCJBcmd1bWVudEVycm9yIiwiRmxvYXREb21haW5FcnJvciIsInJlc3BvbmRfdG8/IiwidG9faW50IiwiY29lcmNlX3RvISIsIkZsb2F0IiwiSGFzaCIsImFyZyIsIiRyZXRfb3JfNCIsIm5pbD8iLCJpc19hPyIsIml0c2VsZiIsImxhbWJkYSIsImxvYWQiLCJmaWxlIiwiU3RyaW5nIiwibG9vcCIsImJsb2NrX2dpdmVuPyIsImJsb2NrIGluIGxvb3AiLCJibG9jayAoMiBsZXZlbHMpIGluIGxvb3AiLCJGbG9hdDo6SU5GSU5JVFkiLCJTdG9wSXRlcmF0aW9uIiwiZSIsInJlc3VsdCIsInByaW50ZiIsImFueT8iLCJwcmludCIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwiJHN0ZG91dCIsInN0cnMiLCJwIiwiYmxvY2sgaW4gcCIsImJsb2NrICgyIGxldmVscykgaW4gcCIsIjw9IiwiW10iLCIwIiwicmVhZGxpbmUiLCJ3YXJuIiwidXBsZXZlbCIsIjwiLCJsb2NhdGlvbiIsImZpcnN0IiwibWFwIiwiYmxvY2sgaW4gd2FybiIsInMiLCJibG9jayAoMiBsZXZlbHMpIGluIHdhcm4iLCIkcmV0X29yXzUiLCIkVkVSQk9TRSIsIiRzdGRlcnIiLCJleGNlcHRpb24iLCJzdHJpbmciLCJiYWNrdHJhY2UiLCIkISIsIlJ1bnRpbWVFcnJvciIsInRvX3N0ciIsIiRAIiwicmFuZCIsIm1heCIsIlJhbmRvbTo6REVGQVVMVCIsIlJhbmRvbSIsImluY2x1ZGVfYWxsIiwicmVzcG9uZF90b19taXNzaW5nPyIsIm1ldGhvZF9uYW1lIiwicHJpc3RpbmUiLCJyZXF1aXJlIiwicmVxdWlyZV9yZWxhdGl2ZSIsInRyeV9jb252ZXJ0ISIsIkZpbGUiLCJleHBhbmRfcGF0aCIsImpvaW4iLCJyZXF1aXJlX3RyZWUiLCJwYXRoIiwic3RhcnRfd2l0aD8iLCJhdXRvbG9hZCIsInNsZWVwIiwic2Vjb25kcyIsInNyYW5kIiwic2VlZCIsIm5ld19zZWVkIiwic3RyIiwiJHJldF9vcl82IiwidGFwIiwiY2F0Y2giLCJ0YWciLCIkcmV0X29yXzciLCJPYmplY3QiLCJVbmNhdWdodFRocm93RXJyb3IiLCJ0aHJvdyIsIm9wZW4iLCJ5aWVsZF9zZWxmIiwiYmxvY2sgaW4geWllbGRfc2VsZiIsImJsb2NrICgyIGxldmVscykgaW4geWllbGRfc2VsZiIsIjxjbGFzczpPYmplY3Q+IiwiaW5jbHVkZSIsIktlcm5lbCJdLCJtYXBwaW5ncyI6IkFBQUFBLGlEQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDO0VBQUFBOztJQUFBQTs7OztBQUNFQyxJQUFBQSxrQ0FBQUEsMkJBQUFBLDBCQUFtQkMsTUFBRCxFQUhwQixFQUdFRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFrQzs7TUFIcEM7O01BRzZCO01BQ3pCQSxPQUFBRSxJQUFBQyxPQUFBQSxDQUFNQyw2QkFBYUMsS0FBQUEsQ0FBSyxFQUFBLEdBQUNMLG9CQUFELEdBQUEsQ0FBcUJDLE1BQXJCLENBQUEsR0FBNEJELFFBQTVCLEdBQUEsQ0FBb0NFLElBQUFJLFNBQUFBLENBQUFBLENBQXBDLENBQWxCLEVBQWlFTCxNQUFqRSxFQUF5RU0sSUFBNURGLENBQW5CLEVBQXNGLEdBQXRGLEVBQTJGSCxJQUFBTSxRQUFBQSxDQUFPQyxDQUFQRCxDQUEzRkw7SUFERkgsQ0FBQUEsdUNBQUFBOztBQUlBVSxJQUFBQSxzQkFBQUEsc0JBQUFBLFNBQU9DLEdBQVBEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBO0lBREZBLENBQUFBLGlDQUFBQTs7QUFJQUUsSUFBQUEsc0JBQUFBLHdCQUFBQSxTQUFPRCxHQUFQQztBQUFB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Q0FBQUE7SUFLQSxhQUFNLE1BQU4sRUFBVyxZQUFYO0lBRUF4TCxPQUFBK0Isb0JBQUkrSCxVQUFBQSxDQUFVM0osSUFBZCxFQUFvQixnQkFBaEIySjtFQXZ1Qk45SixHQUFBQSxXQUFBQTtFQTB1QkFELE9BQUE0TDtFQUFBQTs7SUFBQUE7OztJQUlHQTtJQUNEQSxPQUFBeEwsSUFBQXlMLFNBQUFBLENBQVFDLHNCQUFSRDtFQUxGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQTV1QkE1TDsifX0seyJvZmZzZXQiOnsibGluZSI6NTUzNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZXJyb3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRXhjZXB0aW9uIDwgYEVycm9yYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19leGNlcHRpb24nLCB0cnVlKWBcbiAgYHZhciBzdGFja190cmFjZV9saW1pdGBcblxuICBkZWYgc2VsZi5uZXcoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgbWVzc2FnZSAgID0gKGFyZ3MubGVuZ3RoID4gMCkgPyBhcmdzWzBdIDogbmlsO1xuICAgICAgdmFyIGVycm9yICAgICA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3IobWVzc2FnZSk7XG4gICAgICBlcnJvci5uYW1lICAgID0gc2VsZi4kJG5hbWU7XG4gICAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIGVycm9yLmNhdXNlICAgPSAjeyQhfTtcbiAgICAgIE9wYWwuc2VuZChlcnJvciwgZXJyb3IuJGluaXRpYWxpemUsIGFyZ3MpO1xuXG4gICAgICAvLyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSgpIHdpbGwgdXNlIC5uYW1lIGFuZCAudG9TdHJpbmcgdG8gYnVpbGQgdGhlXG4gICAgICAvLyBmaXJzdCBsaW5lIG9mIHRoZSBzdGFjayB0cmFjZSBzbyBpdCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgZXJyb3JcbiAgICAgIC8vIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXY2LngvZG9jcy9hcGkvZXJyb3JzLmh0bWxcbiAgICAgIGlmIChPcGFsLmNvbmZpZy5lbmFibGVfc3RhY2tfdHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgLy8gUGFzc2luZyBLZXJuZWwucmFpc2Ugd2lsbCBjdXQgdGhlIHN0YWNrIHRyYWNlIGZyb20gdGhhdCBwb2ludCBhYm92ZVxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgc3RhY2tfdHJhY2VfbGltaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICBlbmRcbiAgYHN0YWNrX3RyYWNlX2xpbWl0ID0gc2VsZi4kbmV3YFxuXG4gIGRlZiBzZWxmLmV4Y2VwdGlvbigqYXJncylcbiAgICBuZXcoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgICMgdXNpbmcgc2VsZi5tZXNzYWdlIGFrYSBAbWVzc2FnZSB0byByZXRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG5hdGl2ZSBleGNlcHRpb24ncyBtZXNzYWdlIHByb3BlcnR5XG4gICAgYHNlbGYubWVzc2FnZSA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbGBcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gQ29udmVydCBiYWNrdHJhY2UgZnJvbSBhbnkgZm9ybWF0IHRvIFJ1YnkgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlKSB7XG4gICAgICB2YXIgbmV3X2J0ID0gW10sIG07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFja3RyYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBiYWNrdHJhY2VbaV07XG4gICAgICAgIGlmICghbG9jIHx8ICFsb2MuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAvKiBEbyBub3RoaW5nICovXG4gICAgICAgIH1cbiAgICAgICAgLyogQ2hyb21pdW0gZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pIFxcKCguKj8pXFwpJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyBcIjppbiBgXCIgKyBtWzFdICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICAgIGF0ICguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0gKyBcIjppbiBgdW5kZWZpbmVkJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBOb2RlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiAgZnJvbSAoLio/KSQvKSkpIHtcbiAgICAgICAgICBuZXdfYnQucHVzaChtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBNb3ppbGxhL0FwcGxlIGZvcm1hdCAqL1xuICAgICAgICBlbHNlIGlmICgobSA9IGxvYy5tYXRjaCgvXiguKj8pQCguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMl0gKyAnOmluIGAnICsgbVsxXSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3X2J0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpICE9PSAndW5kZWZpbmVkJyAmJiBiYWNrdHJhY2UuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDAsIDE1KSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiYWNrdHJhY2UpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlID0gY29ycmVjdF9iYWNrdHJhY2UoYmFja3RyYWNlLnNsaWNlKDAsIDE1KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBiYWNrdHJhY2VfbG9jYXRpb25zXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zKSByZXR1cm4gc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zO1xuICAgICAgc2VsZi5iYWNrdHJhY2VfbG9jYXRpb25zID0gI3tiYWNrdHJhY2UmLm1hcCBkbyB8bG9jfFxuICAgICAgICA6OlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbi5uZXcobG9jKVxuICAgICAgZW5kfVxuICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYXVzZVxuICAgIGBzZWxmLmNhdXNlIHx8IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbihzdHIgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gI3tjbG9uZX07XG4gICAgICBjbG9uZWQubWVzc2FnZSA9IHN0cjtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkgY2xvbmVkLmJhY2t0cmFjZSA9IHNlbGYuYmFja3RyYWNlLiRkdXAoKTtcbiAgICAgIGNsb25lZC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICBjbG9uZWQuY2F1c2UgPSBzZWxmLmNhdXNlO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gIGVuZFxuXG4gICMgbm90IHVzaW5nIGFsaWFzIG1lc3NhZ2UgdG9fcyBiZWNhdXNlIHlvdSBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcnJpZGUgdG9fcyBhbmQgaGF2ZSBtZXNzYWdlIHVzZSBvdmVycmlkZGVuIG1ldGhvZCwgd29uJ3Qgd29yayB3aXRoIGFsaWFzXG4gIGRlZiBtZXNzYWdlXG4gICAgdG9fc1xuICBlbmRcblxuICBkZWYgZnVsbF9tZXNzYWdlKGhpZ2hsaWdodDogJHN0ZGVyci50dHk/LCBvcmRlcjogOnRvcClcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImV4cGVjdGVkIHRydWUgb3IgZmFsc2UgYXMgaGlnaGxpZ2h0OiAje2hpZ2hsaWdodH1cIiB1bmxlc3MgW3RydWUsIGZhbHNlXS5pbmNsdWRlPyBoaWdobGlnaHRcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImV4cGVjdGVkIDp0b3Agb3IgOmJvdHRvbSBhcyBvcmRlcjogI3tvcmRlcn1cIiB1bmxlc3MgJWlbdG9wIGJvdHRvbV0uaW5jbHVkZT8gb3JkZXJcblxuICAgIGlmIGhpZ2hsaWdodFxuICAgICAgYm9sZF91bmRlcmxpbmUgPSBcIlxcZVsxOzRtXCJcbiAgICAgIGJvbGQgPSBcIlxcZVsxbVwiXG4gICAgICByZXNldCA9IFwiXFxlW21cIlxuICAgIGVsc2VcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gYm9sZCA9IHJlc2V0ID0gJydcbiAgICBlbmRcblxuICAgIGJ0ID0gYmFja3RyYWNlLmR1cFxuICAgIGJ0ID0gY2FsbGVyIGlmICFidCB8fCBidC5lbXB0eT9cbiAgICBmaXJzdCA9IGJ0LnNoaWZ0XG5cbiAgICBtc2cgPSBcIiN7Zmlyc3R9OiBcIlxuICAgIG1zZyArPSBcIiN7Ym9sZH0je3RvX3N9ICgje2JvbGRfdW5kZXJsaW5lfSN7c2VsZi5jbGFzc30je3Jlc2V0fSN7Ym9sZH0pI3tyZXNldH1cXG5cIlxuXG4gICAgbXNnICs9IGJ0Lm1hcCB7IHxsb2N8IFwiXFx0ZnJvbSAje2xvY31cXG5cIiB9LmpvaW5cblxuICAgIG1zZyArPSBjYXVzZS5mdWxsX21lc3NhZ2UoaGlnaGxpZ2h0OiBoaWdobGlnaHQpIGlmIGNhdXNlXG5cbiAgICBpZiBvcmRlciA9PSA6Ym90dG9tXG4gICAgICBtc2cgPSBtc2cuc3BsaXQoXCJcXG5cIikucmV2ZXJzZS5qb2luKFwiXFxuXCIpXG4gICAgICBtc2cgPSBcIiN7Ym9sZH1UcmFjZWJhY2sje3Jlc2V0fSAobW9zdCByZWNlbnQgY2FsbCBsYXN0KTpcXG5cIiArIG1zZ1xuICAgIGVuZFxuXG4gICAgbXNnXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgYXNfc3RyID0gdG9fc1xuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXG4gIGVuZFxuXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcbiAgICAleHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWUsIGksIGlpO1xuXG4gICAgICBpZiAoYmFja3RyYWNlID09PSBuaWwpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBuaWw7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gW2JhY2t0cmFjZV07XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnICBmcm9tICcgKyBiYWNrdHJhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFja3RyYWNlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2t0cmFjZVtpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcbiAgICAgICAgc2VsZi5zdGFjayA9ICN7YGJhY2t0cmFjZWAubWFwIHsgfGl8ICcgIGZyb20gJyArIGkgfX0uam9pbihcIlxcblwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhY2t0cmFjZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICAoQG1lc3NhZ2UgJiYgQG1lc3NhZ2UudG9fcykgfHwgc2VsZi5jbGFzcy50b19zXG4gIGVuZFxuZW5kXG5cbiMga2VlcCB0aGUgaW5kZW50YXRpb24sIGl0IG1ha2VzIHRoZSBleGNlcHRpb24gaGllcmFyY2h5IGNsZWFyXG5jbGFzcyBTY3JpcHRFcnJvciAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTeW50YXhFcnJvciAgICAgICAgIDwgU2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgTG9hZEVycm9yICAgICAgICAgICA8IFNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIE5vdEltcGxlbWVudGVkRXJyb3IgPCBTY3JpcHRFcnJvcjsgZW5kXG5cbmNsYXNzIFN5c3RlbUV4aXQgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIE5vTWVtb3J5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNpZ25hbEV4Y2VwdGlvbiAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIEludGVycnVwdCAgICAgICAgICAgPCBTaWduYWxFeGNlcHRpb247IGVuZFxuY2xhc3MgU2VjdXJpdHlFcnJvciAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgU3lzdGVtU3RhY2tFcnJvciAgPCBFeGNlcHRpb247IGVuZFxuXG5jbGFzcyBTdGFuZGFyZEVycm9yICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBFbmNvZGluZ0Vycm9yICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBaZXJvRGl2aXNpb25FcnJvciAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBOYW1lRXJyb3IgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBOb01ldGhvZEVycm9yICAgICAgICAgPCBOYW1lRXJyb3I7IGVuZFxuY2xhc3MgUnVudGltZUVycm9yICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgRnJvemVuRXJyb3IgICAgICAgICAgIDwgUnVudGltZUVycm9yOyBlbmRcbmNsYXNzIExvY2FsSnVtcEVycm9yICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIFR5cGVFcnJvciAgICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEFyZ3VtZW50RXJyb3IgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIFVuY2F1Z2h0VGhyb3dFcnJvciAgICA8IEFyZ3VtZW50RXJyb3I7IGVuZFxuY2xhc3MgSW5kZXhFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgU3RvcEl0ZXJhdGlvbiAgICAgICAgIDwgSW5kZXhFcnJvcjsgZW5kXG5jbGFzcyBDbG9zZWRRdWV1ZUVycm9yICAgICAgICA8IFN0b3BJdGVyYXRpb247IGVuZFxuY2xhc3MgS2V5RXJyb3IgICAgICAgICAgICAgIDwgSW5kZXhFcnJvcjsgZW5kXG5jbGFzcyBSYW5nZUVycm9yICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBGbG9hdERvbWFpbkVycm9yICAgICAgPCBSYW5nZUVycm9yOyBlbmRcbmNsYXNzIElPRXJyb3IgICAgICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEVPRkVycm9yICAgICAgICAgICAgICA8IElPRXJyb3I7IGVuZFxuY2xhc3MgU3lzdGVtQ2FsbEVycm9yICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgUmVnZXhwRXJyb3IgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgVGhyZWFkRXJyb3IgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgRmliZXJFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuXG5tb2R1bGUgRXJybm9cbiAgY2xhc3MgRUlOVkFMICAgICAgICAgICAgICA8IFN5c3RlbUNhbGxFcnJvclxuICAgIGRlZiBzZWxmLm5ldyhuYW1lID0gbmlsKVxuICAgICAgbWVzc2FnZSA9ICdJbnZhbGlkIGFyZ3VtZW50J1xuICAgICAgbWVzc2FnZSArPSBcIiAtICN7bmFtZX1cIiBpZiBuYW1lXG4gICAgICBzdXBlcihtZXNzYWdlKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBVbmNhdWdodFRocm93RXJyb3IgPCBBcmd1bWVudEVycm9yXG4gIGF0dHJfcmVhZGVyIDp0YWcsIDp2YWx1ZVxuXG4gIGRlZiBpbml0aWFsaXplKHRhZywgdmFsdWUgPSBuaWwpXG4gICAgQHRhZyA9IHRhZ1xuICAgIEB2YWx1ZSA9IHZhbHVlXG5cbiAgICBzdXBlcihcInVuY2F1Z2h0IHRocm93ICN7QHRhZy5pbnNwZWN0fVwiKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOYW1lRXJyb3JcbiAgYXR0cl9yZWFkZXIgOm5hbWVcblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBuYW1lID0gbmlsKVxuICAgIHN1cGVyIG1lc3NhZ2VcbiAgICBAbmFtZSA9IG5hbWVcbiAgZW5kXG5lbmRcblxuY2xhc3MgTm9NZXRob2RFcnJvclxuICBhdHRyX3JlYWRlciA6YXJnc1xuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwsIGFyZ3MgPSBbXSlcbiAgICBzdXBlciBtZXNzYWdlLCBuYW1lXG4gICAgQGFyZ3MgPSBhcmdzXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0b3BJdGVyYXRpb25cbiAgYXR0cl9yZWFkZXIgOnJlc3VsdFxuZW5kXG5cbmNsYXNzIEtleUVycm9yXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIHJlY2VpdmVyOiBuaWwsIGtleTogbmlsKVxuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgQHJlY2VpdmVyID0gcmVjZWl2ZXJcbiAgICBAa2V5ID0ga2V5XG4gIGVuZFxuXG4gIGRlZiByZWNlaXZlclxuICAgIEByZWNlaXZlciB8fCByYWlzZShBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgaXMgYXZhaWxhYmxlJylcbiAgZW5kXG5cbiAgZGVmIGtleVxuICAgIEBrZXkgfHwgcmFpc2UoQXJndW1lbnRFcnJvciwgJ25vIGtleSBpcyBhdmFpbGFibGUnKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgSlNcbiAgY2xhc3MgRXJyb3JcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkV4Y2VwdGlvbj4iLCJuZXciLCJzZWxmIiwiJCEiLCJleGNlcHRpb24iLCJhcmdzIiwiaW5pdGlhbGl6ZSIsImJhY2t0cmFjZSIsImJhY2t0cmFjZV9sb2NhdGlvbnMiLCJibG9jayBpbiBiYWNrdHJhY2VfbG9jYXRpb25zIiwibG9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBiYWNrdHJhY2VfbG9jYXRpb25zIiwiVGhyZWFkOjpCYWNrdHJhY2U6OkxvY2F0aW9uIiwiVGhyZWFkOjpCYWNrdHJhY2UiLCJUaHJlYWQiLCJjYXVzZSIsInN0ciIsImNsb25lIiwibWVzc2FnZSIsInRvX3MiLCJmdWxsX21lc3NhZ2UiLCIka3dhcmdzIiwiJHN0ZGVyciIsInR0eT8iLCJpbmNsdWRlPyIsImhpZ2hsaWdodCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIm9yZGVyIiwiYm9sZF91bmRlcmxpbmUiLCJib2xkIiwicmVzZXQiLCJidCIsImR1cCIsIiRyZXRfb3JfMSIsIiEiLCJlbXB0eT8iLCJjYWxsZXIiLCJmaXJzdCIsInNoaWZ0IiwibXNnIiwiKyIsImNsYXNzIiwibWFwIiwiYmxvY2sgaW4gZnVsbF9tZXNzYWdlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmdWxsX21lc3NhZ2UiLCJqb2luIiwiPT0iLCJzcGxpdCIsInJldmVyc2UiLCJpbnNwZWN0IiwiYXNfc3RyIiwic2V0X2JhY2t0cmFjZSIsIlR5cGVFcnJvciIsImJsb2NrIGluIHNldF9iYWNrdHJhY2UiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZXRfYmFja3RyYWNlIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiQG1lc3NhZ2UiLCI8Y2xhc3M6U2NyaXB0RXJyb3I+IiwiRXhjZXB0aW9uIiwiPGNsYXNzOlN5bnRheEVycm9yPiIsIlNjcmlwdEVycm9yIiwiPGNsYXNzOkxvYWRFcnJvcj4iLCI8Y2xhc3M6Tm90SW1wbGVtZW50ZWRFcnJvcj4iLCI8Y2xhc3M6U3lzdGVtRXhpdD4iLCI8Y2xhc3M6Tm9NZW1vcnlFcnJvcj4iLCI8Y2xhc3M6U2lnbmFsRXhjZXB0aW9uPiIsIjxjbGFzczpJbnRlcnJ1cHQ+IiwiU2lnbmFsRXhjZXB0aW9uIiwiPGNsYXNzOlNlY3VyaXR5RXJyb3I+IiwiPGNsYXNzOlN5c3RlbVN0YWNrRXJyb3I+IiwiPGNsYXNzOlN0YW5kYXJkRXJyb3I+IiwiPGNsYXNzOkVuY29kaW5nRXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpaZXJvRGl2aXNpb25FcnJvcj4iLCI8Y2xhc3M6TmFtZUVycm9yPiIsIjxjbGFzczpOb01ldGhvZEVycm9yPiIsIk5hbWVFcnJvciIsIjxjbGFzczpSdW50aW1lRXJyb3I+IiwiPGNsYXNzOkZyb3plbkVycm9yPiIsIlJ1bnRpbWVFcnJvciIsIjxjbGFzczpMb2NhbEp1bXBFcnJvcj4iLCI8Y2xhc3M6VHlwZUVycm9yPiIsIjxjbGFzczpBcmd1bWVudEVycm9yPiIsIjxjbGFzczpVbmNhdWdodFRocm93RXJyb3I+IiwiPGNsYXNzOkluZGV4RXJyb3I+IiwiPGNsYXNzOlN0b3BJdGVyYXRpb24+IiwiSW5kZXhFcnJvciIsIjxjbGFzczpDbG9zZWRRdWV1ZUVycm9yPiIsIlN0b3BJdGVyYXRpb24iLCI8Y2xhc3M6S2V5RXJyb3I+IiwiPGNsYXNzOlJhbmdlRXJyb3I+IiwiPGNsYXNzOkZsb2F0RG9tYWluRXJyb3I+IiwiUmFuZ2VFcnJvciIsIjxjbGFzczpJT0Vycm9yPiIsIjxjbGFzczpFT0ZFcnJvcj4iLCJJT0Vycm9yIiwiPGNsYXNzOlN5c3RlbUNhbGxFcnJvcj4iLCI8Y2xhc3M6UmVnZXhwRXJyb3I+IiwiPGNsYXNzOlRocmVhZEVycm9yPiIsIjxjbGFzczpGaWJlckVycm9yPiIsIjxtb2R1bGU6RXJybm8+IiwiPGNsYXNzOkVJTlZBTD4iLCJuYW1lIiwiU3lzdGVtQ2FsbEVycm9yIiwiYXR0cl9yZWFkZXIiLCJ0YWciLCJ2YWx1ZSIsIkB0YWciLCJAdmFsdWUiLCJAbmFtZSIsIkBhcmdzIiwiQHJlY2VpdmVyIiwicmVjZWl2ZXIiLCJAa2V5Iiwia2V5IiwiJHJldF9vcl80IiwiJHJldF9vcl81IiwiPG1vZHVsZTpKUz4iLCI8Y2xhc3M6RXJyb3I+Il0sIm1hcHBpbmdzIjoiQUFBQUEsZ0RBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDR0E7SUFDQUE7SUFFREMsVUFBSUMsSUFBSkQsVUFBQUEsbUJBQUFBLFNBSkYsRUFJRUE7QUFBQUEsTUFBQUE7QUFBQUE7Ozs7TUFKRjs7TUFJZTs7QUFFZkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsc0JBQXdCRSxXQUFHRjtBQUMzQkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FB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ZjtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQXRSRjtNQUFBO01BQUE7TUFBQTtNQUFBOztNQXNSMEI7TUFBQTtNQUFBLGFBQVU7TUFBVjs7TUFBZTtNQUFBO01BQUEsUUFBSztNQUFMO01BQ3JDLE9BQUFKLElBQUEsRUFBQSxxRUFBQSxjQUFBLEVBQUEsQ0FBTWdCLE9BQU4sQ0FBQSxFQUFBLElBQUE7TUFDQWdHLGdCQUFZQztNQUNaN0csT0FBQThHLENBQUFBLFdBQU9DLEdBQVBEO0lBSEY5RyxDQUFBQSxzQ0FBQUE7O0FBTUE2RyxJQUFBQSw0QkFBQUEsd0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBN1JKRyxDQUFBQSxZQTZSSUosYUE3UkpJLENBNlJJLENBQUE7UUE3UkpILE9BQUE7TUE2Ukk7UUFBYUEsT0FBQWpILElBQUF3QixPQUFBQSxDQUFNQyw2QkFBTixFQUFxQndGLDBCQUFyQnpGO01BQWI7SUFERnlGLENBQUFBLG1DQUFBQTtJQUlBdkIsT0FBQXlCLENBQUFBLHVCQUFBQSxtQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQWpTSkUsQ0FBQUEsWUFpU0lILFFBalNKRyxDQWlTSSxDQUFBO1FBalNKRixPQUFBO01BaVNJO1FBQVFBLE9BQUFuSCxJQUFBd0IsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUIwRixxQkFBckIzRjtNQUFSO0lBREYyRixDQUFBQSw4QkFBQUEsQ0FBQUE7RUFYRnpCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBZ0JBN0YsT0FBQXlIO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFBQSxPQUFBO0lBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBclNBekg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYyMzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbnN0YW50cy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJSVUJZX1BMQVRGT1JNICAgICAgID0gJ29wYWwnXG5SVUJZX0VOR0lORSAgICAgICAgID0gJ29wYWwnXG5SVUJZX1ZFUlNJT04gICAgICAgID0gJzMuMC4yJ1xuUlVCWV9FTkdJTkVfVkVSU0lPTiA9ICcxLjMuMSdcblJVQllfUkVMRUFTRV9EQVRFICAgPSAnMjAyMS0xMS0wMydcblJVQllfUEFUQ0hMRVZFTCAgICAgPSAwXG5SVUJZX1JFVklTSU9OICAgICAgID0gJzAnXG5SVUJZX0NPUFlSSUdIVCAgICAgID0gJ29wYWwgLSBDb3B5cmlnaHQgKEMpIDIwMTMtMjAyMSBBZGFtIEJleW5vbiBhbmQgdGhlIE9wYWwgY29udHJpYnV0b3JzJ1xuUlVCWV9ERVNDUklQVElPTiAgICA9IFwib3BhbCAje1JVQllfRU5HSU5FX1ZFUlNJT059ICgje1JVQllfUkVMRUFTRV9EQVRFfSByZXZpc2lvbiAje1JVQllfUkVWSVNJT059KVwiXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjAiLCJSVUJZX0VOR0lORV9WRVJTSU9OIiwiUlVCWV9SRUxFQVNFX0RBVEUiLCJSVUJZX1JFVklTSU9OIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0RBQUFBO0VBQUFBOzs7RUFBQSw2Q0FBc0JBLE1BQXRCO0VBQ0EsMkNBQXNCQSxNQUF0QjtFQUNBLDRDQUFzQkEsT0FBdEI7RUFDQSxtREFBc0JBLE9BQXRCO0VBQ0EsaURBQXNCQSxZQUF0QjtFQUNBLCtDQUFzQkMsQ0FBdEI7RUFDQSw2Q0FBc0JELEdBQXRCO0VBQ0EsOENBQXNCQSxzRUFBdEI7RUFDQUEsT0FBQSxnREFBc0IsRUFBQSxHQUFDQSxPQUFELEdBQUEsQ0FBUUUsbUNBQVIsQ0FBQSxHQUE0QkYsSUFBNUIsR0FBQSxDQUFnQ0csaUNBQWhDLENBQUEsR0FBa0RILFlBQWxELEdBQUEsQ0FBOERJLDZCQUE5RCxDQUFBLEdBQTRFSixHQUFsRztBQVJBQTsifX0seyJvZmZzZXQiOnsibGluZSI6NjI1NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL3J1bnRpbWUnXG5yZXF1aXJlICdjb3JlbGliL2hlbHBlcnMnXG5yZXF1aXJlICdjb3JlbGliL21vZHVsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvY2xhc3MnXG5yZXF1aXJlICdjb3JlbGliL2Jhc2ljX29iamVjdCdcbnJlcXVpcmUgJ2NvcmVsaWIva2VybmVsJ1xucmVxdWlyZSAnY29yZWxpYi9lcnJvcidcblxucmVxdWlyZSAnY29yZWxpYi9jb25zdGFudHMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUEsNENBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsc0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUVBRixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixtQkFBUkU7QUFSQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYyNjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL25pbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBOaWxDbGFzc1xuICBgc2VsZi4kJHByb3RvdHlwZS4kJG1ldGEgPSAje3NlbGZ9YFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmICFcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIGBvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYG90aGVyID09PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAnbmlsJ1xuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIE5pbENsYXNzXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHRvX2hcbiAgICBgT3BhbC5oYXNoKClgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgMFxuICBlbmRcblxuICBhbGlhcyB0b19mIHRvX2lcblxuICBkZWYgdG9fc1xuICAgICcnXG4gIGVuZFxuXG4gIGRlZiB0b19jXG4gICAgQ29tcGxleC5uZXcoMCwgMClcbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKCphcmdzKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IgaWYgYXJncy5sZW5ndGggPiAxXG4gICAgUmF0aW9uYWwoMCwgMSlcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICBSYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5lbmRcblxuTklMID0gbmlsXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpOaWxDbGFzcz4iLCJzZWxmIiwiYWxsb2NhdGUiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5hbWUiLCIhIiwiJiIsIm90aGVyIiwifCIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiJGt3YXJncyIsImluc3BlY3QiLCJuaWw/Iiwic2luZ2xldG9uX2NsYXNzIiwiTmlsQ2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJDb21wbGV4IiwibmV3IiwicmF0aW9uYWxpemUiLCI+IiwiYXJncyIsImxlbmd0aCIsIjEiLCJBcmd1bWVudEVycm9yIiwiUmF0aW9uYWwiLCJ0b19yIiwiaW5zdGFuY2VfdmFyaWFibGVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsOENBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDR0EsMEJBQTRCQztJQUU3QjtNQUFBOzs7O0FBQ0VDLE1BQUFBLDRCQUFBQSxjQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFELElBQUFFLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCLEVBQUEsR0FBQ0YsMEJBQUQsR0FBQSxDQUEyQkQsSUFBQUksTUFBQUEsQ0FBQUEsQ0FBM0IsQ0FBakJGO01BREZELENBQUFBLHlCQUFBQTs7O01BSUEsc0JBQU0sS0FBTjtNQVJKLE9BQUE7SUFHRSw0QkFBU0QsSUFBVDs7QUFRQUssSUFBQUEscUJBQUFBLG9CQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSwrQkFBQUE7O0FBSUFDLElBQUFBLHFCQUFBQSxnQkFBQUEsU0FBTUMsS0FBTkQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsMkJBQUFBOztBQUlBRSxJQUFBQSxxQkFBQUEsZ0JBQUFBLFNBQU1ELEtBQU5DO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxnQ0FBREE7SUFERkEsQ0FBQUEsMkJBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsZ0JBQUFBLFNBQU1GLEtBQU5FO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxnQ0FBREE7SUFERkEsQ0FBQUEsMkJBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEscUJBQUFBLFNBQU9ILEtBQVBHO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxhQUFEQTtJQURGQSxDQUFBQSxnQ0FBQUE7O0FBSUFDLElBQUFBLHVCQUFBQSxrQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsNkJBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEsb0JBQUFBLGlCQW5DRkMsT0FtQ0VEO0FBQUFBLE1BQUFBOzs7O01BbkNGO01BQUE7TUFBQTtNQUFBO01BQUE7O01BbUNZO01BQUE7TUFBQSxXQUFRO01BQVI7TUFDUkEsT0FBQTtJQURGQSxDQUFBQSxnQ0FBQUE7O0FBSUFFLElBQUFBLDJCQUFBQSxzQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQTtJQURGQSxDQUFBQSxpQ0FBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSx3QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsbUNBQUFBOztBQUlBQyxJQUFBQSxtQ0FBQUEsK0JBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUM7SUFERkQsQ0FBQUEsMENBQUFBOztBQUlBRSxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSwrQkFBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxXQUFEQTtJQURGQSxDQUFBQSwrQkFBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQztJQURGRCxDQUFBQSwrQkFBQUE7SUFJQSxhQUFNLE1BQU4sRUFBVyxNQUFYOztBQUVBRSxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUE7SUFERkEsQ0FBQUEsK0JBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUMsdUJBQU9DLEtBQUFBLENBQUtKLENBQVosRUFBZUEsQ0FBUkk7SUFEVEYsQ0FBQUEsK0JBQUFBOztBQUlBRyxJQUFBQSwrQkFBQUEsMkJBQUFBLHVCQXpFRixFQXlFRUE7QUFBQUEsTUFBQUE7Ozs7TUF6RUY7O01BeUVrQjtNQUNkLElBQUEsUUFBbUNDLE9BQVpDLElBQUlDLFFBQUFBLENBQUFBLENBQVFGLEVBQUVHLENBQUZILENBQW5DLENBQUE7UUFBQTNCLElBQUFFLE9BQUFBLENBQU02Qiw2QkFBTjdCLENBQUE7TUFDQXdCLE9BQUExQixJQUFBZ0MsVUFBQUEsQ0FBU1gsQ0FBVCxFQUFZUyxDQUFaRTtJQUZGTixDQUFBQSx1Q0FBQUE7O0FBS0FPLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBakMsSUFBQWdDLFVBQUFBLENBQVNYLENBQVQsRUFBWVMsQ0FBWkU7SUFERkMsQ0FBQUEsK0JBQUFBO0lBSUFsQyxPQUFBbUMsQ0FBQUEsc0NBQUFBLGtDQUFBQSw4QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsNkNBQUFBLENBQUFBO0VBbEZGbkMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUF1RkFELE9BQUEsbUNBQU0sR0FBTjtBQXZGQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY0MzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jvb2xlYW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQm9vbGVhbiA8IGBCb29sZWFuYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19ib29sZWFuJywgdHJ1ZSlgXG5cbiAgJXh7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBbJyQkY2xhc3MnLCAnJCRtZXRhJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCBwcm9wZXJ0aWVzW2ldLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMgPT0gdHJ1ZSAgPyBPcGFsLlRydWVDbGFzcyA6XG4gICAgICAgICAgICAgICAgIHRoaXMgPT0gZmFsc2UgPyBPcGFsLkZhbHNlQ2xhc3MgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3BhbC5Cb29sZWFuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgXCIkJGlkXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gdHJ1ZSAgPyAyIDpcbiAgICAgICAgICAgICAgIHRoaXMgPT0gZmFsc2UgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBfX2lkX19cbiAgICBgc2VsZi52YWx1ZU9mKCkgPyAyIDogMGBcbiAgZW5kXG5cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuXG4gIGRlZiAhXG4gICAgYHNlbGYgIT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKSA6IGZhbHNlYFxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyB0cnVlIDogKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKWBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyID09PSBmYWxzZSB8fCBvdGhlciA9PT0gbmlsKSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPT09IG90aGVyLnZhbHVlT2YoKWBcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYHNlbGYuJCRtZXRhYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAoc2VsZiA9PSB0cnVlKSA/ICd0cnVlJyA6ICdmYWxzZSdgXG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvMjIzMFxuICAjXG4gICMgVGhpcyBpcyBhIGhhY2sgdGhhdCBhbGxvd3MgeW91IHRvIGFkZCBtZXRob2RzIHRvIFRydWVDbGFzcyBhbmQgRmFsc2VDbGFzcy5cbiAgIyBEbyBub3RlLCB0aGF0IHdoaWxlIHRydWUgYW5kIGZhbHNlIGhhdmUgYSBjb3JyZWN0ICQkY2xhc3MgKGl0J3MgZWl0aGVyXG4gICMgVHJ1ZUNsYXNzIG9yIEZhbHNlQ2xhc3MpLCB0aGVpciBwcm90b3R5cGUgaXMgYEJvb2xlYW4uJCRwcm90b3R5cGVgLCB3aGljaFxuICAjIGJhc2ljYWxseSBtZWFucyB0aGF0IHdoZW4gY2FsbGluZyBgdHJ1ZS5zb21ldGhpbmdgIHdlIGFjdHVhbGx5IGNhbGxcbiAgIyBgQm9vbGVhbiNzb21ldGhpbmdgIGluc3RlYWQgb2YgYFRydWVDbGFzcyNzb21ldGhpbmdgLiBTbyB1c2luZ1xuICAjIG1ldGhvZF9taXNzaW5nIHdlIGRpc3BhdGNoIGl0IHRvIGBUcnVlQ2xhc3MvRmFsc2VDbGFzcyNzb21ldGhpbmdgIGNvcnJlY3RseS5cbiAgI1xuICAjIFRoZSBkb3duc2lkZSBpcyB0aGF0IGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBhbHNvIGFsbG93IHVzIHRvIG92ZXJyaWRlXG4gICMgdGhlIG1ldGhvZHMgZGVmaW5lZCBvbiBCb29sZWFuLCBidXQgb3VyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgYWxsb3cgdGhhdCxcbiAgIyB1bmxlc3MgeW91IGRlZmluZSB0aGVtIG9uIEJvb2xlYW4gYW5kIG5vdCBvbiBUcnVlQ2xhc3MvRmFsc2VDbGFzcy5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICBgdmFyIGJvZHkgPSBzZWxmLiQkY2xhc3MuJCRwcm90b3R5cGVbJyQnICsgI3ttZXRob2R9XWBcbiAgICBzdXBlciB1bmxlc3MgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXG4gICAgYE9wYWwuc2VuZChzZWxmLCBib2R5LCAje2FyZ3N9LCAje2Jsb2NrfSlgXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZCwgX2luY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYHZhciBib2R5ID0gc2VsZi4kJGNsYXNzLiQkcHJvdG90eXBlWyckJyArICN7bWV0aG9kfV1gXG4gICAgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRydWVDbGFzcyA8IEJvb2xlYW47IGVuZFxuY2xhc3MgRmFsc2VDbGFzcyA8IEJvb2xlYW47IGVuZFxuXG5UUlVFICA9IHRydWVcbkZBTFNFID0gZmFsc2VcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJvb2xlYW4+IiwiYWxsb2NhdGUiLCJzZWxmIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJvdGhlciIsInwiLCJeIiwiPT0iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19zIiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwibWV0aG9kX21pc3NpbmciLCJtZXRob2QiLCJhcmdzIiwiYmxvY2siLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiX2luY2x1ZGVfYWxsIiwiPGNsYXNzOlRydWVDbGFzcz4iLCJCb29sZWFuIiwiPGNsYXNzOkZhbHNlQ2xhc3M+Il0sIm1hcHBpbmdzIjoiQUFBQUEsa0RBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDR0E7O0FBR0hBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFFRTtNQUFBOzs7O0FBQ0VDLE1BQUFBLDRCQUFBQSxjQUFBQSxvQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLElBQUFDLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCLEVBQUEsR0FBQ0gsMEJBQUQsR0FBQSxDQUEyQkMsSUFBQUcsTUFBQUEsQ0FBQUEsQ0FBM0IsQ0FBakJGO01BREZGLENBQUFBLHlCQUFBQTs7O01BSUEsc0JBQU0sS0FBTjtNQWxDSixPQUFBO0lBNkJFLDRCQUFTQyxJQUFUOztBQVFBSSxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esc0JBQURBO0lBREZBLENBQUFBLCtCQUFBQTtJQUlBLGFBQU0sV0FBTixFQUFnQixRQUFoQjs7QUFFQUMsSUFBQUEscUJBQUFBLG1CQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsWUFBREE7SUFERkEsQ0FBQUEsOEJBQUFBOztBQUlBQyxJQUFBQSxxQkFBQUEsZUFBQUEsU0FBTUMsS0FBTkQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDJEQUFEQTtJQURGQSxDQUFBQSwwQkFBQUE7O0FBSUFFLElBQUFBLHFCQUFBQSxlQUFBQSxTQUFNRCxLQUFOQztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsMERBQURBO0lBREZBLENBQUFBLDBCQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU1GLEtBQU5FO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSx3RkFBREE7SUFERkEsQ0FBQUEsMEJBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEsb0JBQUFBLFNBQU9ILEtBQVBHO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxrQ0FBREE7SUFERkEsQ0FBQUEsK0JBQUFBO0lBSUEsYUFBTSxRQUFOLEVBQWEsSUFBYjtJQUNBLGFBQU0sTUFBTixFQUFXLElBQVg7O0FBRUFDLElBQUFBLG1DQUFBQSw2QkFBQUEsMkJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxXQUFEQTtJQURGQSxDQUFBQSx3Q0FBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxpQ0FBREE7SUFERkEsQ0FBQUEsNkJBQUFBO0lBSUEsYUFBTSxTQUFOLEVBQWMsTUFBZDs7QUFFQUMsSUFBQUEsdUJBQUFBLGtCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWI7SUFERmEsQ0FBQUEsNkJBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEsb0JBQUFBLGlCQWhGRkMsT0FnRkVEO0FBQUFBLE1BQUFBOzs7O01BaEZGO01BQUE7TUFBQTtNQUFBO01BQUE7O01BZ0ZZO01BQUE7TUFBQSxXQUFRO01BQVI7TUFDUkEsT0FBQWQ7SUFERmMsQ0FBQUEsZ0NBQUFBOztBQWdCQUUsSUFBQUEsa0NBQUFBLDZCQUFBQSwwQkFBbUJDLE1BQUQsRUFoR3BCLEVBZ0dFRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFrQzs7TUFoR3BDOztNQWdHNkI7TUFDeEJBLDBDQUE0Q0MsTUFBT0Q7TUFDcEQsSUFBQSxRQUFjQSwyQ0FBZCxDQUFBO01BQUE7UUFBQSxPQUFBaEIsSUFBQSxFQUFBLDRFQUFBLGtCQUFBLEVBQUEsQ0FBQWlCLE1BQUEsQ0FBQSxRQUFBLFVBQUFDLElBQUEsQ0FBQSxDQUFBLEVBQUEsS0FBQTtNQUFBO01BQ0FGLE9BQUNBLHNCQUF3QkUsSUFBS0YsRUFBSUcsS0FBTUg7SUFIMUNBLENBQUFBLHlDQUFBQTtJQU1BbEIsT0FBQXNCLENBQUFBLHVDQUFBQSxzQ0FBQUEsU0FBd0JILE1BQUQsRUFBU0ksWUFBaENEO0FBQUFBLE1BQUFBOzs7O01BQWdDO01BQUEsaUJBQWUsS0FBZjtNQUFBO01BQzdCQSwwQ0FBNENILE1BQU9HO01BQ3BEQSxPQUFDQSwyQ0FBREE7SUFGRkEsQ0FBQUEsa0RBQUFBLENBQUFBO0VBdEdGdEIsR0FBQUEsV0FBQUEsRUFBaUJELE9BQWpCQztFQTRHQXdCO0VBQUFBOztJQUFBQTs7SUFBQUEsT0FBQTtFQUFBQSxHQUFBQSxXQUFBQSxFQUFrQkMsdUJBQWxCRDtFQUNBRTtFQUFBQTs7SUFBQUE7O0lBQUFBLE9BQUE7RUFBQUEsR0FBQUEsV0FBQUEsRUFBbUJELHVCQUFuQkM7RUFFQSxvQ0FBUSxJQUFSO0VBQ0EzQixPQUFBLHFDQUFRLEtBQVI7QUFoSEFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2NjA3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wYXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZmFsc3lcblxubW9kdWxlIENvbXBhcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdoYXQpIHtcbiAgICAgIGlmIChPcGFsLmlzX2Eod2hhdCwgT3BhbC5JbnRlZ2VyKSkgeyByZXR1cm4gd2hhdDsgfVxuXG4gICAgICBpZiAoI3tgd2hhdGAgPiAwfSkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKCN7YHdoYXRgIDwgMH0pIHsgcmV0dXJuIC0xOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpIHtcbiAgICAgIHZhciBjbGFzc19uYW1lO1xuICAgICAgI3tcbiAgICAgICAgY2FzZSBgcmhzYFxuICAgICAgICB3aGVuIG5pbCwgdHJ1ZSwgZmFsc2UsIEludGVnZXIsIEZsb2F0XG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJGluc3BlY3QoKWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiQkY2xhc3NgXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgbGhzYC5jbGFzc30gd2l0aCAje2BjbGFzc19uYW1lYH0gZmFpbGVkXCJ9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY21wX29yX2ZhaWwobGhzLCByaHMpIHtcbiAgICAgIHZhciBjbXAgPSAje2BsaHNgIDw9PiBgcmhzYH07XG4gICAgICBpZiAoJGZhbHN5KGNtcCkpIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocyk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKGNtcCk7XG4gICAgfVxuICB9XG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiB0cnVlIGlmIGVxdWFsPyhvdGhlcilcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGZbXCIkPD0+XCJdID09IE9wYWwuS2VybmVsW1wiJDw9PlwiXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIGlmIChzZWxmLiQkY29tcGFyYWJsZSkge1xuICAgICAgICBkZWxldGUgc2VsZi4kJGNvbXBhcmFibGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcblxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpID4gMGBcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPj0gMGBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA8IDBgXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDw9IDBgXG4gIGVuZFxuXG4gIGRlZiBiZXR3ZWVuPyhtaW4sIG1heClcbiAgICByZXR1cm4gZmFsc2UgaWYgc2VsZiA8IG1pblxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmID4gbWF4XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgY2xhbXAobWluLCBtYXggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgYywgZXhjbDtcblxuICAgICAgaWYgKG1heCA9PT0gbmlsKSB7XG4gICAgICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggYSBuZXcgUnVieSAyLjcgYmVoYXZpb3VyIHRoYXQgd2UgYXJlIGFibGUgdG9cbiAgICAgICAgLy8gcHJvdmlkZSBhIHNpbmdsZSBSYW5nZSBhcmd1bWVudCBpbnN0ZWFkIG9mIDIgQ29tcGFyYWJsZXMuXG5cbiAgICAgICAgaWYgKCFPcGFsLmlzX2EobWluLCBPcGFsLlJhbmdlKSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3ttaW4uY2xhc3N9IChleHBlY3RlZCBSYW5nZSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4Y2wgPSBtaW4uZXhjbDtcbiAgICAgICAgbWF4ID0gbWluLmVuZDtcbiAgICAgICAgbWluID0gbWluLmJlZ2luO1xuXG4gICAgICAgIGlmIChtYXggIT09IG5pbCAmJiBleGNsKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY2Fubm90IGNsYW1wIHdpdGggYW4gZXhjbHVzaXZlIHJhbmdlJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwgJiYgbWF4ICE9PSBuaWwgJiYgY21wX29yX2ZhaWwobWluLCBtYXgpID4gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtaW4gYXJndW1lbnQgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtaW4pO1xuXG4gICAgICAgIGlmIChjID09IDApIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoYyA8IDApIHJldHVybiBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggIT09IG5pbCkge1xuICAgICAgICBjID0gY21wX29yX2ZhaWwoc2VsZiwgbWF4KTtcblxuICAgICAgICBpZiAoYyA+IDApIHJldHVybiBtYXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpDb21wYXJhYmxlPiIsIj4iLCIwIiwiPCIsIj09PSIsIkludGVnZXIiLCJGbG9hdCIsInNlbGYiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjbGFzcyIsIjw9PiIsIj09Iiwib3RoZXIiLCJlcXVhbD8iLCJj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Q0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxVQUFZZCxJQUFBQyxPQUFBQSxDQUFNYyx5QkFBTixFQUFpQixFQUFBLEdBQUNELHNCQUFELEdBQUEsQ0FBdUJGLEdBQUdULE9BQUFBLENBQUFBLENBQTFCLENBQUEsR0FBaUNXLG1CQUFsRGI7QUFDWmE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxVQUFZZCxJQUFBQyxPQUFBQSxDQUFNQyw2QkFBTixFQUFxQlksc0NBQXJCYjtBQUNaYTtBQUNBQTs7QUFFQUE7QUFDQUEsUUFBVWQsSUFBQUMsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUJZLGdEQUFyQmI7QUFDVmE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXZDRUEsQ0FBQUEsa0NBQUFBLENBQUFBO0VBeEVGckIsR0FBQUEsV0FBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjY3NTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JlZ2V4cC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5jbGFzcyBSZWdleHBFcnJvciA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuXG5jbGFzcyBSZWdleHAgPCBgUmVnRXhwYFxuICBJR05PUkVDQVNFID0gMVxuICBFWFRFTkRFRCA9IDJcbiAgTVVMVElMSU5FID0gNFxuXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3JlZ2V4cCcsIHRydWUpYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIGFsbG9jYXRlZCA9IHN1cGVyXG4gICAgICBgI3thbGxvY2F0ZWR9LnVuaW5pdGlhbGl6ZWQgPSB0cnVlYFxuICAgICAgYWxsb2NhdGVkXG4gICAgZW5kXG5cbiAgICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICAgIGBPcGFsLmVzY2FwZV9yZWdleHAoc3RyaW5nKWBcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0X21hdGNoKG4gPSBuaWwpXG4gICAgICBpZiBuLm5pbD9cbiAgICAgICAgJH5cbiAgICAgIGVsc2lmICR+XG4gICAgICAgICR+W25dXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIHF1b3RlIGVzY2FwZVxuXG4gICAgZGVmIHVuaW9uKCpwYXJ0cylcbiAgICAgICV4e1xuICAgICAgICB2YXIgaXNfZmlyc3RfcGFydF9hcnJheSwgcXVvdGVkX3ZhbGlkYXRlZCwgcGFydCwgb3B0aW9ucywgZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAvKD8hKS87XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGZhc3QgaWYgdGhlcmUncyBvbmx5IG9uZSBlbGVtZW50XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT0gMSAmJiBwYXJ0c1swXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3ZlciB0aGUgMiBhcnJheXMgcGFzc2VkIGFzIGFyZ3VtZW50cyBjYXNlXG4gICAgICAgIGlzX2ZpcnN0X3BhcnRfYXJyYXkgPSBwYXJ0c1swXS4kJGlzX2FycmF5O1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIEFycmF5IGludG8gU3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWFsIHdpdGggc3BsYXQgaXNzdWVzIChyZWxhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGFsL29wYWwvaXNzdWVzLzg1OClcbiAgICAgICAgaWYgKGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICBwYXJ0cyA9IHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHF1b3RlZF92YWxpZGF0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKHBhcnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGApfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHBhcnQuJCRpc19yZWdleHApIHtcbiAgICAgICAgICAgIGVhY2hfcGFydF9vcHRpb25zID0gI3tgcGFydGAub3B0aW9uc307XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucyAhPSBlYWNoX3BhcnRfb3B0aW9ucykge1xuICAgICAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0FsbCBleHByZXNzaW9ucyBtdXN0IHVzZSB0aGUgc2FtZSBvcHRpb25zJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgnKCcrcGFydC5zb3VyY2UrJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goI3tlc2NhcGUoYHBhcnRgLnRvX3N0cil9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICMgVGFrZSBhZHZhbnRhZ2Ugb2YgbG9naWMgdGhhdCBjYW4gcGFyc2Ugb3B0aW9ucyBmcm9tIEpTIFJlZ2V4XG4gICAgICBuZXcoYHF1b3RlZF92YWxpZGF0ZWRgLmpvaW4oJ3wnKSwgYG9wdGlvbnNgKVxuICAgIGVuZFxuXG4gICAgZGVmIG5ldyhyZWdleHAsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKHJlZ2V4cC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdleHAgPSAje09wYWwuY29lcmNlX3RvIShyZWdleHAsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIGlmIChyZWdleHAuY2hhckF0KHJlZ2V4cC5sZW5ndGggLSAxKSA9PT0gJ1xcXFwnICYmIHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDIpICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAje3JhaXNlIFJlZ2V4cEVycm9yLCBcInRvbyBzaG9ydCBlc2NhcGUgc2VxdWVuY2U6IC8je3JlZ2V4cH0vXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICN7IW9wdGlvbnN9KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSAnJztcbiAgICAgICAgICBpZiAoI3tJR05PUkVDQVNFfSAmIG9wdGlvbnMpIHsgdGVtcCArPSAnaSc7IH1cbiAgICAgICAgICBpZiAoI3tNVUxUSUxJTkV9ICAmIG9wdGlvbnMpIHsgdGVtcCArPSAnbSc7IH1cbiAgICAgICAgICBvcHRpb25zID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gJ2knO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGFsaWFzIGNvbXBpbGUgbmV3XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgaW5zdGFuY2VvZiBSZWdFeHAgJiYgc2VsZi50b1N0cmluZygpID09PSBvdGhlci50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgPT09KHN0cmluZylcbiAgICBgI3ttYXRjaChPcGFsLmNvZXJjZV90bz8oc3RyaW5nLCBTdHJpbmcsIDp0b19zdHIpKX0gIT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmID1+KHN0cmluZylcbiAgICBtYXRjaChzdHJpbmcpICYmICR+LmJlZ2luKDApXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgaW5zcGVjdFxuICAgICMgVXNlIGEgcmVnZXhwIHRvIGV4dHJhY3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgdGhlIG9wdGlvbmFsIG1vZGUgbW9kaWZpZXJzIGZyb20gdGhlIHN0cmluZy5cbiAgICAjIEluIHRoZSByZWd1bGFyIGV4cHJlc3Npb24sIGVzY2FwZSBhbnkgZnJvbnQgc2xhc2ggKG5vdCBhbHJlYWR5IGVzY2FwZWQpIHdpdGggYSBiYWNrc2xhc2guXG4gICAgJXh7XG4gICAgICB2YXIgcmVnZXhwX2Zvcm1hdCA9IC9eXFwvKC4qKVxcLyhbXlxcL10qKSQvO1xuICAgICAgdmFyIHZhbHVlID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgdmFyIG1hdGNoZXMgPSByZWdleHBfZm9ybWF0LmV4ZWModmFsdWUpO1xuICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgdmFyIHJlZ2V4cF9wYXR0ZXJuID0gbWF0Y2hlc1sxXTtcbiAgICAgICAgdmFyIHJlZ2V4cF9mbGFncyA9IG1hdGNoZXNbMl07XG4gICAgICAgIHZhciBjaGFycyA9IHJlZ2V4cF9wYXR0ZXJuLnNwbGl0KCcnKTtcbiAgICAgICAgdmFyIGNoYXJzX2xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRfY2hhciA9IGNoYXJzW2ldO1xuICAgICAgICAgIGlmICghY2hhcl9lc2NhcGVkICYmIGN1cnJlbnRfY2hhciA9PSAnLycpIHtcbiAgICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdCgnXFxcXCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gcmVnZXhwX3BhdHRlcm5fZXNjYXBlZC5jb25jYXQoY3VycmVudF9jaGFyKTtcbiAgICAgICAgICBpZiAoY3VycmVudF9jaGFyID09ICdcXFxcJykge1xuICAgICAgICAgICAgaWYgKGNoYXJfZXNjYXBlZCkge1xuICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBvdmVyIGVzY2FwZVxuICAgICAgICAgICAgICBjaGFyX2VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy8nICsgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCArICcvJyArIHJlZ2V4cF9mbGFncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaChzdHJpbmcsIHBvcyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ3VuaW5pdGlhbGl6ZWQgUmVnZXhwJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB2YXIgbSA9IHNlbGYuZXhlYygkY29lcmNlX3RvKHN0cmluZywgI3tTdHJpbmd9LCAndG9fc3RyJykpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICN7JH4gPSBNYXRjaERhdGEubmV3KGBzZWxmYCwgYG1gKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoc3RyaW5nID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSAkY29lcmNlX3RvKHN0cmluZywgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xuICAgICAgdmFyIG1kLCByZSA9IE9wYWwuZ2xvYmFsX3JlZ2V4cChzZWxmKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWQgPSByZS5leGVjKHN0cmluZyk7XG4gICAgICAgIGlmIChtZCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWQuaW5kZXggPj0gcG9zKSB7XG4gICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHJlYCwgYG1kYCl9O1xuICAgICAgICAgIHJldHVybiBibG9jayA9PT0gbmlsID8gI3skfn0gOiAje3lpZWxkICR+fTtcbiAgICAgICAgfVxuICAgICAgICByZS5sYXN0SW5kZXggPSBtZC5pbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHN0cmluZywgcG9zID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ3VuaW5pdGlhbGl6ZWQgUmVnZXhwJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcgPT09IG5pbCA/IGZhbHNlIDogc2VsZi50ZXN0KCRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKSk7XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zICs9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdsb2JhbCBSZWdFeHAgbWFpbnRhaW5zIHN0YXRlLCBzbyBub3QgdXNpbmcgc2VsZi90aGlzXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xuXG4gICAgICBtZCA9IHJlLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChtZCA9PT0gbnVsbCB8fCBtZC5pbmRleCA8IHBvcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuYW1lc1xuICAgIHNvdXJjZS5zY2FuKC9cXCg/PChcXHcrKT4vKS5tYXAoJjpmaXJzdCkudW5pcVxuICBlbmRcblxuICBkZWYgbmFtZWRfY2FwdHVyZXNcbiAgICBzb3VyY2Uuc2NhbigvXFwoPzwoXFx3Kyk+LykgICAgICAgICMgU2NhbiBmb3IgY2FwdHVyZSBncm91cHNcbiAgICAgICAgICAubWFwKCY6Zmlyc3QpICAgICAgICAgICAgICAjIEdldCB0aGUgZmlyc3QgcmVnZXhwIG1hdGNoIChcXHcrKVxuICAgICAgICAgIC5lYWNoX3dpdGhfaW5kZXggICAgICAgICAgICMgQWRkIGluZGV4IHRvIGFuIGl0ZXJhdG9yXG4gICAgICAgICAgLmdyb3VwX2J5KCY6Zmlyc3QpICAgICAgICAgIyBHcm91cCBieSB0aGUgY2FwdHVyZSBncm91cCBuYW1lc1xuICAgICAgICAgIC50cmFuc2Zvcm1fdmFsdWVzIGRvIHxpfCAgICMgQ29udmVydCBoYXNoIHZhbHVlc1xuICAgICAgICAgICAgaS5tYXAgeyB8anwgai5sYXN0ICsgMSB9ICMgRHJvcCB0aGUgY2FwdHVyZSBncm91cCBuYW1lczsgaW5jcmVhc2UgaW5kZXhlcyBieSAxXG4gICAgICAgICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgc2VsZiA9fiAkX1xuICBlbmRcblxuICBkZWYgc291cmNlXG4gICAgYHNlbGYuc291cmNlYFxuICBlbmRcblxuICBkZWYgb3B0aW9uc1xuICAgICMgRmxhZ3Mgd291bGQgYmUgbmljZSB0byB1c2Ugd2l0aCB0aGlzLCBidXQgc3RpbGwgZXhwZXJpbWVudGFsIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwL2ZsYWdzXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICAvLyBzaG91bGQgYmUgc3VwcG9ydGVkIGluIElFNiBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS83ZjV6MjZ3NCh2PXZzLjk0KS5hc3B4XG4gICAgICBpZiAoc2VsZi5tdWx0aWxpbmUpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7TVVMVElMSU5FfTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmVzdWx0IHw9ICN7SUdOT1JFQ0FTRX07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNhc2Vmb2xkP1xuICAgIGBzZWxmLmlnbm9yZUNhc2VgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3Mgc291cmNlXG5lbmRcblxuY2xhc3MgTWF0Y2hEYXRhXG4gIGF0dHJfcmVhZGVyIDpwb3N0X21hdGNoLCA6cHJlX21hdGNoLCA6cmVnZXhwLCA6c3RyaW5nXG5cbiAgZGVmIGluaXRpYWxpemUocmVnZXhwLCBtYXRjaF9ncm91cHMpXG4gICAgJH4gICAgICAgICAgPSBzZWxmXG4gICAgQHJlZ2V4cCAgICAgPSByZWdleHBcbiAgICBAYmVnaW4gICAgICA9IGBtYXRjaF9ncm91cHMuaW5kZXhgXG4gICAgQHN0cmluZyAgICAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0YFxuICAgIEBwcmVfbWF0Y2ggID0gYG1hdGNoX2dyb3Vwcy5pbnB1dC5zbGljZSgwLCBtYXRjaF9ncm91cHMuaW5kZXgpYFxuICAgIEBwb3N0X21hdGNoID0gYG1hdGNoX2dyb3Vwcy5pbnB1dC5zbGljZShtYXRjaF9ncm91cHMuaW5kZXggKyBtYXRjaF9ncm91cHNbMF0ubGVuZ3RoKWBcbiAgICBAbWF0Y2hlcyAgICA9IFtdXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtYXRjaF9ncm91cHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gbWF0Y2hfZ3JvdXBzW2ldO1xuXG4gICAgICAgIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChuaWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2goZ3JvdXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgW10oKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAoI3shcmVnZXhwLm5hbWVzLmluY2x1ZGU/KGFyZ3NbMF0pfSkge1xuICAgICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJ1bmRlZmluZWQgZ3JvdXAgbmFtZSByZWZlcmVuY2U6ICN7YXJnc1swXX1cIn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tuYW1lZF9jYXB0dXJlc1thcmdzWzBdXX1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tAbWF0Y2hlc1sqYXJnc119XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgb2Zmc2V0KG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjb2Zmc2V0IG9ubHkgc3VwcG9ydHMgMHRoIGVsZW1lbnQnfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtzZWxmLmJlZ2luLCBzZWxmLmJlZ2luICsgc2VsZi5tYXRjaGVzW25dLmxlbmd0aF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBNYXRjaERhdGEgPT09IG90aGVyXG5cbiAgICBgc2VsZi5zdHJpbmcgPT0gb3RoZXIuc3RyaW5nYCAmJlxuICAgICAgYHNlbGYucmVnZXhwLnRvU3RyaW5nKCkgPT0gb3RoZXIucmVnZXhwLnRvU3RyaW5nKClgICYmXG4gICAgICBgc2VsZi5wcmVfbWF0Y2ggPT0gb3RoZXIucHJlX21hdGNoYCAmJlxuICAgICAgYHNlbGYucG9zdF9tYXRjaCA9PSBvdGhlci5wb3N0X21hdGNoYCAmJlxuICAgICAgYHNlbGYuYmVnaW4gPT0gb3RoZXIuYmVnaW5gXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgYmVnaW4obilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNiZWdpbiBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmJlZ2luO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVuZChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI2VuZCBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmJlZ2luICsgc2VsZi5tYXRjaGVzW25dLmxlbmd0aDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYXB0dXJlc1xuICAgIGAje0BtYXRjaGVzfS5zbGljZSgxKWBcbiAgZW5kXG5cbiAgZGVmIG5hbWVkX2NhcHR1cmVzXG4gICAgbWF0Y2hlcyA9IGNhcHR1cmVzXG4gICAgcmVnZXhwLm5hbWVkX2NhcHR1cmVzLnRyYW5zZm9ybV92YWx1ZXMgZG8gfGl8XG4gICAgICBtYXRjaGVzW2kubGFzdCAtIDFdXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBuYW1lc1xuICAgIHJlZ2V4cC5uYW1lc1xuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IFwiIzxNYXRjaERhdGEgXCIgKyAje2Aje0BtYXRjaGVzfVswXWAuaW5zcGVjdH07XG5cbiAgICAgIGlmICgje3JlZ2V4cC5uYW1lcy5lbXB0eT99KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSAje0BtYXRjaGVzfS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN0ciArPSBcIiBcIiArIGkgKyBcIjpcIiArICN7YCN7QG1hdGNoZXN9W2ldYC5pbnNwZWN0fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7IG5hbWVkX2NhcHR1cmVzLmVhY2ggZG8gfGssIHZ8XG4gICAgICAgICAgICAgJXh7XG4gICAgICAgICAgICAgICBzdHIgKz0gXCIgXCIgKyAje2t9ICsgXCI6XCIgKyAje3YuaW5zcGVjdH1cbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIGVuZCB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHIgKyBcIj5cIjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgI3tAbWF0Y2hlc30ubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGRlZiB0b19hXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgI3tAbWF0Y2hlc31bMF1gXG4gIGVuZFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgYSwgaW5kZXgsIHZhbHVlcyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIGlmIChhcmdzW2ldLiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgICBhID0gI3tgYXJnc1tpXWAudG9fYX07XG4gICAgICAgICAgYS51bnNoaWZ0KGksIDEpO1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoYXJncywgYSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9ICN7T3BhbC5jb2VyY2VfdG8hKGBhcmdzW2ldYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSAje0BtYXRjaGVzfS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gobmlsKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlcy5wdXNoKCN7QG1hdGNoZXN9W2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UmVnZXhwRXJyb3I+IiwiU3RhbmRhcmRFcnJvciIsIjxjbGFzczpSZWdleHA+IiwiMSIsIjIiLCI0IiwiYWxsb2NhdGUiLCJhbGxvY2F0ZWQiLCJzZWxmIiwiZXNjYXBlIiwic3RyaW5nIiwibGFzdF9tYXRjaCIsIm4iLCJuaWw/IiwiJH4iLCJbXSIsInVuaW9uIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJvcHRpb25zIiwidG9fc3RyIiwibmV3Iiwiam9pbiIsInJlZ2V4cCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiUmVnZXhwRXJyb3IiLCIhIiwiSUdOT1JFQ0FTRSIsIk1VTFRJTElORSIsIj09Iiwib3RoZXIiLCI9PT0iLCJtYXRjaCIsImNvZXJjZV90bz8iLCI9fiIsIiRyZXRfb3JfMSIsImJlZ2luIiwiMCIsImluc3BlY3QiLCJwb3MiLCJNYXRjaERhdGEiLCJJbnRlZ2VyIiwibWF0Y2g/IiwibmFtZXMiLCJtYXAiLCJzb3VyY2UiLCJzY2FuIiwidG9fcHJvYyIsInVuaXEiLCJuYW1lZF9jYXB0dXJlcyIsInRyYW5zZm9ybV92YWx1ZXMiLCJncm91cF9ieSIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIG5hbWVkX2NhcHR1cmVzIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gbmFtZWRfY2FwdHVyZXMiLCJqIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYW1lZF9jYXB0dXJlcyIsIisiLCJsYXN0IiwifiIsIiRfIiwiY2FzZWZvbGQ/IiwiPGNsYXNzOk1hdGNoRGF0YT4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJtYXRjaF9ncm91cHMiLCJAcmVnZXhwIiwiQGJlZ2luIiwiQHN0cmluZyIsIkBwcmVfbWF0Y2giLCJAcG9zdF9tYXRjaCIsIkBtYXRjaGVzIiwiaW5jbHVkZT8iLCJhcmdzIiwiSW5kZXhFcnJvciIsIm9mZnNldCIsIkFyZ3VtZW50RXJyb3IiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCIkcmV0X29yXzUiLCJlbmQiLCJjYXB0dXJlcyIsIm1hdGNoZXMiLCItIiwiZW1wdHk/IiwiZWFjaCIsImJsb2NrIGluIGluc3BlY3QiLCJrIiwidiIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsImxlbmd0aCIsInRvX2EiLCJ0b19zIiwidmFsdWVzX2F0Il0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFFQUM7RUFBQUE7O0lBQUFBOztJQUFBQSxPQUFBO0VBQUFBLEdBQUFBLFdBQUFBLEVBQW9CQyw2QkFBcEJEO0VBRUFFO0VBQUFBOztJQUFBQTs7O0lBQ0UsMENBQWFDLENBQWI7SUFDQSx3Q0FBV0MsQ0FBWDtJQUNBLHlDQUFZQyxDQUFaO0lBRUNIO0lBRUQ7TUFBQTs7OztBQUNFSSxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7UUFDRUMsWUFBWSxPQUFBQyxJQUFBLEVBQUEsdURBQUEsWUFBQSxFQUFBLEVBQUEsRUFBQSxLQUFBO1FBQ1RELFNBQVVEO1FBQ2JBLE9B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c2FFQTtBQUFBQSxNQUFBQTs7OztNQXRhRjs7TUFzYWdCOztBQUVoQkE7O0FBRUFBOztBQUVBQTtBQUNBQSxjQUFnQkEsQ0FBQ0EsT0FBREEsQ0FBU0YsTUFBQUEsQ0FBQUEsQ0FBTUU7QUFDL0JBO0FBQ0FBO0FBQ0FBOztBQUVBQSxnQkFBa0J6RSxvQkFBSUMsZUFBQUEsQ0FBYXdFLE9BQWpCLEVBQTJCdEQsdUJBQTNCLEVBQW9DLFFBQWhDbEIsQ0FBeUN3RTs7QUFFL0RBO0FBQ0FBLG1CQUFxQnZCLFlBQVN1QjtBQUM5QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBLG9CQUFzQnZCLFlBQVN1QjtBQUMvQkE7O0FBRUFBO0FBQ0FBO0lBMUJFQSxDQUFBQSxzQ0FBQUEsQ0FBQUE7RUFqSUZoQyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQXJTQWxFOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo3MzYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHJlc3BvbmRfdG9cblxucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbmNsYXNzIFN0cmluZyA8IGBTdHJpbmdgXG4gIGluY2x1ZGUgQ29tcGFyYWJsZVxuXG4gICV4e1xuICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoI3tzZWxmfS4kJHByb3RvdHlwZSwgJyQkaXNfc3RyaW5nJywgdHJ1ZSk7XG5cbiAgICBPcGFsLmRlZmluZVByb3BlcnR5KCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGNhc3QnLCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBrbGFzcyA9IHRoaXMuJCRjbGFzcztcbiAgICAgIGlmIChrbGFzcy4kJGNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcga2xhc3MuJCRjb25zdHJ1Y3RvcihzdHJpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVmIF9faWRfX1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgc2VsZi50cnlfY29udmVydCh3aGF0KVxuICAgIE9wYWwuY29lcmNlX3RvPyh3aGF0LCBTdHJpbmcsIDp0b19zdHIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBhcmdzWzBdIHx8IFwiXCI7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3NbYXJncy5sZW5ndGgtMV07XG4gICAgICBzdHIgPSAkY29lcmNlX3RvKHN0ciwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLiQkaXNfaGFzaCkge1xuICAgICAgICBpZiAob3B0cy4kJHNtYXAuZW5jb2RpbmcpIHN0ciA9IHN0ci4kZm9yY2VfZW5jb2Rpbmcob3B0cy4kJHNtYXAuZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgc3RyID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcihzdHIpO1xuICAgICAgaWYgKCFzdHIuJGluaXRpYWxpemUuJCRwcmlzdGluZSkgI3tgc3RyYC5pbml0aWFsaXplKCphcmdzKX07XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBPdXIgaW5pdGlhbGl6ZSBtZXRob2QgZG9lcyBub3RoaW5nLCB0aGUgc3RyaW5nIHZhbHVlIHNldHVwIGlzIGJlaW5nXG4gICMgZG9uZSBieSBTdHJpbmcubmV3LiBUaGVyZWZvcmUgbm90IGFsbCBraW5kcyBvZiBzdWJjbGFzc2luZyB3aWxsIHdvcmsuXG4gICMgQXMgYSBydWxlIG9mIHRodW1iLCB3aGVuIHN1YmNsYXNzaW5nIFN0cmluZywgZWl0aGVyIG1ha2Ugc3VyZSB0byBvdmVycmlkZVxuICAjIC5uZXcgb3IgbWFrZSBzdXJlIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIGEgY29uc3RydWN0b3IgaXNcbiAgIyBhIHN0cmluZyB3ZSB3YW50IG91ciBzdWJjbGFzcy1zdHJpbmcgdG8gaG9sZC5cbiAgZGVmIGluaXRpYWxpemUoc3RyID0gdW5kZWZpbmVkLCBlbmNvZGluZzogbmlsLCBjYXBhY2l0eTogbmlsKVxuICBlbmRcblxuICBkZWYgJShkYXRhKVxuICAgIGlmIEFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KCcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgLy8gQWxsIGNyZWRpdCBmb3IgdGhlIGJpdC10d2lkZGxpbmcgbWFnaWMgY29kZSBiZWxvdyBnb2VzIHRvIE1vemlsbGFcbiAgICAgIC8vIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIG9mIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KCkgcG9zdGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoICogY291bnQgPj0gMSA8PCAyOCkge1xuICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsICdtdWx0aXBseSBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJ31cbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID4+Pj0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKCN7b3RoZXJ9LCAje1N0cmluZ30sICd0b19zdHInKWBcblxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09IFwiXCIgJiYgc2VsZi4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7c2VsZn07XG4gICAgICBpZiAoc2VsZiA9PSBcIlwiICYmIG90aGVyLiQkY2xhc3MgPT09IE9wYWwuU3RyaW5nKSByZXR1cm4gI3tvdGhlcn07XG4gICAgICB2YXIgb3V0ID0gc2VsZiArIG90aGVyO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZyAmJiBvdGhlci5lbmNvZGluZyA9PT0gb3V0LmVuY29kaW5nKSByZXR1cm4gb3V0O1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PT0gXCJVVEYtOFwiIHx8IG90aGVyLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIikgcmV0dXJuIG91dDtcbiAgICAgIHJldHVybiBPcGFsLmVuYyhvdXQsIHNlbGYuZW5jb2RpbmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX3N0ci50b19zXG5cbiAgICAgIGBzZWxmID4gb3RoZXIgPyAxIDogKHNlbGYgPCBvdGhlciA/IC0xIDogMClgXG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIHZhciBjbXAgPSAje290aGVyIDw9PiBzZWxmfTtcblxuICAgICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbXAgPiAwID8gLTEgOiAoY21wIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudG9TdHJpbmcoKSA9PT0gb3RoZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19zdHInKSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgPT09ID09XG5cbiAgZGVmID1+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndHlwZSBtaXNtYXRjaDogU3RyaW5nIGdpdmVuJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje290aGVyID1+IHNlbGZ9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLCBleGNsdWRlO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgICAgbGVuZ3RoICA9ICRjb2VyY2VfdG8oaW5kZXguZW5kLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGluZGV4ICAgPSAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGluZGV4KSA+IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSBsZW5ndGggLSBpbmRleDtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvcn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGluZGV4KSAhPT0gLTEgPyBzZWxmLiQkY2FzdChpbmRleCkgOiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHNlbGYubWF0Y2goaW5kZXgpO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgICN7JH4gPSBNYXRjaERhdGEubmV3KGBpbmRleGAsIGBtYXRjaGApfVxuXG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwICYmIC1sZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoICs9IG1hdGNoLmxlbmd0aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFtsZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc3Vic3RyKGluZGV4LCAxKSk7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnN1YnN0cihpbmRleCwgbGVuZ3RoKSk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBieXRlc2xpY2UgW11cblxuICBkZWYgYlxuICAgIGBuZXcgU3RyaW5nKCN7c2VsZn0pYC5mb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGNhcGl0YWxpemVcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNlbGYuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG4gICAgJXh7XG4gICAgICB2YXIgYXNjaWlfb25seSA9IC9eW1xceDAwLVxceDdGXSokLztcbiAgICAgIGlmIChhc2NpaV9vbmx5LnRlc3Qoc2VsZikgJiYgYXNjaWlfb25seS50ZXN0KG90aGVyKSkge1xuICAgICAgICBzZWxmID0gc2VsZi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdGhlciA9IG90aGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYgPD0+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBjbXAgPSAje2Nhc2VjbXAob3RoZXIpfTtcbiAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNtcCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qocmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaG9tcChzZXBhcmF0b3IgPSAkLylcbiAgICByZXR1cm4gc2VsZiBpZiBgc2VwYXJhdG9yID09PSBuaWwgfHwgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBzZXBhcmF0b3IgPSBPcGFsLmNvZXJjZV90byEoc2VwYXJhdG9yLCBTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gXCJcXG5cIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoL1xccj9cXG4/JC8sICcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlcGFyYXRvciA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoLyhcXHI/XFxuKSskLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZi5sZW5ndGggPj0gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGFpbCA9IHNlbGYuc3Vic3RyKHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCwgc2VwYXJhdG9yLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRhaWwgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNob3BcbiAgICAleHtcbiAgICAgIHZhciBsZW5ndGggPSBzZWxmLmxlbmd0aCwgcmVzdWx0O1xuXG4gICAgICBpZiAobGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5jaGFyQXQobGVuZ3RoIC0gMSkgPT09IFwiXFxuXCIgJiYgc2VsZi5jaGFyQXQobGVuZ3RoIC0gMikgPT09IFwiXFxyXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgbGVuZ3RoIC0gMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyXG4gICAgYHNlbGYuY2hhckF0KDApYFxuICBlbmRcblxuICBkZWYgY2xvbmVcbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgU3RyaW5nKHNlbGYpYFxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3VudCgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfcHJlZml4KHByZWZpeClcbiAgICAleHtcbiAgICAgIGlmICghcHJlZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4LCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2UoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zbGljZShwcmVmaXgubGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfc3VmZml4KHN1ZmZpeClcbiAgICAleHtcbiAgICAgIGlmICghc3VmZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4LCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2Uoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnNsaWNlKDAsIHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZG93bmNhc2VcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi50b0xvd2VyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9saW5lLCBzZXBhcmF0b3IgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBuaWwpIHtcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHNlbGYpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBzZXBhcmF0b3IgPSAkY29lcmNlX3RvKHNlcGFyYXRvciwgI3tTdHJpbmd9LCAndG9fc3RyJylcblxuICAgICAgdmFyIGEsIGksIG4sIGxlbmd0aCwgY2hvbXBlZCwgdHJhaWxpbmcsIHNwbGl0dGVkO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKGEgPSBzZWxmLnNwbGl0KC8oXFxuezIsfSkvKSwgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgICAgIGlmIChhW2ldIHx8IGFbaSArIDFdKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAoYVtpXSB8fCBcIlwiKSArIChhW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdCh2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XG4gICAgICB0cmFpbGluZyA9IHNlbGYubGVuZ3RoICE9IGNob21wZWQubGVuZ3RoO1xuICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSB8fCB0cmFpbGluZykge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSArIHNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZW5kX3dpdGg/KCpzdWZmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdWZmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXhlc1tpXSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PT1cblxuICBkZWYgZ3N1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6Z3N1YiwgcGF0dGVybn07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJywgbWF0Y2hfZGF0YSA9IG5pbCwgaW5kZXggPSAwLCBtYXRjaCwgX3JlcGxhY2VtZW50O1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXN1bHQgKz0gc2VsZi5zbGljZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaF9kYXRhID0gI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH07XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXN0SW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSBibG9jayhtYXRjaFswXSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBsYXN0SW5kZXg7IC8vIHNhdmUgYW5kIHJlc3RvcmUgbGFzdEluZGV4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQuJCRpc19oYXNoKSB7XG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudCArIChzZWxmW21hdGNoLmluZGV4XSB8fCBcIlwiKSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudClcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgfVxuXG4gICAgICAjeyR+ID0gYG1hdGNoX2RhdGFgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBoZXhcbiAgICB0b19pIDE2XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2Yob3RoZXIpICE9PSAtMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByZWdleDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAkY29lcmNlX3RvKG9mZnNldCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICByZWdleCA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID49IG9mZnNldCkge1xuICAgICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHJlZ2V4YCwgYG1hdGNoYCl9XG4gICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCAmJiBvZmZzZXQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXggPSBzZWxmLmluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBuaWwgOiBpbmRleDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xuICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxcdTAwN0YtXFx1MDA5RlxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgICAgICAgbWV0YSA9IHtcbiAgICAgICAgICAgICdcXHUwMDA3JzogJ1xcXFxhJyxcbiAgICAgICAgICAgICdcXHUwMDFiJzogJ1xcXFxlJyxcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAnXFx2JzogJ1xcXFx2JyxcbiAgICAgICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXNjYXBlZCA9IHNlbGYucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChjaHIpIHtcbiAgICAgICAgICAgIGlmIChtZXRhW2Nocl0pIHJldHVybiBtZXRhW2Nocl07XG4gICAgICAgICAgICBjaHIgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChjaHIgPD0gMHhmZiAmJiAoc2VsZi5lbmNvZGluZ1tcIiRiaW5hcnk/XCJdKCkgfHwgc2VsZi5pbnRlcm5hbF9lbmNvZGluZ1tcIiRiaW5hcnk/XCJdKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBjaHIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHUnICsgKCcwMDAwJyArIGNoci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1xcI1tcXCRcXEBcXHtdL2csICdcXFxcJCYnKSArICdcIic7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzICovXG4gICAgfVxuICBlbmRcblxuICBkZWYgaW50ZXJuXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmIGxpbmVzKHNlcGFyYXRvciA9ICQvLCAmYmxvY2spXG4gICAgZSA9IGVhY2hfbGluZShzZXBhcmF0b3IsICZibG9jaylcbiAgICBibG9jayA/IHNlbGYgOiBlLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGxqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG5cbiAgICBpZiBwYWRzdHIuZW1wdHk/XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnemVybyB3aWR0aCBwYWRkaW5nJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIHNlbGYgaWYgYHdpZHRoIDw9IHNlbGYubGVuZ3RoYFxuXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXggID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gXCJcIjtcblxuICAgICAgd2lkdGggLT0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgd2lkdGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IHBhZHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYgKyByZXN1bHQuc2xpY2UoMCwgd2lkdGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9eXFxzKi8sICcnKWBcbiAgZW5kXG5cbiAgZGVmIGFzY2lpX29ubHk/XG4gICAgIyBub24tQVNDSUktY29tcGF0aWJsZSBlbmNvZGluZyBtdXN0IHJldHVybiBmYWxzZVxuICAgICV4e1xuICAgICAgaWYgKCFzZWxmLmVuY29kaW5nLmFzY2lpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gL15bXFx4MDAtXFx4N0ZdKiQvLnRlc3Qoc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2gocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgU3RyaW5nID09PSBwYXR0ZXJuIHx8IHBhdHRlcm4ucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICAgIHBhdHRlcm4gPSBSZWdleHAubmV3KHBhdHRlcm4udG9fc3RyKVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIFJlZ2V4cCA9PT0gcGF0dGVyblxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3twYXR0ZXJuLmNsYXNzfSAoZXhwZWN0ZWQgUmVnZXhwKVwiXG4gICAgZW5kXG5cbiAgICBwYXR0ZXJuLm1hdGNoKHNlbGYsIHBvcywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWF0Y2g/KHBhdHRlcm4sIHBvcyA9IHVuZGVmaW5lZClcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IFJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgUmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2g/KHNlbGYsIHBvcylcbiAgZW5kXG5cbiAgZGVmIG5leHRcbiAgICAleHtcbiAgICAgIHZhciBpID0gc2VsZi5sZW5ndGg7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QoJycpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHNlbGY7XG4gICAgICB2YXIgZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCA9IHNlbGYuc2VhcmNoKC9bYS16QS1aMC05XS8pO1xuICAgICAgdmFyIGNhcnJ5ID0gZmFsc2U7XG4gICAgICB2YXIgY29kZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29kZSA9IHNlbGYuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8XG4gICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDU3OlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDQ4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSA2NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTIyOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDk3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDI1NSkge1xuICAgICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvZGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSArIDEpO1xuICAgICAgICBpZiAoY2FycnkgJiYgKGkgPT09IDAgfHwgaSA9PT0gZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCkpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDY1OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5NzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0LnNsaWNlKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FycnkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgb2N0XG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYsXG4gICAgICAgICAgcmFkaXggPSA4O1xuXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkL2ksIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICByYWRpeCA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgcmFkaXggPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZy5yZXBsYWNlKC9fKD8hXykvZywgJycpLCByYWRpeCk7XG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYuY29kZVBvaW50QXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc2VsZi5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5jaGFyQ29kZUF0KDApO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHBhcnRpdGlvbihzZXApXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbTtcblxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gc2VwLmV4ZWMoc2VsZik7XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgc2VwYCwgYG1gfTtcbiAgICAgICAgICBzZXAgPSBtWzBdO1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAkY29lcmNlX3RvKHNlcCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGkgPSBzZWxmLmluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbc2VsZiwgJycsICcnXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VcbiAgICBgc2VsZi5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpYFxuICBlbmRcblxuICBkZWYgcmluZGV4KHNlYXJjaCwgb2Zmc2V0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIG0sIHIsIF9tO1xuXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAkY29lcmNlX3RvKG9mZnNldCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwgfHwgX20uaW5kZXggPiBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaCA9ICRjb2VyY2VfdG8oc2VhcmNoLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaSA9PT0gLTEgPyBuaWwgOiBpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJqdXN0KHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG5cbiAgICBpZiBwYWRzdHIuZW1wdHk/XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnemVybyB3aWR0aCBwYWRkaW5nJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIHNlbGYgaWYgYHdpZHRoIDw9IHNlbGYubGVuZ3RoYFxuXG4gICAgJXh7XG4gICAgICB2YXIgY2hhcnMgICAgID0gTWF0aC5mbG9vcih3aWR0aCAtIHNlbGYubGVuZ3RoKSxcbiAgICAgICAgICBwYXR0ZXJucyAgPSBNYXRoLmZsb29yKGNoYXJzIC8gcGFkc3RyLmxlbmd0aCksXG4gICAgICAgICAgcmVzdWx0ICAgID0gQXJyYXkocGF0dGVybnMgKyAxKS5qb2luKHBhZHN0ciksXG4gICAgICAgICAgcmVtYWluaW5nID0gY2hhcnMgLSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0ICsgcGFkc3RyLnNsaWNlKDAsIHJlbWFpbmluZykgKyBzZWxmKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBycGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKHNlcC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBtID0gbnVsbDtcbiAgICAgICAgciA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VwKTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIF9tID0gci5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSBfbTtcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcbiAgICAgICAgICBzZXAgPSBtWzBdO1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYubGFzdEluZGV4T2Yoc2VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbJycsICcnLCBzZWxmXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc2VsZi5zbGljZSgwLCBpKSxcbiAgICAgICAgc2VsZi5zbGljZShpLCBpICsgc2VwLmxlbmd0aCksXG4gICAgICAgIHNlbGYuc2xpY2UoaSArIHNlcC5sZW5ndGgpXG4gICAgICBdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc2NhbihwYXR0ZXJuLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgbWF0Y2hfZGF0YSA9IG5pbCxcbiAgICAgICAgICBtYXRjaDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXRjaF9kYXRhID0gI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH07XG4gICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyByZXN1bHQucHVzaChtYXRjaFswXSkgOiByZXN1bHQucHVzaCgje2BtYXRjaF9kYXRhYC5jYXB0dXJlc30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoLmxlbmd0aCA9PSAxID8gT3BhbC55aWVsZDEoYmxvY2ssIG1hdGNoWzBdKSA6IE9wYWwueWllbGQxKGJsb2NrLCAje2BtYXRjaF9kYXRhYC5jYXB0dXJlc30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICN7JH4gPSBgbWF0Y2hfZGF0YWB9XG5cbiAgICAgIHJldHVybiAoYmxvY2sgIT09IG5pbCA/IHNlbGYgOiByZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2xpY2UgW11cblxuICBkZWYgc3BsaXQocGF0dGVybiA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW1pdCA9ICN7T3BhbC5jb2VyY2VfdG8hKGxpbWl0LCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChsaW1pdCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBbc2VsZl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCB8fCBwYXR0ZXJuID09PSBuaWwpIHtcbiAgICAgICAgcGF0dGVybiA9ICN7JDsgfHwgJyAnfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKSxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgaSwgaWk7XG5cbiAgICAgIGlmIChwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHBhdHRlcm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcgJykge1xuICAgICAgICAgIHBhdHRlcm4gPSAvXFxzKy9nbTtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzdHJpbmcuc3BsaXQocGF0dGVybik7XG5cbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxICYmIHJlc3VsdFswXSA9PT0gc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbc2VsZi4kJGNhc3QocmVzdWx0WzBdKV07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgoaSA9IHJlc3VsdC5pbmRleE9mKHVuZGVmaW5lZCkpICE9PSAtMSkge1xuICAgICAgICByZXN1bHQuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYXN0UmVzdWx0KCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gc2VsZi4kJGNhc3QocmVzdWx0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IDApIHtcbiAgICAgICAgd2hpbGUgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcblxuICAgICAgaWYgKGxpbWl0IDwgMCkge1xuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnICYmIHBhdHRlcm4uc291cmNlLmluZGV4T2YoJyg/PScpID09PSAtMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gbWF0Y2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaFswXSA9PT0gJycpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShsaW1pdCAtIDEsIHJlc3VsdC5sZW5ndGggLSAxLCByZXN1bHQuc2xpY2UobGltaXQgLSAxKS5qb2luKCcnKSk7XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID49IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnNwbGljZShsaW1pdCAtIDEsIHJlc3VsdC5sZW5ndGggLSAxLCBzdHJpbmcuc2xpY2UoaW5kZXgpKTtcbiAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3F1ZWV6ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKC8oLilcXDErL2csICckMScpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFyX2NsYXNzID0gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKTtcbiAgICAgIGlmIChjaGFyX2NsYXNzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIGNoYXJfY2xhc3MgKyAnKVxcXFwxKycsICdnJyksICckMScpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdGFydF93aXRoPygqcHJlZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJlZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByZWZpeGVzW2ldLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgdmFyIHJlZ2V4cCA9IHByZWZpeGVzW2ldO1xuICAgICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKHNlbGYpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoICE9IG51bGwgJiYgbWF0Y2guaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICN7JH4gPSBNYXRjaERhdGEubmV3KGByZWdleHBgLCBgbWF0Y2hgKX07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4ZXNbaV0sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgICAgICBpZiAoc2VsZi5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9bXFxzXFx1MDAwMF0qJC8sICcnKWBcbiAgZW5kXG5cbiAgZGVmIHN1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0LCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzZWxmKTtcblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgIHJlc3VsdCA9IHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgxIGZvciAyKSd9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgYmxvY2sobWF0Y2hbMF0pICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZXBsYWNlbWVudC4kJGlzX2hhc2gpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgcmVwbGFjZW1lbnQgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHN1Y2MgbmV4dFxuXG4gIGRlZiBzdW0obiA9IDE2KVxuICAgICV4e1xuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgJiAoTWF0aC5wb3coMiwgbikgLSAxKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzd2FwY2FzZVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGYucmVwbGFjZSgvKFthLXpdKyl8KFtBLVpdKykvZywgZnVuY3Rpb24oJDAsJDEsJDIpIHtcbiAgICAgICAgcmV0dXJuICQxID8gJDAudG9VcHBlckNhc2UoKSA6ICQwLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGYuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tzZWxmLmNsYXNzLm5ldyBgc3RyYH07XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZsb2F0KHNlbGYucmVwbGFjZSgvXy9nLCAnJykpO1xuXG4gICAgICBpZiAoaXNOYU4ocmVzdWx0KSB8fCByZXN1bHQgPT0gSW5maW5pdHkgfHwgcmVzdWx0ID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2koYmFzZSA9IDEwKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgcmFkaXggPSAkY29lcmNlX3RvKGJhc2UsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHJhZGl4ID09PSAxIHx8IHJhZGl4IDwgMCB8fCByYWRpeCA+IDM2KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YHJhZGl4YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC8sIGZ1bmN0aW9uIChvcmlnaW5hbCwgaGVhZCwgZmxhZywgdGFpbCkge1xuICAgICAgICBzd2l0Y2ggKHRhaWwuY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgxKSA9PT0gJ3gnICYmIGZsYWcgPT09ICcweCcgJiYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDIpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcwbyc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSA4KSB7XG4gICAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxMCkge1xuICAgICAgICAgICAgcmFkaXggPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSB7XG4gICAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBtZXRob2RfbmFtZSA9ICckJyArIGBzZWxmLnZhbHVlT2YoKWBcblxuICAgIHByb2MgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAleHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gcmVjZWl2ZXIgZ2l2ZW4nfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3YgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChyZWN2ID09IG51bGwpIHJlY3YgPSBuaWw7XG5cbiAgICAgICAgdmFyIGJvZHkgPSByZWN2WyN7bWV0aG9kX25hbWV9XTtcblxuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdi4kbWV0aG9kX21pc3NpbmcuYXBwbHkocmVjdiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYm9keS4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBib2R5LmNhbGwocmVjdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBhbGlhcyB0b19zdHIgdG9fc1xuXG4gIGFsaWFzIHRvX3N5bSBpbnRlcm5cblxuICBkZWYgdHIoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgdG8gPSAkY29lcmNlX3RvKHRvLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCB8fCBmcm9tID09PSB0bykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X3RvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGFzdF90byA9IGNoO1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB0b19sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X3RvLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvX2NoYXJzID0gdG9fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICAgICAgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aF9kaWZmID0gZnJvbV9sZW5ndGggLSB0b19sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGhfZGlmZiA+IDApIHtcbiAgICAgICAgICB2YXIgcGFkX2NoYXIgPSAodG9fbGVuZ3RoID4gMCA/IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdIDogJycpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGhfZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICB0b19jaGFycy5wdXNoKHBhZF9jaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0b19jaGFyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gc2VsZi5jaGFyQXQoaSk7XG4gICAgICAgIHZhciBzdWIgPSBzdWJzW2NoXTtcbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgPT0gbnVsbCA/IGdsb2JhbF9zdWIgOiBjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3X3N0ciArPSAoc3ViICE9IG51bGwgPyBzdWIgOiBjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChuZXdfc3RyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cl9zKGZyb20sIHRvKVxuICAgICV4e1xuICAgICAgZnJvbSA9ICRjb2VyY2VfdG8oZnJvbSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgIHRvID0gJGNvZXJjZV90byh0bywgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJvbV9jaGFycyA9IGZyb21fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRvX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdG9fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgICAgICB2YXIgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gdG9fY2hhcnNbaV07XG4gICAgICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBpZiAobGFzdF90byA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpID09IHRvX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvX2NoYXJzID0gdG9fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICAgICAgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aF9kaWZmID0gZnJvbV9sZW5ndGggLSB0b19sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGhfZGlmZiA+IDApIHtcbiAgICAgICAgICB2YXIgcGFkX2NoYXIgPSAodG9fbGVuZ3RoID4gMCA/IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdIDogJycpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGhfZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICB0b19jaGFycy5wdXNoKHBhZF9jaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0b19jaGFyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld19zdHIgPSAnJ1xuICAgICAgdmFyIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGxcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdXG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgaWYgKHN1YiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9zdWJzdGl0dXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbmV3X3N0ciArPSBnbG9iYWxfc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld19zdHIgKz0gY2g7XG4gICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoc3ViICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCB8fCBsYXN0X3N1YnN0aXR1dGUgIT09IHN1Yikge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IHN1YjtcbiAgICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gc3ViO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld19zdHIgKz0gY2g7XG4gICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KG5ld19zdHIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVwY2FzZVxuICAgIGBzZWxmLiQkY2FzdChzZWxmLnRvVXBwZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgdXB0byhzdG9wLCBleGNsID0gZmFsc2UsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOnVwdG8sIHN0b3AsIGV4Y2wgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgdmFyIGEsIGIsIHMgPSBzZWxmLnRvU3RyaW5nKCk7XG5cbiAgICAgIHN0b3AgPSAkY29lcmNlX3RvKHN0b3AsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocy5sZW5ndGggPT09IDEgJiYgc3RvcC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICBhID0gcy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBiID0gc3RvcC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHBhcnNlSW50KHMsIDEwKS50b1N0cmluZygpID09PSBzICYmIHBhcnNlSW50KHN0b3AsIDEwKS50b1N0cmluZygpID09PSBzdG9wKSB7XG5cbiAgICAgICAgYSA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHN0b3AsIDEwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soYS50b1N0cmluZygpKTtcblxuICAgICAgICAgIGEgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHdoaWxlIChzLmxlbmd0aCA8PSBzdG9wLmxlbmd0aCAmJiBzIDw9IHN0b3ApIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBzID09PSBzdG9wKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhzKTtcblxuICAgICAgICAgIHMgPSAje2BzYC5zdWNjfTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cykge1xuICAgICAgZnVuY3Rpb24gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChzZXQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0Lmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJfY2hhcixcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoLFxuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20sXG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byxcbiAgICAgICAgICAgIGNoYXJfY29kZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY3Vycl9jaGFyID0gc2V0LmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoY3Vycl9jaGFyID09PSAnLScgJiYgaSA+IDAgJiYgaSA8IChsZW4gLSAxKSAmJiAhc2tpcF9uZXh0X2Rhc2gpIHtcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tID0gc2V0LmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8gPSBzZXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhcl9jb2RlX2Zyb20gPiBjaGFyX2NvZGVfdXB0bykge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgY2hhcl9jb2RlX2Zyb21gfS0je2BjaGFyX2NvZGVfdXB0b2B9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNoYXJfY29kZSA9IGNoYXJfY29kZV9mcm9tICsgMTsgY2hhcl9jb2RlIDwgY2hhcl9jb2RlX3VwdG8gKyAxOyBjaGFyX2NvZGUrKykge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyX2NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2ggPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IChjdXJyX2NoYXIgPT09ICdcXFxcJyk7XG4gICAgICAgICAgICByZXN1bHQgKz0gY3Vycl9jaGFyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0QSwgc2V0Qikge1xuICAgICAgICBpZiAoc2V0QS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc2V0QjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXRBLmxlbmd0aCxcbiAgICAgICAgICAgIGNocjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gc2V0QS5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKHNldEIuaW5kZXhPZihjaHIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGxlbiwgc2V0LCBuZWcsIGNociwgdG1wLFxuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSAnJyxcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gJyc7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2V0ID0gJGNvZXJjZV90byhzZXRzW2ldLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgbmVnID0gKHNldC5jaGFyQXQoMCkgPT09ICdeJyAmJiBzZXQubGVuZ3RoID4gMSk7XG4gICAgICAgIHNldCA9IGV4cGxvZGVfc2VxdWVuY2VzX2luX2NoYXJhY3Rlcl9zZXQobmVnID8gc2V0LnNsaWNlKDEpIDogc2V0KTtcbiAgICAgICAgaWYgKG5lZykge1xuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24obmVnX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3NfaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uKHBvc19pbnRlcnNlY3Rpb24sIHNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCAmJiBuZWdfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdG1wID0gJyc7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBwb3NfaW50ZXJzZWN0aW9uLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5pbmRleE9mKGNocikgPT09IC0xKSB7XG4gICAgICAgICAgICB0bXAgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3NfaW50ZXJzZWN0aW9uID0gdG1wO1xuICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuICdbJyArICN7UmVnZXhwLmVzY2FwZShgcG9zX2ludGVyc2VjdGlvbmApfSArICddJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1teJyArICN7UmVnZXhwLmVzY2FwZShgbmVnX2ludGVyc2VjdGlvbmApfSArICddJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIFtdXG4gIGVuZFxuXG4gIGRlZiBzZWxmLl9sb2FkKCphcmdzKVxuICAgIG5ldygqYXJncylcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplKGZvcm0gPSA6bmZjKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiSW52YWxpZCBub3JtYWxpemF0aW9uIGZvcm0gI3tmb3JtfVwiIHVubGVzcyAlaVtuZmMgbmZkIG5ma2MgbmZrZF0uaW5jbHVkZT8oZm9ybSlcbiAgICBgc2VsZi5ub3JtYWxpemUoI3tmb3JtLnVwY2FzZX0pYFxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemVkPyhmb3JtID0gOm5mYylcbiAgICB1bmljb2RlX25vcm1hbGl6ZShmb3JtKSA9PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiB1bnBhY2soZm9ybWF0KVxuICAgIHJhaXNlIFwiVG8gdXNlIFN0cmluZyN1bnBhY2ssIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5cbiAgZGVmIHVucGFjazEoZm9ybWF0KVxuICAgIHJhaXNlIFwiVG8gdXNlIFN0cmluZyN1bnBhY2sxLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL3N0cmluZy91bnBhY2snLlwiXG4gIGVuZFxuXG4gIGRlZiBmcmVlemVcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHJldHVybiBzZWxmO1xuICAgICAgc2VsZi4kJGZyb3plbiA9IHRydWU7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzICtAIGR1cFxuXG4gIGRlZiAtQFxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGZyb3plbiA9PT0gdHJ1ZSkgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi5lbmNvZGluZy5uYW1lID09ICdVVEYtOCcgJiYgc2VsZi5pbnRlcm5hbF9lbmNvZGluZy5uYW1lID09ICdVVEYtOCcpIHJldHVybiBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gc2VsZi4kZHVwKCkuJGZyZWV6ZSgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZyb3plbj9cbiAgICBgdHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnIHx8IHNlbGYuJCRmcm96ZW4gPT09IHRydWVgXG4gIGVuZFxuXG4gIE9wYWwucHJpc3RpbmUgc2VsZiwgOmluaXRpYWxpemVcbmVuZFxuXG5TeW1ib2wgPSBTdHJpbmdcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6U3RyaW5nPiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiX19pZF9fIiwidHJ5X2NvbnZlcnQiLCJ3aGF0IiwiT3BhbCIsImNvZXJjZV90bz8iLCJTdHJpbmciLCJuZXciLCJpbml0aWFsaXplIiwiYXJncyIsIiUiLCJkYXRhIiwiQXJyYXkiLCI9PT0iLCJmb3JtYXQiLCIqIiwiY291bnQiLCJJbnRlZ2VyIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwiUmFuZ2VFcnJvciIsIisiLCJvdGhlciIsIjw9PiIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwidG9fcyIsIj09IiwiPX4iLCJUeXBlRXJyb3IiLCJbXSIsImluZGV4IiwibGVuZ3RoIiwiJH4iLCJNYXRjaERhdGEiLCJiIiwiZm9yY2VfZW5jb2RpbmciLCJjYXBpdGFsaXplIiwiY2FzZWNtcCIsImNhc2VjbXA/IiwiY2VudGVyIiwid2lkdGgiLCJwYWRzdHIiLCJlbXB0eT8iLCJsanVzdCIsIi8iLCIyIiwiY2VpbCIsInJqdXN0IiwiZmxvb3IiLCJjaG9tcCIsInNlcGFyYXRvciIsIiQvIiwiY29lcmNlX3RvISIsImNob3AiLCJjaHIiLCJjbG9uZSIsImNvcHkiLCJjb3B5X3NpbmdsZXRvbl9tZXRob2RzIiwiaW5pdGlhbGl6ZV9jbG9uZSIsImR1cCIsImluaXRpYWxpemVfZHVwIiwiZGVsZXRlIiwiZGVsZXRlX3ByZWZpeCIsInByZWZpeCIsImRlbGV0ZV9zdWZmaXgiLCJzdWZmaXgiLCJkb3duY2FzZSIsImVhY2hfbGluZSIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiZW5kX3dpdGg/IiwiZ3N1YiIsInBhdHRlcm4iLCJyZXBsYWNlbWVudCIsImhhc2giLCJoZXgiLCJ0b19pIiwiMTYiLCJpbmNsdWRlPyIsInNlYXJjaCIsIm9mZnNldCIsImluc3BlY3QiLCJpbnRlcm4iLCJsaW5lcyIsImUiLCJibG9jayIsInRvX3Byb2MiLCJ0b19hIiwibHN0cmlwIiwiYXNjaWlfb25seT8iLCJtYXRjaCIsInBvcyIsIiRyZXRfb3JfMSIsIlJlZ2V4cCIsImNsYXNzIiwibWF0Y2g/IiwiJHJldF9vcl8yIiwibmV4dCIsIm9jdCIsIm9yZCIsInBhcnRpdGlvbiIsInNlcCIsInJldmVyc2UiLCJyaW5kZXgiLCJycGFydGl0aW9uIiwicnN0cmlwIiwic2NhbiIsImNhcHR1cmVzIiwic3BsaXQiLCJsaW1pdCIsIiRyZXRfb3JfMyIsIiQ7Iiwic3F1ZWV6ZSIsInN0YXJ0X3dpdGg/Iiwic3RyaXAiLCJzdWIiLCJzdW0iLCJuIiwic3dhcGNhc2UiLCJ0b19mIiwiYmFzZSIsIjEwIiwibWV0aG9kX25hbWUiLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInRyIiwiZnJvbSIsInRvIiwidHJfcyIsInVwY2FzZSIsInVwdG8iLCJzdG9wIiwiZXhjbCIsInN1Y2MiLCJlc2NhcGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJfbG9hZCIsInVuaWNvZGVfbm9ybWFsaXplIiwiZm9ybSIsInVuaWNvZGVfbm9ybWFsaXplZD8iLCJ1bnBhY2siLCJ1bnBhY2sxIiwiZnJlZXplIiwiLUAiLCJmcm96ZW4/IiwicHJpc3RpbmUiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBRUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLDBCQUFSRDs7QUFHRkQsd0JBQTBCRixJQUFLRTs7QUFFL0JBLHdCQUEwQkYsSUFBS0U7QUFDL0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVFRyxJQUFBQSwwQkFBQUEsbUJBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsZUFBREE7SUFERkEsQ0FBQUEsOEJBQUFBO0lBSUEsYUFBTSxXQUFOLEVBQWdCLFFBQWhCO0lBRUFDLFVBQUlOLElBQUpNLGtCQUFBQSx3QkFBQUEsdUJBQXFCQyxJQUFyQkQ7QUFBQUEsTUFB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QkFBQUEscUJBQUFBLG1CQUFZakksTUFBWmlJO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBbkosSUFBQXNCLE9BQUFBLENBQU02SCx3RUFBTjdIO0lBREY2SCxDQUFBQSxnQ0FBQUE7O0FBSUFDLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsK0JBQUFBO0lBUUEsYUFBTSxJQUFOLEVBQVMsS0FBVDs7QUFFQUMsSUFBQUEsc0JBQUFBLHFCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTkVBLENBQUFBLGdDQUFBQTs7QUFTQUMsSUFBQUEsMkJBQUFBLHlCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0Esa0RBQURBO0lBREZBLENBQUFBLG9DQUFBQTtJQUlBcEosT0FBQU0sb0JBQUkrSSxVQUFBQSxDQUFVdkosSUFBZCxFQUFvQixZQUFoQnVKO0VBajFETnJKLEdBQUFBLFdBQUFBLEVBQWdCSCxNQUFoQkc7RUFvMURBSCxPQUFBLHNDQUFTVyxzQkFBVDtBQXoxREFYOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo5NTcxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZmFsc3ksIHRydXRoeSwgY29lcmNlX3RvXG5cbm1vZHVsZSBFbnVtZXJhYmxlXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gW25pbF07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBhbGw/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIHVubGVzcyBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBjaHVuaygmYmxvY2spXG4gICAgcmV0dXJuIHRvX2VudW0oOmNodW5rKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gbmlsLCBhY2N1bXVsYXRlID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcmVsZWFzZUFjY3VtdWxhdGUoKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBwcmV2aW91c2AsIGBhY2N1bXVsYXRlYCl9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBrZXkgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFtdO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuaWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbmlsIHx8IHByZXZpb3VzID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2aW91cyA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNodW5rX3doaWxlKCZibG9jaylcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNsaWNlX3doZW4geyB8YmVmb3JlLCBhZnRlcnwgISh5aWVsZCBiZWZvcmUsIGFmdGVyKSB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0X2NvbmNhdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0X2NvbmNhdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgbWFwIHsgfGl0ZW18IHlpZWxkIGl0ZW0gfS5mbGF0dGVuKDEpXG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXN1bHQgPSAwXG5cbiAgICAleHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBibG9jayA9IHByb2MgZG8gfCphcmdzfFxuICAgICAgICBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9iamVjdFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2submlsP1xuICAgICAgYmxvY2sgPSBwcm9jIHsgdHJ1ZSB9XG4gICAgZW5kXG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGByZXN1bHQrK2AgaWYgYE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKWBcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IEZsb2F0OjpJTkZJTklUWSA6IG5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIG4gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgICByZXR1cm4gaWYgYG4gPD0gMGBcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGFsbCA9IFtdLCBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKGFsbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgYWxsW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIGFsbFtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGV0ZWN0KGlmbm9uZSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZGV0ZWN0LCBpZm5vbmUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IE9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAgIGlmIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaWZub25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihpZm5vbmUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpZm5vbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG51bWJlciA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgID0gW10sXG4gICAgICAgICAgY3VycmVudCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChudW1iZXIgPD0gY3VycmVudCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZHJvcF93aGlsZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgICA9IFtdLFxuICAgICAgICAgIGRyb3BwaW5nID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgaWYgKGRyb3BwaW5nKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgIGlmICgkZmFsc3kodmFsdWUpKSB7XG4gICAgICAgICAgICBkcm9wcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvbnMobiwgJmJsb2NrKVxuICAgIGlmIGBhcmd1bWVudHMubGVuZ3RoICE9IDFgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMSlcIlxuICAgIGVuZFxuXG4gICAgbiA9IE9wYWwudHJ5X2NvbnZlcnQgbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNpemUnXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfY29ucywgbikgZG9cbiAgICAgICAgZW51bV9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICAgIGlmIGVudW1fc2l6ZS5uaWw/XG4gICAgICAgICAgbmlsXG4gICAgICAgIGVsc2lmIGVudW1fc2l6ZSA9PSAwIHx8IGVudW1fc2l6ZSA8IG5cbiAgICAgICAgICAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtX3NpemUgLSBuICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYnVmZmVyID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGJ1ZmZlci5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IG4pIHtcbiAgICAgICAgICBidWZmZXIuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBuKSB7XG4gICAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGJ1ZmZlci5zbGljZSgwLCBuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfZW50cnkoKmRhdGEsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaF9lbnRyeSwgKmRhdGEpIHsgZW51bWVyYXRvcl9zaXplIH1cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgZGF0YSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfc2xpY2UobiwgJmJsb2NrKVxuICAgIG4gPSBgJGNvZXJjZV90bygje259LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2xpY2Ugc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9zbGljZSwgbikgeyByZXNwb25kX3RvPyg6c2l6ZSkgPyAoc2l6ZSAvIG4pLmNlaWwgOiBuaWwgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBzbGljZSA9IFtdXG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuXG4gICAgICAgIGlmIChzbGljZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgLy8gb3VyIFwibGFzdFwiIGdyb3VwLCBpZiBzbWFsbGVyIHRoYW4gbiB0aGVuIHdvbid0IGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgsICphcmdzKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfb2JqZWN0KG9iamVjdCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX29iamVjdCwgb2JqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIG9iamVjdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG4gICAgfVxuXG4gICAgb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiBlbnRyaWVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbHRlcl9tYXAoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmlsdGVyX21hcCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBtYXAoJmJsb2NrKS5zZWxlY3QoJjppdHNlbGYpXG4gIGVuZFxuXG4gIGFsaWFzIGZpbmQgZGV0ZWN0XG5cbiAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbmRfYWxsKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKSA9PSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZmlyc3QobnVtYmVyID0gdW5kZWZpbmVkKVxuICAgIGlmIGBudW1iZXIgPT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfHZhbHVlfFxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IFtdXG4gICAgICBudW1iZXIgPSBgJGNvZXJjZV90byhudW1iZXIsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgYG51bWJlciA8IDBgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSlgXG5cbiAgICAgICAgaWYgYG51bWJlciA8PSArK2N1cnJlbnRgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICN7KGhhc2hbYHZhbHVlYF0gfHw9IFtdKSA8PCBgcGFyYW1gfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvYmopXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBbcmVzdWx0LCB2YWx1ZV0pO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCEje1N5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiI3tvYmplY3QuaW5zcGVjdH0gaXMgbm90IGEgU3ltYm9sXCJ9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN5bSAgICA9IG9iamVjdDtcbiAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLl9fc2VuZF9fIHN5bSwgYHZhbHVlYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGF6eVxuICAgIEVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA9PT0gbmlsKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgW2l0ZW0sIHJlc3VsdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICN7YGl0ZW1gIDw9PiBgcmVzdWx0YH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykucmV2ZXJzZS50YWtlIG5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG5cbiAgZGVmIG1pbihuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHJldHVybiBzb3J0IHsgfGEsIGJ8IHlpZWxkIGEsIGIgfS50YWtlIG5cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvcnQudGFrZSBuXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gYmxvY2socGFyYW0sIHJlc3VsdCk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7T3BhbC5jb21wYXJlKGBwYXJhbWAsIGByZXN1bHRgKX0gPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbl9ieShuID0gbmlsLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5fYnksIG4pIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICByZXR1cm4gc29ydF9ieSgmYmxvY2spLnRha2UgblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGJ5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA8IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXgoJmJsb2NrKVxuICAgIGJsb2NrIHx8PSBwcm9jIHsgfGEsIGJ8IGEgPD0+IGIgfVxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gbmlsLCBtYXggPSBuaWwsIGZpcnN0X3RpbWUgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBpZiAoZmlyc3RfdGltZSkge1xuICAgICAgICAgIG1pbiA9IG1heCA9IGVsZW1lbnQ7XG4gICAgICAgICAgZmlyc3RfdGltZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW5fY21wID0gI3tibG9jay5jYWxsKGBtaW5gLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtaW5fY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1pbl9jbXAgPiAwKSB7XG4gICAgICAgICAgICBtaW4gPSBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXhfY21wID0gI3tibG9jay5jYWxsKGBtYXhgLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtYXhfY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1heF9jbXAgPCAwKSB7XG4gICAgICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5tYXhfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW5fcmVzdWx0ID0gbmlsLFxuICAgICAgICAgIG1heF9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWluX2J5LFxuICAgICAgICAgIG1heF9ieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKChtaW5fYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWluX2J5YH0gPCAwKSB7XG4gICAgICAgICAgbWluX3Jlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIG1pbl9ieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobWF4X2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1heF9ieWB9ID4gMCkge1xuICAgICAgICAgIG1heF9yZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBtYXhfYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFttaW5fcmVzdWx0LCBtYXhfcmVzdWx0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBub25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaXRlbSA9IE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgb25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgY291bnQgPSAwXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIG5leHQgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY291bnQgPT0gMVxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnBhcnRpdGlvbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciB0cnV0aHkgPSBbXSwgZmFsc3kgPSBbXSwgcmVzdWx0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHJlZHVjZSBpbmplY3RcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCRmYWxzeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaChhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIE9wYWwueWllbGRYKGJsb2NrLCByZXN1bHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG5cbiAgZGVmIHNsaWNlX2JlZm9yZShwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxuICAgIGVuZFxuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfGV8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgI3twYXR0ZXJuLmR1cH0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2VfYWZ0ZXIocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGV4cGVjdGVkIDEpXCJcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBibG9jayA9IHByb2MgeyB8ZXwgcGF0dGVybiA9PT0gZSB9XG4gICAgZW5kXG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWNjdW11bGF0ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGVuZF9jaHVuayA9IE9wYWwueWllbGQxKGJsb2NrLCBlbGVtZW50KTtcblxuICAgICAgICAgIGlmIChhY2N1bXVsYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShlbmRfY2h1bmspKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKGVsZW1lbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChhY2N1bXVsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNsaWNlX3doZW4oJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKScgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gbmlsLCBsYXN0X2FmdGVyID0gbmlsO1xuXG4gICAgICAgIHNlbGYuJGVhY2hfY29ucy4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGJlZm9yZSA9IHBhcmFtc1swXSxcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJhbXNbMV0sXG4gICAgICAgICAgICAgIG1hdGNoID0gT3BhbC55aWVsZFgoYmxvY2ssIFtiZWZvcmUsIGFmdGVyXSk7XG5cbiAgICAgICAgICBsYXN0X2FmdGVyID0gYWZ0ZXI7XG5cbiAgICAgICAgICBpZiAoc2xpY2UgPT09IG5pbCkge1xuICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShtYXRjaCkpIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gT3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYClcbiAgICAgIFt5aWVsZChhcmcpLCBhcmddXG4gICAgZW5kXG4gICAgZHVwLnNvcnQhIHsgfGEsIGJ8IGBhWzBdYCA8PT4gYGJbMF1gIH1cbiAgICBkdXAubWFwISB7IHxpfCBgaVsxXWAgfVxuICBlbmRcblxuICBkZWYgc3VtKGluaXRpYWwgPSAwKVxuICAgIHJlc3VsdCA9IGluaXRpYWxcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgT3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgICAgICAgIGVuZFxuICAgICAgcmVzdWx0ICs9IGl0ZW1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHVubGVzcyB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgZW5kXG5cbiAgICAgIGByZXN1bHQucHVzaCh2YWx1ZSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICBoYXNoID0ge31cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHByb2R1Y2VkID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICAgICAgeWllbGQodmFsdWUpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdW5sZXNzIGhhc2gua2V5Pyhwcm9kdWNlZClcbiAgICAgICAgaGFzaFtwcm9kdWNlZF0gPSB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBoYXNoLnZhbHVlc1xuICBlbmRcblxuICBkZWYgdGFsbHlcbiAgICBncm91cF9ieSgmOml0c2VsZikudHJhbnNmb3JtX3ZhbHVlcygmOmNvdW50KVxuICBlbmRcblxuICBhbGlhcyB0b19hIGVudHJpZXNcblxuICBkZWYgdG9faCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIHZhciBhcnkgPSAje09wYWwuY29lcmNlX3RvPyhgcGFyYW1gLCBBcnJheSwgOnRvX2FyeSl9LCBrZXksIHZhbDtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgYXJyYXkgbGVuZ3RoIChleHBlY3RlZCAyLCB3YXMgI3tgYXJ5YC5sZW5ndGh9KVwifVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IGFyeVswXTtcbiAgICAgICAgdmFsID0gYXJ5WzFdO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICB0b19hLnppcCgqb3RoZXJzKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkVudW1lcmFibGU+IiwiYWxsPyIsInBhdHRlcm4iLCJlYWNoIiwic2VsZiIsImJsb2NrIGluIGFsbD8iLCJibG9jayAoMiBsZXZlbHMpIGluIGFsbD8iLCJjb21wYXJhYmxlIiwicHVibGljX3NlbmQiLCJibG9ja19naXZlbj8iLCJ2YWx1ZSIsIk9wYWwiLCJkZXN0cnVjdHVyZSIsImFueT8iLCJibG9jayBpbiBhbnk/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhbnk/IiwiY2h1bmsiLCJ0b19lbnVtIiwiYmxvY2sgaW4gY2h1bmsiLCJibG9jayAoMiBsZXZlbHMpIGluIGNodW5rIiwiZW51bWVyYXRvcl9zaXplIiwibmV3IiwiRW51bWVyYXRvciIsInlpZWxkZXIiLCJ5aWVsZCIsImNodW5rX3doaWxlIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwic2xpY2Vfd2hlbiIsImJsb2NrIGluIGNodW5rX3doaWxlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIGNodW5rX3doaWxlIiwiISIsImNvbGxlY3QiLCJlbnVtX2ZvciIsImJsb2NrIGluIGNvbGxlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QiLCJjb2xsZWN0X2NvbmNhdCIsImJsb2NrIGluIGNvbGxlY3RfY29uY2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsIm1hcCIsIml0ZW0iLCJmbGF0dGVuIiwiMSIsImNvdW50Iiwib2JqZWN0IiwicmVzdWx0IiwiMCIsIndhcm4iLCJibG9jayIsInByb2MiLCJibG9jayBpbiBjb3VudCIsImJsb2NrICgyIGxldmVscykgaW4gY291bnQiLCJhcmdzIiwiPT0iLCJuaWw/IiwiY3ljbGUiLCJuIiwiYmxvY2sgaW4gY3ljbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGN5Y2xlIiwicmVzcG9uZF90bz8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJibG9jayBpbiBkZXRlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGRldGVjdCIsImRyb3AiLCJudW1iZXIiLCJkcm9wX3doaWxlIiwiZWFjaF9jb25zIiwidHJ5X2NvbnZlcnQiLCJibG9jayBpbiBlYWNoX2NvbnMiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfY29ucyIsImVudW1fc2l6ZSIsIiRyZXRfb3JfMSIsIjwiLCIrIiwiLSIsImVhY2hfZW50cnkiLCJkYXRhIiwiYmxvY2sgaW4gZWFjaF9lbnRyeSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9lbnRyeSIsImVhY2hfc2xpY2UiLCJibG9jayBpbiBlYWNoX3NsaWNlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfaW5kZXgiLCJlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgaW4gZWFjaF93aXRoX29iamVjdCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX29iamVjdCIsImVudHJpZXMiLCJmaWx0ZXJfbWFwIiwiYmxvY2sgaW4gZmlsdGVyX21hcCIsImJsb2NrICgyIGxldmVscykgaW4gZmlsdGVyX21hcCIsInNlbGVjdCIsInRvX3Byb2MiLCJmaW5kX2FsbCIsImJsb2NrIGluIGZpbmRfYWxsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaW5kX2FsbCIsImZpbmRfaW5kZXgiLCJpbmRleCIsImJsb2NrIGluIGZpbmRfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfaW5kZXgiLCJmaXJzdCIsImJsb2NrIGluIGZpcnN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaXJzdCIsImN1cnJlbnQiLCJncmVwIiwiYmxvY2sgaW4gZ3JlcCIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJibG9jayBpbiBncmVwX3YiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXBfdiIsImdyb3VwX2J5IiwiYmxvY2sgaW4gZ3JvdXBfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyb3VwX2J5IiwiaGFzaCIsIiRyZXRfb3JfMiIsIiR3cml0ZXIiLCJbXT0iLCI8PCIsImluY2x1ZGU/Iiwib2JqIiwiYmxvY2sgaW4gaW5jbHVkZT8iLCJibG9jayAoMiBsZXZlbHMpIGluIGluY2x1ZGU/IiwiaW5qZWN0Iiwic3ltIiwiU3ltYm9sIiwiPT09IiwiVHlwZUVycm9yIiwiaW5zcGVjdCIsImxhenkiLCJFbnVtZXJhdG9yOjpMYXp5IiwiYmxvY2sgaW4gbGF6eSIsImVudW0kIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBsYXp5IiwibWF4IiwiPD0+Iiwic29ydCIsInJldmVyc2UiLCJtYXhfYnkiLCJibG9jayBpbiBtYXhfYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1heF9ieSIsInNvcnRfYnkiLCJ0YWtlIiwibWluIiwiYmxvY2sgaW4gbWluIiwiYSIsImIiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbiIsImNvbXBhcmUiLCJtaW5fYnkiLCJibG9jayBpbiBtaW5fYnkiLCJibG9jayAoMiBsZXZlbHMpIGluIG1pbl9ieSIsIm1pbm1heCIsIiRyZXRfb3JfMyIsImJsb2NrIGluIG1pbm1heCIsImJsb2NrICgyIGxldmVscykgaW4gbWlubWF4IiwiY2FsbCIsIm1pbm1heF9ieSIsImJsb2NrIGluIG1pbm1heF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWlubWF4X2J5Iiwibm9uZT8iLCJibG9jayBpbiBub25lPyIsImJsb2NrICgyIGxldmVscykgaW4gbm9uZT8iLCJvbmU/IiwiYmxvY2sgaW4gb25lPyIsImJsb2NrICgyIGxldmVscykgaW4gb25lPyIsInBhcnRpdGlvbiIsImJsb2NrIGluIHBhcnRpdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcGFydGl0aW9uIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXZlcnNlX2VhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHJldmVyc2VfZWFjaCIsInNsaWNlX2JlZm9yZSIsImJsb2NrIGluIHNsaWNlX2JlZm9yZSIsImUiLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX2JlZm9yZSIsImR1cCIsInNsaWNlX2FmdGVyIiwiYmxvY2sgaW4gc2xpY2VfYWZ0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIHNsaWNlX2FmdGVyIiwiYmxvY2sgaW4gc2xpY2Vfd2hlbiIsImJsb2NrICgyIGxldmVscykgaW4gc2xpY2Vfd2hlbiIsImFyeSIsInRvX2EiLCJibG9jayBpbiBzb3J0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0IiwiYmxvY2sgaW4gc29ydF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gc29ydF9ieSIsImFyZyIsInNvcnQhIiwibWFwISIsImkiLCJzdW0iLCJpbml0aWFsIiwiYmxvY2sgaW4gc3VtIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdW0iLCJudW0iLCJ0YWtlX3doaWxlIiwiYmxvY2sgaW4gdGFrZV93aGlsZSIsImJsb2NrICgyIGxldmVscykgaW4gdGFrZV93aGlsZSIsInVuaXEiLCJibG9jayBpbiB1bmlxIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1bmlxIiwicHJvZHVjZWQiLCJrZXk/IiwidmFsdWVzIiwidGFsbHkiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwidG9faCIsImNvZXJjZV90bz8iLCJBcnJheSIsImNsYXNzIiwiemlwIiwib3RoZXJzIl0sIm1hcHBpbmdzIjoiQUFBQUEscURBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7Ozs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFRUMsSUFBQUEsd0JBQUFBLHlCQUFBQSxTQUFTQyxPQUFURCxHQUFBQTs7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBOEI7O01BQzVCLElBQUEsUUFBSUEscUJBQUosQ0FBQTtRQUNFRSxNQUFBQyxJQUFBRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFLRSxnQkFuQlgsRUFtQldBLEVBQUFDOzs7O1VBbkJYOztVQW1CZTtVQUNQQyxhQUFjRDtVQUVkLElBQUEsUUFBMkJFLE1BQVBOLE9B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LEdBQUNvRixxQkFBRCxHQUFBLENBQXNCQSxDQUFDQSxHQUFEQSxDQUFLRyxPQUFBQSxDQUFBQSxDQUEzQixDQUFBLEdBQWtDSCxtQkFBbkQzTTtBQUNaMk07QUFDQUE7QUFDQUEsVUFBWWpPLElBQUFzQixPQUFBQSxDQUFNQyw2QkFBTixFQUFxQixFQUFBLEdBQUMwTSxzQ0FBRCxHQUFBLENBQXVDQSxDQUFDQSxHQUFEQSxDQUFLM0csUUFBQUEsQ0FBQUEsQ0FBNUMsQ0FBQSxHQUFvRDJHLEdBQXpFM007QUFDWjJNO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0lBeEJFQSxDQUFBQSxtQ0FBQUE7SUEyQkFyTyxPQUFBeU8sQ0FBQUEsdUJBQUFBLHNCQUFBQSxlQWh2Q0YsRUFndkNFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFpQjs7TUFodkNuQjs7TUFndkNVO01BQ05BLE9BQUlBLE1BQUpyTyxJQUFBd00sTUFBQUEsQ0FBQUEsQ0FBSTZCLE9BQUFBLEVBQUssVUFBQ0MsTUFBRCxDQUFMRDtJQUROQSxDQUFBQSxrQ0FBQUEsQ0FBQUE7RUE5dUNGek8sR0FBQUEsV0FBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNTQ0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhdG9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogYnJlYWtlciwgc2xpY2UsIGZhbHN5LCB0cnV0aHksIGNvZXJjZV90b1xuXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIEVudW1lcmF0b3JcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19lbnVtZXJhdG9yID0gdHJ1ZWBcblxuICBkZWYgc2VsZi5mb3Iob2JqZWN0LCBtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSAje2FsbG9jYXRlfTtcblxuICAgICAgb2JqLm9iamVjdCA9IG9iamVjdDtcbiAgICAgIG9iai5zaXplICAgPSBibG9jaztcbiAgICAgIG9iai5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBvYmouYXJncyAgID0gYXJncztcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCosICZibG9jaylcbiAgICBpZiBibG9ja1xuICAgICAgQG9iamVjdCA9IEdlbmVyYXRvci5uZXcoJmJsb2NrKVxuICAgICAgQG1ldGhvZCA9IDplYWNoXG4gICAgICBAYXJncyAgID0gW11cbiAgICAgIEBzaXplICAgPSBgYXJndW1lbnRzWzBdIHx8IG5pbGBcblxuICAgICAgaWYgQHNpemUgJiYgIUBzaXplLnJlc3BvbmRfdG8/KDpjYWxsKVxuICAgICAgICBAc2l6ZSA9IGAkY29lcmNlX3RvKCN7QHNpemV9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBAb2JqZWN0ID0gYGFyZ3VtZW50c1swXWBcbiAgICAgIEBtZXRob2QgPSBgYXJndW1lbnRzWzFdIHx8IFwiZWFjaFwiYFxuICAgICAgQGFyZ3MgICA9IGAkc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpYFxuICAgICAgQHNpemUgICA9IG5pbFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBzZWxmIGlmIGJsb2NrLm5pbD8gJiYgYXJncy5lbXB0eT9cblxuICAgIGFyZ3MgPSBAYXJncyArIGFyZ3NcblxuICAgIHJldHVybiBzZWxmLmNsYXNzLm5ldyhAb2JqZWN0LCBAbWV0aG9kLCAqYXJncykgaWYgYmxvY2submlsP1xuXG4gICAgQG9iamVjdC5fX3NlbmRfXyhAbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc2l6ZVxuICAgIEBzaXplLnJlc3BvbmRfdG8/KDpjYWxsKSA/IEBzaXplLmNhbGwoKkBhcmdzKSA6IEBzaXplXG4gIGVuZFxuXG4gIGRlZiB3aXRoX2luZGV4KG9mZnNldCA9IDAsICZibG9jaylcbiAgICBvZmZzZXQgPSBpZiBvZmZzZXRcbiAgICAgICAgICAgICAgIGAkY29lcmNlX3RvKG9mZnNldCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6d2l0aF9pbmRleCwgb2Zmc2V0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCwgaW5kZXggPSBvZmZzZXQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZWFjaCgpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgd2l0aF9vYmplY3QgZWFjaF93aXRoX29iamVjdFxuXG4gIGRlZiBlYWNoX3dpdGhfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzdXBlclxuICAgIEBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICByZXN1bHQgPSBcIiM8I3tzZWxmLmNsYXNzfTogI3tAb2JqZWN0Lmluc3BlY3R9OiN7QG1ldGhvZH1cIlxuXG4gICAgaWYgQGFyZ3MuYW55P1xuICAgICAgcmVzdWx0ICs9IFwiKCN7QGFyZ3MuaW5zcGVjdFtSYW5nZS5uZXcoMSwgLTIpXX0pXCJcbiAgICBlbmRcblxuICAgIHJlc3VsdCArICc+J1xuICBlbmRcblxuICBjbGFzcyBHZW5lcmF0b3JcbiAgICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICAgIHJhaXNlIExvY2FsSnVtcEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgICBAYmxvY2sgPSBibG9ja1xuICAgIGVuZFxuXG4gICAgZGVmIGVhY2goKmFyZ3MsICZibG9jaylcbiAgICAgIHlpZWxkZXIgPSBZaWVsZGVyLm5ldygmYmxvY2spXG5cbiAgICAgICV4e1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFyZ3MudW5zaGlmdCgje3lpZWxkZXJ9KTtcblxuICAgICAgICAgIE9wYWwueWllbGRYKCN7QGJsb2NrfSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gJGJyZWFrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAkYnJlYWtlci4kdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIFlpZWxkZXJcbiAgICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgICBAYmxvY2sgPSBibG9ja1xuICAgIGVuZFxuXG4gICAgZGVmIHlpZWxkKCp2YWx1ZXMpXG4gICAgICAleHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoI3tAYmxvY2t9LCB2YWx1ZXMpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJGJyZWFrZXIpIHtcbiAgICAgICAgICB0aHJvdyAkYnJlYWtlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiA8PCgqdmFsdWVzKVxuICAgICAgc2VsZi55aWVsZCgqdmFsdWVzKVxuXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIExhenkgPCBzZWxmXG4gICAgY2xhc3MgU3RvcExhenlFcnJvciA8IEV4Y2VwdGlvbjsgZW5kXG5cbiAgICBkZWYgaW5pdGlhbGl6ZShvYmplY3QsIHNpemUgPSBuaWwsICZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBuZXcgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIEBlbnVtZXJhdG9yID0gb2JqZWN0XG5cbiAgICAgIHN1cGVyIHNpemUgZG8gfHlpZWxkZXIsICplYWNoX2FyZ3N8XG4gICAgICAgIG9iamVjdC5lYWNoKCplYWNoX2FyZ3MpIGRvIHwqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCgje3lpZWxkZXJ9KTtcblxuICAgICAgICAgICAgT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICByZXNjdWUgRXhjZXB0aW9uXG4gICAgICAgIG5pbFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBmb3JjZSB0b19hXG5cbiAgICBkZWYgbGF6eVxuICAgICAgc2VsZlxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbWFwIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBlbnVtZXJhdG9yX3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgI3tlbnVtLnlpZWxkIGB2YWx1ZWB9O1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBjb2xsZWN0X2NvbmNhdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoI3tgdmFsdWVgLnJlc3BvbmRfdG8/IDpmb3JjZX0gJiYgI3tgdmFsdWVgLnJlc3BvbmRfdG8/IDplYWNofSkge1xuICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gI3tPcGFsLnRyeV9jb252ZXJ0IGB2YWx1ZWAsIEFycmF5LCA6dG9fYXJ5fTtcblxuICAgICAgICAgICAgaWYgKGFycmF5ID09PSBuaWwpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGB2YWx1ZWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICN7YHZhbHVlYC5lYWNoIHsgfHZ8IGVudW0ueWllbGQgdiB9fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRyb3AobilcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgIGlmIG4gPCAwXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIGRyb3AgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBjdXJyZW50X3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgIHNldF9zaXplICAgICA9IGlmIEludGVnZXIgPT09IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICBkcm9wcGVkID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgZHJvcHBlZCA8IG5cbiAgICAgICAgICBkcm9wcGVkICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBkcm9wX3doaWxlIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBzdWNjZWVkaW5nID0gdHJ1ZVxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIHN1Y2NlZWRpbmdcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKCRmYWxzeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3VjY2VlZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgICBzZWxmLmNsYXNzLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gICAgZW5kXG5cbiAgICBhbGlhcyBmaWx0ZXIgZmluZF9hbGxcblxuICAgIGRlZiBmaW5kX2FsbCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBzZWxlY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBmbGF0X21hcCBjb2xsZWN0X2NvbmNhdFxuXG4gICAgZGVmIGdyZXAocGF0dGVybiwgJmJsb2NrKVxuICAgICAgaWYgYmxvY2tcbiAgICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSlgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGBwYXJhbWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIG1hcCBjb2xsZWN0XG5cbiAgICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcblxuICAgIGRlZiByZWplY3QoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgcmVqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCRmYWxzeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZShuKVxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gdGFrZSBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgSW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIHRha2VuID0gMFxuICAgICAgTGF6eS5uZXcoc2VsZiwgc2V0X3NpemUpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgdGFrZW4gPCBuXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgICB0YWtlbiArPSAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICByYWlzZSBTdG9wTGF6eUVycm9yXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSB0YWtlX3doaWxlIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAje3JhaXNlIFN0b3BMYXp5RXJyb3J9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QGVudW1lcmF0b3IuaW5zcGVjdH0+XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgQXJpdGhtZXRpY1NlcXVlbmNlIDwgc2VsZlxuICAgICMgV2UgbmVlZCB0byBzdHViIHRoaXMgZm9yIHRoZSB0aW1lIGJlaW5nXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkVudW1lcmF0b3I+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJmb3IiLCJvYmplY3QiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJibG9jayIsIkBvYmplY3QiLCJuZXciLCJHZW5lcmF0b3IiLCJ0b19wcm9jIiwiQG1ldGhvZCIsIkBhcmdzIiwiQHNpemUiLCIkcmV0X29yXzEiLCJyZXNwb25kX3RvPyIsIiEiLCJJbnRlZ2VyIiwiZWFjaCIsIiRyZXRfb3JfMiIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsImNsYXNzIiwiX19zZW5kX18iLCJzaXplIiwiY2FsbCIsIndpdGhfaW5kZXgiLCJvZmZzZXQiLCIwIiwiZW51bV9mb3IiLCJibG9jayBpbiB3aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB3aXRoX2luZGV4IiwiT3BhbCIsImRlc3RydWN0dXJlIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2tfZ2l2ZW4/IiwiYmxvY2sgaW4gZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfaW5kZXgiLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIltdIiwiUmFuZ2UiLCIxIiwiLTIiLCI8Y2xhc3M6R2VuZXJhdG9yPiIsInJhaXNlIiwiTG9jYWxKdW1wRXJyb3IiLCJAYmxvY2siLCJ5aWVsZGVyIiwiWWllbGRlciIsIjxjbGFzczpZaWVsZGVyPiIsInlpZWxkIiwiPDwiLCJ2YWx1ZXMiLCI8Y2xhc3M6TGF6eT4iLCI8Y2xhc3M6U3RvcExhenlFcnJvcj4iLCJFeGNlcHRpb24iLCJBcmd1bWVudEVycm9yIiwiQGVudW1lcmF0b3IiLCJibG9jayBpbiBpbml0aWFsaXplIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiZWFjaF9hcmdzIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwibGF6eSIsImNvbGxlY3QiLCJMYXp5IiwiZW51bWVyYXRvcl9zaXplIiwiYmxvY2sgaW4gY29sbGVjdCIsImVudW0kIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwiY29sbGVjdF9jb25jYXQiLCJibG9jayBpbiBjb2xsZWN0X2NvbmNhdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJ2IiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBjb2xsZWN0X2NvbmNhdCIsInRyeV9jb252ZXJ0IiwiQXJyYXkiLCJkcm9wIiwibiIsIjwiLCJjdXJyZW50X3NpemUiLCJzZXRfc2l6ZSIsIj09PSIsImRyb3BwZWQiLCJibG9jayBpbiBkcm9wIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wIiwiZHJvcF93aGlsZSIsInN1Y2NlZWRpbmciLCJibG9jayBpbiBkcm9wX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkcm9wX3doaWxlIiwibWV0aG9kIiwiZmluZF9hbGwiLCJibG9jayBpbiBmaW5kX2FsbCIsImJsb2NrICgyIGxldmVscykgaW4gZmluZF9hbGwiLCJncmVwIiwicGF0dGVybiIsImJsb2NrIGluIGdyZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIGdyZXAiLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInRha2UiLCJ0YWtlbiIsImJsb2NrIGluIHRha2UiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2UiLCJTdG9wTGF6eUVycm9yIiwidGFrZV93aGlsZSIsImJsb2NrIGluIHRha2Vfd2hpbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIHRha2Vfd2hpbGUiLCI8Y2xhc3M6QXJpdGhtZXRpY1NlcXVlbmNlPiJdLCJtYXBwaW5ncyI6IkFBQUFBLHFEQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQywwQkFBUkQ7SUFFQ0Q7SUFFREcsVUFBSUwsSUFBSkssVUFBQUEsb0JBQUFBLFNBQWFDLE1BQUQsRUFUZCxFQVNjLEVBVGQsRUFTRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBNEM7O01BVDlDOztNQVN1QjtNQUFBO01BQUE7TUFBQTtNQUFBO01BQUEsV0FBUyxNQUFUO01BQUE7O01BQWdCOztBQUV2Q0EsZ0JBQWtCTCxJQUFBTyxVQUFBQSxDQUFBQSxDQUFTRjs7QUFFM0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQVZFQSxDQUFBQSxnQ0FBQUE7O0FBYUFHLElBQUFBLDhCQUFBQSwyQkFBQUEsc0JBdEJGLEVBc0JFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFrQjs7TUF0QnBCOztNQXNCaUI7TUFDYixJQUFBLFFBQUdDLEtBQUgsQ0FBQTs7UUFDRUMsY0FBbUJDLE1BQVRDLHlCQUFTRCxPQUFBQSxFQUFBQSxFQUFBQSxFQUFNRixLQUFESSxTQUFBQSxDQUFBQSxDQUFMRjtRQUNuQkcsY0FBVTtRQUNWQyxZQUFVO1FBQ1ZDLFlBQVdSO1FBRVgsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTdCVFMsQ0FBQUEsWUE2QlNELFNBN0JUQyxDQTZCUyxDQUFBO1VBQVNULE9BQUNRLFNBQUtFLGdCQUFBQSxDQUFhLE1BQWJBLENBQU5DLE1BQUFBLENBQUFBO1FBQVQ7VUE3QlRYLE9BQUE7UUE2QlMsQ0FBQSxrQkFBSCxDQUFBO1VBQ0VBLE9BQUFRLENBQUFBLFlBQVNSLFdBQWFRLFNBQU1SLEVBQUlZLHVCQUFRWixXQUF4Q1E7UUFERjtVQTdCTlIsT0FBQTtRQTZCTTtNQU5GOztRQVVFRSxjQUFXRjtRQUNYTSxjQUFXTjtRQUNYTyxZQUFXUDtRQUNYQSxPQUFBUSxDQUFBQSxZQUFVLEdBQVZBO01BYkY7SUFERlIsQ0FBQUEsdUNBQUFBOztBQWtCQWEsSUFBQUEsd0JBQUFBLHFCQUFBQSxnQkF4Q0YsRUF3Q0VBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWdCOztNQXhDbEI7O01Bd0NXO01BQ1AsSUFBQSxRQUFlLGFBQUEsSUFBQSxRQXpDbkJDLENBQUFBLFlBeUNtQmIsS0FBS2MsU0FBQUEsQ0FBQUEsQ0F6Q3hCRCxDQXlDbUIsQ0FBQTtRQUFjRCxPQUFBRyxJQUFJQyxXQUFBQSxDQUFBQTtNQUFsQjtRQXpDbkJKLE9BQUE7TUF5Q21CLENBQUEsa0JBQWYsQ0FBQTtRQUFBLE9BQU9yQixJQUFQO01BRUF3QixPQUFhRSxTQUFOWCxTQUFNVyxFQUFFRixJQUFGRTtNQUViLElBQUEsUUFBa0RqQixLQUFLYyxTQUFBQSxDQUFBQSxDQUF2RCxDQUFBO1FBQUEsT0FBaUJaLE1BQVZYLElBQUkyQixPQUFBQSxDQUFBQSxDQUFNaEIsT0FBQUEsRUFBVixDQUFlRCxXQUFmLEVBQXdCSSxXQUF4QixDQUFBLFFBQWlDLFVBQUNVLElBQUQsQ0FBakMsQ0FBVWIsQ0FBakI7TUFFQVUsT0FBT08sTUFBUGxCLFdBQU9rQixZQUFBQSxFQUFQLENBQWlCZCxXQUFqQixDQUFBLFFBQTBCLFVBQUNVLElBQUQsQ0FBMUIsQ0FBT0ksRUFBMkJuQixLQUFESSxTQUFBQSxDQUFBQSxDQUExQmU7SUFQVFAsQ0FBQUEsaUNBQUFBOztBQVVBUSxJQUFBQSx3QkFBQUEscUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUFiLFNBQUtFLGdCQUFBQSxDQUFhLE1BQWJBLENBQUwsQ0FBQTtRQUEyQlcsT0FBS0MsTUFBTGQsU0FBS2MsUUFBQUEsRUFBTSxVQUFDZixTQUFELENBQU5lO01BQWhDO1FBQWdERCxPQUFBYjtNQUFoRDtJQURGYSxDQUFBQSxnQ0FBQUE7O0FBSUFFLElBQUFBLDhCQUFBQSwyQkFBQUEsc0JBQWVDLE1BQWZEO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQTJCOztNQUFaO01BQUEsV0FBU0UsQ0FBVDtNQUFBO01BQ2JELFNBQVMsYUFBQSxJQUFBLFFBQUdBLE1BQUgsQ0FBQTtRQUNFRCxPQUFDQSxtQkFBcUJYLHVCQUFRVztNQURoQztRQUdFQSxPQUFBRTtNQUhGLENBQUE7TUFNVCxJQUFBLFFBQXFEeEIsS0FBckQsQ0FBQTtNQUFBO1FBQUEsT0FBT3lCLE1BQUFsQyxJQUFBa0MsWUFBQUEsRUFBQUEsQ0FBUyxZQUFULEVBQXNCRixNQUF0QkUsQ0FBQUEsRUFBOEJDLGdCQUFBQSxFQUFBQzs7VUFBRUEsT0FBQXBDLElBQUE2QixNQUFBQSxDQUFBQSxDQUFGTSxrQkFBQUEsaUJBQUFBLEtBQTlCRDtNQUFQOztBQUdKSDs7QUFFQUE7QUFDQUEsb0JBQXNCTSxvQkFBSUMsYUFBQUEsQ0FBY1AsU0FBZE8sQ0FBMEJQO0FBQ3BEQTs7QUFFQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQXRCRUEsQ0FBQUEsdUNBQUFBO0lBeUJBLGFBQU0sYUFBTixFQUFrQixrQkFBbEI7O0FBRUFRLElBQUFBLG1DQUFBQSxnQ0FBQUEsMkJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQW9CO01BQ2xCLElBQWtEQyxlQUFsRDtNQUFBO1FBQUEsT0FBT04sTUFBQWxDLElBQUFrQyxZQUFBQSxFQUFBQSxDQUFTLGlCQUFUQSxDQUFBQSxFQUEyQk8sZ0JBQUFBLEVBQUFDOztVQUFFQSxPQUFBMUMsSUFBQTZCLE1BQUFBLENBQUFBLENBQUZZLGtCQUFBQSxpQkFBQUEsS0FBM0JQO01BQVA7TUFFQSxPQUFBbEMsSUFBQSxFQUFBLGdGQUFBLG1CQUFBLEVBQUEsRUFBQSxFQUFBLEtBQUE7TUFDQXVDLE9BQUE3QjtJQUpGNkIsQ0FBQUEsMkNBQUFBOztBQU9BSSxJQUFBQSwyQkFBQUEsd0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0VDLFNBQVMsRUFBQSxHQUFDRCxJQUFELEdBQUEsQ0FBSzNDLElBQUkyQixPQUFBQSxDQUFBQSxDQUFULENBQUEsR0FBZ0JnQixJQUFoQixHQUFBLENBQW9CakMsV0FBT2lDLFNBQUFBLENBQUFBLENBQTNCLENBQUEsR0FBb0NBLEdBQXBDLEdBQUEsQ0FBdUM3QixXQUF2QztNQUVULElBQUEsUUFBR0MsU0FBSzhCLFNBQUFBLENBQUFBLENBQVIsQ0FBQTtRQUNFRCxTQUFPbEIsU0FBUGtCLE1BQU9sQixFQUFHLEVBQUEsR0FBQ2lCLEdBQUQsR0FBQSxDQUFJNUIsU0FBSzRCLFNBQUFBLENBQUFBLENBQVFHLE9BQUFBLENBQUNDLHFCQUFLcEMsS0FBQUEsQ0FBS3FDLENBQVYsRUFBYUMsRUFBUnRDLENBQU5tQyxDQUFqQixDQUFBLEdBQW9DSCxHQUF2Q2pCLENBRFQ7TUFJQWlCLE9BQU9qQixTQUFQa0IsTUFBT2xCLEVBQUVpQixHQUFGakI7SUFQVGlCLENBQUFBLG1DQUFBQTtJQVVBTztJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFbEQsSUFBQUcsU0FBQUEsQ0FBUUMsMEJBQVJEOztBQUVBSyxNQUFBQSw4QkFBQUEsMkJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFlO1FBQ2IsSUFBQSxRQUE4Q0MsS0FBOUMsQ0FBQTtRQUFBO1VBQUFULElBQUFtRCxPQUFBQSxDQUFNQyw4QkFBTixFQUFzQjVDLGdCQUF0QjJDO1FBQUE7UUFFQTNDLE9BQUE2QyxDQUFBQSxhQUFTNUMsS0FBVDRDO01BSEY3QyxDQUFBQSxzQ0FBQUE7TUFNQTBDLE9BQUE3QixDQUFBQSx3QkFBQUEscUJBQUFBLGdCQTNHSixFQTJHSUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBZ0I7O1FBM0dwQjs7UUEyR2E7UUFDUGlDLFVBQWlCM0MsTUFBUDRDLHVCQUFPNUMsT0FBQUEsRUFBQUEsRUFBQUEsRUFBTUYsS0FBREksU0FBQUEsQ0FBQUEsQ0FBTEY7O0FBR3ZCVTtBQUNBQSx1QkFBeUJpQyxPQUFRakM7O0FBRWpDQSxzQkFBd0JnQyxVQUFPaEM7QUFDL0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO1FBRU1BLE9BQUFyQjtNQW5CRnFCLENBQUFBLGlDQUFBQSxDQUFBQTtJQVRGNkIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7SUFnQ0FNO0lBQUFBOztNQUFBQTs7QUFBQUE7OztBQUNFaEQsTUFBQUEsOEJBQUFBLHlCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBZTtRQUNiQSxPQUFBNkMsQ0FBQUEsYUFBUzVDLEtBQVQ0QztNQURGN0MsQ0FBQUEsb0NBQUFBOztBQUlBaUQsTUFBQUEseUJBQUFBLG9CQUFBQSxTQXZJSixFQXVJSUE7QUFBQUEsUUFBQUE7Ozs7UUF2SUo7O1FBdUljOztBQUVkQSxnQ0FBa0NKLFVBQU9JOztBQUV6Q0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO01BVElBLENBQUFBLGdDQUFBQTtNQVlBRCxPQUFBRSxDQUFBQSxzQkFBQUEscUJBQUFBLFNBbkpKLEVBbUpJQTtBQUFBQSxRQUFBQTs7OztRQW5KSjs7UUFtSlc7UUFDREQsTUFBSnpELElBQUl5RCxTQUFBQSxFQUFPLFVBQUNFLE1BQUQsQ0FBUEY7UUFFSkMsT0FBQTFEO01BSEYwRCxDQUFBQSxpQ0FBQUEsQ0FBQUE7SUFqQkZGLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0lBd0JBSTtJQUFBQTs7TUFBQUE7O0FBQUFBOztNQUNFQztNQUFBQTs7UUFBQUE7O1FBQUFBLE9BQUE7TUFBQUEsR0FBQUEsV0FBQUEsRUFBc0JDLHlCQUF0QkQ7O0FBRUFyRCxNQUFBQSw4QkFBQUEsc0JBQUFBLHNCQUFlRixNQUFELEVBQVN1QixJQUF2QnJCO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQW1DOztRQUFaO1FBQUEsU0FBTyxHQUFQO1FBQUE7UUFDckIsSUFBT2dDLGVBQVA7UUFBQTtVQUNFeEMsSUFBQW1ELE9BQUFBLENBQU1ZLDZCQUFOLEVBQXFCdkQsd0NBQXJCMkM7UUFERjtRQUlBYSxrQkFBYzFEO1FBRWRFLE9BQUEsT0FBQVIsSUFBQSxFQUFBLGlFQUFBLGNBQUEsRUFBQSxDQUFNNkIsSUFBTixDQUFBLEVBQVdvQyxpQkFBSVgsT0FBRCxFQXBLcEIsRUFvS2lCVyxFQUFBQzs7OztVQUFJO1VBQUE7VUFBQTs7VUFwS3JCOztVQW9LOEI7VUFDdEI7WUFBQUEsT0FBTTdDLE1BQU5mLE1BQU1lLFFBQUFBLEVBQU0sVUFBQzhDLFNBQUQsQ0FBTjlDLEVBQWtCNkMsaUJBcktoQyxFQXFLZ0NBLEVBQUFFOzs7O2NBcktoQzs7Y0FxS29DOztBQUVwQ0EseUJBQTJCZCxPQUFRYzs7QUFFbkNBO0FBQ0FBLFdBTGdDRixtQkFBQUEsbUJBQUFBLE1BQWxCN0M7VUFBTjtZQU9GLHNCQUFPLENBQUF5Qyx5QkFBQSxDQUFQO2NBQUE7Z0JBQ0VJLE9BQUE7Y0FERjtZQUFBLENBUEU7VUFBQSxFQURTRCxtQkFBQUEsbUJBQUFBLE1BQVg7TUFQRnpELENBQUFBLGtDQUFBQTtNQW9CQSxhQUFNLE9BQU4sRUFBWSxNQUFaOztBQUVBNkQsTUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFyRTtNQURGcUUsQ0FBQUEsMkJBQUFBOztBQUlBQyxNQUFBQSwyQkFBQUEsbUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFZO1FBQ1YsSUFBQSxRQUFPN0QsS0FBUCxDQUFBO1FBQUE7VUFDRVQsSUFBQW1ELE9BQUFBLENBQU1ZLDZCQUFOLEVBQXFCTyx3Q0FBckJuQjtRQURGO1FBSUFtQixPQUFJM0QsTUFBSjRELG9CQUFJNUQsT0FBQUEsRUFBQUEsQ0FBS1gsSUFBVCxFQUFlQSxJQUFBd0UsaUJBQUFBLENBQUFBLENBQVg3RCxDQUFBQSxFQUE0QjhELGlCQUFJQyxLQUFELEVBNUx6QyxFQTRMc0NELEVBQUFFOzs7O1VBQUk7VUFBQTtVQUFBOztVQTVMMUM7O1VBNExnRDs7QUFFaERBOztBQUVBQSxVQUFZRCxLQUFJakIsT0FBQUEsQ0FBUWtCLEtBQVJsQixDQUFla0I7QUFDL0JBLFNBTHNDRixtQkFBQUEsbUJBQUFBLE1BQTVCOUQ7TUFMTjJELENBQUFBLDhCQUFBQTs7QUFjQU0sTUFBQUEsa0NBQUFBLDBCQUFBQSwwQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBbUI7UUFDakIsSUFBQSxRQUFPbkUsS0FBUCxDQUFBO1FBQUE7VUFDRVQsSUFBQW1ELE9BQUFBLENBQU1ZLDZCQUFOLEVBQXFCYSx3Q0FBckJ6QjtRQURGO1FBSUF5QixPQUFJakUsTUFBSjRELG9CQUFJNUQsT0FBQUEsRUFBQUEsQ0FBS1gsSUFBVCxFQUFlLEdBQVhXLENBQUFBLEVBQWdCa0UsaUJBQUlILEtBQUQsRUExTTdCLEVBME0wQkcsRUFBQUM7Ozs7VUFBSTtVQUFBO1VBQUE7O1VBMU05Qjs7VUEwTW9DOztBQUVwQ0E7O0FBRUFBLGNBQWdCQSxDQUFDQSxLQUFEQSxDQUFPNUQsZ0JBQUFBLENBQWEsT0FBYkEsQ0FBb0I0RCxJQUFNQSxDQUFDQSxLQUFEQSxDQUFPNUQsZ0JBQUFBLENBQWEsTUFBYkEsQ0FBbUI0RDtBQUMzRUEsWUFBcUJ6RCxNQUFQeUQsQ0FBQ0EsS0FBREEsQ0FBT3pELFFBQUFBLEVBQUFBLEVBQUFBLEVBQU15RCxpQkFBR0MsQ0FBSEQsRUFBQUU7Ozs7WUFBRztZQUFBO1lBQUE7WUFBR0EsT0FBQU4sS0FBSWpCLE9BQUFBLENBQU9zQixDQUFQdEIsRUFBVnFCLG1CQUFBQSxrQkFBQUEsTUFBTnpEO0FBQ3JCeUQ7QUFDQUE7QUFDQUEsd0JBQTBCekMsb0JBQUk0QyxhQUFBQSxDQUFjSCxLQUFsQixFQUEwQkkscUJBQTFCLEVBQWlDLFFBQTdCRCxDQUFxQ0g7O0FBRW5FQTtBQUNBQSxjQUFnQkosS0FBSWpCLE9BQUFBLENBQVFxQixLQUFSckIsQ0FBZXFCO0FBQ25DQTtBQUNBQTtBQUNBQSxjQUF1QnpELE1BQVB5RCxDQUFDQSxLQUFEQSxDQUFPekQsUUFBQUEsRUFBQUEsRUFBQUEsRUFBTXlELGlCQUFHQyxDQUFIRCxFQUFBRTs7OztZQUFHO1lBQUE7WUFBQTtZQUFHQSxPQUFBTixLQUFJakIsT0FBQUEsQ0FBT3NCLENBQVB0QixFQUFWcUIsbUJBQUFBLGtCQUFBQSxNQUFOekQsQ0FBMkJ5RDtBQUNsREE7QUFDQUE7QUFDQUEsU0FqQjBCRCxtQkFBQUEsbUJBQUFBLE1BQWhCbEU7TUFMTmlFLENBQUFBLHFDQUFBQTs7QUEwQkFPLE1BQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQVNDLENBQVREO0FBQUFBLFFBQUFBOzs7UUFDRUMsSUFBS0QsV0FBYUMsQ0FBRUQsRUFBSS9ELHVCQUFRK0Q7UUFFaEMsSUFBQSxRQUFLRSxPQUFGRCxDQUFFQyxFQUFFcEQsQ0FBRm9ELENBQUwsQ0FBQTtVQUNFckYsSUFBQW1ELE9BQUFBLENBQU1ZLDZCQUFOLEVBQXFCb0IsK0JBQXJCaEMsQ0FERjtRQUlBbUMsZUFBZXRGLElBQUF3RSxpQkFBQUEsQ0FBQUE7UUFDZmUsV0FBZSxhQUFBLElBQUEsUUFBR25FLHVCQUFRb0UsUUFBQUEsQ0FBSUYsWUFBSkUsQ0FBWCxDQUFBO1VBQ0UsSUFBQSxRQUFFSCxPQUFGRCxDQUFFQyxFQUFFQyxZQUFGRCxDQUFGLENBQUE7WUFBbUJGLE9BQUFDO1VBQW5CO1lBQXVCRCxPQUFBRztVQUF2QjtRQURGO1VBR0VILE9BQUFHO1FBSEYsQ0FBQTtRQU1mRyxVQUFVeEQ7UUFDVmtELE9BQUl4RSxNQUFKNEQsb0JBQUk1RCxPQUFBQSxFQUFBQSxDQUFLWCxJQUFULEVBQWV1RixRQUFYNUUsQ0FBQUEsRUFBcUIrRSxpQkFBSWhCLEtBQUQsRUE5T2xDLEVBOE8rQmdCLEVBQUFDOzs7O1VBQUk7VUFBQTtVQUFBOztVQTlPbkM7O1VBOE95QztVQUNqQyxJQUFBLFFBQVdOLE9BQVJJLE9BQVFKLEVBQUVELENBQUZDLENBQVgsQ0FBQTtZQUNFTSxPQUFBRixDQUFBQSxVQUFRL0QsU0FBUitELE9BQVEvRCxFQUFHc0IsQ0FBSHRCLENBQVIrRDtVQURGO1lBR0VFLE9BQUlsQyxNQUFKaUIsS0FBSWpCLFNBQUFBLEVBQU8sVUFBQ2pDLElBQUQsQ0FBUGlDO1VBSE4sRUFEdUJpQyxtQkFBQUEsbUJBQUFBLE1BQXJCL0U7TUFmTndFLENBQUFBLDJCQUFBQTs7QUF3QkFTLE1BQUFBLDhCQUFBQSxzQkFBQUEsc0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQWU7UUFDYixJQUFBLFFBQU9uRixLQUFQLENBQUE7UUFBQTtVQUNFVCxJQUFBbUQsT0FBQUEsQ0FBTVksNkJBQU4sRUFBcUI2QiwrQ0FBckJ6QztRQURGO1FBSUEwQyxhQUFhO1FBQ2JELE9BQUlqRixNQUFKNEQsb0JBQUk1RCxPQUFBQSxFQUFBQSxDQUFLWCxJQUFULEVBQWUsR0FBWFcsQ0FBQUEsRUFBZ0JtRixpQkFBSXBCLEtBQUQsRUE3UDdCLEVBNlAwQm9CLEVBQUFDOzs7O1VBQUk7VUFBQTtVQUFBOztVQTdQOUI7O1VBNlBvQztVQUM1QixJQUFBLFFBQUdGLFVBQUgsQ0FBQTs7QUFFUkU7O0FBRUFBO0FBQ0FBOztBQUVBQSxjQUFvQnRDLE1BQUppQixLQUFJakIsU0FBQUEsRUFBTyxVQUFDakMsSUFBRCxDQUFQaUMsQ0FBY3NDO0FBQ2xDQTtBQUNBQTtVQVRRO1lBV0VBLE9BQUl0QyxNQUFKaUIsS0FBSWpCLFNBQUFBLEVBQU8sVUFBQ2pDLElBQUQsQ0FBUGlDO1VBWE4sRUFEa0JxQyxtQkFBQUEsbUJBQUFBLE1BQWhCbkY7TUFOTmlGLENBQUFBLGlDQUFBQTs7QUF1QkExRCxNQUFBQSw0QkFBQUEsb0JBQUFBLG9CQTlRSixFQThRZ0IsRUE5UWhCLEVBOFFJQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFvQzs7UUE5UXhDOztRQThRaUI7UUFBQTtRQUFBO1FBQUE7UUFBQTtRQUFBLFdBQVMsTUFBVDtRQUFBOztRQUFnQjtRQUMzQkEsT0FBVTdCLE1BQVZMLElBQUkyQixPQUFBQSxDQUFBQSxDQUFNdEIsT0FBQUEsRUFBVixDQUFlTCxJQUFmLEVBQXFCZ0csTUFBckIsQ0FBQSxRQUE2QixVQUFDeEUsSUFBRCxDQUE3QixDQUFVbkIsRUFBMkJJLEtBQURJLFNBQUFBLENBQUFBLENBQTFCUjtNQURaNkIsQ0FBQUEsZ0NBQUFBO01BSUEsYUFBTSxRQUFOLEVBQWEsVUFBYjs7QUFFQStELE1BQUFBLDRCQUFBQSxvQkFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQWE7UUFDWCxJQUFBLFFBQU94RixLQUFQLENBQUE7UUFBQTtVQUNFVCxJQUFBbUQsT0FBQUEsQ0FBTVksNkJBQU4sRUFBcUJrQywyQ0FBckI5QztRQURGO1FBSUE4QyxPQUFJdEYsTUFBSjRELG9CQUFJNUQsT0FBQUEsRUFBQUEsQ0FBS1gsSUFBVCxFQUFlLEdBQVhXLENBQUFBLEVBQWdCdUYsaUJBQUl4QixLQUFELEVBelI3QixFQXlSMEJ3QixFQUFBQzs7OztVQUFJO1VBQUE7VUFBQTs7VUF6UjlCOztVQXlSb0M7O0FBRXBDQTs7QUFFQUE7QUFDQUEsWUFBa0IxQyxNQUFKaUIsS0FBSWpCLFNBQUFBLEVBQU8sVUFBQ2pDLElBQUQsQ0FBUGlDLENBQWMwQztBQUNoQ0E7QUFDQUEsU0FQMEJELG1CQUFBQSxtQkFBQUEsTUFBaEJ2RjtNQUxOc0YsQ0FBQUEsK0JBQUFBO01BZ0JBLGFBQU0sVUFBTixFQUFlLGdCQUFmOztBQUVBRyxNQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFTQyxPQUFURDtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQUFrQjtRQUNoQixJQUFBLFFBQUczRixLQUFILENBQUE7VUFDRTJGLE9BQUl6RixNQUFKNEQsb0JBQUk1RCxPQUFBQSxFQUFBQSxDQUFLWCxJQUFULEVBQWUsR0FBWFcsQ0FBQUEsRUFBZ0IyRixpQkFBSTVCLEtBQUQsRUF4Uy9CLEVBd1M0QjRCLEVBQUFDOzs7O1lBQUk7WUFBQTtZQUFBOztZQXhTaEM7O1lBd1NzQzs7QUFFdENBLHdCQUEwQmxFLG9CQUFJQyxhQUFBQSxDQUFhZCxJQUFiYyxDQUFtQmlFO0FBQ2pEQSx3QkFBMEJGLE9BQVFiLFFBQUFBLENBQUtlLEtBQUxmLENBQVllOztBQUU5Q0E7QUFDQUE7O0FBRUFBLGNBQWdCN0IsS0FBSWpCLE9BQUFBLENBQVE4Qyx5QkFBUjlDLENBQW1DOEM7QUFDdkRBO0FBQ0FBLFdBVjRCRCxtQkFBQUEsbUJBQUFBLE1BQWhCM0Y7UUFETjtVQWNFeUYsT0FBSXpGLE1BQUo0RCxvQkFBSTVELE9BQUFBLEVBQUFBLENBQUtYLElBQVQsRUFBZSxHQUFYVyxDQUFBQSxFQUFnQjJGLGlCQUFJNUIsS0FBRCxFQXJUL0IsRUFxVDRCNEIsRUFBQUM7Ozs7WUFBSTtZQUFBO1lBQUE7O1lBclRoQzs7WUFxVHNDOztBQUV0Q0Esd0JBQTBCbEUsb0JBQUlDLGFBQUFBLENBQWFkLElBQWJjLENBQW1CaUU7QUFDakRBLHdCQUEwQkYsT0FBUWIsUUFBQUEsQ0FBS2UsS0FBTGYsQ0FBWWU7O0FBRTlDQTtBQUNBQSxjQUFnQjdCLEtBQUlqQixPQUFBQSxDQUFROEMsS0FBUjlDLENBQWU4QztBQUNuQ0E7QUFDQUEsV0FSNEJELG1CQUFBQSxtQkFBQUEsTUFBaEIzRjtRQWROO01BREZ5RixDQUFBQSwyQkFBQUE7TUE0QkEsYUFBTSxLQUFOLEVBQVUsU0FBVjtNQUVBLGFBQU0sUUFBTixFQUFhLFVBQWI7O0FBRUFJLE1BQUFBLDBCQUFBQSxrQkFBQUEsa0JBQUFBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBQVc7UUFDVCxJQUFBLFFBQU8vRixLQUFQLENBQUE7UUFBQTtVQUNFVCxJQUFBbUQsT0FBQUEsQ0FBTVksNkJBQU4sRUFBcUJ5QywyQ0FBckJyRDtRQURGO1FBSUFxRCxPQUFJN0YsTUFBSjRELG9CQUFJNUQsT0FBQUEsRUFBQUEsQ0FBS1gsSUFBVCxFQUFlLEdBQVhXLENBQUFBLEVBQWdCOEYsaUJBQUkvQixLQUFELEVBM1U3QixFQTJVMEIrQixFQUFBQzs7OztVQUFJO1VBQUE7VUFBQTs7VUEzVTlCOztVQTJVb0M7O0FBRXBDQTs7QUFFQUE7QUFDQUEsWUFBa0JqRCxNQUFKaUIsS0FBSWpCLFNBQUFBLEVBQU8sVUFBQ2pDLElBQUQsQ0FBUGlDLENBQWNpRDtBQUNoQ0E7QUFDQUEsU0FQMEJELG1CQUFBQSxtQkFBQUEsTUFBaEI5RjtNQUxONkYsQ0FBQUEsNkJBQUFBOztBQWdCQUcsTUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBU3ZCLENBQVR1QjtBQUFBQSxRQUFBQTs7O1FBQ0V2QixJQUFLdUIsV0FBYXZCLENBQUV1QixFQUFJdkYsdUJBQVF1RjtRQUVoQyxJQUFBLFFBQUt0QixPQUFGRCxDQUFFQyxFQUFFcEQsQ0FBRm9ELENBQUwsQ0FBQTtVQUNFckYsSUFBQW1ELE9BQUFBLENBQU1ZLDZCQUFOLEVBQXFCNEMsK0JBQXJCeEQsQ0FERjtRQUlBbUMsZUFBZXRGLElBQUF3RSxpQkFBQUEsQ0FBQUE7UUFDZmUsV0FBZSxhQUFBLElBQUEsUUFBR25FLHVCQUFRb0UsUUFBQUEsQ0FBSUYsWUFBSkUsQ0FBWCxDQUFBO1VBQ0UsSUFBQSxRQUFFSCxPQUFGRCxDQUFFQyxFQUFFQyxZQUFGRCxDQUFGLENBQUE7WUFBbUJzQixPQUFBdkI7VUFBbkI7WUFBdUJ1QixPQUFBckI7VUFBdkI7UUFERjtVQUdFcUIsT0FBQXJCO1FBSEYsQ0FBQTtRQU1mc0IsUUFBUTNFO1FBQ1IwRSxPQUFJaEcsTUFBSjRELG9CQUFJNUQsT0FBQUEsRUFBQUEsQ0FBS1gsSUFBVCxFQUFldUYsUUFBWDVFLENBQUFBLEVBQXFCa0csaUJBQUluQyxLQUFELEVBcldsQyxFQXFXK0JtQyxFQUFBQzs7OztVQUFJO1VBQUE7VUFBQTs7VUFyV25DOztVQXFXeUM7VUFDakMsSUFBQSxRQUFTekIsT0FBTnVCLEtBQU12QixFQUFFRCxDQUFGQyxDQUFULENBQUE7O1lBQ001QixNQUFKaUIsS0FBSWpCLFNBQUFBLEVBQU8sVUFBQ2pDLElBQUQsQ0FBUGlDO1lBQ0pxRCxPQUFBRixDQUFBQSxRQUFNbEYsU0FBTmtGLEtBQU1sRixFQUFHc0IsQ0FBSHRCLENBQU5rRjtVQUZGO1lBSUVFLE9BQUE5RyxJQUFBbUQsT0FBQUEsQ0FBTTRELDZCQUFONUQ7VUFKRixFQUR1QjBELG1CQUFBQSxtQkFBQUEsTUFBckJsRztNQWZOZ0csQ0FBQUEsMkJBQUFBOztBQXlCQUssTUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFBZTtRQUNiLElBQUEsUUFBT3ZHLEtBQVAsQ0FBQTtRQUFBO1VBQ0VULElBQUFtRCxPQUFBQSxDQUFNWSw2QkFBTixFQUFxQmlELCtDQUFyQjdEO1FBREY7UUFJQTZELE9BQUlyRyxNQUFKNEQsb0JBQUk1RCxPQUFBQSxFQUFBQSxDQUFLWCxJQUFULEVBQWUsR0FBWFcsQ0FBQUEsRUFBZ0JzRyxpQkFBSXZDLEtBQUQsRUFwWDdCLEVBb1gwQnVDLEVBQUFDOzs7O1VBQUk7VUFBQTtVQUFBOztVQXBYOUI7O1VBb1hvQzs7QUFFcENBOztBQUVBQTtBQUNBQSxZQUFrQnpELE1BQUppQixLQUFJakIsU0FBQUEsRUFBTyxVQUFDakMsSUFBRCxDQUFQaUMsQ0FBY3lEO0FBQ2hDQTtBQUNBQTtBQUNBQSxZQUFjbEgsSUFBQW1ELE9BQUFBLENBQU00RCw2QkFBTjVELENBQW9CK0Q7QUFDbENBO0FBQ0FBLFNBVjBCRCxtQkFBQUEsbUJBQUFBLE1BQWhCdEc7TUFMTnFHLENBQUFBLGlDQUFBQTtNQW1CQSxhQUFNLFNBQU4sRUFBYyxVQUFkO01BRUFwRCxPQUFBakIsQ0FBQUEsMkJBQUFBLG1CQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUEsRUFBQSxHQUFDQSxJQUFELEdBQUEsQ0FBSzNDLElBQUkyQixPQUFBQSxDQUFBQSxDQUFULENBQUEsR0FBZ0JnQixJQUFoQixHQUFBLENBQW9CcUIsZUFBV3JCLFNBQUFBLENBQUFBLENBQS9CLENBQUEsR0FBd0NBO01BRDFDQSxDQUFBQSw4QkFBQUEsQ0FBQUE7SUExT0ZpQixHQUFBQSxXQUFBQSxFQUFhNUQsSUFBYjREO0lBK09BMUQsT0FBQWlIO0lBQUFBOztNQUFBQTs7TUFBQUEsT0FBQTtJQUFBQSxHQUFBQSxXQUFBQSxFQUEyQm5ILElBQTNCbUg7RUFyWUZqSCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTIyODYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL251bWVyaWMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xuXG5jbGFzcyBOdW1lcmljXG4gIGluY2x1ZGUgQ29tcGFyYWJsZVxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgaWYgb3RoZXIuaW5zdGFuY2Vfb2Y/IHNlbGYuY2xhc3NcbiAgICAgIHJldHVybiBbb3RoZXIsIHNlbGZdXG4gICAgZW5kXG5cbiAgICBbRmxvYXQob3RoZXIpLCBGbG9hdChzZWxmKV1cbiAgZW5kXG5cbiAgZGVmIF9fY29lcmNlZF9fKG1ldGhvZCwgb3RoZXIpXG4gICAgaWYgb3RoZXIucmVzcG9uZF90bz8oOmNvZXJjZSlcbiAgICAgIGEsIGIgPSBvdGhlci5jb2VyY2Uoc2VsZilcbiAgICAgIGEuX19zZW5kX18gbWV0aG9kLCBiXG4gICAgZWxzZVxuICAgICAgY2FzZSBtZXRob2RcbiAgICAgIHdoZW4gOissIDotLCA6KiwgOi8sIDolLCA6JiwgOnwsIDpeLCA6KipcbiAgICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBOdW1lcmljXCJcbiAgICAgIHdoZW4gOj4sIDo+PSwgOjwsIDo8PSwgOjw9PlxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7b3RoZXIuY2xhc3N9IGZhaWxlZFwiXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBlcXVhbD8gb3RoZXJcbiAgICAgIHJldHVybiAwXG4gICAgZW5kXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgLUBcbiAgICAwIC0gc2VsZlxuICBlbmRcblxuICBkZWYgJShvdGhlcilcbiAgICBzZWxmIC0gb3RoZXIgKiBkaXYob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBzZWxmIDwgMCA/IC1zZWxmIDogc2VsZlxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIHNlbGYgKiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIHNlbGYgPCAwID8gTWF0aDo6UEkgOiAwXG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuXG4gIGRlZiBjZWlsKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YuY2VpbChuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgY29ualxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICB0b19yLmRlbm9taW5hdG9yXG4gIGVuZFxuXG4gIGRlZiBkaXYob3RoZXIpXG4gICAgcmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IG8nIGlmIG90aGVyID09IDBcblxuICAgIChzZWxmIC8gb3RoZXIpLmZsb29yXG4gIGVuZFxuXG4gIGRlZiBkaXZtb2Qob3RoZXIpXG4gICAgW2RpdihvdGhlciksIHNlbGYgJSBvdGhlcl1cbiAgZW5kXG5cbiAgZGVmIGZkaXYob3RoZXIpXG4gICAgdG9fZiAvIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihuZGlnaXRzID0gMClcbiAgICB0b19mLmZsb29yKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBpXG4gICAgQ29tcGxleCgwLCBzZWxmKVxuICBlbmRcblxuICBkZWYgaW1hZ1xuICAgIDBcbiAgZW5kXG5cbiAgYWxpYXMgaW1hZ2luYXJ5IGltYWdcblxuICBkZWYgaW50ZWdlcj9cbiAgICBmYWxzZVxuICBlbmRcblxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG5cbiAgYWxpYXMgbW9kdWxvICVcblxuICBkZWYgbm9uemVybz9cbiAgICB6ZXJvPyA/IG5pbCA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIHRvX3IubnVtZXJhdG9yXG4gIGVuZFxuXG4gIGFsaWFzIHBoYXNlIGFyZ1xuXG4gIGRlZiBwb2xhclxuICAgIFthYnMsIGFyZ11cbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICBPcGFsLmNvZXJjZV90byEoc2VsZiwgUmF0aW9uYWwsIDp0b19yKSAvIG90aGVyXG4gIGVuZFxuXG4gIGRlZiByZWFsXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVhbD9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW3NlbGYsIDBdXG4gIGVuZFxuXG4gIGFsaWFzIHJlY3Rhbmd1bGFyIHJlY3RcblxuICBkZWYgcm91bmQoZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIHRvX2Yucm91bmQoZGlnaXRzKVxuICBlbmRcblxuICBkZWYgc3RlcChsaW1pdCA9IHVuZGVmaW5lZCwgc3RlcCA9IHVuZGVmaW5lZCwgdG86IHVuZGVmaW5lZCwgYnk6IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgdG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0byBpcyBnaXZlbiB0d2ljZSd9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwICE9PSB1bmRlZmluZWQgJiYgYnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdzdGVwIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSB0bztcbiAgICAgIH1cblxuICAgICAgaWYgKGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RlcCA9IGJ5O1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IG5pbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdzdGVwIG11c3QgYmUgbnVtZXJpYyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCAhPSBudWxsICYmICN7c3RlcCA9PSAwfSkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09PSBuaWwgfHwgc3RlcCA9PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2lnbiA9ICN7c3RlcCA8PT4gMH07XG5cbiAgICAgICAgaWYgKHNpZ24gPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCIwIGNhbid0IGJlIGNvZXJjZWQgaW50byAje3N0ZXAuY2xhc3N9XCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGltaXQgPT09IG5pbCB8fCBsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgbGltaXQgPSBzaWduID4gMCA/ICN7RmxvYXQ6OklORklOSVRZfSA6ICN7LUZsb2F0OjpJTkZJTklUWX07XG4gICAgICAgIH1cblxuICAgICAgICAje09wYWwuY29tcGFyZShzZWxmLCBsaW1pdCl9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXBGbG9hdFNpemUoKSB7XG4gICAgICAgIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IEluZmluaXR5IHx8IHN0ZXAgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKHNlbGYpICsgYWJzKGxpbWl0KSArIGFicyhsaW1pdCAtIHNlbGYpKSAvIGFicyhzdGVwKSAqICN7RmxvYXQ6OkVQU0lMT059O1xuXG4gICAgICAgICAgaWYgKGVyciA9PT0gSW5maW5pdHkgfHwgZXJyID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXJyID4gMC41KSB7XG4gICAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZsb29yKChsaW1pdCAtIHNlbGYpIC8gc3RlcCArIGVycikgKyAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXBTaXplKCkge1xuICAgICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgICBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICUgMSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBzdGVwRmxvYXRTaXplKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCwgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgICAgIGxocyA9IGFicyhzZWxmIC0gbGltaXQpICsgMSxcbiAgICAgICAgICAgICAgcmhzID0gYWJzKHN0ZXApO1xuXG4gICAgICAgICAgcmV0dXJuIGNlaWwobGhzIC8gcmhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBsaW1pdCwgc3RlcCwgJmBzdGVwU2l6ZWApIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgIHZhciBpc0Rlc2MgPSAje3N0ZXAubmVnYXRpdmU/fSxcbiAgICAgICAgICBpc0luZiA9ICN7c3RlcCA9PSAwfSB8fFxuICAgICAgICAgICAgICAgICAgKGxpbWl0ID09PSBJbmZpbml0eSAmJiAhaXNEZXNjKSB8fFxuICAgICAgICAgICAgICAgICAgKGxpbWl0ID09PSAtSW5maW5pdHkgJiYgaXNEZXNjKTtcblxuICAgICAgaWYgKHNlbGYuJCRpc19udW1iZXIgJiYgc3RlcC4kJGlzX251bWJlciAmJiBsaW1pdC4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoc2VsZiAlIDEgPT09IDAgJiYgKGlzSW5mIHx8IGxpbWl0ICUgMSA9PT0gMCkgJiYgc3RlcCAlIDEgPT09IDApIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmO1xuXG4gICAgICAgICAgaWYgKGlzSW5mKSB7XG4gICAgICAgICAgICBmb3IgKDs7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZXNjKSB7XG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUgPj0gbGltaXQ7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKDsgdmFsdWUgPD0gbGltaXQ7IHZhbHVlICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgYmxvY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiZWdpbiA9ICN7dG9fZn0udmFsdWVPZigpO1xuICAgICAgICAgIHN0ZXAgPSAje3N0ZXAudG9fZn0udmFsdWVPZigpO1xuICAgICAgICAgIGxpbWl0ID0gI3tsaW1pdC50b19mfS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICB2YXIgbiA9IHN0ZXBGbG9hdFNpemUoKTtcblxuICAgICAgICAgIGlmICghaXNGaW5pdGUoc3RlcCkpIHtcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSBibG9jayhiZWdpbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBibG9jayhiZWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBkID0gaSAqIHN0ZXAgKyBzZWxmO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+PSAwID8gbGltaXQgPCBkIDogbGltaXQgPiBkKSB7XG4gICAgICAgICAgICAgICAgZCA9IGxpbWl0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJsb2NrKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY291bnRlciA9IHNlbGZcblxuICAgIHdoaWxlIGBpc0Rlc2MgPyAje2NvdW50ZXIgPj0gbGltaXR9IDogI3tjb3VudGVyIDw9IGxpbWl0fWBcbiAgICAgIHlpZWxkIGNvdW50ZXJcbiAgICAgIGNvdW50ZXIgKz0gc3RlcFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fY1xuICAgIENvbXBsZXgoc2VsZiwgMClcbiAgZW5kXG5cbiAgZGVmIHRvX2ludFxuICAgIHRvX2lcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YudHJ1bmNhdGUobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHplcm8/XG4gICAgc2VsZiA9PSAwXG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBzZWxmID4gMFxuICBlbmRcblxuICBkZWYgbmVnYXRpdmU/XG4gICAgc2VsZiA8IDBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgbmlsXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOk51bWVyaWM+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsImNsYXNzIiwiRmxvYXQiLCJfX2NvZXJjZWRfXyIsIm1ldGhvZCIsInJlc3BvbmRfdG8/IiwiYSIsImIiLCJfX3NlbmRfXyIsIj09PSIsInJhaXNlIiwiVHlwZUVycm9yIiwiQXJndW1lbnRFcnJvciIsIjw9PiIsImVxdWFsPyIsIjAiLCIrQCIsIi1AIiwiLSIsIiUiLCIqIiwiZGl2IiwiYWJzIiwiPCIsImFiczIiLCJhbmdsZSIsIk1hdGg6OlBJIiwiTWF0aCIsImNlaWwiLCJuZGlnaXRzIiwidG9fZiIsImNvbmoiLCJkZW5vbWluYXRvciIsInRvX3IiLCI9PSIsIlplcm9EaXZpc2lvbkVycm9yIiwiLyIsImZsb29yIiwiZGl2bW9kIiwiZmRpdiIsImkiLCJDb21wbGV4IiwiaW1hZyIsImludGVnZXI/Iiwibm9uemVybz8iLCJ6ZXJvPyIsIm51bWVyYXRvciIsInBvbGFyIiwiYXJnIiwicXVvIiwiT3BhbCIsImNvZXJjZV90byEiLCJSYXRpb25hbCIsInJlYWwiLCJyZWFsPyIsInJlY3QiLCJyb3VuZCIsImRpZ2l0cyIsInN0ZXAiLCJGbG9hdDo6SU5GSU5JVFkiLCJjb21wYXJlIiwibGltaXQiLCJGbG9hdDo6RVBTSUxPTiIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwidG9fcHJvYyIsIm5lZ2F0aXZlPyIsImNvdW50ZXIiLCI+PSIsIjw9IiwiKyIsInRvX2MiLCJ0b19pbnQiLCJ0b19pIiwidHJ1bmNhdGUiLCJwb3NpdGl2ZT8iLCI+IiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwiZmluaXRlPyIsImluZmluaXRlPyJdLCJtYXBwaW5ncyI6IkFBQUFBLGtEQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQywwQkFBUkQ7O0FBRUFFLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQVdDLEtBQVhEO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFBLFFBQUdDLEtBQUtDLGlCQUFBQSxDQUFjUCxJQUFJUSxPQUFBQSxDQUFBQSxDQUFsQkQsQ0FBUixDQUFBO1FBQ0UsT0FBTyxDQUFDRCxLQUFELEVBQVFOLElBQVIsQ0FEVDtNQUlBSyxPQUFBLENBQUNMLElBQUFTLE9BQUFBLENBQU1ILEtBQU5HLENBQUQsRUFBZVQsSUFBQVMsT0FBQUEsQ0FBTVQsSUFBTlMsQ0FBZjtJQUxGSixDQUFBQSwrQkFBQUE7O0FBUUFLLElBQUFBLCtCQUFBQSx5QkFBQUEsdUJBQWdCQyxNQUFELEVBQVNMLEtBQXhCSTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdKLEtBQUtNLGdCQUFBQSxDQUFhLFFBQWJBLENBQVIsQ0FBQTs7UUFDRSxLQUFPTixLQUFLRCxRQUFBQSxDQUFRTCxJQUFSSyxDQUFaLHNCQUFBLEVBQUFRLENBQUFBLElBQUEsNkJBQUFBLENBQUEsRUFBR0MsQ0FBQUEsSUFBSCw2QkFBR0EsQ0FBSDtRQUNBSixPQUFBRyxDQUFDRSxVQUFBQSxDQUFVSixNQUFYLEVBQW1CRyxDQUFsQkM7TUFGSDtRQUlFTCxPQUFBLGFBQUEsUUFBS0MsTUFBTDtRQUNBLElBQUssR0FBTEssUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLElBQVMsR0FBVEEsUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLElBQWEsR0FBYkEsUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLElBQWlCLEdBQWpCQSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsSUFBcUIsR0FBckJBLFFBQUFBLENBQUEsS0FBQUEsQ0FBQSxJQUF5QixHQUF6QkEsUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLElBQTZCLEdBQTdCQSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsSUFBaUMsR0FBakNBLFFBQUFBLENBQUEsS0FBQUEsQ0FBQSxJQUFxQyxJQUFyQ0EsUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLEdBQ0VOLE9BQUFWLElBQUFpQixPQUFBQSxDQUFNQyx5QkFBTixFQUFpQixFQUFBLEdBQUEsQ0FBR1osS0FBS0UsT0FBQUEsQ0FBQUEsQ0FBUixDQUFBLEdBQWVFLGdDQUFoQ08sQ0FERjtRQURBLEtBR0EsSUFBSyxHQUFMRCxRQUFBQSxDQUFBLEtBQUFBLENBQUEsSUFBUyxJQUFUQSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsSUFBYyxHQUFkQSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsSUFBa0IsSUFBbEJBLFFBQUFBLENBQUEsS0FBQUEsQ0FBQSxJQUF1QixLQUF2QkEsUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLEdBQ0VOLE9BQUFWLElBQUFpQixPQUFBQSxDQUFNRSw2QkFBTixFQUFxQixFQUFBLEdBQUNULGdCQUFELEdBQUEsQ0FBaUJWLElBQUlRLE9BQUFBLENBQUFBLENBQXJCLENBQUEsR0FBNEJFLFFBQTVCLEdBQUEsQ0FBb0NKLEtBQUtFLE9BQUFBLENBQUFBLENBQXpDLENBQUEsR0FBZ0RFLFNBQXJFTyxDQURGO1FBSEEsbUJBQUE7TUFKRjtJQURGUCxDQUFBQSxvQ0FBQUE7O0FBY0FVLElBQUFBLHVCQUFBQSx1QkFBQUEsU0FBUWQsS0FBUmM7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBR3BCLElBQUFxQixXQUFBQSxDQUFPZixLQUFQZSxDQUFILENBQUE7UUFDRSxPQUFPQyxDQURUO01BSUFGLE9BQUE7SUFMRkEsQ0FBQUEsa0NBQUFBOztBQVFBRyxJQUFBQSxzQkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBdkI7SUFERnVCLENBQUFBLCtCQUFBQTs7QUFJQUMsSUFBQUEsc0JBQUFBLHFCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBRUMsVUFBRkgsQ0FBRUcsRUFBRXpCLElBQUZ5QjtJQURKRCxDQUFBQSxnQ0FBQUE7O0FBSUFFLElBQUFBLHFCQUFBQSxzQkFBQUEsU0FBTXBCLEtBQU5vQjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS0QsVUFBTHpCLElBQUt5QixFQUFRRSxVQUFOckIsS0FBTXFCLEVBQUUzQixJQUFBNEIsS0FBQUEsQ0FBSXRCLEtBQUpzQixDQUFGRCxDQUFSRjtJQURQQyxDQUFBQSxpQ0FBQUE7O0FBSUFHLElBQUFBLHVCQUFBQSxpQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBS0MsT0FBTDlCLElBQUs4QixFQUFFUixDQUFGUSxDQUFMO1FBQVdELE9BQUM3QixJQUFEd0IsT0FBQUEsQ0FBQUE7TUFBWDtRQUFtQkssT0FBQTdCO01BQW5CO0lBREY2QixDQUFBQSw0QkFBQUE7O0FBSUFFLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFLSixVQUFMM0IsSUFBSzJCLEVBQUUzQixJQUFGMkI7SUFEUEksQ0FBQUEsNkJBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFLRixPQUFMOUIsSUFBSzhCLEVBQUVSLENBQUZRLENBQUw7UUFBV0UsT0FBQUMsSUFBQUMsb0JBQUFEO01BQVg7UUFBc0JELE9BQUFWO01BQXRCO0lBREZVLENBQUFBLDhCQUFBQTtJQUlBLGFBQU0sS0FBTixFQUFVLE9BQVY7O0FBRUFHLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQVNDLE9BQVREO0FBQUFBLE1BQUFBOzs7O01BQVM7TUFBQSxZQUFVYixDQUFWO01BQUE7TUFDUGEsT0FBQW5DLElBQUFxQyxNQUFBQSxDQUFBQSxDQUFJRixNQUFBQSxDQUFNQyxPQUFORDtJQUROQSxDQUFBQSwrQkFBQUE7O0FBSUFHLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBdEM7SUFERnNDLENBQUFBLDhCQUFBQTtJQUlBLGFBQU0sV0FBTixFQUFnQixNQUFoQjs7QUFFQUMsSUFBQUEsK0JBQUFBLDBCQUFBQSx1QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF2QyxJQUFBd0MsTUFBQUEsQ0FBQUEsQ0FBSUQsYUFBQUEsQ0FBQUE7SUFETkEsQ0FBQUEscUNBQUFBOztBQUlBWCxJQUFBQSx1QkFBQUEsa0JBQUFBLGVBQVF0QixLQUFSc0I7QUFBQUEsTUFBQUE7OztNQUNFLElBQTJDdEIsS0FBTW1DLE9BQUFBLENBQUduQixDQUFIbUIsQ0FBakQ7UUFBQXpDLElBQUFpQixPQUFBQSxDQUFNeUIsaUNBQU4sRUFBeUJkLGNBQXpCWCxDQUFBO01BRUFXLE9BQU1lLFdBQUwzQyxJQUFLMkMsRUFBRXJDLEtBQUZxQyxDQUFRQyxPQUFBQSxDQUFBQTtJQUhoQmhCLENBQUFBLDZCQUFBQTs7QUFNQWlCLElBQUFBLDBCQUFBQSxxQkFBQUEsa0JBQVd2QyxLQUFYdUM7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQzdDLElBQUE0QixLQUFBQSxDQUFJdEIsS0FBSnNCLENBQUQsRUFBYTVCLElBQUswQixNQUFBQSxDQUFFcEIsS0FBRm9CLENBQWxCO0lBREZtQixDQUFBQSxnQ0FBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQVN4QyxLQUFUd0M7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUtILFdBQUwzQyxJQUFBcUMsTUFBQUEsQ0FBQUEsQ0FBS00sRUFBRXJDLEtBQUZxQztJQURQRyxDQUFBQSw4QkFBQUE7O0FBSUFGLElBQUFBLHlCQUFBQSxvQkFBQUEsaUJBQVVSLE9BQVZRO0FBQUFBLE1BQUFBOzs7O01BQVU7TUFBQSxZQUFVdEIsQ0FBVjtNQUFBO01BQ1JzQixPQUFBNUMsSUFBQXFDLE1BQUFBLENBQUFBLENBQUlPLE9BQUFBLENBQU9SLE9BQVBRO0lBRE5BLENBQUFBLGdDQUFBQTs7QUFJQUcsSUFBQUEscUJBQUFBLGdCQUFBQSxhQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQS9DLElBQUFnRCxTQUFBQSxDQUFRMUIsQ0FBUixFQUFXdEIsSUFBWGdEO0lBREZELENBQUFBLDJCQUFBQTs7QUFJQUUsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEzQjtJQURGMkIsQ0FBQUEsOEJBQUFBO0lBSUEsYUFBTSxXQUFOLEVBQWdCLE1BQWhCOztBQUVBQyxJQUFBQSw0QkFBQUEsMkJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBO0lBREZBLENBQUFBLHNDQUFBQTtJQUlBLGFBQU0sV0FBTixFQUFnQixLQUFoQjtJQUVBLGFBQU0sUUFBTixFQUFhLEdBQWI7O0FBRUFDLElBQUFBLDRCQUFBQSwyQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFBbkQsSUFBQW9ELFVBQUFBLENBQUFBLENBQUEsQ0FBQTtRQUFRRCxPQUFBO01BQVI7UUFBY0EsT0FBQW5EO01BQWQ7SUFERm1ELENBQUFBLHNDQUFBQTs7QUFJQUUsSUFBQUEsNkJBQUFBLHdCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFyRCxJQUFBd0MsTUFBQUEsQ0FBQUEsQ0FBSWEsV0FBQUEsQ0FBQUE7SUFETkEsQ0FBQUEsbUNBQUFBO0lBSUEsYUFBTSxPQUFOLEVBQVksS0FBWjs7QUFFQUMsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQ3RELElBQUE2QixLQUFBQSxDQUFBQSxDQUFELEVBQU03QixJQUFBdUQsS0FBQUEsQ0FBQUEsQ0FBTjtJQURGRCxDQUFBQSwrQkFBQUE7O0FBSUFFLElBQUFBLHVCQUFBQSxrQkFBQUEsZUFBUWxELEtBQVJrRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBdUNiLFdBQXZDYyxvQkFBSUMsZUFBQUEsQ0FBWTFELElBQWhCLEVBQXNCMkQsd0JBQXRCLEVBQWdDLE1BQTVCRCxDQUFtQ2YsRUFBRXJDLEtBQUZxQztJQUR6Q2EsQ0FBQUEsNkJBQUFBOztBQUlBSSxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTVEO0lBREY0RCxDQUFBQSw4QkFBQUE7O0FBSUFDLElBQUFBLHlCQUFBQSx3QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsbUNBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxDQUFDOUQsSUFBRCxFQUFPc0IsQ0FBUDtJQURGd0MsQ0FBQUEsOEJBQUFBO0lBSUEsYUFBTSxhQUFOLEVBQWtCLE1BQWxCOztBQUVBQyxJQUFBQSx5QkFBQUEsb0JBQUFBLGlCQUFVQyxNQUFWRDtBQUFBQSxNQUFBQTs7OztNQUNFQSxPQUFBL0QsSUFBQXFDLE1BQUFBLENBQUFBLENBQUkwQixPQUFBQSxDQUFPQyxNQUFQRDtJQUROQSxDQUFBQSxnQ0FBQUE7O0FBSUFFLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBbkpGLEVBbUpVLEVBbkpWLEVBbUpVLEVBbkpWLEVBbUpFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUE0RTs7TUFuSjlFOztNQUFBOztNQUFBO01BQUE7TUFBQTtNQUFBO01BQUE7O01BbUpXO01BQUE7TUFBQTtNQUFBOztNQUFtQjtNQUFBO01BQUE7TUFBQTs7TUFBa0I7O01BQWU7O0FBRS9EQTtBQUNBQSxRQUFVakUsSUFBQWlCLE9BQUFBLENBQU1FLDZCQUFOLEVBQXFCOEMsbUJBQXJCaEQ7QUFDVmdEOztBQUVBQTtBQUNBQSxRQUFVakUsSUFBQWlCLE9BQUFBLENBQU1FLDZCQUFOLEVBQXFCOEMscUJBQXJCaEQ7QUFDVmdEOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxVQUFZakUsSUFBQWlCLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCK0Msc0JBQWpCaEQ7QUFDWmdEOztBQUVBQSw0QkFBOEJBLElBQUt4QixPQUFBQSxDQUFHbkIsQ0FBSG1CLENBQUt3QjtBQUN4Q0EsVUFBWWpFLElBQUFpQixPQUFBQSxDQUFNRSw2QkFBTixFQUFxQjhDLGlCQUFyQmhEO0FBQ1pnRDs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBLG1CQUFxQkEsSUFBSzdDLFFBQUFBLENBQUlFLENBQUpGLENBQU02Qzs7QUFFaENBO0FBQ0FBLFVBQVlqRSxJQUFBaUIsT0FBQUEsQ0FBTUUsNkJBQU4sRUFBcUIsRUFBQSxHQUFDOEMsMEJBQUQsR0FBQSxDQUEyQkEsSUFBSXpELE9BQUFBLENBQUFBLENBQS9CLENBQXJCUztBQUNaZ0Q7O0FBRUFBO0FBQ0FBLDZCQUErQkMsSUFBQXpELHFCQUFBeUQsYUFBZ0JELEdBQU1DLElBQUF6RCxxQkFBQXlELGFBQUQxQyxPQUFBQSxDQUFBQSxDQUFpQnlDO0FBQ3JFQTs7QUFFQUEsUUFBVVIsb0JBQUlVLFNBQUFBLENBQVNuRSxJQUFiLEVBQW1Cb0UsS0FBZkQ7QUFDZEY7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLCtFQUFpRkksSUFBQTVELHFCQUFBNEQsWUFBZUo7O0FBRWhHQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtNQUVJLElBQXdESyxlQUF4RDtNQUFBO1FBQUEsT0FBT0MsTUFBQXZFLElBQUF1RSxZQUFBQSxFQUFBQSxDQUFTLE1BQVQsRUFBZ0JILEtBQWhCLEVBQXVCSCxJQUF2Qk0sQ0FBQUEsRUFBOEJOLENBQUNBLFFBQURBLENBQURPLFNBQUFBLENBQUFBLENBQTdCRDtNQUFQOztBQUdKTjs7QUFFQUEsbUJBQXFCQSxJQUFJUSxjQUFBQSxDQUFBQSxDQUFXUjtBQUNwQ0Esa0JBQW9CQSxJQUFLeEIsT0FBQUEsQ0FBR25CLENBQUhtQixDQUFLd0I7QUFDOUJBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLHNCQUF3QmpFLElBQUFxQyxNQUFBQSxDQUFBQSxDQUFLNEI7QUFDN0JBLGlCQUFtQkEsSUFBSTVCLE1BQUFBLENBQUFBLENBQU00QjtBQUM3QkEsa0JBQW9CRyxLQUFLL0IsTUFBQUEsQ0FBQUEsQ0FBTTRCOztBQUUvQkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJUyxVQUFVMUU7TUFFVixPQUFBLFFBQU9pRSxTQUFtQlUsT0FBUkQsT0FBUUMsRUFBR1AsS0FBSE8sQ0FBU1YsR0FBYVcsT0FBUkYsT0FBUUUsRUFBR1IsS0FBSFEsQ0FBaEQsQ0FBQTs7UUFDRSxtQkFBTUYsT0FBTjtRQUNBQSxVQUFRRyxTQUFSSCxPQUFRRyxFQUFHWixJQUFIWTtNQUZWO0lBdEpGWixDQUFBQSwrQkFBQUE7O0FBNEpBYSxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTlFLElBQUFnRCxTQUFBQSxDQUFRaEQsSUFBUixFQUFjc0IsQ0FBZDBCO0lBREY4QixDQUFBQSw4QkFBQUE7O0FBSUFDLElBQUFBLDBCQUFBQSxxQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBL0UsSUFBQWdGLE1BQUFBLENBQUFBO0lBREZELENBQUFBLGdDQUFBQTs7QUFJQUUsSUFBQUEsNEJBQUFBLHVCQUFBQSxvQkFBYTdDLE9BQWI2QztBQUFBQSxNQUFBQTs7OztNQUFhO01BQUEsWUFBVTNELENBQVY7TUFBQTtNQUNYMkQsT0FBQWpGLElBQUFxQyxNQUFBQSxDQUFBQSxDQUFJNEMsVUFBQUEsQ0FBVTdDLE9BQVY2QztJQUROQSxDQUFBQSxtQ0FBQUE7O0FBSUE3QixJQUFBQSx5QkFBQUEsd0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBcEQsSUFBS3lDLE9BQUFBLENBQUduQixDQUFIbUI7SUFEUFcsQ0FBQUEsbUNBQUFBOztBQUlBOEIsSUFBQUEsNkJBQUFBLDRCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBS0MsT0FBTG5GLElBQUttRixFQUFFN0QsQ0FBRjZEO0lBRFBELENBQUFBLHVDQUFBQTs7QUFJQVQsSUFBQUEsNkJBQUFBLDRCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBSzNDLE9BQUw5QixJQUFLOEIsRUFBRVIsQ0FBRlE7SUFEUDJDLENBQUFBLHVDQUFBQTs7QUFJQVcsSUFBQUEsdUJBQUFBLGtCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXBGO0lBREZvRixDQUFBQSw2QkFBQUE7O0FBSUFDLElBQUFBLHlCQUFBQSxvQkFBQUEsaUJBM1VGQyxPQTJVRUQ7QUFBQUEsTUFBQUE7Ozs7TUEzVUY7TUFBQTtNQUFBO01BQUE7TUFBQTs7TUEyVVk7TUFBQTtNQUFBLFdBQVE7TUFBUjtNQUNSQSxPQUFBckY7SUFERnFGLENBQUFBLGdDQUFBQTs7QUFJQUUsSUFBQUEsMkJBQUFBLDBCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSxxQ0FBQUE7SUFJQXJGLE9BQUFzRixDQUFBQSw2QkFBQUEsNEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBO0lBREZBLENBQUFBLHVDQUFBQSxDQUFBQTtFQWpWRnRGLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjc5OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYXJyYXkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGZhbHN5LCBoYXNoX2lkcywgeWllbGQxLCBoYXNoX2dldCwgaGFzaF9wdXQsIGhhc2hfZGVsZXRlLCBjb2VyY2VfdG8sIHJlc3BvbmRfdG9cblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBBcnJheSA8IGBBcnJheWBcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgIyBNYXJrIGFsbCBqYXZhc2NyaXB0IGFycmF5cyBhcyBiZWluZyB2YWxpZCBydWJ5IGFycmF5c1xuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcnJheScsIHRydWUpYFxuXG4gICV4e1xuICAgIC8vIFJlY2VudCB2ZXJzaW9ucyBvZiBWOCAoPiA3LjEpIG9ubHkgdXNlIGFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyB1bm1vZGlmaWVkLlxuICAgIC8vIEZvciBpbnN0YW5jZSwgXCJhcnJheS1zcGxpY2UudHFcIiBoYXMgYSBcImZhc3QgcGF0aFwiIChFeHRyYWN0RmFzdEpTQXJyYXksIGRlZmluZWQgaW4gXCJzcmMvY29kZWdlbi9jb2RlLXN0dWItYXNzZW1ibGVyLmNjXCIpXG4gICAgLy8gYnV0IGl0J3Mgb25seSBlbmFibGVkIHdoZW4gXCJJc1Byb3RvdHlwZUluaXRpYWxBcnJheVByb3RvdHlwZSgpXCIgaXMgdHJ1ZS5cbiAgICAvL1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIFY4IHdlcmUgdXNpbmcgcmVsYXRpdmVseSBmYXN0IEpTLXdpdGgtZXh0ZW5zaW9ucyBjb2RlIGV2ZW4gd2hlbiBBcnJheS5wcm90b3R5cGUgaXMgbW9kaWZpZWQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNy4wLjEvc3JjL2pzL2FycmF5LmpzI0w1OTktTDY0MlxuICAgIC8vXG4gICAgLy8gSW4gc2hvcnQsIEFycmF5IG9wZXJhdGlvbnMgYXJlIHNsb3cgaW4gcmVjZW50IHZlcnNpb25zIG9mIFY4IHdoZW4gdGhlIEFycmF5LnByb3RvdHlwZSBoYXMgYmVlbiB0YW1wZXJlZC5cbiAgICAvLyBTbywgd2hlbiBwb3NzaWJsZSwgd2UgYXJlIHVzaW5nIGZhc3RlciBvcGVuLWNvZGVkIHZlcnNpb24gdG8gYm9vc3QgdGhlIHBlcmZvcm1hbmNlLlxuXG4gICAgLy8gQXMgb2YgVjggOC40LCBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIGFycmF5LCB0aGlzIGlzIHVwIHRvIH4yNXggdGltZXMgZmFzdGVyIHRoYW4gQXJyYXkjc2hpZnQoKVxuICAgIC8vIEltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgaW5zcGlyZWQgYnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2JhNjg0ODA1YjZjMGVkZWQ3NmU1Y2Q4OWVlMDAzMjhhYzdhNTkzNjUvbGliL2ludGVybmFsL3V0aWwuanMjTDM0MS1MMzQ3XG4gICAgZnVuY3Rpb24gc2hpZnROb0FyZyhsaXN0KSB7XG4gICAgICB2YXIgciA9IGxpc3RbMF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGxpc3RbaW5kZXggLSAxXSA9IGxpc3RbaW5kZXhdO1xuICAgICAgfVxuICAgICAgbGlzdC5wb3AoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXlTdWJjbGFzcyhvYmosIGtsYXNzKSB7XG4gICAgICBpZiAoa2xhc3MuJCRuYW1lID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2xhc3MuJGFsbG9jYXRlKCkuJHJlcGxhY2UoI3tgb2JqYC50b19hfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSBoZWxwZXIgZm9yIGtlZXBfaWYgYW5kIGRlbGV0ZV9pZiwgZmlsdGVyIGlzIGVpdGhlciBPcGFsLnRydXRoeVxuICAgIC8vIG9yIE9wYWwuZmFsc3kuXG4gICAgZnVuY3Rpb24gZmlsdGVySWYoc2VsZiwgZmlsdGVyLCBibG9jaykge1xuICAgICAgdmFyIHZhbHVlLCByYWlzZWQgPSBudWxsLCB1cGRhdGVkID0gbmV3IEFycmF5KHNlbGYubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGkyID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXJhaXNlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pXG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgcmFpc2VkID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJhaXNlZCB8fCBmaWx0ZXIodmFsdWUpKSB7XG4gICAgICAgICAgdXBkYXRlZFtpMl0gPSBzZWxmW2ldXG4gICAgICAgICAgaTIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaTIgIT09IGkpIHtcbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgWzAsIHVwZGF0ZWQubGVuZ3RoXS5jb25jYXQodXBkYXRlZCkpO1xuICAgICAgICBzZWxmLnNwbGljZShpMiwgdXBkYXRlZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFpc2VkKSB0aHJvdyByYWlzZWQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYuW10oKm9iamVjdHMpXG4gICAgYHRvQXJyYXlTdWJjbGFzcyhvYmplY3RzLCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc2l6ZSA9IG5pbCwgb2JqID0gbmlsLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAob2JqICE9PSBuaWwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA+ICN7SW50ZWdlcjo6TUFYfSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdhcnJheSBzaXplIHRvbyBiaWcnfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMilcIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHNpemUuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2EpfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9IGVsc2UgaWYgKCN7c2l6ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2FyeSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2l6ZSA9ICRjb2VyY2VfdG8oc2l6ZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgdmFsdWU7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGkpO1xuICAgICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8gb2JqLCBBcnJheSwgOnRvX2FyeVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShoYXNoLCBpdGVtKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIHNlbGZbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaC4ka2V5cygpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgcmV0dXJuIGpvaW4ob3RoZXIudG9fc3RyKSBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG5cbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgb3RoZXIgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29udmVydGVkID0gI3t0b19hfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29udmVydGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgYHNlbGYuY29uY2F0KG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgIHJldHVybiBgc2VsZi5zbGljZSgpYCBpZiBgb3RoZXIubGVuZ3RoID09PSAwYFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw8KG9iamVjdClcbiAgICBgc2VsZi5wdXNoKG9iamVjdClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FcbiAgICBlbHNpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXG4gICAgZWxzZVxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICgje2hhc2h9ID09PSAje290aGVyLmhhc2h9KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzZWxmLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0bXAgPSAje2BzZWxmW2ldYCA8PT4gYG90aGVyW2ldYH07XG5cbiAgICAgICAgaWYgKHRtcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YHNlbGYubGVuZ3RoYCA8PT4gYG90aGVyLmxlbmd0aGB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmIChhcnJheSA9PT0gb3RoZXIpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgaWYgKCRyZXNwb25kX3RvKG90aGVyLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgICByZXR1cm4gI3tgb3RoZXJgID09IGBhcnJheWB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycmF5LiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuICAgICAgICBpZiAob3RoZXIuJCRjb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG4gICAgICAgICAgb3RoZXIgPSAje2BvdGhlcmAudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAgPT0gYGJgfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgaW5kZXgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICBmcm9tICAgID0gJGNvZXJjZV90byhpbmRleC5iZWdpbiwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG4gICAgICB0byAgICAgID0gJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gc2l6ZTtcblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9pbmRleF9sZW5ndGgoc2VsZiwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSwgZXh0cmEgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc2l6ZSA9IHNlbGYubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIFJhbmdlID09PSBpbmRleFxuICAgICAgZGF0YSA9IGlmIEFycmF5ID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgIGVsc2lmIHZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgICAgICAgICAgIHZhbHVlLnRvX2FyeS50b19hXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBpbmRleC5leGNsLFxuICAgICAgICAgICAgZnJvbSAgICA9ICRjb2VyY2VfdG8oaW5kZXguYmVnaW4sICN7SW50ZWdlcn0sICd0b19pbnQnKSxcbiAgICAgICAgICAgIHRvICAgICAgPSAkY29lcmNlX3RvKGluZGV4LmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCBcIiN7aW5kZXguaW5zcGVjdH0gb3V0IG9mIHJhbmdlXCJ9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICB0byArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlKSB7XG4gICAgICAgICAgdG8gKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tID4gc2l6ZSkge1xuICAgICAgICAgIGZvciAoaSA9IHNpemU7IGkgPCBmcm9tOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCAwXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCB0byAtIGZyb21dLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaWYgYGV4dHJhID09PSB1bmRlZmluZWRgXG4gICAgICAgIGxlbmd0aCA9IDFcbiAgICAgIGVsc2VcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVcbiAgICAgICAgdmFsdWUgID0gZXh0cmFcblxuICAgICAgICBkYXRhID0gaWYgQXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgIHZhbHVlLnRvX2FcbiAgICAgICAgICAgICAgIGVsc2lmIHZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgICAgICAgICAgICAgdmFsdWUudG9fYXJ5LnRvX2FcbiAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgJXh7XG4gICAgICAgIHZhciBvbGQ7XG5cbiAgICAgICAgaW5kZXggID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBvbGQgICAgPSBpbmRleDtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9sZGB9IHRvbyBzbWFsbCBmb3IgYXJyYXk7IG1pbmltdW0gI3tgLXNlbGYubGVuZ3RoYH1cIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwibmVnYXRpdmUgbGVuZ3RoICgje2xlbmd0aH0pXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgbGVuZ3RoXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgYGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnNlYXJjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoX2luZGV4IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IDAsXG4gICAgICAgICAgbWF4ID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgbWlkLFxuICAgICAgICAgIHZhbCxcbiAgICAgICAgICByZXQsXG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlLFxuICAgICAgICAgIHNhdGlzZmllZCA9IG5pbDtcblxuICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICBtaWQgPSBtaW4gKyBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gMik7XG4gICAgICAgIHZhbCA9IHNlbGZbbWlkXTtcbiAgICAgICAgcmV0ID0gJHlpZWxkMShibG9jaywgdmFsKTtcblxuICAgICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgc2F0aXNmaWVkID0gbWlkO1xuICAgICAgICAgIHNtYWxsZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJldCA9PT0gZmFsc2UgfHwgcmV0ID09PSBuaWwpIHtcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKHJldCA9PT0gMCkgeyByZXR1cm4gbWlkOyB9XG4gICAgICAgICAgc21hbGxlciA9IChyZXQgPCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YHJldGAuY2xhc3N9IChtdXN0IGJlIG51bWVyaWMsIHRydWUsIGZhbHNlIG9yIG5pbClcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbWFsbGVyKSB7IG1heCA9IG1pZDsgfSBlbHNlIHsgbWluID0gbWlkICsgMTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2F0aXNmaWVkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6YnNlYXJjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBpbmRleCA9IGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxuXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleC4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIEZsb2F0OjpJTkZJTklUWVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJldHVybiBpZiBlbXB0eT8gfHwgbiA9PSAwXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBpZiAobiA9PT0gbmlsKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuID0gI3tPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNsZWFyXG4gICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBvYmplY3QgIT09IHVuZGVmaW5lZGAgfHwgYmxvY2tcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2l6ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICAgIHJlcGxhY2Ugb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29sbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGJpbm9taWFsX2NvZWZmaWNpZW50KG4sIGspIHtcbiAgICAgIGlmIChuID09PSBrIHx8IGsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChrID4gMCAmJiBuID4gaykge1xuICAgICAgICByZXR1cm4gYmlub21pYWxfY29lZmZpY2llbnQobiAtIDEsIGsgLSAxKSArIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgZGVmIGNvbWJpbmF0aW9uKG4pXG4gICAgbnVtID0gT3BhbC5jb2VyY2VfdG8hIG4sIEludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KCN7c2VsZn0ubGVuZ3RoLCBudW0pYCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgc3RhY2ssIGNob3NlbiwgbGV2LCBkb25lLCBuZXh0O1xuXG4gICAgICBpZiAobnVtID09PSAwKSB7XG4gICAgICAgICN7eWllbGQgW119XG4gICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3t5aWVsZCBgW3NlbGZbaV1dYH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAje3lpZWxkIGBzZWxmLnNsaWNlKClgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID49IDAgJiYgbnVtIDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2sgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8PSBudW0gKyAxOyBpKyspIHtcbiAgICAgICAgICBzdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hvc2VuID0gW107XG4gICAgICAgIGxldiA9IDA7XG4gICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgc3RhY2tbMF0gPSAtMTtcblxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICBjaG9zZW5bbGV2XSA9IHNlbGZbc3RhY2tbbGV2KzFdXTtcbiAgICAgICAgICB3aGlsZSAobGV2IDwgbnVtIC0gMSkge1xuICAgICAgICAgICAgbGV2Kys7XG4gICAgICAgICAgICBuZXh0ID0gc3RhY2tbbGV2KzFdID0gc3RhY2tbbGV2XSArIDE7XG4gICAgICAgICAgICBjaG9zZW5bbGV2XSA9IHNlbGZbbmV4dF07XG4gICAgICAgICAgfVxuICAgICAgICAgICN7IHlpZWxkIGBjaG9zZW4uc2xpY2UoKWAgfVxuICAgICAgICAgIGxldisrO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRvbmUgPSAobGV2ID09PSAwKTtcbiAgICAgICAgICAgIHN0YWNrW2xldl0rKztcbiAgICAgICAgICAgIGxldi0tO1xuICAgICAgICAgIH0gd2hpbGUgKCBzdGFja1tsZXYrMV0gKyBudW0gPT09IHNlbGYubGVuZ3RoICsgbGV2ICsgMSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX2NvbWJpbmF0aW9uKG4pXG4gICAgbnVtID0gT3BhbC5jb2VyY2VfdG8hIG4sIEludGVnZXIsIDp0b19pbnRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6cmVwZWF0ZWRfY29tYmluYXRpb24sIG51bSkgeyBgYmlub21pYWxfY29lZmZpY2llbnQoc2VsZi5sZW5ndGggKyBudW0gLSAxLCBudW0pYCB9XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUobWF4LCBmcm9tLCBidWZmZXIsIHNlbGYpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbWF4KSB7XG4gICAgICAgICAgdmFyIGNvcHkgPSBidWZmZXIuc2xpY2UoKTtcbiAgICAgICAgICAje3lpZWxkIGBjb3B5YH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goc2VsZltpXSk7XG4gICAgICAgICAgaXRlcmF0ZShtYXgsIGksIGJ1ZmZlciwgc2VsZik7XG4gICAgICAgICAgYnVmZmVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPj0gMCkge1xuICAgICAgICBpdGVyYXRlKG51bSwgMCwgW10sIHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoaXRlbSA9IHNlbGZbaV0pICE9PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3QhXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGZbaV0gPT09IG5pbCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwgPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbmNhdCgqb3RoZXJzKVxuICAgIG90aGVycyA9IG90aGVycy5tYXAgZG8gfG90aGVyfFxuICAgICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgICBlbmRcblxuICAgICAgaWYgb3RoZXIuZXF1YWw/KHNlbGYpXG4gICAgICAgIG90aGVyID0gb3RoZXIuZHVwXG4gICAgICBlbmRcblxuICAgICAgb3RoZXJcbiAgICBlbmRcblxuICAgIG90aGVycy5lYWNoIGRvIHxvdGhlcnxcbiAgICAgICV4e1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzZWxmLnB1c2gob3RoZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkZWxldGUob2JqZWN0KVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvcmlnaW5hbDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCkge1xuICAgICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgICAgcmV0dXJuICN7eWllbGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9hdChpbmRleClcbiAgICAleHtcbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBzZWxmW2luZGV4XTtcblxuICAgICAgc2VsZi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtmaWx0ZXJJZihzZWxmLCAkZmFsc3ksIGJsb2NrKX1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBkaWZmZXJlbmNlKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh0b19hLmR1cCkgeyB8YSwgYnwgYSAtIGIgfVxuICBlbmRcblxuICBkZWYgZGlnKGlkeCwgKmlkeHMpXG4gICAgaXRlbSA9IHNlbGZbaWR4XVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXRlbSA9PT0gbmlsIHx8IGlkeHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVubGVzcyBpdGVtLnJlc3BvbmRfdG8/KDpkaWcpXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiI3tpdGVtLmNsYXNzfSBkb2VzIG5vdCBoYXZlICNkaWcgbWV0aG9kXCJcbiAgICBlbmRcblxuICAgIGl0ZW0uZGlnKCppZHhzKVxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgJXh7XG4gICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKG51bWJlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkFycmF5ICYmXG4gICAgICAgICAgc2VsZi4kJGNsYXNzLiRhbGxvY2F0ZS4kJHByaXN0aW5lICYmXG4gICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGluaXRpYWxpemVfZHVwLiQkcHJpc3RpbmUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZCA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFsKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmICghb3RoZXIuJCRpc19hcnJheSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gI3tvdGhlci50b19hfTtcblxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNlZFsje2BhcnJheWAub2JqZWN0X2lkfV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYSA9IGFycmF5W2ldO1xuICAgICAgICAgIGIgPSBvdGhlcltpXTtcbiAgICAgICAgICBpZiAoYS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICBpZiAoYi4kJGlzX2FycmF5ICYmIGIubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkLmhhc093blByb3BlcnR5KCN7YGFgLm9iamVjdF9pZH0pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgLmVxbD8oYGJgKX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxbChzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmV0Y2goaW5kZXgsIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBpbmRleDtcblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJpbmRleCAje2BvcmlnaW5hbGB9IG91dHNpZGUgb2YgYXJyYXkgYm91bmRzOiAwLi4uMFwifVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJpbmRleCAje2BvcmlnaW5hbGB9IG91dHNpZGUgb2YgYXJyYXkgYm91bmRzOiAtI3tgc2VsZi5sZW5ndGhgfS4uLiN7YHNlbGYubGVuZ3RoYH1cIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmlsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgYmxvY2tcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA+IDJgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDAuLjIpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbHNlXG4gICAgICBpZiBgYXJncy5sZW5ndGggPT0gMGBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJ1xuICAgICAgZWxzaWYgYGFyZ3MubGVuZ3RoID4gM2BcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMS4uMylcIlxuICAgICAgZW5kXG5cbiAgICAgIG9iaiwgb25lLCB0d28gPSBhcmdzXG4gICAgZW5kXG5cbiAgICBpZiBSYW5nZSA9PT0gb25lXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdsZW5ndGggaW52YWxpZCB3aXRoIHJhbmdlJyBpZiB0d29cblxuICAgICAgbGVmdCAgID0gYCRjb2VyY2VfdG8ob25lLmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCIje29uZS5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIiBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIHJpZ2h0ID0gYCRjb2VyY2VfdG8ob25lLmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYHJpZ2h0ICs9IHRoaXMubGVuZ3RoYCBpZiBgcmlnaHQgPCAwYFxuICAgICAgYHJpZ2h0ICs9IDFgIHVubGVzcyBvbmUuZXhjbHVkZV9lbmQ/XG5cbiAgICAgIHJldHVybiBzZWxmIGlmIGByaWdodCA8PSBsZWZ0YFxuICAgIGVsc2lmIG9uZVxuICAgICAgbGVmdCAgID0gYCRjb2VyY2VfdG8ob25lLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgbGVmdCArPSB0aGlzLmxlbmd0aGAgaWYgYGxlZnQgPCAwYFxuICAgICAgbGVmdCAgID0gMCBpZiBgbGVmdCA8IDBgXG5cbiAgICAgIGlmIHR3b1xuICAgICAgICByaWdodCA9IGAkY29lcmNlX3RvKHR3bywgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgIHJldHVybiBzZWxmIGlmIGByaWdodCA9PSAwYFxuXG4gICAgICAgIGByaWdodCArPSBsZWZ0YFxuICAgICAgZWxzZVxuICAgICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGxlZnQgID0gMFxuICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXG4gICAgZW5kXG5cbiAgICBpZiBgbGVmdCA+IHRoaXMubGVuZ3RoYFxuICAgICAgJXh7XG4gICAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoOyBpIDwgcmlnaHQ7IGkrKykge1xuICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGlmIGByaWdodCA+IHRoaXMubGVuZ3RoYFxuICAgICAgYHRoaXMubGVuZ3RoID0gcmlnaHRgXG4gICAgZW5kXG5cbiAgICBpZiBibG9ja1xuICAgICAgJXh7XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGhpcy5sZW5ndGg7IGxlZnQgPCByaWdodDsgbGVmdCsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBibG9jayhsZWZ0KTtcbiAgICAgICAgICBzZWxmW2xlZnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICBzZWxmW2xlZnRdID0gI3tvYmp9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbMF07XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4obGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBfZmxhdHRlbihhcnJheSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuZ3RoLFxuICAgICAgICAgICAgaXRlbSwgYXJ5O1xuXG4gICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGFycmF5W2ldO1xuXG4gICAgICAgICAgaWYgKCEkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScsIHRydWUpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFyeSA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcnkgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChfZmxhdHRlbihhcnkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyeSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfZmxhdHRlbihhcnksIGxldmVsIC0gMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXZlbCA9ICRjb2VyY2VfdG8obGV2ZWwsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mbGF0dGVuKHNlbGYsIGxldmVsKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuIShsZXZlbCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBmbGF0dGVuZWQgPSAje2ZsYXR0ZW4gbGV2ZWx9O1xuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT0gZmxhdHRlbmVkLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWxmW2ldICE9PSBmbGF0dGVuZWRbaV0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID09IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3tyZXBsYWNlIGBmbGF0dGVuZWRgfTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKCRoYXNoX2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0EnXSxcbiAgICAgICAgICBoYXNoX2lkID0gc2VsZi4kb2JqZWN0X2lkKCksXG4gICAgICAgICAgaXRlbSwgaSwga2V5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgJGhhc2hfaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBlYXJseSBmb3IgcmVjdXJzaXZlIHN0cnVjdHVyZXNcbiAgICAgICAgaWYgKCRoYXNoX2lkc1toYXNoX2lkXSkge1xuICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiAkaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gJGhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkaGFzaF9pZHNbaGFzaF9pZF0gPSBzZWxmO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbS4kaGFzaCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignLCcpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICRoYXNoX2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1lbWJlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBtZW1iZXJ9KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6aW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc2VydChpbmRleCwgKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGggKyAxO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgI3sgcmFpc2UgSW5kZXhFcnJvciwgXCIje2luZGV4fSBpcyBvdXQgb2YgYm91bmRzXCIgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5sZW5ndGg7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLnB1c2gobmlsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbaW5kZXgsIDBdLmNvbmNhdChvYmplY3RzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIGlkICAgICA9ICN7X19pZF9ffTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAje3NlbGZbYGlgXX07XG5cbiAgICAgICAgaWYgKCN7YGl0ZW1gLl9faWRfX30gPT09IGlkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ1suLi5dJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tgaXRlbWAuaW5zcGVjdH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnWycgKyByZXN1bHQuam9pbignLCAnKSArICddJztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnRlcnNlY3Rpb24oKmFycmF5cylcbiAgICBhcnJheXMucmVkdWNlKHRvX2EuZHVwKSB7IHxhLCBifCBhICYgYiB9XG4gIGVuZFxuXG4gIGRlZiBqb2luKHNlcCA9IG5pbClcbiAgICByZXR1cm4gJycgaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgaWYgYHNlcCA9PT0gbmlsYFxuICAgICAgc2VwID0gJCxcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGksIGxlbmd0aCwgaXRlbSwgdG1wO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3N0cicpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc3RyfTtcblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC50b19zfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmICh0bXAgPT09IHNlbGYpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLmpvaW4oc2VwKX0pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19zJykpIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19zfTtcblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godG1wKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgI3tyYWlzZSBOb01ldGhvZEVycm9yLm5ldyhcIiN7YE9wYWwuaW5zcGVjdChpdGVtKWB9IGRvZXNuJ3QgcmVzcG9uZCB0byAjdG9fc3RyLCAjdG9fYXJ5IG9yICN0b19zXCIsICd0b19zdHInKX07XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbigje09wYWwuY29lcmNlX3RvIShzZXAsIFN0cmluZywgOnRvX3N0cikudG9fc30pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e2ZpbHRlcklmKHNlbGYsICR0cnV0aHksIGJsb2NrKX1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZltzZWxmLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9ICRjb2VyY2VfdG8oY291bnQsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ307XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIGNvdW50ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIG1hcCBjb2xsZWN0XG5cbiAgYWxpYXMgbWFwISBjb2xsZWN0IVxuXG4gIGRlZiBtYXgobiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGVhY2gubWF4KG4sICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1pbigmYmxvY2spXG4gICAgZWFjaC5taW4oJmJsb2NrKVxuICBlbmRcblxuICAleHtcbiAgICAvLyBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIGZyb20sIGZyb20tMSwgLi4uLCBmcm9tIC0gaG93X21hbnkgKyAxLlxuICAgIGZ1bmN0aW9uIGRlc2NlbmRpbmdfZmFjdG9yaWFsKGZyb20sIGhvd19tYW55KSB7XG4gICAgICB2YXIgY291bnQgPSBob3dfbWFueSA+PSAwID8gMSA6IDA7XG4gICAgICB3aGlsZSAoaG93X21hbnkpIHtcbiAgICAgICAgY291bnQgKj0gZnJvbTtcbiAgICAgICAgZnJvbS0tO1xuICAgICAgICBob3dfbWFueS0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBwZXJtdXRhdGlvbihudW0gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnBlcm11dGF0aW9uLCBudW0pIGRvXG4gICAgICAgIGBkZXNjZW5kaW5nX2ZhY3RvcmlhbChzZWxmLmxlbmd0aCwgbnVtID09PSB1bmRlZmluZWQgPyBzZWxmLmxlbmd0aCA6IG51bSlgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHBlcm11dGUsIG9mZmVuc2l2ZSwgb3V0cHV0O1xuXG4gICAgICBpZiAobnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbnVtID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbnVtID0gJGNvZXJjZV90byhudW0sICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bSA8IDAgfHwgc2VsZi5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgLy8gbm8gcGVybXV0YXRpb25zLCB5aWVsZCBub3RoaW5nXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPT09IDApIHtcbiAgICAgICAgLy8gZXhhY3RseSBvbmUgcGVybXV0YXRpb246IHRoZSB6ZXJvLWxlbmd0aCBhcnJheVxuICAgICAgICAjeyB5aWVsZCBbXSB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwsIGVhc3kgY2FzZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAjeyB5aWVsZCBgW3NlbGZbaV1dYCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBnZW5lcmFsIGNhc2VcbiAgICAgICAgI3sgcGVybSA9IEFycmF5Lm5ldyhudW0pIH07XG4gICAgICAgICN7IHVzZWQgPSBBcnJheS5uZXcoYHNlbGYubGVuZ3RoYCwgZmFsc2UpIH07XG5cbiAgICAgICAgcGVybXV0ZSA9IGZ1bmN0aW9uKG51bSwgcGVybSwgaW5kZXgsIHVzZWQsIGJsaykge1xuICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmKCN7ICF1c2VkW2BpYF0gfSkge1xuICAgICAgICAgICAgICBwZXJtW2luZGV4XSA9IGk7XG4gICAgICAgICAgICAgIGlmKGluZGV4IDwgbnVtIC0gMSkge1xuICAgICAgICAgICAgICAgIHVzZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIGluZGV4ICsgMSwgdXNlZCwgYmxrKTtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwZXJtLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzZWxmW3Blcm1bal1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHlpZWxkMShibGssIG91dHB1dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgICAgLy8gb2ZmZW5zaXZlIChib3RoIGRlZmluaXRpb25zKSBjb3B5LlxuICAgICAgICAgIG9mZmVuc2l2ZSA9IHNlbGYuc2xpY2UoKTtcbiAgICAgICAgICBwZXJtdXRlLmNhbGwob2ZmZW5zaXZlLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCAwLCB1c2VkLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9wZXJtdXRhdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXBlYXRlZF9wZXJtdXRhdGlvbiwgbnVtKSB7IG51bSA+PSAwID8gc2l6ZSoqbnVtIDogMCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZShtYXgsIGJ1ZmZlciwgc2VsZikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBtYXgpIHtcbiAgICAgICAgICB2YXIgY29weSA9IGJ1ZmZlci5zbGljZSgpO1xuICAgICAgICAgICN7eWllbGQgYGNvcHlgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXIucHVzaChzZWxmW2ldKTtcbiAgICAgICAgICBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKTtcbiAgICAgICAgICBidWZmZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZShudW0sIFtdLCBzZWxmLnNsaWNlKCkpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBvcChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcbiAgICAgIHJldHVybiBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgICByZXR1cm4gYHNlbGYucG9wKClgXG4gICAgZW5kXG5cbiAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgaWYgYGNvdW50ID09PSAxYFxuICAgICAgYFtzZWxmLnBvcCgpXWBcbiAgICBlbHNpZiBgY291bnQgPiBzZWxmLmxlbmd0aGBcbiAgICAgIGBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aClgXG4gICAgZWxzZVxuICAgICAgYHNlbGYuc3BsaWNlKHNlbGYubGVuZ3RoIC0gY291bnQsIHNlbGYubGVuZ3RoKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHByb2R1Y3QoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAje2Jsb2NrX2dpdmVuP30gPyBudWxsIDogW10sXG4gICAgICAgICAgbiA9IGFyZ3MubGVuZ3RoICsgMSxcbiAgICAgICAgICBjb3VudGVycyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBsZW5ndGhzICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBhcnJheXMgICA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgICBpLCBtLCBzdWJhcnJheSwgbGVuLCByZXN1bHRsZW4gPSAxO1xuXG4gICAgICBhcnJheXNbMF0gPSBzZWxmO1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBhcnJheXNbaV0gPSAkY29lcmNlX3RvKGFyZ3NbaSAtIDFdLCAje0FycmF5fSwgJ3RvX2FyeScpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxlbiA9IGFycmF5c1tpXS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0bGVuICo9IGxlbjtcbiAgICAgICAgaWYgKHJlc3VsdGxlbiA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsICd0b28gYmlnIHRvIHByb2R1Y3QnfVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aHNbaV0gPSBsZW47XG4gICAgICAgIGNvdW50ZXJzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgb3V0ZXJfbG9vcDogZm9yICg7Oykge1xuICAgICAgICBzdWJhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgc3ViYXJyYXkucHVzaChhcnJheXNbaV1bY291bnRlcnNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3ViYXJyYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7eWllbGQgYHN1YmFycmF5YH1cbiAgICAgICAgfVxuICAgICAgICBtID0gbiAtIDE7XG4gICAgICAgIGNvdW50ZXJzW21dKys7XG4gICAgICAgIHdoaWxlIChjb3VudGVyc1ttXSA9PT0gbGVuZ3Roc1ttXSkge1xuICAgICAgICAgIGNvdW50ZXJzW21dID0gMDtcbiAgICAgICAgICBpZiAoLS1tIDwgMCkgYnJlYWsgb3V0ZXJfbG9vcDtcbiAgICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwdXNoKCpvYmplY3RzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgYXBwZW5kIHB1c2hcblxuICBkZWYgcmFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIGlmIChpdGVtLmxlbmd0aCAmJiBpdGVtWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoI3tgaXRlbVsxXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGZbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgb3JpZ2luYWwgPSBsZW5ndGhcbiAgICBkZWxldGVfaWYoJmJsb2NrKVxuXG4gICAgdW5sZXNzIGxlbmd0aCA9PSBvcmlnaW5hbFxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVwbGFjZShvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgc2VsZi5wdXNoLmFwcGx5KHNlbGYsIG90aGVyKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc2xpY2UoMCkucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZSFcbiAgICBgc2VsZi5yZXZlcnNlKClgXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICByZXZlcnNlLmVhY2goJmJsb2NrKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IGBvYmplY3RgfSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IHNlbGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6cmluZGV4fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3RhdGUobiA9IDEpXG4gICAgJXh7XG4gICAgICB2YXIgYXJ5LCBpZHgsIGZpcnN0UGFydCwgbGFzdFBhcnQ7XG5cbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7SW50ZWdlcn0sICd0b19pbnQnKVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGFyeSA9IHNlbGYuc2xpY2UoKTtcbiAgICAgIGlkeCA9IG4gJSBhcnkubGVuZ3RoO1xuXG4gICAgICBmaXJzdFBhcnQgPSBhcnkuc2xpY2UoaWR4KTtcbiAgICAgIGxhc3RQYXJ0ID0gYXJ5LnNsaWNlKDAsIGlkeCk7XG4gICAgICByZXR1cm4gZmlyc3RQYXJ0LmNvbmNhdChsYXN0UGFydCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcm90YXRlIShjbnQgPSAxKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwIHx8IHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgY250ID0gJGNvZXJjZV90byhjbnQsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG4gICAgYXJ5ID0gcm90YXRlKGNudClcbiAgICByZXBsYWNlIGFyeVxuICBlbmRcblxuICBjbGFzcyBTYW1wbGVSYW5kb21cbiAgICBkZWYgaW5pdGlhbGl6ZShybmcpXG4gICAgICBAcm5nID0gcm5nXG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZChzaXplKVxuICAgICAgcmFuZG9tID0gYCRjb2VyY2VfdG8oI3tAcm5nLnJhbmQoc2l6ZSl9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgPj0gMCcgaWYgYHJhbmRvbSA8IDBgXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCAncmFuZG9tIHZhbHVlIG11c3QgYmUgbGVzcyB0aGFuIEFycmF5IHNpemUnIHVubGVzcyBgcmFuZG9tIDwgc2l6ZWBcblxuICAgICAgcmFuZG9tXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzYW1wbGUoY291bnQgPSB1bmRlZmluZWQsIG9wdGlvbnMgPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGF0IEtlcm5lbC5yYW5kKGBzZWxmLmxlbmd0aGApIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuXG4gICAgaWYgYG9wdGlvbnMgPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIChvID0gT3BhbC5jb2VyY2VfdG8/IGNvdW50LCBIYXNoLCA6dG9faGFzaClcbiAgICAgICAgb3B0aW9ucyA9IG9cbiAgICAgICAgY291bnQgPSBuaWxcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucyA9IG5pbFxuICAgICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBvcHRpb25zID0gYCRjb2VyY2VfdG8ob3B0aW9ucywgI3tIYXNofSwgJ3RvX2hhc2gnKWBcbiAgICBlbmRcblxuICAgIGlmIGNvdW50ICYmIGBjb3VudCA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnY291bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCdcbiAgICBlbmRcblxuICAgIHJuZyA9IG9wdGlvbnNbOnJhbmRvbV0gaWYgb3B0aW9uc1xuICAgIHJuZyA9IGlmIHJuZyAmJiBybmcucmVzcG9uZF90bz8oOnJhbmQpXG4gICAgICAgICAgICBTYW1wbGVSYW5kb20ubmV3IHJuZ1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIEtlcm5lbFxuICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGBzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XWAgdW5sZXNzIGNvdW50XG5cbiAgICAleHtcblxuICAgICAgdmFyIGFiYW5kb24sIHNwaW4sIHJlc3VsdCwgaSwgaiwgaywgdGFyZ2V0SW5kZXgsIG9sZFZhbHVlO1xuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNvdW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gW3NlbGZbI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX1dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGkgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICBqID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIGogPSBpID09PSAwID8gaSArIDEgOiBpIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtzZWxmW2ldLCBzZWxmW2pdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoc2VsZi5sZW5ndGggLyBjb3VudCA+IDMpIHtcbiAgICAgICAgICAgIGFiYW5kb24gPSBmYWxzZTtcbiAgICAgICAgICAgIHNwaW4gPSAwO1xuXG4gICAgICAgICAgICByZXN1bHQgPSAjeyBBcnJheS5uZXcoY291bnQpIH07XG4gICAgICAgICAgICBpID0gMTtcblxuICAgICAgICAgICAgcmVzdWx0WzBdID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGogPCBpKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPT09IHJlc3VsdFtqXSkge1xuICAgICAgICAgICAgICAgICAgc3BpbisrO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwaW4gPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWJhbmRvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgayA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWJhbmRvbikgeyBicmVhazsgfVxuXG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICByZXN1bHRbaV0gPSBrO1xuXG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhYmFuZG9uKSB7XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gc2VsZltyZXN1bHRbaV1dO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICAgICAgICB0YXJnZXRJbmRleCA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgb2xkVmFsdWUgPSByZXN1bHRbY107XG4gICAgICAgICAgICByZXN1bHRbY10gPSByZXN1bHRbdGFyZ2V0SW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0W3RhcmdldEluZGV4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3VudCA9PT0gc2VsZi5sZW5ndGggPyByZXN1bHQgOiAje2ByZXN1bHRgWzAsIGNvdW50XX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuICAgICAgI3sga2VlcF9pZigmYmxvY2spIH07XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGZpbHRlciBzZWxlY3RcbiAgYWxpYXMgZmlsdGVyISBzZWxlY3QhXG5cbiAgZGVmIHNoaWZ0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2hpZnROb0FyZyhzZWxmKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBjb3VudCA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBgc2VsZi5zcGxpY2UoMCwgY291bnQpYFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGRlZiBzaHVmZmxlKHJuZyA9IHVuZGVmaW5lZClcbiAgICBkdXAudG9fYS5zaHVmZmxlIShybmcpXG4gIGVuZFxuXG4gIGRlZiBzaHVmZmxlIShybmcgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgcmFuZGdlbiwgaSA9IHNlbGYubGVuZ3RoLCBqLCB0bXA7XG5cbiAgICAgIGlmIChybmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBybmcgPSAje09wYWwuY29lcmNlX3RvPyhybmcsIEhhc2gsIDp0b19oYXNoKX07XG5cbiAgICAgICAgaWYgKHJuZyAhPT0gbmlsKSB7XG4gICAgICAgICAgcm5nID0gI3tybmdbOnJhbmRvbV19O1xuXG4gICAgICAgICAgaWYgKHJuZyAhPT0gbmlsICYmICN7cm5nLnJlc3BvbmRfdG8/KDpyYW5kKX0pIHtcbiAgICAgICAgICAgIHJhbmRnZW4gPSBybmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGlmIChyYW5kZ2VuKSB7XG4gICAgICAgICAgaiA9IHJhbmRnZW4uJHJhbmQoaSkuJHRvX2ludCgpO1xuXG4gICAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwicmFuZG9tIG51bWJlciB0b28gc21hbGwgI3tgamB9XCJ9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGogPj0gaSkge1xuICAgICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIGJpZyAje2BqYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaiA9ICN7cmFuZChgaWApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcCA9IHNlbGZbLS1pXTtcbiAgICAgICAgc2VsZltpXSA9IHNlbGZbal07XG4gICAgICAgIHNlbGZbal0gPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2xpY2UgW11cblxuICBkZWYgc2xpY2UhKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgcmVzdWx0ID0gbmlsXG5cbiAgICBpZiBgbGVuZ3RoID09PSB1bmRlZmluZWRgXG4gICAgICBpZiBSYW5nZSA9PT0gaW5kZXhcbiAgICAgICAgcmFuZ2UgPSBpbmRleFxuICAgICAgICByZXN1bHQgPSBzZWxmW3JhbmdlXVxuXG4gICAgICAgIHJhbmdlX3N0YXJ0ID0gYCRjb2VyY2VfdG8ocmFuZ2UuYmVnaW4sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgcmFuZ2VfZW5kID0gYCRjb2VyY2VfdG8ocmFuZ2UuZW5kLCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHJhbmdlX3N0YXJ0IDwgMCkge1xuICAgICAgICAgICAgcmFuZ2Vfc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhbmdlX2VuZCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJhbmdlX2VuZCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kID0gc2VsZi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmV4Y2wpIHtcbiAgICAgICAgICAgICAgcmFuZ2VfZW5kICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJhbmdlX2xlbmd0aCA9IHJhbmdlX2VuZCAtIHJhbmdlX3N0YXJ0O1xuICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgLT0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VfbGVuZ3RoICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhbmdlX3N0YXJ0IDwgc2VsZi5sZW5ndGggJiYgcmFuZ2Vfc3RhcnQgPj0gMCAmJiByYW5nZV9lbmQgPCBzZWxmLmxlbmd0aCAmJiByYW5nZV9lbmQgPj0gMCAmJiByYW5nZV9sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLnNwbGljZShyYW5nZV9zdGFydCwgcmFuZ2VfbGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgc3RhcnQgPSBgJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGZbc3RhcnRdO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICBzZWxmLnNoaWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc3BsaWNlKHN0YXJ0LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGxlbmd0aCA9IGAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAleHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgbGVuZ3RoO1xuXG4gICAgICAgIHJlc3VsdCA9ICN7c2VsZltzdGFydCwgbGVuZ3RoXX07XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgIHN0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0ICsgbGVuZ3RoID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgc2VsZi5sZW5ndGggJiYgc3RhcnQgPj0gMCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlKHN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICByZXR1cm4gc2VsZiB1bmxlc3MgYHNlbGYubGVuZ3RoID4gMWBcblxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgYmxvY2sgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuICN7YGFgIDw9PiBgYmB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgpLnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgcmV0ID0gYmxvY2soeCwgeSk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgeGAuaW5zcGVjdH0gd2l0aCAje2B5YC5pbnNwZWN0fSBmYWlsZWRcIn07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3tgcmV0YCA+IDB9ID8gMSA6ICgje2ByZXRgIDwgMH0gPyAtMSA6IDApO1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydCEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICByZXN1bHQgPSAje2BzZWxmLnNsaWNlKClgLnNvcnQoJmJsb2NrKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0fTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5sZW5ndGggPSAwO1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChyZXN1bHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzb3J0X2J5ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgcmVwbGFjZSBzb3J0X2J5KCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRha2UoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIHZhbHVlID0gYmxvY2soaXRlbSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuQXJyYXkuJG5ldyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hcnlcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICBhcnJheSA9IHNlbGZcbiAgICBhcnJheSA9IGFycmF5Lm1hcCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuID0gYXJyYXkubGVuZ3RoLCBhcnksIGtleSwgdmFsLCBoYXNoID0gI3t7fX07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnkgPSAje09wYWwuY29lcmNlX3RvPyhgYXJyYXlbaV1gLCBBcnJheSwgOnRvX2FyeSl9O1xuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IGF0ICN7YGlgfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgYXJyYXkgbGVuZ3RoIGF0ICN7YGlgfSAoZXhwZWN0ZWQgMiwgd2FzICN7YGFyeWAubGVuZ3RofSlcIn1cbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBhcnlbMF07XG4gICAgICAgIHZhbCA9IGFyeVsxXTtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHJhbnNwb3NlXG4gICAgcmV0dXJuIFtdIGlmIGVtcHR5P1xuXG4gICAgcmVzdWx0ID0gW11cbiAgICBtYXggICAgPSBuaWxcblxuICAgIGVhY2ggZG8gfHJvd3xcbiAgICAgIHJvdyA9IGlmIEFycmF5ID09PSByb3dcbiAgICAgICAgICAgICAgcm93LnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ocm93LCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICAgbWF4IHx8PSBgcm93Lmxlbmd0aGBcblxuICAgICAgaWYgYHJvdy5sZW5ndGhgICE9IG1heFxuICAgICAgICByYWlzZSBJbmRleEVycm9yLCBcImVsZW1lbnQgc2l6ZSBkaWZmZXJzICgje2Byb3cubGVuZ3RoYH0gc2hvdWxkIGJlICN7bWF4fSlcIlxuICAgICAgZW5kXG5cbiAgICAgIGByb3cubGVuZ3RoYC50aW1lcyBkbyB8aXxcbiAgICAgICAgZW50cnkgPSAocmVzdWx0W2ldIHx8PSBbXSlcbiAgICAgICAgZW50cnkgPDwgcm93LmF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdW5pb24oKmFycmF5cylcbiAgICBhcnJheXMucmVkdWNlKHVuaXEpIHsgfGEsIGJ8IGEgfCBiIH1cbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBpdGVtLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAga2V5ID0gJHlpZWxkMShibG9jaywgaXRlbSk7XG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tgaGFzaGAudmFsdWVzfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxISgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtLCBrZXk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsX2xlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBrZXkgPSAoYmxvY2sgPT09IG5pbCA/IGl0ZW0gOiAkeWllbGQxKGJsb2NrLCBpdGVtKSk7XG5cbiAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBrZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsX2xlbmd0aCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5zaGlmdCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIHZhciBzZWxmTGVuZ3RoID0gc2VsZi5sZW5ndGhcbiAgICAgIHZhciBvYmplY3RzTGVuZ3RoID0gb2JqZWN0cy5sZW5ndGhcbiAgICAgIGlmIChvYmplY3RzTGVuZ3RoID09IDApIHJldHVybiBzZWxmO1xuICAgICAgdmFyIGluZGV4ID0gc2VsZkxlbmd0aCAtIG9iamVjdHNMZW5ndGhcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChzZWxmW2luZGV4ICsgaV0pXG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gc2VsZkxlbmd0aCAtIDFcbiAgICAgIHdoaWxlIChsZW4gLSBvYmplY3RzTGVuZ3RoID49IDApIHtcbiAgICAgICAgc2VsZltsZW5dID0gc2VsZltsZW4gLSBvYmplY3RzTGVuZ3RoXVxuICAgICAgICBsZW4tLVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3RzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc2VsZltqXSA9IG9iamVjdHNbal1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgcHJlcGVuZCB1bnNoaWZ0XG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICBvdXQgPSBbXVxuXG4gICAgYXJncy5lYWNoIGRvIHxlbGVtfFxuICAgICAgaWYgZWxlbS5pc19hPyBSYW5nZVxuICAgICAgICBmaW5pc2ggPSBgJGNvZXJjZV90bygje2VsZW0ubGFzdH0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgc3RhcnQgPSBgJGNvZXJjZV90bygje2VsZW0uZmlyc3R9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoZmluaXNoIDwgMCkge1xuICAgICAgICAgICAgZmluaXNoID0gZmluaXNoICsgc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgje2VsZW0uZXhjbHVkZV9lbmQ/fSkge1xuICAgICAgICAgICAgZmluaXNoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaW5pc2ggPCBzdGFydCkge1xuICAgICAgICAgICAgI3tuZXh0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydC51cHRvKGZpbmlzaCkgeyB8aXwgb3V0IDw8IGF0KGkpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgaSA9IGAkY29lcmNlX3RvKGVsZW0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgb3V0IDw8IGF0KGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG91dFxuICBlbmRcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgc2l6ZSA9IHNlbGYubGVuZ3RoLCBwYXJ0LCBvLCBpLCBqLCBqajtcblxuICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBvID0gb3RoZXJzW2pdO1xuICAgICAgICBpZiAoby4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uJCRpc19yYW5nZSB8fCBvLiQkaXNfZW51bWVyYXRvcikge1xuICAgICAgICAgIG90aGVyc1tqXSA9IG8uJHRha2Uoc2l6ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJzW2pdID0gI3soXG4gICAgICAgICAgT3BhbC5jb2VyY2VfdG8/KGBvYCwgQXJyYXksIDp0b19hcnkpIHx8XG4gICAgICAgICAgT3BhbC5jb2VyY2VfdG8hKGBvYCwgRW51bWVyYXRvciwgOnRvX2VudW0sIDplYWNoKVxuICAgICAgICApLnRvX2F9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHBhcnQgPSBbc2VsZltpXV07XG5cbiAgICAgICAgZm9yIChqID0gMCwgamogPSBvdGhlcnMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIG8gPSBvdGhlcnNbal1baV07XG5cbiAgICAgICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRbaiArIDFdID0gbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtpXSA9IHBhcnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgcmVzdWx0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgJXh7XG4gICAgICBrbGFzcy4kJHByb3RvdHlwZS4kdG9fYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgc3VwZXIucmVqZWN0IHsgfGl2YXJ8IGAvXkBcXGQrJC8udGVzdCgje2l2YXJ9KWAgfHwgaXZhciA9PSAnQGxlbmd0aCcgfVxuICBlbmRcblxuICBPcGFsLnByaXN0aW5lIHNpbmdsZXRvbl9jbGFzcywgOmFsbG9jYXRlXG4gIE9wYWwucHJpc3RpbmUgc2VsZiwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcblxuICBkZWYgcGFjaygqYXJncylcbiAgICByYWlzZSBcIlRvIHVzZSBBcnJheSNwYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL2FycmF5L3BhY2snLlwiXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOkFycmF5PiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwidG9fYSIsIltdIiwiaW5pdGlhbGl6ZSIsInNpemUiLCJvYmoiLCJ3YXJuIiwiSW50ZWdlcjo6TUFYIiwiSW50ZWdlciIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInJlcGxhY2UiLCJyZXNwb25kX3RvPyIsInRvX2FyeSIsInRyeV9jb252ZXJ0IiwiT3BhbCIsImNvZXJjZV90bz8iLCJBcnJheSIsIiYiLCJvdGhlciIsIj09PSIsInwiLCIqIiwiam9pbiIsInRvX3N0ciIsIisiLCItIiwiPDwiLCJvYmplY3QiLCI8PT4iLCJoYXNoIiwiPT0iLCJvYmplY3RfaWQiLCJpbmRleCIsImxlbmd0aCIsIltdPSIsInZhbHVlIiwiZXh0cmEiLCJSYW5nZSIsImRhdGEiLCJSYW5nZUVycm9yIiwiaW5zcGVjdCIsIjEiLCJJbmRleEVycm9yIiwiYW55PyIsInBhdHRlcm4iLCJhc3NvYyIsImF0IiwiYnNlYXJjaF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiVHlwZUVycm9yIiwiY2xhc3MiLCJic2VhcmNoIiwiYmxvY2siLCJ0b19wcm9jIiwiY3ljbGUiLCJuIiwiYmxvY2sgaW4gY3ljbGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGN5Y2xlIiwibmlsPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwiY29lcmNlX3RvISIsIj4iLCIwIiwiZW51bWVyYXRvcl9zaXplIiwiJHJldF9vcl8xIiwiZW1wdHk/IiwiY2xlYXIiLCJjb3VudCIsIiRyZXRfb3JfMiIsImluaXRpYWxpemVfY29weSIsImNvbGxlY3QiLCJibG9jayBpbiBjb2xsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb2xsZWN0IiwiY29sbGVjdCEiLCJibG9jayBpbiBjb2xsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCEiLCJjb21iaW5hdGlvbiIsIm51bSIsImJsb2NrIGluIGNvbWJpbmF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb21iaW5hdGlvbiIsInJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiYmxvY2sgaW4gcmVwZWF0ZWRfY29tYmluYXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29uY2F0Iiwib3RoZXJzIiwibWFwIiwiYmxvY2sgaW4gY29uY2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb25jYXQiLCJlcXVhbD8iLCJkdXAiLCJlYWNoIiwiZGVsZXRlIiwiZGVsZXRlX2F0IiwiZGVsZXRlX2lmIiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJkaWZmZXJlbmNlIiwicmVkdWNlIiwiYXJyYXlzIiwiYmxvY2sgaW4gZGlmZmVyZW5jZSIsImEiLCJiIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkaWZmZXJlbmNlIiwiZGlnIiwiaWR4IiwiaXRlbSIsImlkeHMiLCJkcm9wIiwibnVtYmVyIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfaW5kZXgiLCJibG9jayBpbiBlYWNoX2luZGV4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2luZGV4IiwiZXFsPyIsImZldGNoIiwiZGVmYXVsdHMiLCJmaWxsIiwiYXJncyIsIm9uZSIsInR3byIsImxlZnQiLCJyaWdodCIsImV4Y2x1ZGVfZW5kPyIsImZpcnN0IiwiZmxhdHRlbiIsImxldmVsIiwiZmxhdHRlbiEiLCJpbmNsdWRlPyIsIm1lbWJlciIsImluc2VydCIsIl9faWRfXyIsImludGVyc2VjdGlvbiIsImJsb2NrIGluIGludGVyc2VjdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gaW50ZXJzZWN0aW9uIiwic2VwIiwiJCwiLCJ0b19zIiwiTm9NZXRob2RFcnJvciIsIm5ldyIsIlN0cmluZyIsImtlZXBfaWYiLCJibG9jayBpbiBrZWVwX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBrZWVwX2lmIiwibGFzdCIsIm1heCIsIm1pbiIsInBlcm11dGF0aW9uIiwiYmxvY2sgaW4gcGVybXV0YXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHBlcm11dGF0aW9uIiwicGVybSIsInVzZWQiLCIhIiwicmVwZWF0ZWRfcGVybXV0YXRpb24iLCJibG9jayBpbiByZXBlYXRlZF9wZXJtdXRhdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gcmVwZWF0ZWRfcGVybXV0YXRpb24iLCI+PSIsIioqIiwicG9wIiwicHJvZHVjdCIsInB1c2giLCJyYXNzb2MiLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwib3JpZ2luYWwiLCJyZXZlcnNlIiwicmV2ZXJzZSEiLCJyZXZlcnNlX2VhY2giLCJibG9jayBpbiByZXZlcnNlX2VhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIHJldmVyc2VfZWFjaCIsInJpbmRleCIsInJvdGF0ZSIsInJvdGF0ZSEiLCJjbnQiLCJhcnkiLCI8Y2xhc3M6U2FtcGxlUmFuZG9tPiIsInJuZyIsIkBybmciLCJyYW5kIiwicmFuZG9tIiwic2FtcGxlIiwib3B0aW9ucyIsIktlcm5lbCIsIm8iLCJIYXNoIiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwiU2FtcGxlUmFuZG9tIiwic2VsZWN0IiwiYmxvY2sgaW4gc2VsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QiLCJzZWxlY3QhIiwiYmxvY2sgaW4gc2VsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0ISIsInNoaWZ0Iiwic2h1ZmZsZSIsInNodWZmbGUhIiwic2xpY2UhIiwicmVzdWx0IiwicmFuZ2UiLCJyYW5nZV9zdGFydCIsInJhbmdlX2VuZCIsInN0YXJ0Iiwic29ydCIsIjwiLCJzb3J0ISIsInNvcnRfYnkhIiwiYmxvY2sgaW4gc29ydF9ieSEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnRfYnkhIiwic29ydF9ieSIsInRha2UiLCJ0YWtlX3doaWxlIiwidG9faCIsImFycmF5IiwidHJhbnNwb3NlIiwiYmxvY2sgaW4gdHJhbnNwb3NlIiwicm93IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc3Bvc2UiLCIkcmV0X29yXzUiLCIhPSIsInRpbWVzIiwiaSIsImJsb2NrICgzIGxldmVscykgaW4gdHJhbnNwb3NlIiwiZW50cnkiLCIkcmV0X29yXzYiLCIkd3JpdGVyIiwidW5pb24iLCJ1bmlxIiwiYmxvY2sgaW4gdW5pb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHVuaW9uIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiYmxvY2sgaW4gdmFsdWVzX2F0IiwiZWxlbSIsImJsb2NrICgyIGxldmVscykgaW4gdmFsdWVzX2F0IiwiaXNfYT8iLCJmaW5pc2giLCJ1cHRvIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJ6aXAiLCIkcmV0X29yXzciLCJFbnVtZXJhdG9yIiwiaW5oZXJpdGVkIiwia2xhc3MiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJibG9jayBpbiBpbnN0YW5jZV92YXJpYWJsZXMiLCJpdmFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbnN0YW5jZV92YXJpYWJsZXMiLCIkcmV0X29yXzgiLCJwcmlzdGluZSIsInNpbmdsZXRvbl9jbGFzcyIsInBhY2siXSwibWFwcGluZ3MiOiJBQUFBQSxnREFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLDBCQUFSRDtJQUdDRDs7QUFHSEE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSwwQ0FBNENBLENBQUNBLEdBQURBLENBQUtHLE1BQUFBLENBQUFBLENBQU1IO0FBQ3ZEQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0lBRUVJLFVBQUlOLElBQUpNLFNBQUFBLGNBQUFBLFNBeEVGLEVBd0VFQTtBQUFBQSxNQUFBQTs7OztNQXhFRjs7TUF3RWM7TUFDVkEsT0FBQ0EsOEJBQURBO0lBREZBLENBQUFB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QSxDQUFkLEVBQStCLFVBQTNCRDtJQUNKdFAsb0JBQUlzUCxVQUFBQSxDQUFVelEsSUFBZCxFQUFvQix5QkFBcEIsRUFBOEMsZ0JBQTFDeVE7SUFFSnZRLE9BQUF5USxDQUFBQSx3QkFBQUEsa0JBQUFBLGdCQTcyRUYsRUE2MkVFQTtBQUFBQSxNQUFBQTs7OztNQTcyRUY7O01BNjJFVztNQUNQQSxPQUFBM1EsSUFBQWEsT0FBQUEsQ0FBTThQLGlFQUFOOVA7SUFERjhQLENBQUFBLDhCQUFBQSxDQUFBQTtFQXgyRUZ6USxHQUFBQSxXQUFBQSxFQUFlSCxLQUFmRztBQUxBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTU4MzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hhc2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG4jIC0tLVxuIyBJbnRlcm5hbCBwcm9wZXJ0aWVzOlxuI1xuIyAtICQkbWFwICAgICAgICAgW0pTOjpPYmplY3Q8U3RyaW5nID0+IGhhc2gtYnVja2V0Pl0gdGhlIGhhc2ggdGFibGUgZm9yIG9yZGluYXJ5IGtleXNcbiMgLSAkJHNtYXAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBzdHJpbmcga2V5c1xuIyAtICQka2V5cyAgICAgICAgW0FycmF5PGhhc2gtYnVja2V0Pl0gdGhlIGxpc3Qgb2YgYWxsIGtleXNcbiMgLSAkJHByb2MgICAgICAgIFtQcm9jLG51bGwsbmlsXSB0aGUgZGVmYXVsdCBwcm9jIHVzZWQgZm9yIG1pc3Npbmcga2V5c1xuIyAtIGhhc2gtYnVja2V0ICAgW0pTOjpPYmplY3RdIGFuIGVsZW1lbnQgb2YgYSBsaW5rZWQgbGlzdCB0aGF0IGhvbGRzIGhhc2ggdmFsdWVzLCBrZXlzIGFyZSBge2tleTosa2V5X2hhc2g6LHZhbHVlOixuZXh0On1gXG5jbGFzcyBIYXNoXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgaGFzaCBpbnN0YW5jZXMgYXMgdmFsaWQgaGFzaGVzICh1c2VkIHRvIGNoZWNrIGtleXdvcmQgYXJncywgZXRjKVxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2hhc2ggPSB0cnVlYFxuXG4gIGRlZiBzZWxmLltdKCphcmd2KVxuICAgICV4e1xuICAgICAgdmFyIGhhc2gsIGFyZ2MgPSBhcmd2Lmxlbmd0aCwgaTtcblxuICAgICAgaWYgKGFyZ2MgPT09IDEpIHtcbiAgICAgICAgaGFzaCA9ICN7T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIGlmIChoYXNoICE9PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gI3thbGxvY2F0ZS5tZXJnZSEoYGhhc2hgKX07XG4gICAgICAgIH1cblxuICAgICAgICBhcmd2ID0gI3tPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKGFyZ3YgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3ZbaV0uJCRpc19hcnJheSkgY29udGludWU7XG4gICAgICAgICAgc3dpdGNoKGFyZ3ZbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgbmlsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIGFyZ3ZbaV1bMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJndltpXS5sZW5ndGhgfSBmb3IgMS4uMilcIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ2MgJSAyICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgIH1cblxuICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSArPSAyKSB7XG4gICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV0sIGFyZ3ZbaSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8ob2JqLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggIT09IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IE9wYWwuaGFzaF9nZXQob3RoZXIsIGtleS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIXZhbHVlWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPCBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPD0gb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmID49IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+IHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShrZXkpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQoa2V5KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIGlmICgje2BrZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCBzZWxmLiQkc21hcFtrZXldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCN7YGtleS5rZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LmtleSwga2V5LnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgICV4e1xuICAgICAgT3BhbC5oYXNoX2luaXQoc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNsYXNzKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICV4e1xuICAgICAgdmFyIGksIGlpLCBrZXksIGtleXMgPSBzZWxmLiQka2V5cywgaWRlbnRpdHlfaGFzaDtcblxuICAgICAgaWYgKHNlbGYuJCRieV9pZGVudGl0eSkgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlkZW50aXR5X2hhc2ggPSAjeyB7fS5jb21wYXJlX2J5X2lkZW50aXR5IH07XG4gICAgICBmb3IoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICgha2V5LiQkaXNfc3RyaW5nKSBrZXkgPSBrZXkua2V5O1xuICAgICAgICBPcGFsLmhhc2hfcHV0KGlkZW50aXR5X2hhc2gsIGtleSwgT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuJCRtYXAgPSBpZGVudGl0eV9oYXNoLiQkbWFwO1xuICAgICAgc2VsZi4kJHNtYXAgPSBpZGVudGl0eV9oYXNoLiQkc21hcDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuJCRwcm9jICE9PSBuaWwgJiYgc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLiQkbm9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJG5vbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxuICAgICV4e1xuICAgICAgc2VsZi4kJHByb2MgPSBuaWw7XG4gICAgICBzZWxmLiQkbm9uZSA9IG9iamVjdDtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jPShkZWZhdWx0X3Byb2MpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcblxuICAgICAgaWYgKHByb2MgIT09IG5pbCkge1xuICAgICAgICBwcm9jID0gI3tPcGFsLmNvZXJjZV90byEoYHByb2NgLCBQcm9jLCA6dG9fcHJvYyl9O1xuXG4gICAgICAgIGlmICgje2Bwcm9jYC5sYW1iZGE/fSAmJiAje2Bwcm9jYC5hcml0eS5hYnN9ICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRub25lID0gbmlsO1xuICAgICAgc2VsZi4kJHByb2MgPSBwcm9jO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdF9wcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShrZXksICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3t5aWVsZCBrZXl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHVwIGNsb25lXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBzZWxmW2tleV1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9rZXkpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlYWNoX3BhaXIgZWFjaFxuXG4gIGRlZiBlYWNoX3ZhbHVlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfdmFsdWUpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBleGNlcHQoKmtleXMpXG4gICAgZHVwLmV4Y2VwdCEoKmtleXMpXG4gIGVuZFxuXG4gIGRlZiBleGNlcHQhKCprZXlzKVxuICAgIGtleXMuZWFjaCB7IHxrZXl8IGRlbGV0ZShrZXkpIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmZXRjaChrZXksIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IE9wYWwuY29lcmNlX3RvIShsZXZlbCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcblxuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCgje2B2YWx1ZWAuZmxhdHRlbihgbGV2ZWwgLSAyYCl9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhrZXkpXG4gICAgYE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYgaGFzX3ZhbHVlPyh2YWx1ZSlcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmICgje2Aoa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSlgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKE9wYWwuaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnSGFzaCddLFxuICAgICAgICAgIGtleSwgaXRlbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9wYWxbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gT3BhbC5oYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSBPcGFsLmhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHNlbGYuJCRzbWFwW2tleV0uJGhhc2goKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LmtleV9oYXNoLCBrZXkudmFsdWUuJGhhc2goKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgpLmpvaW4oKTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XG5cbiAgZGVmIGluZGV4KG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXhlcygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gYXJnc1tpXTtcbiAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2RlZmF1bHR9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluZGljZXMgaW5kZXhlc1xuXG4gIGB2YXIgaW5zcGVjdF9pZHNgXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoaW5zcGVjdF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnNwZWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShoYXNoX2lkKSkge1xuICAgICAgICAgIHJldHVybiAney4uLn0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zcGVjdF9pZHNbaGFzaF9pZF0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LiRpbnNwZWN0KCkgKyAnPT4nICsgdmFsdWUuJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnfSc7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBpbnNwZWN0X2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludmVydFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBrZXkgaW5kZXhcblxuICBhbGlhcyBrZXk/IGhhc19rZXk/XG5cbiAgZGVmIGtleXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi4kJGtleXMubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGhhc19rZXk/XG5cbiAgZGVmIG1lcmdlKCpvdGhlcnMsICZibG9jaylcbiAgICBkdXAubWVyZ2UhKCpvdGhlcnMsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgaiwgb3RoZXIsIG90aGVyX2tleXMsIGxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG90aGVyID0gI3tPcGFsLmNvZXJjZV90byEoYG90aGVyc1tpXWAsIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2soa2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVoYXNoXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfcmVoYXNoKHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfaW5pdChzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgICBzZWxmLmRlZmF1bHRfcHJvYyA9IG90aGVyLmRlZmF1bHRfcHJvY1xuICAgIGVsc2VcbiAgICAgIHNlbGYuZGVmYXVsdCA9IG90aGVyLmRlZmF1bHRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChuaWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9IE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3RvcmUgW109XG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2ggaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuSGFzaCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19oYXNoXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHByb2MgZG8gfGtleSA9IHVuZGVmaW5lZHxcbiAgICAgICV4e1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBrZXkgZ2l2ZW4nfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZba2V5XVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHJhbnNmb3JtX2tleXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBPcGFsLnlpZWxkMShibG9jaywga2V5KTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX2tleXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT3BhbC5zbGljZS5jYWxsKHNlbGYuJCRrZXlzKSxcbiAgICAgICAgICBpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgbmV3X2tleTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3X2tleSA9IE9wYWwueWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBuZXdfa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcyEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdXBkYXRlIG1lcmdlIVxuXG4gIGFsaWFzIHZhbHVlPyBoYXNfdmFsdWU/XG5cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcblxuICBkZWYgdmFsdWVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmLiQkc21hcFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpIYXNoPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiW10iLCJPcGFsIiwiY29lcmNlX3RvPyIsImFyZ3YiLCIwIiwiSGFzaCIsImFsbG9jYXRlIiwibWVyZ2UhIiwiQXJyYXkiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0cnlfY29udmVydCIsIm9iaiIsImluaXRpYWxpemUiLCJkZWZhdWx0cyIsIj09Iiwib3RoZXIiLCI+PSIsImNvZXJjZV90byEiLCJyZXN1bHQiLCJlYWNoIiwiYmxvY2sgaW4gPj0iLCJvdGhlcl9rZXkiLCJvdGhlcl92YWwiLCJibG9jayAoMiBsZXZlbHMpIGluID49IiwidmFsIiwiZmV0Y2giLCI+IiwiPCIsIjw9Iiwia2V5IiwiW109IiwidmFsdWUiLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwiUHJvYyIsImxhbWJkYT8iLCJhcml0eSIsImFicyIsIlR5cGVFcnJvciIsImRlbGV0ZSIsImRlbGV0ZV9pZiIsImJsb2NrIiwiZW51bV9mb3IiLCJibG9jayBpbiBkZWxldGVfaWYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlbGV0ZV9pZiIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJjbGFzcyIsImtleXMiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9rZXkiLCJibG9jayBpbiBlYWNoX2tleSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiYmxvY2sgaW4gZWFjaF92YWx1ZSIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF92YWx1ZSIsImVtcHR5PyIsImV4Y2VwdCIsImV4Y2VwdCEiLCJkdXAiLCJibG9jayBpbiBleGNlcHQhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBleGNlcHQhIiwiS2V5RXJyb3IiLCJuZXciLCJpbnNwZWN0IiwiZmV0Y2hfdmFsdWVzIiwibWFwIiwiYmxvY2sgaW4gZmV0Y2hfdmFsdWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmZXRjaF92YWx1ZXMiLCJ0b19wcm9jIiwiZmxhdHRlbiIsImxldmVsIiwiMSIsIkludGVnZXIiLCJoYXNfa2V5PyIsImhhc192YWx1ZT8iLCJoYXNoIiwiZXFsPyIsImluZGV4IiwiaW5kZXhlcyIsImludmVydCIsImtlZXBfaWYiLCJibG9jayBpbiBrZWVwX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBrZWVwX2lmIiwibGVuZ3RoIiwibWVyZ2UiLCJvdGhlcnMiLCJyYXNzb2MiLCJyZWhhc2giLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJlamVjdCEiLCJibG9jayBpbiByZWplY3QhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QhIiwicmVwbGFjZSIsIiR3cml0ZXIiLCItIiwic2VsZWN0IiwiYmxvY2sgaW4gc2VsZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzZWxlY3QiLCJzZWxlY3QhIiwiYmxvY2sgaW4gc2VsZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0ISIsInNoaWZ0Iiwic2xpY2UiLCJ0b19hIiwidG9faCIsImJsb2NrX2dpdmVuPyIsInRvX2hhc2giLCJwcm9jIiwiYmxvY2sgaW4gdG9fcHJvYyIsImJsb2NrICgyIGxldmVscykgaW4gdG9fcHJvYyIsInRyYW5zZm9ybV9rZXlzIiwiYmxvY2sgaW4gdHJhbnNmb3JtX2tleXMiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV9rZXlzIiwidHJhbnNmb3JtX2tleXMhIiwiYmxvY2sgaW4gdHJhbnNmb3JtX2tleXMhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fa2V5cyEiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwiYmxvY2sgaW4gdHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX3ZhbHVlcyIsInRyYW5zZm9ybV92YWx1ZXMhIiwiYmxvY2sgaW4gdHJhbnNmb3JtX3ZhbHVlcyEiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV92YWx1ZXMhIiwidmFsdWVzIl0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBVUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLDBCQUFSRDtJQUdDRDtJQUVERyxVQUFJTCxJQUFKSyxTQUFBQSxhQUFBQSxTQWhCRixFQWdCRUE7QUFBQUEsTUFBQUE7Ozs7TUFoQkY7O01BZ0JjOztBQUVkQTs7QUFFQUE7QUFDQUEsZUFBaUJDLG9CQUFJQyxlQUFBQSxDQUFZQyxJQUFJSCxPQUFBQSxDQUFDSSxDQUFESixDQUFwQixFQUF5Qkssb0JBQXpCLEVBQStCLFNBQTNCSCxDQUFxQ0Y7QUFDMURBO0FBQ0FBLGlCQUFtQkwsSUFBQVcsVUFBQUEsQ0FBQUEsQ0FBUUMsV0FBQUEsQ0FBU1AsSUFBVE8sQ0FBZ0JQO0FBQzNDQTs7QUFFQUEsZUFBaUJDLG9CQUFJQyxlQUFBQSxDQUFZQyxJQUFJSCxPQUFBQSxDQUFDSSxDQUFESixDQUFwQixFQUF5QlEscUJBQXpCLEVBQWdDLFFBQTVCTixDQUFxQ0Y7QUFDMURBO0FBQ0FBLFVBQVlMLElBQUFjLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCVixrQ0FBckJTO0FBQ1pUOztBQUVBQTtBQUNBQSxlQUFpQkwsSUFBQVcsVUFBQUEsQ0FBQUEsQ0FBU047O0FBRTFCQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxZQUFjTCxJQUFBYyxP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QSxJQUFBQTtBQVZBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MTczNzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL251bWJlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIE51bWJlciA8IE51bWVyaWNcbiAgT3BhbC5icmlkZ2UoYE51bWJlcmAsIHNlbGYpXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX251bWJlcicsIHRydWUpYFxuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje290aGVyLmNsYXNzfSBpbnRvIEZsb2F0XCJ9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFsje0Zsb2F0KG90aGVyKX0sIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyg6dG9fZil9KSB7XG4gICAgICAgIHJldHVybiBbI3tPcGFsLmNvZXJjZV90byEob3RoZXIsIEZsb2F0LCA6dG9fZil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBbb3RoZXIsIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBfX2lkX19cbiAgICBgKHNlbGYgKiAyKSArIDFgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgKyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiArIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDorLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAtIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDotLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAqIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDoqLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAvIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDovLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmZGl2IC9cblxuICBkZWYgJShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyID09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPCAwIHx8IHNlbGYgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIChzZWxmICUgb3RoZXIgKyBvdGhlcikgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZiAlIG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiUsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICYgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiYsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIHwgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOnwsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIF4gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOl4sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIDwgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjwsIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmID4gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj4sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Pj0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gICMgQ29tcHV0ZSB0aGUgcmVzdWx0IG9mIHRoZSBzcGFjZXNoaXAgb3BlcmF0b3IgaW5zaWRlIGl0cyBvd24gZnVuY3Rpb24gc28gaXRcbiAgIyBjYW4gYmUgb3B0aW1pemVkIGRlc3BpdGUgYSB0cnkvZmluYWxseSBjb25zdHJ1Y3QuXG4gICV4e1xuICAgIHZhciBzcGFjZXNoaXBfb3BlcmF0b3IgPSBmdW5jdGlvbihzZWxmLCBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChpc05hTihzZWxmKSB8fCBpc05hTihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYgPiBvdGhlcikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYgPCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PT4sIGBvdGhlcmB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgYHNwYWNlc2hpcF9vcGVyYXRvcihzZWxmLCBvdGhlcilgXG4gIHJlc2N1ZSBBcmd1bWVudEVycm9yXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiA8PChjb3VudClcbiAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvISBjb3VudCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPDwgI3tjb3VudH0gOiBzZWxmID4+IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmID4+KGNvdW50KVxuICAgIGNvdW50ID0gT3BhbC5jb2VyY2VfdG8hIGNvdW50LCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBgI3tjb3VudH0gPiAwID8gc2VsZiA+PiAje2NvdW50fSA6IHNlbGYgPDwgLSN7Y291bnR9YFxuICBlbmRcblxuICBkZWYgW10oYml0KVxuICAgIGJpdCA9IE9wYWwuY29lcmNlX3RvISBiaXQsIEludGVnZXIsIDp0b19pbnRcblxuICAgICV4e1xuICAgICAgaWYgKCN7Yml0fSA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoI3tiaXR9ID49IDMyKSB7XG4gICAgICAgIHJldHVybiAjeyBzZWxmIH0gPCAwID8gMSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHNlbGYgPj4gI3tiaXR9KSAmIDE7XG4gICAgfVxuICBlbmRcblxuICBkZWYgK0BcbiAgICBgK3NlbGZgXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIGAtc2VsZmBcbiAgZW5kXG5cbiAgZGVmIH5cbiAgICBgfnNlbGZgXG4gIGVuZFxuXG4gIGRlZiAqKihvdGhlcilcbiAgICBpZiBJbnRlZ2VyID09PSBvdGhlclxuICAgICAgaWYgIShJbnRlZ2VyID09PSBzZWxmKSB8fCBvdGhlciA+IDBcbiAgICAgICAgYE1hdGgucG93KHNlbGYsIG90aGVyKWBcbiAgICAgIGVsc2VcbiAgICAgICAgUmF0aW9uYWwubmV3KHNlbGYsIDEpKipvdGhlclxuICAgICAgZW5kXG4gICAgZWxzaWYgc2VsZiA8IDAgJiYgKEZsb2F0ID09PSBvdGhlciB8fCBSYXRpb25hbCA9PT0gb3RoZXIpXG4gICAgICBDb21wbGV4Lm5ldyhzZWxmLCAwKSoqb3RoZXIudG9fZlxuICAgIGVsc2lmIGBvdGhlci4kJGlzX251bWJlciAhPSBudWxsYFxuICAgICAgYE1hdGgucG93KHNlbGYsIG90aGVyKWBcbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/IDo9PX0pIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBgTWF0aC5hYnMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgYE1hdGguYWJzKHNlbGYgKiBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFsbGJpdHM/KG1hc2spXG4gICAgbWFzayA9IE9wYWwuY29lcmNlX3RvISBtYXNrLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gbWFza2BcbiAgZW5kXG5cbiAgZGVmIGFueWJpdHM/KG1hc2spXG4gICAgbWFzayA9IE9wYWwuY29lcmNlX3RvISBtYXNrLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgIT09IDBgXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIHJldHVybiBzZWxmIGlmIG5hbj9cblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCkge1xuICAgICAgICBpZiAoMSAvIHNlbGYgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG4gIGFsaWFzIHBoYXNlIGFuZ2xlXG5cbiAgZGVmIGJpdF9sZW5ndGhcbiAgICB1bmxlc3MgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBiaXRfbGVuZ3RoYCBmb3IgI3tzZWxmfTpGbG9hdFwiLCAnYml0X2xlbmd0aCcpXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSAwIHx8IHNlbGYgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gMCxcbiAgICAgICAgICB2YWx1ZSAgPSBzZWxmIDwgMCA/IH5zZWxmIDogc2VsZjtcblxuICAgICAgd2hpbGUgKHZhbHVlICE9IDApIHtcbiAgICAgICAgcmVzdWx0ICAgKz0gMTtcbiAgICAgICAgdmFsdWUgID4+Pj0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZWlsKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguY2VpbChmICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaHIoZW5jb2RpbmcgPSB1bmRlZmluZWQpXG4gICAgYE9wYWwuZW5jKFN0cmluZy5mcm9tQ2hhckNvZGUoc2VsZiksIGVuY29kaW5nIHx8IFwiQklOQVJZXCIpYFxuICBlbmRcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgMVxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBkb3dudG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZG93bnRvLCBzdG9wKSBkb1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIE51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA+IHNlbGYgPyAwIDogc2VsZiAtIHN0b3AgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPj0gc3RvcDsgaS0tKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBlcXVhbD8ob3RoZXIpXG4gICAgc2VsZiA9PSBvdGhlciB8fCBgaXNOYU4oc2VsZikgJiYgaXNOYU4ob3RoZXIpYFxuICBlbmRcblxuICBkZWYgZXZlbj9cbiAgICBgc2VsZiAlIDIgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBmbG9vcihuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmZsb29yKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZChvdGhlcilcbiAgICB1bmxlc3MgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gTWF0aC5hYnMoc2VsZiksXG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMob3RoZXIpO1xuXG4gICAgICB3aGlsZSAobWluID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gbWluO1xuXG4gICAgICAgIG1pbiA9IG1heCAlIG1pbjtcbiAgICAgICAgbWF4ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdjZGxjbShvdGhlcilcbiAgICBbZ2NkKG90aGVyKSwgbGNtKG90aGVyKV1cbiAgZW5kXG5cbiAgZGVmIGludGVnZXI/XG4gICAgYHNlbGYgJSAxID09PSAwYFxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gRmxvYXQgJiYgRmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBGbG9hdCAmJiBGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGxjbShvdGhlcilcbiAgICB1bmxlc3MgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ25vdCBhbiBpbnRlZ2VyJ1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwIHx8IG90aGVyID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHNlbGYgKiBvdGhlciAvICN7Z2NkKG90aGVyKX0pO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIGFsaWFzIG1vZHVsbyAlXG5cbiAgZGVmIG5leHRcbiAgICBgc2VsZiArIDFgXG4gIGVuZFxuXG4gIGRlZiBub2JpdHM/KG1hc2spXG4gICAgbWFzayA9IE9wYWwuY29lcmNlX3RvISBtYXNrLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgYChzZWxmICYgbWFzaykgPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgYHNlbGYgPT0gMCA/IG5pbCA6IHNlbGZgXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBvZGQ/XG4gICAgYHNlbGYgJSAyICE9PSAwYFxuICBlbmRcblxuICBkZWYgb3JkXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG93KGIsIG0gPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfVxuICAgICAgfVxuXG4gICAgICBpZiAobSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAje3NlbGYqKmJ9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoI3tJbnRlZ2VyID09PSBifSkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhIDFzdCBhcmd1bWVudCBpcyBpbnRlZ2VyJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAxc3QgYXJndW1lbnQgY2Fubm90IGJlIG5lZ2F0aXZlIHdoZW4gMm5kIGFyZ3VtZW50IHNwZWNpZmllZCd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgje0ludGVnZXIgPT09IG19KSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3soc2VsZioqYikgJSBtfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZWRcbiAgICBgc2VsZiAtIDFgXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzZWxmIC8gb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICBlbHNpZiBuYW4/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGBlcHMgPT0gbnVsbGBcbiAgICAgIGYsIG4gID0gTWF0aC5mcmV4cCBzZWxmXG4gICAgICBmICAgICA9IE1hdGgubGRleHAoZiwgRmxvYXQ6Ok1BTlRfRElHKS50b19pXG4gICAgICBuICAgIC09IEZsb2F0OjpNQU5UX0RJR1xuXG4gICAgICBSYXRpb25hbC5uZXcoMiAqIGYsIDEgPDwgKDEgLSBuKSkucmF0aW9uYWxpemUoUmF0aW9uYWwubmV3KDEsIDEgPDwgKDEgLSBuKSkpXG4gICAgZWxzZVxuICAgICAgdG9fci5yYXRpb25hbGl6ZShlcHMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZW1haW5kZXIoeSlcbiAgICBzZWxmIC0geSAqIChzZWxmIC8geSkudHJ1bmNhdGVcbiAgZW5kXG5cbiAgZGVmIHJvdW5kKG5kaWdpdHMgPSB1bmRlZmluZWQpXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgaWYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiBGbG9hdCA9PT0gbmRpZ2l0cyAmJiBuZGlnaXRzLmluZmluaXRlP1xuICAgICAgICByYWlzZSBSYW5nZUVycm9yLCAnSW5maW5pdHknXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IE9wYWwuY29lcmNlX3RvIShuZGlnaXRzLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDwgSW50ZWdlcjo6TUlOXG4gICAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdvdXQgb2YgYm91bmRzJ1xuICAgICAgZW5kXG5cbiAgICAgIGlmIGBuZGlnaXRzID49IDBgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IC1uZGlnaXRzXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAoMC40MTUyNDEgKiBuZGlnaXRzIC0gMC4xMjUgPiAje3NpemV9KSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKChNYXRoLmFicyhzZWxmKSArIGYgLyAyKSAvIGYpICogZjtcblxuICAgICAgICByZXR1cm4gc2VsZiA8IDAgPyAteCA6IHg7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaWYgbmFuPyAmJiBgbmRpZ2l0cyA9PSBudWxsYFxuICAgICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSBPcGFsLmNvZXJjZV90byEoYG5kaWdpdHMgfHwgMGAsIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPD0gMFxuICAgICAgICBpZiBuYW4/XG4gICAgICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ05hTidcbiAgICAgICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIG5kaWdpdHMgPT0gMFxuICAgICAgICByZXR1cm4gYE1hdGgucm91bmQoc2VsZilgXG4gICAgICBlbHNpZiBuYW4/IHx8IGluZmluaXRlP1xuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIF8sIGV4cCA9IE1hdGguZnJleHAoc2VsZilcblxuICAgICAgaWYgbmRpZ2l0cyA+PSAoRmxvYXQ6OkRJRyArIDIpIC0gKGV4cCA+IDAgPyBleHAgLyA0IDogZXhwIC8gMyAtIDEpXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgbmRpZ2l0cyA8IC0oZXhwID4gMCA/IGV4cCAvIDMgKyAxIDogZXhwIC8gNClcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIGVuZFxuXG4gICAgICBgTWF0aC5yb3VuZChzZWxmICogTWF0aC5wb3coMTAsIG5kaWdpdHMpKSAvIE1hdGgucG93KDEwLCBuZGlnaXRzKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgc3VjYyBuZXh0XG5cbiAgZGVmIHRpbWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRpbWVzKSB7IHNlbGYgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICBgc2VsZiA8IDAgPyBNYXRoLmNlaWwoc2VsZikgOiBNYXRoLmZsb29yKHNlbGYpYFxuICBlbmRcblxuICBhbGlhcyB0b19pbnQgdG9faVxuXG4gIGRlZiB0b19yXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgUmF0aW9uYWwubmV3KHNlbGYsIDEpXG4gICAgZWxzZVxuICAgICAgZiwgZSAgPSBNYXRoLmZyZXhwKHNlbGYpXG4gICAgICBmICAgICA9IE1hdGgubGRleHAoZiwgRmxvYXQ6Ok1BTlRfRElHKS50b19pXG4gICAgICBlICAgIC09IEZsb2F0OjpNQU5UX0RJR1xuXG4gICAgICAoZiAqIChGbG9hdDo6UkFESVgqKmUpKS50b19yXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19zKGJhc2UgPSAxMClcbiAgICBiYXNlID0gT3BhbC5jb2VyY2VfdG8hIGJhc2UsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGJhc2UgPCAyIHx8IGJhc2UgPiAzNlxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIlxuICAgIGVuZFxuXG4gICAgIyBEb24ndCBsb3NlIHRoZSBuZWdhdGl2ZSB6ZXJvXG4gICAgaWYgc2VsZiA9PSAwICYmIGAxL3NlbGYgPT09IC1JbmZpbml0eWBcbiAgICAgIHJldHVybiAnLTAuMCdcbiAgICBlbmRcblxuICAgIGBzZWxmLnRvU3RyaW5nKGJhc2UpYFxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoZiAqIGZhY3RvciwgMTApIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5cbiAgZGVmIGRpZ2l0cyhiYXNlID0gMTApXG4gICAgaWYgc2VsZiA8IDBcbiAgICAgIHJhaXNlIE1hdGg6OkRvbWFpbkVycm9yLCAnb3V0IG9mIGRvbWFpbidcbiAgICBlbmRcblxuICAgIGJhc2UgPSBPcGFsLmNvZXJjZV90byEgYmFzZSwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDJcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgIT0gcGFyc2VJbnQoc2VsZikpICN7cmFpc2UgTm9NZXRob2RFcnJvciwgXCJ1bmRlZmluZWQgbWV0aG9kIGBkaWdpdHMnIGZvciAje2luc3BlY3R9XCJ9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYsIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIHJldHVybiBbMF07XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlICUgYmFzZSk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUgLyBiYXNlLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIGlmIG5hbj8gfHwgb3RoZXIubmFuP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdXB0byhzdG9wLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDp1cHRvLCBzdG9wKSBkb1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCIgdW5sZXNzIE51bWVyaWMgPT09IHN0b3BcbiAgICAgICAgc3RvcCA8IHNlbGYgPyAwIDogc3RvcCAtIHNlbGYgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFzdG9wLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwifVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHNlbGY7IGkgPD0gc3RvcDsgaSsrKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHplcm8/XG4gICAgYHNlbGYgPT0gMGBcbiAgZW5kXG5cbiAgIyBTaW5jZSBiaXR3aXNlIG9wZXJhdGlvbnMgYXJlIDMyIGJpdCwgZGVjbGFyZSBpdCB0byBiZSBzby5cbiAgZGVmIHNpemVcbiAgICA0XG4gIGVuZFxuXG4gIGRlZiBuYW4/XG4gICAgYGlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIGBzZWxmICE9IEluZmluaXR5ICYmIHNlbGYgIT0gLUluZmluaXR5ICYmICFpc05hTihzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuICsxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZiA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgYHNlbGYgIT0gMCAmJiAoc2VsZiA9PSBJbmZpbml0eSB8fCAxIC8gc2VsZiA+IDApYFxuICBlbmRcblxuICBkZWYgbmVnYXRpdmU/XG4gICAgYHNlbGYgPT0gLUluZmluaXR5IHx8IDEgLyBzZWxmIDwgMGBcbiAgZW5kXG5lbmRcblxuRml4bnVtID0gTnVtYmVyXG5cbmNsYXNzIEludGVnZXIgPCBOdW1lcmljXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcbiAgYHNlbGYuJCRpc19pbnRlZ2VyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG5cbiAgICBkZWYgc3FydChuKVxuICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgJXh7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgTWF0aDo6RG9tYWluRXJyb3IsICdOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFwiaXNxcnRcIid9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoTWF0aC5zcXJ0KG4pLCAxMCk7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIE1BWCA9IGBNYXRoLnBvdygyLCAzMCkgLSAxYFxuICBNSU4gPSBgLU1hdGgucG93KDIsIDMwKWBcbmVuZFxuXG5jbGFzcyBGbG9hdCA8IE51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiA9PT0ob3RoZXIpXG4gICAgICBgISFvdGhlci4kJGlzX251bWJlcmBcbiAgICBlbmRcbiAgZW5kXG5cbiAgSU5GSU5JVFkgPSBgSW5maW5pdHlgXG4gIE1BWCAgICAgID0gYE51bWJlci5NQVhfVkFMVUVgXG4gIE1JTiAgICAgID0gYE51bWJlci5NSU5fVkFMVUVgXG4gIE5BTiAgICAgID0gYE5hTmBcblxuICBESUcgICAgICA9IDE1XG4gIE1BTlRfRElHID0gNTNcbiAgUkFESVggICAgPSAyXG5cbiAgRVBTSUxPTiA9IGBOdW1iZXIuRVBTSUxPTiB8fCAyLjIyMDQ0NjA0OTI1MDMxMzA4MDg0NzI2MzMzNjE4MTZFLTE2YFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOk51bWJlcj4iLCJPcGFsIiwiYnJpZGdlIiwiYWxsb2NhdGUiLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsImNsYXNzIiwiRmxvYXQiLCJyZXNwb25kX3RvPyIsImNvZXJjZV90byEiLCJfX2lkX18iLCIrIiwiX19jb2VyY2VkX18iLCItIiwiKiIsIi8iLCIlIiwiWmVyb0RpdmlzaW9uRXJyb3IiLCImIiwifCIsIl4iLCI8IiwiPD0iLCI+IiwiPj0iLCI8PT4iLCJBcmd1bWVudEVycm9yIiwiPDwiLCJjb3VudCIsIkludGVnZXIiLCI+PiIsIltdIiwiYml0IiwiK0AiLCItQCIsIn4iLCIqKiIsIj09PSIsIiRyZXRfb3JfMSIsIiEiLCIwIiwiUmF0aW9uYWwiLCJuZXciLCIxIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiQ29tcGxleCIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJOb01ldGhvZEVycm9yIiwiY2VpbCIsIm5kaWdpdHMiLCJjaHIiLCJlbmNvZGluZyIsImRlbm9taW5hdG9yIiwiJHJldF9vcl80IiwiaW5maW5pdGU/IiwiZG93bnRvIiwic3RvcCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZG93bnRvIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkb3dudG8iLCJOdW1lcmljIiwiZXF1YWw/IiwiJHJldF9vcl81IiwiZXZlbj8iLCJmbG9vciIsImdjZCIsImdjZGxjbSIsImxjbSIsImludGVnZXI/IiwiaXNfYT8iLCJrbGFzcyIsIiRyZXRfb3JfNiIsIiRyZXRfb3JfNyIsIiRyZXRfb3JfOCIsImluc3RhbmNlX29mPyIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCIkcmV0X29yXzExIiwibmV4dCIsIm5vYml0cz8iLCJub256ZXJvPyIsIm51bWVyYXRvciIsIiRyZXRfb3JfMTIiLCJvZGQ/Iiwib3JkIiwicG93IiwiYiIsIm0iLCJwcmVkIiwicXVvIiwicmF0aW9uYWxpemUiLCJlcHMiLCJGbG9hdERvbWFpbkVycm9yIiwiTWF0aCIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsIkZsb2F0OjpNQU5UX0RJRyIsInRvX2kiLCIyIiwidG9fciIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiJHJldF9vcl8xMyIsIlJhbmdlRXJyb3IiLCJJbnRlZ2VyOjpNSU4iLCJzaXplIiwiJHJldF9vcl8xNCIsIiRyZXRfb3JfMTUiLCJfIiwiZXhwIiwiRmxvYXQ6OkRJRyIsIjQiLCIzIiwidGltZXMiLCJibG9jayIsImJsb2NrIGluIHRpbWVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0aW1lcyIsImUiLCJGbG9hdDo6UkFESVgiLCJ0b19zIiwiYmFzZSIsIjEwIiwiJHJldF9vcl8xNiIsIjM2IiwiJHJldF9vcl8xNyIsImRpZ2l0cyIsIk1hdGg6OkRvbWFpbkVycm9yIiwiaW5zcGVjdCIsImRpdm1vZCIsIiRyZXRfb3JfMTgiLCJ1cHRvIiwiYmxvY2sgaW4gdXB0byIsImJsb2NrICgyIGxldmVscykgaW4gdXB0byIsInplcm8/IiwiZmluaXRlPyIsInBvc2l0aXZlPyIsIm5lZ2F0aXZlPyIsIk51bWJlciIsIjxjbGFzczpJbnRlZ2VyPiIsInNxcnQiLCI8Y2xhc3M6RmxvYXQ+Iiwi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QUFFQUE7QUFDQUE7TUFSSUEsQ0FBQUEsc0JBQUFBLENBQUFBO0lBUEYsNEJBQVMvSixJQUFUO0lBbUJBLG1DQUFPOEosbUJBQVA7SUFDQUEsT0FBQSxtQ0FBT0EsZ0JBQVA7RUF4QkZBLEdBQUFBLFdBQUFBLEVBQWdCbEYsdUJBQWhCa0Y7RUEyQkEvSixPQUFBaUs7RUFBQUE7O0lBQUFBOzs7SUFDR0E7SUFFRDtNQUFBOzs7O0FBQ0UzSixNQUFBQSw0QkFBQUEsZUFBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBTCxJQUFBTSxPQUFBQSxDQUFNQyx5QkFBTixFQUFpQixFQUFBLEdBQUNGLDBCQUFELEdBQUEsQ0FBMkJMLElBQUFRLE1BQUFBLENBQUFBLENBQTNCLENBQWpCRjtNQURGRCxDQUFBQSwwQkFBQUE7O01BSUEsc0JBQU0sS0FBTjtNQUVBLE9BQUFxQyxDQUFBQSx1QkFBQUEsZUFBQUEsU0FBUWhDLEtBQVJnQztBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQ0EsbUJBQURBO01BREZBLENBQUFBLDBCQUFBQSxDQUFBQTtJQVBGLDRCQUFTMUMsSUFBVDtJQVlBLHdDQUFZZ0ssUUFBWjtJQUNBLG1DQUFZQSxnQkFBWjtJQUNBLG1DQUFZQSxnQkFBWjtJQUNBLG1DQUFZQSxHQUFaO0lBRUEsbUNBQVdDLEVBQVg7SUFDQSx3Q0FBV0MsRUFBWDtJQUNBLHFDQUFXOUMsQ0FBWDtJQUVBNEMsT0FBQSx1Q0FBV0EsdURBQVg7RUF4QkZBLEdBQUFBLFdBQUFBLEVBQWNwRix1QkFBZG9GO0FBdDJCQWpLOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODU5MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBSYW5nZVxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX3JhbmdlID0gdHJ1ZWBcblxuICBhdHRyX3JlYWRlciA6YmVnaW4sIDplbmRcblxuICBkZWYgaW5pdGlhbGl6ZShmaXJzdCwgbGFzdCwgZXhjbHVkZSA9IGZhbHNlKVxuICAgIHJhaXNlIE5hbWVFcnJvciwgXCInaW5pdGlhbGl6ZScgY2FsbGVkIHR3aWNlXCIgaWYgQGJlZ2luXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JhZCB2YWx1ZSBmb3IgcmFuZ2UnIHVubGVzcyBmaXJzdCA8PT4gbGFzdCB8fCBmaXJzdC5uaWw/IHx8IGxhc3QubmlsP1xuXG4gICAgQGJlZ2luID0gZmlyc3RcbiAgICBAZW5kICAgPSBsYXN0XG4gICAgQGV4Y2wgID0gZXhjbHVkZVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGlzX2luZmluaXRlKHNlbGYpIHtcbiAgICAgIGlmIChzZWxmLmJlZ2luID09PSBuaWwgfHwgc2VsZi5lbmQgPT09IG5pbCB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IC1JbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICBzZWxmLmJlZ2luID09PSBJbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gLUluZmluaXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWYgY291bnQoJmJsb2NrKVxuICAgIGlmICFibG9ja19naXZlbj8gJiYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgICAgcmV0dXJuIEZsb2F0OjpJTkZJTklUWVxuICAgIGVuZFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgcmFpc2UgVHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgZW5kbGVzcyByYW5nZSB0byBhbiBhcnJheScgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4ubmlsPyAmJiAtMSkgfHwgKEBiZWdpbiA8PT4gdmFsdWUpIHx8IGZhbHNlXG4gICAgZW5kX2NtcCA9IChAZW5kLm5pbD8gJiYgLTEpIHx8ICh2YWx1ZSA8PT4gQGVuZCkgfHwgZmFsc2VcbiAgICBpZiBAZXhjbFxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDwgMFxuICAgIGVsc2VcbiAgICAgIGVuZF9jbXAgJiYgZW5kX2NtcCA8PSAwXG4gICAgZW5kICYmIGJlZ19jbXAgJiYgYmVnX2NtcCA8PSAwXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxpbWl0O1xuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfbnVtYmVyICYmICN7QGVuZH0uJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufSAlIDEgIT09IDAgfHwgI3tAZW5kfSAlIDEgIT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gRmxvYXRcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9ICN7QGJlZ2lufSwgbGltaXQgPSAje0BlbmR9ICsgI3tAZXhjbCA/IDAgOiAxfTsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICBibG9jayhpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tAYmVnaW4udXB0byhAZW5kLCBAZXhjbCwgJmJsb2NrKX1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudCA9IEBiZWdpblxuICAgIGxhc3QgICAgPSBAZW5kXG5cbiAgICB1bmxlc3MgY3VycmVudC5yZXNwb25kX3RvPyg6c3VjYylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gI3tjdXJyZW50LmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICB3aGlsZSBAZW5kLm5pbD8gfHwgKGN1cnJlbnQgPD0+IGxhc3QpIDwgMFxuICAgICAgeWllbGQgY3VycmVudFxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5zdWNjXG4gICAgZW5kXG5cbiAgICB5aWVsZCBjdXJyZW50IGlmICFAZXhjbCAmJiBjdXJyZW50ID09IGxhc3RcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5nZSA9PT0gb3RoZXJcblxuICAgIEBleGNsID09PSBvdGhlci5leGNsdWRlX2VuZD8gJiZcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxuICAgICAgQGVuZC5lcWw/KG90aGVyLmVuZClcbiAgZW5kXG5cbiAgYWxpYXMgPT0gZXFsP1xuXG4gIGRlZiBleGNsdWRlX2VuZD9cbiAgICBAZXhjbFxuICBlbmRcblxuICBkZWYgZmlyc3QobiA9IHVuZGVmaW5lZClcbiAgICByYWlzZSBSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWluaW11bSBvZiBiZWdpbmxlc3MgcmFuZ2UnIGlmIEBiZWdpbi5uaWw/XG4gICAgcmV0dXJuIEBiZWdpbiBpZiBgbiA9PSBudWxsYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGNvdmVyP1xuXG4gIGRlZiBsYXN0KG4gPSB1bmRlZmluZWQpXG4gICAgcmFpc2UgUmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZScgaWYgQGVuZC5uaWw/XG4gICAgcmV0dXJuIEBlbmQgaWYgYG4gPT0gbnVsbGBcbiAgICB0b19hLmxhc3QobilcbiAgZW5kXG5cbiAgIyBGSVhNRTogY3VycmVudGx5IGhhcmRjb2RlZCB0byBhc3N1bWUgcmFuZ2UgaG9sZHMgbnVtZXJpY3NcbiAgZGVmIG1heFxuICAgIGlmIEBlbmQubmlsP1xuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBiZWdpbi5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZClcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWVtYmVyPyBjb3Zlcj9cblxuICBkZWYgbWluXG4gICAgaWYgQGJlZ2luLm5pbD9cbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBlbmQubmlsPyAmJiAoQGJlZ2luID4gQGVuZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgQGJlZ2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgaW5maW5pdHkgPSBGbG9hdDo6SU5GSU5JVFlcblxuICAgIHJldHVybiAwIGlmIChAYmVnaW4gPT0gaW5maW5pdHkgJiYgIUBlbmQubmlsPykgfHwgKEBlbmQgPT0gLWluZmluaXR5ICYmICFAYmVnaW4ubmlsPylcbiAgICByZXR1cm4gaW5maW5pdHkgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHJldHVybiBuaWwgdW5sZXNzIE51bWVyaWMgPT09IEBiZWdpbiAmJiBOdW1lcmljID09PSBAZW5kXG5cbiAgICByYW5nZV9iZWdpbiA9IEBiZWdpblxuICAgIHJhbmdlX2VuZCAgID0gQGVuZFxuICAgIHJhbmdlX2VuZCAgLT0gMSBpZiBAZXhjbFxuXG4gICAgcmV0dXJuIDAgaWYgcmFuZ2VfZW5kIDwgcmFuZ2VfYmVnaW5cblxuICAgIGBNYXRoLmFicyhyYW5nZV9lbmQgLSByYW5nZV9iZWdpbikgKyAxYC50b19pXG4gIGVuZFxuXG4gIGRlZiBzdGVwKG4gPSAxKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gY29lcmNlU3RlcFNpemUoKSB7XG4gICAgICAgIGlmICghbi4kJGlzX251bWJlcikge1xuICAgICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIG5lZ2F0aXZlXCJ9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcbiAgICAgICAgaWYgKCEje0BiZWdpbi5yZXNwb25kX3RvPyg6c3VjYyl9KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gI3soc2l6ZSAvIG4pLmNlaWx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxuICAgICAgICAgIHZhciBiZWdpbiA9IHNlbGYuYmVnaW4sIGVuZCA9IHNlbGYuZW5kLFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAje0Zsb2F0OjpFUFNJTE9OfSxcbiAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5leGNsKSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xuICAgICAgICAgICAgaWYgKHNpemUgKiBuICsgYmVnaW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gKyBlcnIpICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBuKSBkb1xuICAgICAgICAleHtcbiAgICAgICAgICBjb2VyY2VTdGVwU2l6ZSgpO1xuICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGBjb2VyY2VTdGVwU2l6ZSgpYFxuXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICBpID0gMFxuICAgICAgbG9vcCBkb1xuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cbiAgICAgICAgaWYgQGV4Y2xcbiAgICAgICAgICBicmVhayBpZiBjdXJyZW50ID49IEBlbmRcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgICAgeWllbGQoY3VycmVudClcbiAgICAgICAgaSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nICYmIG4gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGZsb2F0IGZyb20gc3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaF93aXRoX2luZGV4IGRvIHx2YWx1ZSwgaWR4fFxuICAgICAgICB5aWVsZCh2YWx1ZSkgaWYgaWR4ICUgbiA9PSAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmJzZWFyY2gpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGlmIGBpc19pbmZpbml0ZShzZWxmKSAmJiAoc2VsZi5iZWdpbi4kJGlzX251bWJlciB8fCBzZWxmLmVuZC4kJGlzX251bWJlcilgXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIkNhbid0ICNic2VhcmNoIGFuIGluZmluaXRlIHJhbmdlXCJcbiAgICBlbmRcblxuICAgIHVubGVzcyBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBkbyBiaW5hcnkgc2VhcmNoIGZvciAje0BiZWdpbi5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgdG9fYS5ic2VhcmNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QGJlZ2luIHx8ICcnfSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kIHx8ICcnfVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIje0BiZWdpbiAmJiBAYmVnaW4uaW5zcGVjdH0je0BleGNsID8gJy4uLicgOiAnLi4nfSN7QGVuZCAmJiBAZW5kLmluc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIG1hcnNoYWxfbG9hZChhcmdzKVxuICAgIEBiZWdpbiA9IGFyZ3NbOmJlZ2luXVxuICAgIEBlbmQgPSBhcmdzWzplbmRdXG4gICAgQGV4Y2wgPSBhcmdzWzpleGNsXVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtAYmVnaW4sIEBlbmQsIEBleGNsXS5oYXNoXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhbmdlPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZmlyc3QiLCJsYXN0IiwiZXhjbHVkZSIsIkBiZWdpbiIsInJhaXNlIiwiTmFtZUVycm9yIiwiJHJldF9vcl8xIiwiJHJldF9vcl8yIiwiPD0+IiwibmlsPyIsIkFyZ3VtZW50RXJyb3IiLCJAZW5kIiwiQGV4Y2wiLCI9PT0iLCJ2YWx1ZSIsImluY2x1ZGU/IiwiY291bnQiLCIkcmV0X29yXzMiLCJibG9ja19naXZlbj8iLCIhIiwiRmxvYXQ6OklORklOSVRZIiwiRmxvYXQiLCJ0b19hIiwiVHlwZUVycm9yIiwiY292ZXI/IiwiYmVnX2NtcCIsIiRyZXRfb3JfNCIsIiRyZXRfb3JfNSIsIiRyZXRfb3JfNiIsIi0xIiwiZW5kX2NtcCIsIiRyZXRfb3JfNyIsIiRyZXRfb3JfOCIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCIkcmV0X29yXzExIiwiJHJldF9vcl8xMiIsIjwiLCIwIiwiJHJldF9vcl8xMyIsIjw9IiwiZWFjaCIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsInNpemUiLCIxIiwidXB0byIsImJsb2NrIiwidG9fcHJvYyIsImN1cnJlbnQiLCJyZXNwb25kX3RvPyIsImNsYXNzIiwiJHJldF9vcl8xNCIsInN1Y2MiLCIkcmV0X29yXzE1IiwiPT0iLCJlcWw/Iiwib3RoZXIiLCJSYW5nZSIsIiRyZXRfb3JfMTYiLCIkcmV0X29yXzE3IiwiZXhjbHVkZV9lbmQ/IiwiYmVnaW4iLCJlbmQiLCJuIiwiUmFuZ2VFcnJvciIsIm1heCIsIiRyZXRfb3JfMTgiLCIkcmV0X29yXzE5IiwiPiIsIiRyZXRfb3JfMjAiLCJtaW4iLCIkcmV0X29yXzIxIiwiJHJldF9vcl8yMiIsIiRyZXRfb3JfMjMiLCJpbmZpbml0eSIsIiRyZXRfb3JfMjQiLCIkcmV0X29yXzI1IiwiJHJldF9vcl8yNiIsIi1AIiwiJHJldF9vcl8yNyIsIk51bWVyaWMiLCJyYW5nZV9iZWdpbiIsInJhbmdlX2VuZCIsIi0iLCJ0b19pIiwic3RlcCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsIi8iLCJjZWlsIiwiRmxvYXQ6OkVQU0lMT04iLCJibG9jayBpbiBzdGVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzdGVwIiwiaSIsImxvb3AiLCIrIiwiKiIsIj49IiwiZWFjaF93aXRoX2luZGV4IiwiaWR4IiwiJSIsImJzZWFyY2giLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwidG9fcyIsIiRyZXRfb3JfMjgiLCIkcmV0X29yXzI5IiwiaW5zcGVjdCIsIiRyZXRfb3JfMzAiLCIkcmV0X29yXzMxIiwibWFyc2hhbF9sb2FkIiwiYXJncyIsIltdIiwiaGFzaCJdLCJtYXBwaW5ncyI6IkFBQUFBLGdEQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQywwQkFBUkQ7SUFFQ0Q7SUFFREYsSUFBQUssYUFBQUEsQ0FBWSxPQUFaLEVBQW9CLEtBQXBCQTs7QUFFQUMsSUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBZUMsS0FBRCxFQUFRQyxJQUFSLEVBQWNDLE9BQTVCSDtBQUFBQSxNQUFBQTs7OztNQUE0QjtNQUFBLFlBQVUsS0FBVjtNQUFBO01BQzFCLElBQUEsUUFBZ0RJLFVBQWhELENBQUE7UUFBQVYsSUFBQVcsT0FBQUEsQ0FBTUMseUJBQU4sRUFBaUJOLDJCQUFqQkssQ0FBQTtNQUNBLElBQUEsUUFBa0QsYUFBQSxJQUFBLFFBWHRERSxDQUFBQSxZQVdzRCxhQUFBLElBQUEsUUFYdERDLENBQUFBLFlBV3NEUCxLQUFNUSxRQUFBQSxDQUFJUCxJQUFKTyxDQVg1REQsQ0FXc0QsQ0FBQTtRQVh0RFIsT0FBQTtNQVdzRDtRQUFrQkEsT0FBQUMsS0FBS1MsU0FBQUEsQ0FBQUE7TUFBdkIsQ0FBQSxrQkFYdERILENBV3NELENBQUE7UUFYdERQLE9BQUE7TUFXc0Q7UUFBZ0NBLE9BQUFFLElBQUlRLFNBQUFBLENBQUFBO01BQXBDLENBQUEsa0JBQWxELENBQUE7TUFBQTtRQUFBaEIsSUFBQVcsT0FBQUEsQ0FBTU0sNkJBQU4sRUFBcUJYLHFCQUFyQks7TUFBQTtNQUVBRCxhQUFTSDtNQUNUVyxXQUFTVjtNQUNURixPQUFBYSxDQUFBQSxZQUFTVixPQUFUVTtJQU5GYixDQUFBQSxrQ0FBQUE7O0FBU0FjLElBQUFBLHVCQUFBQSxxQkFBQUEsU0FBUUMsS0FBUkQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFwQixJQUFBc0IsYUFBQUEsQ0FBU0QsS0FBVEM7SUFERkYsQ0FBQUEsZ0NBQUFBOztBQUtGbEI7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUVxQixJQUFBQSx5QkFBQUEsaUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFVO01BQ1IsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQWhDUEMsQ0FBQUEsWUFnQ1FDLGVBQURDLE1BQUFBLENBQUFBLENBaENQRixDQWdDTyxDQUFBO1FBQWlCRCxPQUFDQSxpQkFBREE7TUFBakI7UUFoQ1BBLE9BQUE7TUFnQ08sQ0FBQSxrQkFBSCxDQUFBO1FBQ0UsT0FBT0ksSUFBQUMscUJBQUFELGFBRFQ7TUFHQUosT0FBQSxPQUFBdkIsSUFBQSxFQUFBLHVEQUFBLFNBQUEsRUFBQSxFQUFBLEVBQUEsS0FBQTtJQUpGdUIsQ0FBQUEsNEJBQUFBOztBQU9BTSxJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7O01BQ0UsSUFBQSxRQUFnRUEsaUJBQWhFLENBQUE7UUFBQTdCLElBQUFXLE9BQUFBLENBQU1tQix5QkFBTixFQUFpQkQsMENBQWpCbEIsQ0FBQTtNQUNBa0IsT0FBQSxPQUFBN0IsSUFBQSxFQUFBLHFEQUFBLFFBQUEsRUFBQSxFQUFBLEVBQUEsS0FBQTtJQUZGNkIsQ0FBQUEsMkJBQUFBOztBQUtBRSxJQUFBQSwwQkFBQUEsc0JBQUFBLFNBQVdWLEtBQVhVO0FBQUFBLE1BQUFBOzs7TUFDRUMsVUFBVSxhQUFBLElBQUEsUUE1Q2RDLENBQUFBLFlBNENjLGFBQUEsSUFBQSxRQTVDZEMsQ0FBQUEsWUE0Q2UsYUFBQSxJQUFBLFFBNUNmQyxDQUFBQSxZQTRDZXpCLFVBQU1NLFNBQUFBLENBQUFBLENBNUNyQm1CLENBNENlLENBQUE7UUFBZUosT0FBQUs7TUFBZjtRQTVDZkwsT0FBQTtNQTRDZSxDQUFBLGtCQTVDZkcsQ0E0Q2MsQ0FBQTtRQTVDZEgsT0FBQTtNQTRDYzs7UUFBd0JBLE9BQUFyQixVQUFPSyxRQUFBQSxDQUFJTSxLQUFKTjtNQUEvQixDQUFBLGtCQTVDZGtCLENBNENjLENBQUE7UUE1Q2RGLE9BQUE7TUE0Q2M7UUFBNkNBLE9BQUE7TUFBN0MsQ0FBQTtNQUNWTSxVQUFVLGFBQUEsSUFBQSxRQTdDZEMsQ0FBQUEsWUE2Q2MsYUFBQSxJQUFBLFFBN0NkQyxDQUFBQSxZQTZDZSxhQUFBLElBQUEsUUE3Q2ZDLENBQUFBLFlBNkNldEIsUUFBSUYsU0FBQUEsQ0FBQUEsQ0E3Q25Cd0IsQ0E2Q2UsQ0FBQTtRQUFhVCxPQUFBSztNQUFiO1FBN0NmTCxPQUFBO01BNkNlLENBQUEsa0JBN0NmUSxDQTZDYyxDQUFBO1FBN0NkUixPQUFBO01BNkNjOztRQUFzQkEsT0FBQVYsS0FBTU4sUUFBQUEsQ0FBSUcsUUFBSkg7TUFBNUIsQ0FBQSxrQkE3Q2R1QixDQTZDYyxDQUFBO1FBN0NkUCxPQUFBO01BNkNjO1FBQXlDQSxPQUFBO01BQXpDLENBQUE7TUFDVixJQUFBLFFBOUNKVSxDQUFBQSxhQThDSSxhQUFBLElBQUEsUUE5Q0pDLENBQUFBLGFBOENJLGFBQUEsSUFBQSxRQUFHdkIsU0FBSCxDQUFBO1FBQ0UsSUFBQSxRQS9DTndCLENBQUFBLGFBK0NNTixPQS9DTk0sQ0ErQ00sQ0FBQTtVQUFXWixPQUFRYSxPQUFSUCxPQUFRTyxFQUFFQyxDQUFGRDtRQUFuQjtVQS9DTmIsT0FBQTtRQStDTTtNQURGLE9BR0UsSUFBQSxRQWpETmUsQ0FBQUEsYUFpRE1ULE9BakROUyxDQWlETSxDQUFBO1FBQVdmLE9BQVFnQixPQUFSVixPQUFRVSxFQUFHRixDQUFIRTtNQUFuQjtRQWpETmhCLE9BQUE7TUFpRE0sQ0FIRixrQkE5Q0pXLENBOENJLENBQUE7UUFJT1gsT0FBQUM7TUFKUDtRQTlDSkQsT0FBQTtNQThDSSxDQUFBLGtCQTlDSlUsQ0E4Q0ksQ0FBQTtRQUlrQlYsT0FBUWdCLE9BQVJmLE9BQVFlLEVBQUdGLENBQUhFO01BSjFCO1FBOUNKaEIsT0FBQTtNQThDSTtJQUhGQSxDQUFBQSxpQ0FBQUE7O0FBVUFpQixJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFTO01BQ1AsSUFBdUN2QixlQUF2QztNQUFBO1FBQUEsT0FBT3dCLE1BQUFqRCxJQUFBaUQsWUFBQUEsRUFBQUEsQ0FBUyxNQUFUQSxDQUFBQSxFQUFnQkMsZ0JBQUFBLEVBQUFDOztVQUFFQSxPQUFBbkQsSUFBQW9ELE1BQUFBLENBQUFBLENBQUZGLGtCQUFBQSxpQkFBQUEsS0FBaEJEO01BQVA7O0FBR0pEOztBQUVBQSxVQUFZdEMsVUFBT3NDLGdCQUFrQjlCLFFBQUs4QjtBQUMxQ0EsWUFBY3RDLFVBQU9zQyxjQUFnQjlCLFFBQUs4QjtBQUMxQ0EsVUFBWWhELElBQUFXLE9BQUFBLENBQU1tQix5QkFBTixFQUFpQmtCLDBCQUFqQnJDO0FBQ1pxQzs7QUFFQUEsaUJBQW1CdEMsVUFBT3NDLFVBQVk5QixRQUFLOEIsR0FBSyxhQUFBLElBQUEsUUFBQTdCLFNBQUEsQ0FBQTtRQUFRNkIsT0FBQUg7TUFBUjtRQUFZRyxPQUFBSztNQUFaLENBQUEsa0JBQWNMO0FBQzlEQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBLFVBQVl0QyxVQUFPc0MsZ0JBQWtCOUIsUUFBSzhCO0FBQzFDQSxRQUFnQk0sTUFBTjVDLFVBQU00QyxRQUFBQSxFQUFBQSxDQUFNcEMsUUFBWixFQUFrQkMsU0FBWm1DLENBQUFBLEVBQW9CQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFuQkY7QUFDaEJOO0FBQ0FBO0FBQ0FBO01BRUlTLFVBQVUvQztNQUNWRixPQUFVVTtNQUVWLElBQUEsUUFBT3VDLE9BQU9DLGdCQUFBQSxDQUFhLE1BQWJBLENBQWQsQ0FBQTtNQUFBO1FBQ0UxRCxJQUFBVyxPQUFBQSxDQUFNbUIseUJBQU4sRUFBaUIsRUFBQSxHQUFDa0IscUJBQUQsR0FBQSxDQUFzQlMsT0FBT0UsT0FBQUEsQ0FBQUEsQ0FBN0IsQ0FBakJoRDtNQURGO01BSUEsT0FBQSxRQUFNLGFBQUEsSUFBQSxRQXBGVmlELENBQUFBLGFBb0ZVMUMsUUFBSUYsU0FBQUEsQ0FBQUEsQ0FwRmQ0QyxDQW9GVSxDQUFBO1FBcEZWWixPQUFBO01Bb0ZVO1FBQWFBLE9BQW1CSixPQUFsQmEsT0FBUTFDLFFBQUFBLENBQUlQLElBQUpPLENBQVU2QixFQUFFQyxDQUFGRDtNQUFoQyxDQUFBLGtCQUFOLENBQUE7O1FBQ0UsbUJBQU1hLE9BQU47UUFFQUEsVUFBVUEsT0FBT0ksTUFBQUEsQ0FBQUE7TUFIbkI7TUFNQSxJQUFBLFFBQWlCLGFBQUEsSUFBQSxRQTFGckJDLENBQUFBLGFBMEZzQjNDLFNBQURPLE1BQUFBLENBQUFBLENBMUZyQm9DLENBMEZxQixDQUFBO1FBQVVkLE9BQUFTLE9BQVFNLE9BQUFBLENBQUd2RCxJQUFIdUQ7TUFBbEI7UUExRnJCZixPQUFBO01BMEZxQixDQUFBLGtCQUFqQixDQUFBO1FBQUEsbUJBQU1TLE9BQU4sQ0FBQTtNQUVBVCxPQUFBaEQ7SUF2Q0ZnRCxDQUFBQSwyQkFBQUE7O0FBMENBZ0IsSUFBQUEsd0JBQUFBLG9CQUFBQSxTQUFTQyxLQUFURDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFvQkUscUJBQU05QyxRQUFBQSxDQUFJNkMsS0FBSjdDLENBQTFCLENBQUE7TUFBQTtRQUFBLE9BQU87TUFBUDtNQUVBLElBQUEsUUFsR0orQyxDQUFBQSxhQWtHSSxhQUFBLElBQUEsUUFsR0pDLENBQUFBLGFBa0dJakQsU0FBTUMsUUFBQUEsQ0FBSTZDLEtBQUtJLGlCQUFBQSxDQUFBQSxDQUFUakQsQ0FsR1ZnRCxDQWtHSSxDQUFBO1FBQ0VKLE9BQUF0RCxVQUFNc0QsU0FBQUEsQ0FBTUMsS0FBS0ssT0FBQUEsQ0FBQUEsQ0FBWE47TUFEUjtRQWxHSkEsT0FBQTtNQWtHSSxDQUFBLGtCQWxHSkcsQ0FrR0ksQ0FBQTtRQUVFSCxPQUFBOUMsUUFBSThDLFNBQUFBLENBQU1DLEtBQUtNLEtBQUFBLENBQUFBLENBQVhQO01BRk47UUFsR0pBLE9BQUE7TUFrR0k7SUFIRkEsQ0FBQUEsK0JBQUFBO0lBUUEsYUFBTSxJQUFOLEVBQVMsTUFBVDs7QUFFQUssSUFBQUEsZ0NBQUFBLDRCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWxEO0lBREZrRCxDQUFBQSx1Q0FBQUE7O0FBSUE5RCxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFVaUUsQ0FBVmpFO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQ0UsSUFBQSxRQUFpRUcsVUFBTU0sU0FBQUEsQ0FBQUEsQ0FBdkUsQ0FBQTtRQUFBaEIsSUFBQVcsT0FBQUEsQ0FBTThELDBCQUFOLEVBQWtCbEUsMkNBQWxCSSxDQUFBO01BQ0EsSUFBQSxRQUFrQkosU0FBbEIsQ0FBQTtRQUFBLE9BQU9HLFVBQVA7TUFDQUgsT0FBQSxPQUFBUCxJQUFBLEVBQUEsd0RBQUEsU0FBQSxFQUFBLENBQUF3RSxDQUFBLENBQUEsRUFBQSxLQUFBO0lBSEZqRSxDQUFBQSw4QkFBQUE7SUFNQSxhQUFNLFVBQU4sRUFBZSxRQUFmOztBQUVBQyxJQUFBQSx3QkFBQUEsaUJBQUFBLGdCQUFTZ0UsQ0FBVGhFO0FBQUFBLE1BQUFBOzs7O01BQ0UsSUFBQSxRQUErRFUsUUFBSUYsU0FBQUEsQ0FBQUEsQ0FBbkUsQ0FBQTtRQUFBaEIsSUFBQVcsT0FBQUEsQ0FBTThELDBCQUFOLEVBQWtCakUseUNBQWxCRyxDQUFBO01BQ0EsSUFBQSxRQUFnQkgsU0FBaEIsQ0FBQTtRQUFBLE9BQU9VLFFBQVA7TUFDQVYsT0FBQVIsSUFBQTZCLE1BQUFBLENBQUFBLENBQUlyQixNQUFBQSxDQUFNZ0UsQ0FBTmhFO0lBSE5BLENBQUFBLDZCQUFBQTs7QUFPQWtFLElBQUFBLHVCQUFBQSxnQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQUFBO01BQ0UsSUFBQSxRQUFHeEQsUUFBSUYsU0FBQUEsQ0FBQUEsQ0FBUCxDQUFBO1FBQ0UwRCxPQUFBMUUsSUFBQVcsT0FBQUEsQ0FBTThELDBCQUFOLEVBQWtCQyx5Q0FBbEIvRDtNQURGLE9BRUEsSUFBTWMsZ0JBQU47UUFDRWlELE9BQUEsT0FBQTFFLElBQUEsRUFBQSxvREFBQSxPQUFBLEVBQUEsRUFBQSxFQUFBLEtBQUE7TUFERixPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUFqSVYyRSxDQUFBQSxhQWlJV2pFLFVBQU1NLFNBQUFBLENBQUFBLENBQVBVLE1BQUFBLENBQUFBLENBaklWaUQsQ0FpSVUsQ0FBQTs7UUFBaUIsSUFBQSxRQWpJM0JDLENBQUFBLGFBaUlrQ0MsT0FBUG5FLFVBQU9tRSxFQUFFM0QsUUFBRjJELENBaklsQ0QsQ0FpSTJCLENBQUE7VUFqSTNCRixPQUFBO1FBaUkyQixPQUNBLElBQUEsUUFsSTNCSSxDQUFBQSxhQWtJMkIzRCxTQWxJM0IyRCxDQWtJMkIsQ0FBQTtVQUFTSixPQUFBaEUsVUFBT3FELE9BQUFBLENBQUc3QyxRQUFINkM7UUFBaEI7VUFsSTNCVyxPQUFBO1FBa0kyQjtNQURqQjtRQWpJVkEsT0FBQTtNQWlJVSxDQUFBLGtCQUFOLENBQUE7UUFFRUEsT0FBQTtNQUZGO1FBSUVBLE9BQUd2RCxTQUFNdUQsR0FBS3hELFFBQUt3RCxPQUFTeEQ7TUFKOUI7SUFMRndELENBQUFBLDJCQUFBQTtJQWFBLGFBQU0sU0FBTixFQUFjLFFBQWQ7O0FBRUFLLElBQUFBLHVCQUFBQSxnQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQUFBO01BQ0UsSUFBQSxRQUFHckUsVUFBTU0sU0FBQUEsQ0FBQUEsQ0FBVCxDQUFBO1FBQ0UrRCxPQUFBL0UsSUFBQVcsT0FBQUEsQ0FBTThELDBCQUFOLEVBQWtCTSwyQ0FBbEJwRTtNQURGLE9BRUEsSUFBTWMsZ0JBQU47UUFDRXNELE9BQUEsT0FBQS9FLElBQUEsRUFBQSxvREFBQSxPQUFBLEVBQUEsRUFBQSxFQUFBLEtBQUE7TUFERixPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUFoSlZnRixDQUFBQSxhQWdKVzlELFFBQUlGLFNBQUFBLENBQUFBLENBQUxVLE1BQUFBLENBQUFBLENBaEpWc0QsQ0FnSlUsQ0FBQTs7UUFBZSxJQUFBLFFBaEp6QkMsQ0FBQUEsYUFnSmdDSixPQUFQbkUsVUFBT21FLEVBQUUzRCxRQUFGMkQsQ0FoSmhDSSxDQWdKeUIsQ0FBQTtVQWhKekJGLE9BQUE7UUFnSnlCLE9BQ0EsSUFBQSxRQWpKekJHLENBQUFBLGFBaUp5Qi9ELFNBakp6QitELENBaUp5QixDQUFBO1VBQVNILE9BQUFyRSxVQUFPcUQsT0FBQUEsQ0FBRzdDLFFBQUg2QztRQUFoQjtVQWpKekJnQixPQUFBO1FBaUp5QjtNQURmO1FBaEpWQSxPQUFBO01BZ0pVLENBQUEsa0JBQU4sQ0FBQTtRQUVFQSxPQUFBO01BRkY7UUFJRUEsT0FBQXJFO01BSkY7SUFMRnFFLENBQUFBLDJCQUFBQTs7QUFhQTNCLElBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRStCLFdBQVd4RCxJQUFBQyxxQkFBQUQ7TUFFWCxJQUFBLFFBQVksYUFBQSxJQUFBLFFBM0poQnlELENBQUFBLGFBMkppQixhQUFBLElBQUEsUUEzSmpCQyxDQUFBQSxhQTJKaUIzRSxVQUFPcUQsT0FBQUEsQ0FBR29CLFFBQUhwQixDQTNKeEJzQixDQTJKaUIsQ0FBQTtRQUFzQmpDLE9BQUNsQyxRQUFJRixTQUFBQSxDQUFBQSxDQUFMVSxNQUFBQSxDQUFBQTtNQUF0QjtRQTNKakIwQixPQUFBO01BMkppQixDQUFBLGtCQTNKakJnQyxDQTJKZ0IsQ0FBQTtRQTNKaEJoQyxPQUFBO01BMkpnQjs7UUFBdUMsSUFBQSxRQTNKdkRrQyxDQUFBQSxhQTJKdURwRSxRQUFLNkMsT0FBQUEsQ0FBSW9CLFFBQURJLE9BQUFBLENBQUFBLENBQUh4QixDQTNKNUR1QixDQTJKdUQsQ0FBQTtVQUFxQmxDLE9BQUMxQyxVQUFNTSxTQUFBQSxDQUFBQSxDQUFQVSxNQUFBQSxDQUFBQTtRQUFyQjtVQTNKdkQwQixPQUFBO1FBMkp1RDtNQUF2QyxDQUFBLGtCQUFaLENBQUE7UUFBQSxPQUFPUCxDQUFQO01BQ0EsSUFBQSxRQUFvQk8saUJBQXBCLENBQUE7UUFBQSxPQUFPK0IsUUFBUDtNQUNBLElBQUEsUUFBa0IsYUFBQSxJQUFBLFFBN0p0QkssQ0FBQUEsYUE2SnNCQyx1QkFBUXJFLFFBQUFBLENBQUlWLFVBQUpVLENBN0o5Qm9FLENBNkpzQixDQUFBO1FBQXNCcEMsT0FBQXFDLHVCQUFRckUsUUFBQUEsQ0FBSUYsUUFBSkU7TUFBOUI7UUE3SnRCZ0MsT0FBQTtNQTZKc0IsQ0FBQSxrQkFBbEIsQ0FBQTtNQUFBO1FBQUEsT0FBTztNQUFQO01BRUFzQyxjQUFjaEY7TUFDZGlGLFlBQWN6RTtNQUNkLElBQUEsUUFBbUJDLFNBQW5CLENBQUE7UUFBQXdFLFlBQVdDLFVBQVhELFNBQVdDLEVBQUd2QyxDQUFIdUMsQ0FBWDtNQUVBLElBQUEsUUFBc0JoRCxPQUFWK0MsU0FBVS9DLEVBQUU4QyxXQUFGOUMsQ0FBdEIsQ0FBQTtRQUFBLE9BQU9DLENBQVA7TUFFQU8sT0FBQUEsQ0FBQ0EscUNBQURBLENBQXVDeUMsTUFBQUEsQ0FBQUE7SUFiekN6QyxDQUFBQSw0QkFBQUE7O0FBZ0JBMEMsSUFBQUEsd0JBQUFBLGlCQUFBQSxnQkFBU3RCLENBQVRzQjtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFTO01BQUEsTUFBSXpDLENBQUo7TUFBQTs7QUFFWHlDO0FBQ0FBO0FBQ0FBLGNBQWdCQyxvQkFBSUMsZUFBQUEsQ0FBWXhCLENBQWhCLEVBQW1CeUIsdUJBQW5CLEVBQTRCLFFBQXhCRDtBQUNwQkY7O0FBRUFBO0FBQ0FBLFVBQVk5RixJQUFBVyxPQUFBQSxDQUFNTSw2QkFBTixFQUFxQjZFLHdCQUFyQm5GO0FBQ1ptRjtBQUNBQSxVQUFZOUYsSUFBQVcsT0FBQUEsQ0FBTU0sNkJBQU4sRUFBcUI2RSxpQkFBckJuRjtBQUNabUY7QUFDQUE7O0FBRUFBO0FBQ0FBLGFBQWVwRixVQUFNZ0QsZ0JBQUFBLENBQWEsTUFBYkEsQ0FBb0JvQztBQUN6Q0E7QUFDQUE7O0FBRUFBLFlBQWNwRixVQUFPb0YsZ0JBQWtCNUUsUUFBSzRFO0FBQzVDQTtBQUNBQTs7QUFFQUE7QUFDQUEsaUJBQXlCSSxXQUFMbEcsSUFBQW9ELE1BQUFBLENBQUFBLENBQUs4QyxFQUFFMUIsQ0FBRjBCLENBQUlDLE1BQUFBLENBQUFBLENBQU1MO0FBQ25DQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSwwRUFBNEVNLElBQUF4RSxxQkFBQXdFLFlBQWVOO0FBQzNGQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJLElBQU9yRSxnQkFBUDtNQUFBO1FBQ0UsT0FBT3dCLE1BQUFqRCxJQUFBaUQsWUFBQUEsRUFBQUEsQ0FBUyxNQUFULEVBQWdCdUIsQ0FBaEJ2QixDQUFBQSxFQUFtQm9ELGlCQUFBQSxFQUFBQzs7O0FBRWhDQTtBQUNBQTtBQUNBQSxRQUpnQ0QsbUJBQUFBLGtCQUFBQSxNQUFuQnBEO01BRFQ7TUFTQzZDO01BRUQsSUFBQSxRQUFJQSw4Q0FBSixDQUFBOztRQUNFUyxJQUFJMUQ7UUFDSjJELDRDQUFBQSxPQUFBQSxNQUFBeEcsSUFBQXdHLFFBQUFBLEVBQUFBLEVBQUFBLEVBQUtILGlCQUFBQSxFQUFBQztBQUFBQTtBQUFBQTtBQUFBQTs7O1VBQ0g3QyxVQUFpQmdELFNBQVAvRixVQUFPK0YsRUFBSUMsVUFBRkgsQ0FBRUcsRUFBRWxDLENBQUZrQyxDQUFKRDtVQUNqQixJQUFBLFFBQUd0RixTQUFILENBQUE7WUFDRSxJQUFBLFFBQWlCd0YsT0FBUmxELE9BQVFrRCxFQUFHekYsUUFBSHlGLENBQWpCLENBQUE7O2NBQUEsU0FBQSxHQUFBLE9BQUE7VUFERixPQUVBLElBQUEsUUFBYzlCLE9BQVJwQixPQUFRb0IsRUFBRTNELFFBQUYyRCxDQUFkLENBQUE7O1lBQ0UsU0FBQSxHQUFBLE9BREY7VUFHQSxvQkFBTXBCLE9BQU47VUFDQTZDLE9BQUFDLENBQUFBLElBQUVFLFNBQUZGLENBQUVFLEVBQUdwRCxDQUFIb0QsQ0FBRkYsRUFSR0YsbUJBQUFBLG1CQUFBQSxrQkFBQUEsTUFBTEc7UUFBQUE7TUFGRjs7O0FBY0pWLFlBQWNwRixVQUFPb0YsZ0JBQWtCNUUsUUFBSzRFO0FBQzVDQSxVQUFZOUYsSUFBQVcsT0FBQUEsQ0FBTW1CLHlCQUFOLEVBQWlCZ0UsNkNBQWpCbkY7QUFDWm1GO0FBQ0FBO1FBQ01jLE1BQUE1RyxJQUFBNEcsbUJBQUFBLEVBQUFBLEVBQUFBLEVBQWdCUCxpQkFBSWhGLEtBQUQsRUFBUXdGLEdBQVhSLEVBQUFDOzs7O1VBQUk7VUFBQTtVQUFBOztVQUFPO1VBQUE7VUFBQTtVQUN6QixJQUFnQk8sR0FBSUMsTUFBQUEsQ0FBRXRDLENBQUZzQyxDQUFJL0MsT0FBQUEsQ0FBR2xCLENBQUhrQixDQUF4QjtZQUFBLE9BQUEsb0JBQU0xQyxLQUFOLENBQUE7VUFBQTtZQXhQUmlGLE9BQUE7VUF3UFEsRUFEY0QsbUJBQUFBLGtCQUFBQSxNQUFoQk87TUFsQkY7TUFzQkFkLE9BQUE5RjtJQW5GRjhGLENBQUFBLDZCQUFBQTs7QUFzRkFpQixJQUFBQSwyQkFBQUEsb0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFZO01BQ1YsSUFBaUN0RixlQUFqQztNQUFBO1FBQUEsT0FBT3pCLElBQUFpRCxVQUFBQSxDQUFTLFNBQVRBO01BQVA7TUFFQSxJQUFBLFFBQUk4RCxxRUFBSixDQUFBO1FBQ0UvRyxJQUFBVyxPQUFBQSxDQUFNcUcsbUNBQU4sRUFBMkJELGtDQUEzQnBHLENBREY7TUFJQSxJQUFBLFFBQVFvRyw4Q0FBUixDQUFBO01BQUE7UUFDRS9HLElBQUFXLE9BQUFBLENBQU1tQix5QkFBTixFQUFpQixFQUFBLEdBQUNpRiw2QkFBRCxHQUFBLENBQThCckcsVUFBTWlELE9BQUFBLENBQUFBLENBQXBDLENBQWpCaEQ7TUFERjtNQUlBb0csT0FBSUEsTUFBSi9HLElBQUE2QixNQUFBQSxDQUFBQSxDQUFJa0YsV0FBQUEsRUFBQUEsRUFBQUEsRUFBVXhELEtBQURDLFNBQUFBLENBQUFBLENBQVR1RDtJQVhOQSxDQUFBQSwrQkFBQUE7O0FBY0FFLElBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLEVBQUEsR0FBQSxDQUFHLGFBQUEsSUFBQSxRQTdRUEMsQ0FBQUEsYUE2UU94RyxVQTdRUHdHLENBNlFPLENBQUE7UUE3UVBELE9BQUE7TUE2UU87UUFBVUEsT0FBQUE7TUFBVixDQUFBLGtCQUFILENBQUEsR0FBQSxDQUFrQixhQUFBLElBQUEsUUFBQTlGLFNBQUEsQ0FBQTtRQUFROEYsT0FBQUE7TUFBUjtRQUFnQkEsT0FBQUE7TUFBaEIsQ0FBQSxrQkFBbEIsQ0FBQSxHQUFBLENBQXlDLGFBQUEsSUFBQSxRQTdRN0NFLENBQUFBLGFBNlE2Q2pHLFFBN1E3Q2lHLENBNlE2QyxDQUFBO1FBN1E3Q0YsT0FBQTtNQTZRNkM7UUFBUUEsT0FBQUE7TUFBUixDQUFBLGtCQUF6QztJQURGQSxDQUFBQSw0QkFBQUE7O0FBSUFHLElBQUFBLDJCQUFBQSxvQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLEVBQUEsR0FBQSxDQUFHLGFBQUEsSUFBQSxRQWpSUEMsQ0FBQUEsYUFpUk8zRyxVQWpSUDJHLENBaVJPLENBQUE7UUFBVUQsT0FBQTFHLFVBQU0wRyxTQUFBQSxDQUFBQTtNQUFoQjtRQWpSUEEsT0FBQTtNQWlSTyxDQUFBLGtCQUFILENBQUEsR0FBQSxDQUE4QixhQUFBLElBQUEsUUFBQWpHLFNBQUEsQ0FBQTtRQUFRaUcsT0FBQUE7TUFBUjtRQUFnQkEsT0FBQUE7TUFBaEIsQ0FBQSxrQkFBOUIsQ0FBQSxHQUFBLENBQXFELGFBQUEsSUFBQSxRQWpSekRFLENBQUFBLGFBaVJ5RHBHLFFBalJ6RG9HLENBaVJ5RCxDQUFBO1FBQVFGLE9BQUFsRyxRQUFJa0csU0FBQUEsQ0FBQUE7TUFBWjtRQWpSekRBLE9BQUE7TUFpUnlELENBQUEsa0JBQXJEO0lBREZBLENBQUFBLCtCQUFBQTs7QUFJQUcsSUFBQUEsZ0NBQUFBLHlCQUFBQSx3QkFBaUJDLElBQWpCRDtBQUFBQSxNQUFBQTs7O01BQ0U3RyxhQUFTOEcsSUFBSUMsT0FBQUEsQ0FBQyxPQUFEQTtNQUNidkcsV0FBT3NHLElBQUlDLE9BQUFBLENBQUMsS0FBREE7TUFDWEYsT0FBQXBHLENBQUFBLFlBQVFxRyxJQUFJQyxPQUFBQSxDQUFDLE1BQURBLENBQVp0RztJQUhGb0csQ0FBQUEsb0NBQUFBO0lBTUFySCxPQUFBd0gsQ0FBQUEsd0JBQUFBLGlCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQ2hILFVBQUQsRUFBU1EsUUFBVCxFQUFlQyxTQUFmLENBQXFCdUcsTUFBQUEsQ0FBQUE7SUFEdkJBLENBQUFBLDRCQUFBQSxDQUFBQTtFQXhSRnhILEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTE0NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbmNsYXNzIFByb2MgPCBgRnVuY3Rpb25gXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsICRicmsgPSBzZWxmLiQkYnJrO1xuXG4gICAgICBpZiAoJGJyaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuICRicmsuJHZcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbiAgYWxpYXMgeWllbGQgY2FsbFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgb3RoZXIuY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gb3RoZXIuY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGFyaXR5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgcmV0dXJuIG5pbDsgfWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxuXG4gICAgaWYgZGVmaW5lZD8gQmluZGluZ1xuICAgICAgQmluZGluZy5uZXcobmlsLCBbXSwgYHNlbGYuJCRzYCwgc291cmNlX2xvY2F0aW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAje09wYWwuY29lcmNlX3RvIShhcml0eSwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbG9uZSBkdXBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UHJvYz4iLCJuZXciLCJzZWxmIiwiYmxvY2siLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjYWxsIiwiPj4iLCJvdGhlciIsInByb2MiLCJibG9jayBpbiA+PiIsImJsb2NrICgyIGxldmVscykgaW4gPj4iLCJvdXQiLCJhcmdzIiwidG9fcHJvYyIsIjw8IiwiYmxvY2sgaW4gPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIDw8IiwibGFtYmRhPyIsImFyaXR5Iiwic291cmNlX2xvY2F0aW9uIiwiYmluZGluZyIsIkJpbmRpbmciLCJwYXJhbWV0ZXJzIiwiY3VycnkiLCJPcGFsIiwiY29lcmNlX3RvISIsIkludGVnZXIiLCJkdXAiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0dBO0lBQ0FBO0lBRURDLFVBQUlDLElBQUpELFVBQUFBLGNBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWE7TUFDWCxJQUFBLFFBQU9FLEtBQVAsQ0FBQTtNQUFBO1FBQ0VELElBQUFFLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCSiwrQ0FBckJHO01BREY7TUFJQUgsT0FBQUU7SUFMRkYsQ0FBQUEseUJBQUFBOztBQVFBSyxJQUFBQSx3QkFBQUEsZUFBQUEsZ0JBZEYsRUFjRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBZ0I7O01BZGxCOztNQWNXOztBQUVYQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQW5DRUEsQ0FBQUEsMkJBQUFBO0lBc0NBLGFBQU0sSUFBTixFQUFTLE1BQVQ7SUFDQSxhQUFNLEtBQU4s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V0FBOUMsQ0FBQSxHQUEyREEsR0FBaEZwQjtBQUNab0I7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxVQUFZdEIsSUFBQUUsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUIsRUFBQSxHQUFDbUIsNkJBQUQsR0FBQSxDQUErQkEsTUFBL0IsQ0FBQSxHQUF1Q0EsT0FBdkMsR0FBQSxDQUErQ0EsS0FBL0MsQ0FBQSxHQUFzREEsR0FBM0VwQjtBQUNab0I7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBdENFQSxDQUFBQSw2QkFBQUE7O0FBeUNBSSxJQUFBQSx1QkFBQUEsZUFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBZEVBLENBQUFBLDBCQUFBQTtJQWlCQTVCLE9BQUEsYUFBTSxPQUFOLEVBQVksS0FBWjtFQTVMRkEsR0FBQUEsV0FBQUEsRUFBY0QsUUFBZEM7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5Mzk3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTWV0aG9kXG4gIGF0dHJfcmVhZGVyIDpvd25lciwgOnJlY2VpdmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHJlY2VpdmVyLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQG93bmVyICAgID0gb3duZXJcbiAgICBAbmFtZSAgICAgPSBuYW1lXG4gICAgQG1ldGhvZCAgID0gbWV0aG9kXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgI3tAbWV0aG9kfS4kJHAgPSBibG9jaztcblxuICAgICAgcmV0dXJuICN7QG1ldGhvZH0uYXBwbHkoI3tAcmVjZWl2ZXJ9LCBhcmdzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICBAbWV0aG9kLmN1cnJ5KGFyaXR5KVxuICBlbmRcblxuICBhbGlhcyBbXSBjYWxsXG4gIGFsaWFzID09PSBjYWxsXG5cbiAgZGVmID4+KG90aGVyKVxuICAgIEBtZXRob2QgPj4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw8KG90aGVyKVxuICAgIEBtZXRob2QgPDwgb3RoZXJcbiAgZW5kXG5cbiAgZGVmIHVuYmluZFxuICAgIFVuYm91bmRNZXRob2QubmV3KEByZWNlaXZlci5jbGFzcywgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSlcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICAleHtcbiAgICAgIHZhciBwcm9jID0gc2VsZi4kY2FsbC5iaW5kKHNlbGYpO1xuICAgICAgcHJvYy4kJHVuYm91bmQgPSAje0BtZXRob2R9O1xuICAgICAgcHJvYy4kJGlzX2xhbWJkYSA9IHRydWU7XG4gICAgICBwcm9jLiQkYXJpdHkgPSAje0BtZXRob2R9LiQkYXJpdHk7XG4gICAgICBwcm9jLiQkcGFyYW1ldGVycyA9ICN7QG1ldGhvZH0uJCRwYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0ByZWNlaXZlci5jbGFzc30jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuYm91bmRNZXRob2RcbiAgYXR0cl9yZWFkZXIgOnNvdXJjZSwgOm93bmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHNvdXJjZSwgb3duZXIsIG1ldGhvZCwgbmFtZSlcbiAgICBAc291cmNlID0gc291cmNlXG4gICAgQG93bmVyICA9IG93bmVyXG4gICAgQG1ldGhvZCA9IG1ldGhvZFxuICAgIEBuYW1lICAgPSBuYW1lXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgYmluZChvYmplY3QpXG4gICAgJXh7XG4gICAgICBpZiAoI3tAb3duZXJ9LiQkaXNfbW9kdWxlIHx8IE9wYWwuaXNfYSgje29iamVjdH0sICN7QG93bmVyfSkpIHtcbiAgICAgICAgcmV0dXJuICN7TWV0aG9kLm5ldyhvYmplY3QsIEBvd25lciwgQG1ldGhvZCwgQG5hbWUpfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBiaW5kIHNpbmdsZXRvbiBtZXRob2QgdG8gYSBkaWZmZXJlbnQgY2xhc3MgKGV4cGVjdGVkICN7b2JqZWN0fS5raW5kX29mPygje0Bvd25lcn0gdG8gYmUgdHJ1ZSlcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0Bzb3VyY2V9IyN7QG5hbWV9IChkZWZpbmVkIGluICN7QG93bmVyfSBpbiAje3NvdXJjZV9sb2NhdGlvbi5qb2luKCc6Jyl9KT5cIlxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6TWV0aG9kPiIsInNlbGYiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJyZWNlaXZlciIsIm93bmVyIiwibWV0aG9kIiwibmFtZSIsIkByZWNlaXZlciIsIkBvd25lciIsIkBuYW1lIiwiQG1ldGhvZCIsImFyaXR5IiwicGFyYW1ldGVycyIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsIjAiLCJjb21tZW50cyIsIiRyZXRfb3JfMiIsImNhbGwiLCJjdXJyeSIsIj4+Iiwib3RoZXIiLCI8PCIsInVuYmluZCIsIlVuYm91bmRNZXRob2QiLCJuZXciLCJjbGFzcyIsInRvX3Byb2MiLCJpbnNwZWN0Iiwiam9pbiIsIjxjbGFzczpVbmJvdW5kTWV0aG9kPiIsInNvdXJjZSIsIkBzb3VyY2UiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJiaW5kIiwib2JqZWN0IiwiTWV0aG9kIiwicmFpc2UiLCJUeXBlRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxJQUFBQyxhQUFBQSxDQUFZLE9BQVosRUFBb0IsVUFBcEIsRUFBK0IsTUFBL0JBOztBQUVBQyxJQUFBQSw4QkFBQUEsdUJBQUFBLHNCQUFlQyxRQUFELEVBQVdDLEtBQVgsRUFBa0JDLE1BQWxCLEVBQTBCQyxJQUF4Q0o7QUFBQUEsTUFBQUE7OztNQUNFSyxnQkFBWUo7TUFDWkssYUFBWUo7TUFDWkssWUFBWUg7TUFDWkosT0FBQVEsQ0FBQUEsY0FBWUwsTUFBWks7SUFKRlIsQ0FBQUEsa0NBQUFBOztB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TUFBWCxFQUFtQjVCLFVBQW5CLEVBQTJCRSxXQUEzQixFQUFvQ0QsU0FBOUJnQixDQUFxQ1U7QUFDNURBO0FBQ0FBO0FBQ0FBLFFBQVVuQyxJQUFBc0MsT0FBQUEsQ0FBTUMseUJBQU4sRUFBaUIsRUFBQSxHQUFDSiw2REFBRCxHQUFBLENBQThEQyxNQUE5RCxDQUFBLEdBQXFFRCxZQUFyRSxHQUFBLENBQWlGM0IsVUFBakYsQ0FBQSxHQUF3RjJCLGNBQXpHRyxDQUF1SEg7QUFDaklBO0FBQ0FBO0lBUkVBLENBQUFBLG9DQUFBQTtJQVdBTCxPQUFBRixDQUFBQSwyQkFBQUEsNEJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxFQUFBLEdBQUNBLElBQUQsR0FBQSxDQUFLNUIsSUFBSTBCLE9BQUFBLENBQUFBLENBQVQsQ0FBQSxHQUFnQkUsSUFBaEIsR0FBQSxDQUFvQkksV0FBcEIsQ0FBQSxHQUE0QkosR0FBNUIsR0FBQSxDQUErQm5CLFNBQS9CLENBQUEsR0FBcUNtQixlQUFyQyxHQUFBLENBQW9EcEIsVUFBcEQsQ0FBQSxHQUEyRG9CLE1BQTNELEdBQUEsQ0FBaUU1QixJQUFBYSxpQkFBQUEsQ0FBQUEsQ0FBZWdCLE1BQUFBLENBQU1ELEdBQU5DLENBQWhGLENBQUEsR0FBMkZEO0lBRDdGQSxDQUFBQSx1Q0FBQUEsQ0FBQUE7RUFyQ0ZFLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBckVBaEM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5NTg4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi92YXJpYWJsZXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyByZWdleHAgbWF0Y2hlc1xuJXh7JGd2YXJzWycmJ10gPSAkZ3ZhcnNbJ34nXSA9ICRndmFyc1snYCddID0gJGd2YXJzW1wiJ1wiXSA9IG5pbH1cblxuIyByZXF1aXJlc1xuJExPQURFRF9GRUFUVVJFUyA9ICRcIiA9IGBPcGFsLmxvYWRlZF9mZWF0dXJlc2BcbiRMT0FEX1BBVEggICAgICAgPSAkOiA9IFtdXG5cbiMgc3BsaXQgbGluZXNcbiQvID0gXCJcXG5cIlxuJCwgPSBuaWxcblxuQVJHViA9IFtdXG5BUkdGID0gT2JqZWN0Lm5ld1xuRU5WICA9IHt9XG5cbiRWRVJCT1NFID0gZmFsc2VcbiRERUJVRyAgID0gZmFsc2VcbiRTQUZFICAgID0gMFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIkTE9BREVEX0ZFQVRVUkVTIiwiJFwiIiwiJExPQURfUEFUSCIsIiQ6IiwiJC8iLCIkLCIsIk9iamVjdCIsIm5ldyIsIiRWRVJCT1NFIiwiJERFQlVHIiwiJFNBRkUiLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUEsb0RBQUFBO0VBQUFBOztFQUFBQTs7RUFDR0E7RUFHSEMseUJBQW1CQyxDQUFBQSxlQUFNRixvQkFBTkU7RUFDbkJDLG1CQUFtQkMsQ0FBQUEsY0FBSyxFQUFMQTtFQUduQkMsY0FBS0w7RUFDTE0sY0FBSztFQUVMLG9DQUFPLEVBQVA7RUFDQSxvQ0FBT0Msc0JBQU1DLEtBQUFBLENBQUFBLENBQWI7RUFDQSxtQ0FBTyxZQUFBLEVBQVA7RUFFQUMsaUJBQVc7RUFDWEMsZUFBVztFQUNYVixPQUFBVyxDQUFBQSxjQUFXQyxDQUFYRDtBQWpCQVg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5NjA2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBJT1xuICBTRUVLX1NFVCA9IDBcbiAgU0VFS19DVVIgPSAxXG4gIFNFRUtfRU5EID0gMlxuICBTRUVLX0RBVEEgPSAzXG4gIFNFRUtfSE9MRSA9IDRcblxuICBSRUFEQUJMRSA9IDFcbiAgV1JJVEFCTEUgPSA0XG5cbiAgZGVmIGluaXRpYWxpemUoZmQsIGZsYWdzID0gJ3InKVxuICAgIEBmZCA9IGZkXG4gICAgQGZsYWdzID0gZmxhZ3NcbiAgICBAZW9mID0gZmFsc2VcblxuICAgIGlmIGZsYWdzLmluY2x1ZGU/KCdyJykgJiYgIWZsYWdzLm1hdGNoPygvW3dhK10vKVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVsc2lmIGZsYWdzLm1hdGNoPygvW3dhXS8pICYmICFmbGFncy5tYXRjaD8oL1tyK10vKVxuICAgICAgQGNsb3NlZCA9IDpyZWFkXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBmaWxlbm9cbiAgICBAZmRcbiAgZW5kXG5cbiAgZGVmIHR0eT9cbiAgICBgc2VsZi50dHkgPT0gdHJ1ZWBcbiAgZW5kXG5cbiAgYXR0cl9hY2Nlc3NvciA6d3JpdGVfcHJvY1xuICBhdHRyX2FjY2Vzc29yIDpyZWFkX3Byb2NcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGBzZWxmLndyaXRlX3Byb2Moc3RyaW5nKWBcbiAgICBzdHJpbmcuc2l6ZVxuICBlbmRcblxuICBhdHRyX2FjY2Vzc29yIDpzeW5jLCA6dHR5XG5cbiAgYXR0cl9yZWFkZXIgOmVvZlxuICBhbGlhcyBlb2Y/IGVvZlxuXG4gIGRlZiBmbHVzaFxuICAgICMgbm9vcFxuICBlbmRcblxuICBkZWYgPDwoc3RyaW5nKVxuICAgIHdyaXRlKHN0cmluZylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqYXJncylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gI3tTdHJpbmcoYGFyZ3NbaV1gKX1cbiAgICAgIH1cbiAgICAgIHNlbGYuJHdyaXRlKGFyZ3Muam9pbigjeyQsfSkpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9ICN7U3RyaW5nKGBhcmdzW2ldYCkuY2hvbXB9XG4gICAgICB9XG4gICAgICBzZWxmLiR3cml0ZShhcmdzLmNvbmNhdChbbmlsXSkuam9pbigjeyQvfSkpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgIyBSZWFkaW5nXG5cbiAgZGVmIGdldGNcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydHMgPSAnJ1xuXG4gICAgIyBXaWxsIGV4ZWN1cmUgYXQgbW9zdCB0d2ljZSAtIG9uZSB0aW1lIHJlYWRpbmcgZnJvbSBhIGJ1ZmZlclxuICAgICMgc2Vjb25kIHRpbWVcbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IHBhcnRzXG4gICAgICBpZiBAcmVhZF9idWZmZXIgIT0gJydcbiAgICAgICAgcmV0ID0gQHJlYWRfYnVmZmVyWzBdXG4gICAgICAgIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclsxLi4tMV1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgZW5kXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKDEpXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGdldGJ5dGVcbiAgICBnZXRjJi5vcmRcbiAgZW5kXG5cbiAgZGVmIHJlYWRieXRlXG4gICAgcmVhZGNoYXIub3JkXG4gIGVuZFxuXG4gIGRlZiByZWFkY2hhclxuICAgIGdldGMgfHwgcmFpc2UoRU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJylcbiAgZW5kXG5cbiAgZGVmIHJlYWRsaW5lKCphcmdzKVxuICAgIGdldHMoKmFyZ3MpIHx8IHJhaXNlKEVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCcpXG4gIGVuZFxuXG4gIGRlZiBnZXRzKHNlcCA9IGZhbHNlLCBsaW1pdCA9IG5pbCwgb3B0cyA9IHt9KVxuICAgIGlmIGBzZXAuJCRpc19udW1iZXJgICYmICFsaW1pdFxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IGZhbHNlLCBzZXAsIGxpbWl0XG4gICAgZW5kXG4gICAgaWYgYHNlcC4kJGlzX2hhc2hgICYmICFsaW1pdCAmJiBvcHRzID09IHt9XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gZmFsc2UsIG5pbCwgc2VwXG4gICAgZWxzaWYgYGxpbWl0LiQkaXNfaGFzaGAgJiYgb3B0cyA9PSB7fVxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IHNlcCwgbmlsLCBsaW1pdFxuICAgIGVuZFxuXG4gICAgb3JpZ19zZXAgPSBzZXBcblxuICAgIHNlcCA9ICQvIGlmIHNlcCA9PSBmYWxzZVxuICAgIHNlcCA9IC9cXHI/XFxuXFxyP1xcbi8gaWYgc2VwID09ICcnXG4gICAgc2VwIHx8PSAnJ1xuICAgIHNlcCA9IHNlcC50b19zdHIgdW5sZXNzIG9yaWdfc2VwID09ICcnXG5cbiAgICAjIFRyeSB0byBkZWR1Y2UgbGVuZ3RoIG9mIGEgcmVnZXhwXG4gICAgc2VwbGVuID0gYG9yaWdfc2VwID09ICcnID8gMiA6IHNlcC5sZW5ndGhgXG5cbiAgICBzZXAgPSAvIC8gaWYgc2VwID09ICcgJyAjIFdURiBpcyB0aGlzLCBTdHJpbmcjc3BsaXQoXCIgXCIpIG1hdGNoZXMgYWxsIHdoaXRlc3BhY2VzPz8/XG5cbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgZGF0YSA9ICcnXG4gICAgcmV0ID0gbmlsXG5cbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IGRhdGFcbiAgICAgIGlmIHNlcCAhPSAnJyAmJiAoYHNlcC4kJGlzX3JlZ2V4cGAgPyBAcmVhZF9idWZmZXIubWF0Y2g/KHNlcCkgOiBAcmVhZF9idWZmZXIuaW5jbHVkZT8oc2VwKSlcbiAgICAgICAgb3JpZ19idWZmZXIgPSBAcmVhZF9idWZmZXJcbiAgICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIuc3BsaXQoc2VwLCAyKVxuICAgICAgICByZXQgKz0gb3JpZ19idWZmZXJbcmV0Lmxlbmd0aCwgc2VwbGVuXSBpZiByZXQgIT0gb3JpZ19idWZmZXJcbiAgICAgICAgYnJlYWtcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBkYXRhID0gc3lzcmVhZF9ub3JhaXNlKHNlcCA9PSAnJyA/IDY1XzUzNiA6IDEpXG5cbiAgICB1bmxlc3MgcmV0XG4gICAgICByZXQsIEByZWFkX2J1ZmZlciA9IChAcmVhZF9idWZmZXIgfHwgJycpLCAnJ1xuICAgICAgcmV0ID0gbmlsIGlmIHJldCA9PSAnJ1xuICAgIGVuZFxuXG4gICAgaWYgcmV0XG4gICAgICBpZiBsaW1pdFxuICAgICAgICByZXQgPSByZXRbMC4uLmxpbWl0XVxuICAgICAgICBAcmVhZF9idWZmZXIgPSByZXRbbGltaXQuLi0xXSArIEByZWFkX2J1ZmZlclxuICAgICAgZW5kXG4gICAgICByZXQgPSByZXQuc3ViKC9cXHI/XFxuXFx6LywgJycpIGlmIG9wdHNbOmNob21wXVxuICAgICAgcmV0ID0gcmV0LnN1YigvXFxBW1xcclxcbl0rLywgJycpIGlmIG9yaWdfc2VwID09ICcnXG4gICAgZW5kXG5cbiAgICAkXyA9IHJldCBpZiBvcmlnX3NlcCA9PSBmYWxzZVxuICAgIHJldFxuICBlbmRcblxuICAjIFRoaXMgbWV0aG9kIGlzIHRvIGJlIG92ZXJsb2FkZWQsIG9yIHJlYWRfcHJvYyBjYW4gYmUgY2hhbmdlZFxuICBkZWYgc3lzcmVhZChpbnRlZ2VyKVxuICAgIGBzZWxmLnJlYWRfcHJvYyhpbnRlZ2VyKWAgfHwgYmVnaW5cbiAgICAgIEBlb2YgPSB0cnVlXG4gICAgICByYWlzZSBFT0ZFcnJvciwgJ2VuZCBvZiBmaWxlIHJlYWNoZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIHN5c3JlYWRfbm9yYWlzZShpbnRlZ2VyKVxuICAgIHN5c3JlYWQoaW50ZWdlcilcbiAgcmVzY3VlIEVPRkVycm9yXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiByZWFkcGFydGlhbChpbnRlZ2VyKVxuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0ID0gc3lzcmVhZChpbnRlZ2VyKVxuICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyICsgKHBhcnQgfHwgJycpLCAnJ1xuICAgIHJldCA9IG5pbCBpZiByZXQgPT0gJydcbiAgICByZXRcbiAgZW5kXG5cbiAgZGVmIHJlYWQoaW50ZWdlciA9IG5pbClcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydHMgPSAnJ1xuICAgIHJldCA9IG5pbFxuXG4gICAgYmVnaW5cbiAgICAgIEByZWFkX2J1ZmZlciArPSBwYXJ0c1xuICAgICAgaWYgaW50ZWdlciAmJiBAcmVhZF9idWZmZXIubGVuZ3RoID4gaW50ZWdlclxuICAgICAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclswLi4uaW50ZWdlcl0sIEByZWFkX2J1ZmZlcltpbnRlZ2VyLi4tMV1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgZW5kXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKGludGVnZXIgfHwgNjVfNTM2KVxuXG4gICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIsICcnXG4gICAgcmV0XG4gIGVuZFxuXG4gICMgRWFjaGVzXG5cbiAgZGVmIHJlYWRsaW5lcyhzZXBhcmF0b3IgPSAkLylcbiAgICBlYWNoX2xpbmUoc2VwYXJhdG9yKS50b19hXG4gIGVuZFxuXG4gIGRlZiBlYWNoKHNlcCA9ICQvLCAqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCwgc2VwLCAqYXJncyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSAocyA9IGdldHMoc2VwLCAqYXJncykpXG4gICAgICB5aWVsZChzKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBlYWNoX2xpbmUgZWFjaFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9ieXRlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0Ynl0ZSlcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jaGFyIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0YylcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQ2xvc2VkbmVzc1xuXG4gIGRlZiBjbG9zZVxuICAgIEBjbG9zZWQgPSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VfcmVhZFxuICAgIGlmIEBjbG9zZWQgPT0gOndyaXRlXG4gICAgICBAY2xvc2VkID0gOmJvdGhcbiAgICBlbHNlXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlX3dyaXRlXG4gICAgaWYgQGNsb3NlZCA9PSA6cmVhZFxuICAgICAgQGNsb3NlZCA9IDpib3RoXG4gICAgZWxzZVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2VkP1xuICAgIEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZF9yZWFkP1xuICAgIEBjbG9zZWQgPT0gOnJlYWQgfHwgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VkX3dyaXRlP1xuICAgIEBjbG9zZWQgPT0gOndyaXRlIHx8IEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgY2hlY2tfd3JpdGFibGVcbiAgICBpZiBjbG9zZWRfd3JpdGU/XG4gICAgICByYWlzZSBJT0Vycm9yLCAnbm90IG9wZW5lZCBmb3Igd3JpdGluZydcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgY2hlY2tfcmVhZGFibGVcbiAgICBpZiBjbG9zZWRfcmVhZD9cbiAgICAgIHJhaXNlIElPRXJyb3IsICdub3Qgb3BlbmVkIGZvciByZWFkaW5nJ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5TVERJTiAgPSAkc3RkaW4gID0gSU8ubmV3KDAsICdyJylcblNURE9VVCA9ICRzdGRvdXQgPSBJTy5uZXcoMSwgJ3cnKVxuU1RERVJSID0gJHN0ZGVyciA9IElPLm5ldygyLCAndycpXG5cbmB2YXIgY29uc29sZSA9IE9wYWwuZ2xvYmFsLmNvbnNvbGVgXG5TVERPVVQud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZG91dCkgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRvdXQud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS5sb2cocyl9YFxuU1RERVJSLndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRlcnIpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3RkZXJyLndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUud2FybihzKX1gXG5cblNURElOLnJlYWRfcHJvYyA9IGBmdW5jdGlvbihzKSB7IHZhciBwID0gcHJvbXB0KCk7IGlmIChwICE9PSBudWxsKSByZXR1cm4gcCArIFwiXFxuXCI7IHJldHVybiBuaWw7IH1gXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpJTz4iLCIwIiwiMSIsIjIiLCIzIiwiNCIsImluaXRpYWxpemUiLCJmZCIsImZsYWdzIiwiQGZkIiwiQGZsYWdzIiwiQGVvZiIsIiRyZXRfb3JfMSIsImluY2x1ZGU/IiwibWF0Y2g/IiwiISIsIkBjbG9zZWQiLCIkcmV0X29yXzIiLCJmaWxlbm8iLCJ0dHk/Iiwic2VsZiIsImF0dHJfYWNjZXNzb3IiLCJ3cml0ZSIsInN0cmluZyIsInNpemUiLCJhdHRyX3JlYWRlciIsImZsdXNoIiwiPDwiLCJwcmludCIsIlN0cmluZyIsIiQsIiwicHV0cyIsImNob21wIiwiJC8iLCJnZXRjIiwiQHJlYWRfYnVmZmVyIiwiJHJldF9vcl8zIiwicGFydHMiLCIrIiwiIT0iLCJyZXQiLCJbXSIsIi0xIiwic3lzcmVhZF9ub3JhaXNlIiwiZ2V0Ynl0ZSIsInJlYWRieXRlIiwicmVhZGNoYXIiLCJvcmQiLCIkcmV0X29yXzQiLCJyYWlzZSIsIkVPRkVycm9yIiwicmVhZGxpbmUiLCIkcmV0X29yXzUiLCJnZXRzIiwiYXJncyIsInNlcCIsImxpbWl0Iiwib3B0cyIsIiRyZXRfb3JfNiIsIiRyZXRfb3JfNyIsIiRyZXRfb3JfOCIsIj09IiwiJHJldF9vcl85Iiwib3JpZ19zZXAiLCIkcmV0X29yXzEwIiwidG9fc3RyIiwic2VwbGVuIiwiJHJldF9vcl8xMSIsImRhdGEiLCIkcmV0X29yXzEyIiwib3JpZ19idWZmZXIiLCJzcGxpdCIsImxlbmd0aCIsIjY1NTM2IiwiJHJldF9vcl8xMyIsInN1YiIsIiRfIiwic3lzcmVhZCIsImludGVnZXIiLCIkcmV0X29yXzE0IiwicmVhZHBhcnRpYWwiLCIkcmV0X29yXzE1IiwicGFydCIsIiRyZXRfb3JfMTYiLCJyZWFkIiwiJHJldF9vcl8xNyIsIiRyZXRfb3JfMTkiLCI+IiwiJHJldF9vcl8xOCIsInJlYWRsaW5lcyIsInNlcGFyYXRvciIsImVhY2hfbGluZSIsInRvX2EiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJzIiwiZWFjaF9ieXRlIiwiZWFjaF9jaGFyIiwiY2xvc2UiLCJjbG9zZV9yZWFkIiwiY2xvc2Vfd3JpdGUiLCJjbG9zZWQ/IiwiY2xvc2VkX3JlYWQ/IiwiJHJldF9vcl8yMCIsImNsb3NlZF93cml0ZT8iLCIkcmV0X29yXzIxIiwiY2hlY2tfd3JpdGFibGUiLCJJT0Vycm9yIiwiY2hlY2tfcmVhZGFibGUiLCIkc3RkaW4iLCJJTyIsIm5ldyIsIiRzdGRvdXQiLCIkc3RkZXJyIiwiJHdyaXRlciIsIndyaXRlX3Byb2M9IiwiU1RET1VUIiwiLSIsIlNUREVSUiIsInJlYWRfcHJvYz0iLCJTVERJTiJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtF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cEgsd0lBdFNyQjtFQXNTTXFILE1BQU5DLHNCQUFNRCxlQUFBQSxFQXRTTixVQUFBRCxPQUFBLENBc1NNQztFQXRTTkQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUFwSCxRQUFBLENBQUF1SCxFQUFBcEgsQ0FBQW9ILENBQUE7O0VBQUFILFVBQUEsQ0F1U3FCcEgseUlBdlNyQjtFQXVTTXFILE1BQU5HLHNCQUFNSCxlQUFBQSxFQXZTTixVQUFBRCxPQUFBLENBdVNNQztFQXZTTkQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUFwSCxRQUFBLENBQUF1SCxFQUFBcEgsQ0FBQW9ILENBQUE7O0VBQUFILFVBQUEsQ0F5U21CcEgsOEVBelNuQjtFQXlTS3lILE1BQUxDLHFCQUFLRCxjQUFBQSxFQXpTTCxVQUFBTCxPQUFBLENBeVNLSztFQXpTTHpILE9BQUFvSCxPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQXBILFFBQUEsQ0FBQXVILEVBQUFwSCxDQUFBb0gsQ0FBQTtBQUFBdkg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwMTU3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9yZWdleHBfYW5jaG9ycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgT3BhbFxuICBSRUdFWFBfU1RBUlQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnXicgOiAnXFxBJ1xuICBSRUdFWFBfRU5EID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gJyQnIDogJ1xceidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyRiAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UgKyAhXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDQwICg6Ozw9Pj9AIGNoYXJzKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGJlZ2dpbmluZyBvciBtaWRkbGUgb2YgaXRzIG5hbWVcbiAgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyMCAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UpXG4gICMgXFx1MDAyMiAtIFxcdTAwMkYgKFwiIyQlJicoKSorLC0uLyBjaGFycylcbiAgIyBcXHUwMDNBIC0gXFx1MDAzRSAoOjs8PT4gY2hhcnMpXG4gICMgXFx1MDA0MCAgICAgICAgICAoQCBjaGFyKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGVuZCBvZiBpdHMgbmFtZVxuICAjIEluIGZhY3QsIEZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTID0gRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICsgXFx1MDAyMSAoJz8nKSArIFxcdTAwM0YgKCchJylcbiAgRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICAgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMi1cXHUwMDJGXFx1MDAzQS1cXHUwMDNFXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIElOTElORV9JREVOVElGSUVSX1JFR0VYUCA9IFJlZ2V4cC5uZXcoXCJbXiN7Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlN9XSpbXiN7Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTfV1cIilcblxuICAjIEZvciBjb25zdGFudHMgcnVsZXMgYXJlIHByZXR0eSBtdWNoIHRoZSBzYW1lLCBidXQgJzonIGlzIGFsbG93ZWQgYW5kICc/IScgYXJlIG5vdC5cbiAgIyBQbHVzIGl0IG1heSBzdGFydCB3aXRoIGEgJzo6JyB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29uc3RhbnQgY29tZXMgZnJvbSB0b3BsZXZlbC5cbiAgRk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMS1cXHUwMDJGXFx1MDAzQi1cXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIENPTlNUX05BTUVfUkVHRVhQID0gUmVnZXhwLm5ldyhcIiN7UkVHRVhQX1NUQVJUfSg6Oik/W0EtWl1bXiN7Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlN9XSoje1JFR0VYUF9FTkR9XCIpXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsIlJlZ2V4cCIsIm5ldyIsIkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTIiwiRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTIiwiUkVHRVhQX1NUQVJUIiwiRk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMiLCJSRUdFWFBfRU5EIl0sIm1hcHBpbmdzIjoiQUFBQUEsc0RBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLDRDQUF1Q0EsR0FBdkM7SUFDQSwwQ0FBcUNBLEdBQXJDO0lBU0EsbUVBQXNDQSxxRUFBdEM7SUFZQSxpRUFBc0NBLDJGQUF0QztJQUNBLHdEQUEyQkMsc0JBQU1DLEtBQUFBLENBQUssRUFBQSxHQUFDRixJQUFELEdBQUEsQ0FBS0csbURBQUwsQ0FBQSxHQUF5Q0gsTUFBekMsR0FBQSxDQUErQ0ksaURBQS9DLENBQUEsR0FBaUZKLEdBQXRGRSxDQUFqQztJQUlBLDBEQUE2QkYsMkZBQTdCO0lBQ0FBLE9BQUEsaURBQW9CQyxzQkFBTUMsS0FBQUEsQ0FBSyxFQUFBLEdBQUEsQ0FBR0csNEJBQUgsQ0FBQSxHQUFnQkwsY0FBaEIsR0FBQSxDQUE4Qk0sMENBQTlCLENBQUEsR0FBeUROLElBQXpELEdBQUEsQ0FBNkRPLDBCQUE3RCxDQUFMTCxDQUExQjtFQTdCRkYsR0FBQUEsV0FBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwMTc3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9taW5pLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcblxucmVxdWlyZSAnY29yZWxpYi9uaWwnXG5yZXF1aXJlICdjb3JlbGliL2Jvb2xlYW4nXG5yZXF1aXJlICdjb3JlbGliL3N0cmluZydcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYXRvcidcbnJlcXVpcmUgJ2NvcmVsaWIvYXJyYXknXG5yZXF1aXJlICdjb3JlbGliL2hhc2gnXG5yZXF1aXJlICdjb3JlbGliL251bWJlcidcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZ2UnXG5yZXF1aXJlICdjb3JlbGliL3Byb2MnXG5yZXF1aXJlICdjb3JlbGliL21ldGhvZCdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xucmVxdWlyZSAnY29yZWxpYi92YXJpYWJsZXMnXG5yZXF1aXJlICdjb3JlbGliL2lvJ1xucmVxdWlyZSAnb3BhbC9yZWdleHBfYW5jaG9ycydcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQSw0Q0FBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixXQUFSRTtFQUVBRCxJQUFBQyxTQUFBQSxDQUFRRixhQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGVBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixjQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLG1CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixZQUFSRTtFQUNBRixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7QUFqQkFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDIwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWFpbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWYgc2VsZi50b19zXG4gICdtYWluJ1xuZW5kXG5cbmRlZiBzZWxmLmluY2x1ZGUobW9kKVxuICBPYmplY3QuaW5jbHVkZSBtb2RcbmVuZFxuXG5kZWYgc2VsZi5hdXRvbG9hZCgqYXJncylcbiAgT2JqZWN0LmF1dG9sb2FkKCphcmdzKVxuZW5kXG5cbiMgQ29tcGlsZXIgb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG5kZWYgc2VsZi51c2luZyhtb2QpXG4gIHJhaXNlICdtYWluLnVzaW5nIGlzIHBlcm1pdHRlZCBvbmx5IGF0IHRvcGxldmVsJ1xuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInRvX3MiLCJzZWxmIiwiaW5jbHVkZSIsIm1vZCIsIk9iamVjdCIsImF1dG9sb2FkIiwiYXJncyIsInVzaW5nIiwicmFpc2UiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxVQUFJQyxJQUFKRCxXQUFBQSxVQUFBQSxnQkFBQUE7QUFBQUEsSUFBQUE7O0lBQ0VBLE9BQUFBO0VBREZBLENBQUFBLHFCQUFBQTtFQUlBRSxVQUFJRCxJQUFKQyxjQUFBQSxhQUFBQSxtQkFBaUJDLEdBQWpCRDtBQUFBQSxJQUFBQTs7SUFDRUEsT0FBQUUsc0JBQU1GLFNBQUFBLENBQVNDLEdBQVREO0VBRFJBLENBQUFBLHdCQUFBQTtFQUlBRyxVQUFJSixJQUFKSSxlQUFBQSxjQUFBQSxvQkFSQSxFQVFBQTtBQUFBQSxJQUFBQTs7OztJQVJBOztJQVFrQjtJQUNoQkEsT0FBTUEsTUFBTkQsc0JBQU1DLFlBQUFBLEVBQVUsVUFBQ0MsSUFBRCxDQUFWRDtFQURSQSxDQUFBQSwwQkFBQUE7RUFLQU4sT0FBQVEsQ0FBQUEsVUFBSU4sSUFBSk0sWUFBQUEsV0FBQUEsaUJBQWVKLEdBQWZJO0FBQUFBLElBQUFBOztJQUNFQSxPQUFBTixJQUFBTyxPQUFBQSxDQUFNRCwwQ0FBTkM7RUFERkQsQ0FBQUEsc0JBQUFBLENBQUFBO0FBYkFSOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDIzMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIva2VybmVsL2Zvcm1hdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBmb3JtYXQoZm9ybWF0X3N0cmluZywgKmFyZ3MpXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMSAmJiBhcmdzWzBdLnJlc3BvbmRfdG8/KDp0b19hcnkpXG4gICAgICBhcnkgPSBPcGFsLmNvZXJjZV90bz8oYXJnc1swXSwgQXJyYXksIDp0b19hcnkpXG4gICAgICBhcmdzID0gYXJ5LnRvX2EgdW5sZXNzIGFyeS5uaWw/XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAvL3VzZWQgZm9yIHNsaWNpbmc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSAwLFxuICAgICAgICAgIGVuZF9zbGljZSxcbiAgICAgICAgICAvL3VzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nOlxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuID0gZm9ybWF0X3N0cmluZy5sZW5ndGgsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nIGZpZWxkIHZhbHVlczpcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlZyBhbmQgJUcgZmllbGRzOlxuICAgICAgICAgIGV4cG9uZW50LFxuICAgICAgICAgIC8vdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aWR0aCBhbmQgcHJlY2lzaW9uOlxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAvL3VzZWQgZm9yIGhvbGRpbmcgdGVtcG9yYXJ5IHZhbHVlczpcbiAgICAgICAgICB0bXBfbnVtLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAle30gYW5kICU8PiBmaWxlZHM6XG4gICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5LFxuICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhcixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWIsICVCLCAlbywgJXgsIGFuZCAlWCBmaWVsZHM6XG4gICAgICAgICAgYmFzZV9udW1iZXIsXG4gICAgICAgICAgYmFzZV9wcmVmaXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCxcbiAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0LFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgbmV4dF9hcmcsXG4gICAgICAgICAgc2VxX2FyZ19udW0gPSAxLFxuICAgICAgICAgIHBvc19hcmdfbnVtID0gMCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgZmxhZ3M6XG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgRk5PTkUgID0gMCxcbiAgICAgICAgICBGU0hBUlAgPSAxLFxuICAgICAgICAgIEZNSU5VUyA9IDIsXG4gICAgICAgICAgRlBMVVMgID0gNCxcbiAgICAgICAgICBGWkVSTyAgPSA4LFxuICAgICAgICAgIEZTUEFDRSA9IDE2LFxuICAgICAgICAgIEZXSURUSCA9IDMyLFxuICAgICAgICAgIEZQUkVDICA9IDY0LFxuICAgICAgICAgIEZQUkVDMCA9IDEyODtcblxuICAgICAgZnVuY3Rpb24gQ0hFQ0tfRk9SX0ZMQUdTKCkge1xuICAgICAgICBpZiAoZmxhZ3MmRldJRFRIKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgd2lkdGgnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnZmxhZyBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9XSURUSCgpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3aWR0aCBnaXZlbiB0d2ljZSd9IH1cbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3aWR0aCBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9OVEhfQVJHKG51bSkge1xuICAgICAgICBpZiAobnVtID49IGFyZ3MubGVuZ3RoKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvbyBmZXcgYXJndW1lbnRzJ30gfVxuICAgICAgICByZXR1cm4gYXJnc1tudW1dO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTkVYVF9BUkcoKSB7XG4gICAgICAgIHN3aXRjaCAocG9zX2FyZ19udW0pIHtcbiAgICAgICAgY2FzZSAtMTogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBudW1iZXJlZFwifSAvLyByYWlzZVxuICAgICAgICBjYXNlIC0yOiAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5udW1iZXJlZCgje2BzZXFfYXJnX251bWB9KSBtaXhlZCB3aXRoIG5hbWVkXCJ9IC8vIHJhaXNlXG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSBzZXFfYXJnX251bSsrO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcocG9zX2FyZ19udW0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX1BPU19BUkcobnVtKSB7XG4gICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibnVtYmVyZWQoI3tgbnVtYH0pIGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0yKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW0gPCAxKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgaW5kZXggLSAje2BudW1gfSRcIn1cbiAgICAgICAgfVxuICAgICAgICBwb3NfYXJnX251bSA9IC0xO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcobnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9BUkcoKSB7XG4gICAgICAgIHJldHVybiAobmV4dF9hcmcgPT09IHVuZGVmaW5lZCA/IEdFVF9ORVhUX0FSRygpIDogbmV4dF9hcmcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBSRUFEX05VTShsYWJlbCkge1xuICAgICAgICB2YXIgbnVtLCBzdHIgPSAnJztcbiAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUqWzAtOV0nfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpIDwgNDggfHwgZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpID4gNTcpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KHN0ciwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAobnVtID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tgbGFiZWxgfSB0b28gYmlnXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU1fQUZURVJfQVNURVIobGFiZWwpIHtcbiAgICAgICAgdmFyIGFyZywgbnVtID0gUkVBRF9OVU0obGFiZWwpO1xuICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgYXJnID0gR0VUX1BPU19BUkcobnVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmcgPSBHRVRfTkVYVF9BUkcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tgYXJnYC50b19pbnR9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnKTsgaSAhPT0gLTE7IGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnLCBpKSkge1xuICAgICAgICBzdHIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZmxhZ3MgPSBGTk9ORTtcbiAgICAgICAgd2lkdGggPSAtMTtcbiAgICAgICAgcHJlY2lzaW9uID0gLTE7XG4gICAgICAgIG5leHRfYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGVuZF9zbGljZSA9IGk7XG5cbiAgICAgICAgaSsrO1xuXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSBpO1xuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xcMCc6XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0X3NlcXVlbmNlOiBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuXG4gICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTUEFDRTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGU0hBUlA7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlBMVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZaRVJPO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICB0bXBfbnVtID0gUkVBRF9OVU0oJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgaWYgKGkgKyAyID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmV4dF9hcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ2YWx1ZSBnaXZlbiB0d2ljZSAtICUje2B0bXBfbnVtYH0kXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV4dF9hcmcgPSBHRVRfUE9TX0FSRyh0bXBfbnVtKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQ0hFQ0tfRk9SX1dJRFRIKCk7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgICAgd2lkdGggPSB0bXBfbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FzZSAnXFx7JzpcbiAgICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhciA9IChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJzwnID8gJz4nIDogJ1xcfScpO1xuICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ID0gJyc7XG5cbiAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBuYW1lIC0gdW5tYXRjaGVkIHBhcmVudGhlc2lzJ31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGNsb3NpbmdfYnJhY2VfY2hhcikge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvc19hcmdfbnVtID4gMCkge1xuICAgICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIG51bWJlcmVkXCJ9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc19hcmdfbnVtID0gLTI7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gdW5kZWZpbmVkIHx8ICFhcmdzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnb25lIGhhc2ggcmVxdWlyZWQnfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5leHRfYXJnID0gI3tgYXJnc1swXWAuZmV0Y2goYGhhc2hfcGFyYW1ldGVyX2tleWApfTtcblxuICAgICAgICAgICAgICAgIGlmIChjbG9zaW5nX2JyYWNlX2NoYXIgPT09ICc+Jykge1xuICAgICAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSBuZXh0X2FyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSArPSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJhaXNlXG5cbiAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIENIRUNLX0ZPUl9XSURUSCgpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgd2lkdGggPSBSRUFEX05VTV9BRlRFUl9BU1RFUignd2lkdGgnKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdwcmVjaXNpb24gZ2l2ZW4gdHdpY2UnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MgfD0gRlBSRUN8RlBSRUMwO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIGZsYWdzICY9IH5GUFJFQztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBSRUFEX05VTSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIGFyZyA9ICN7SW50ZWdlcihgR0VUX0FSRygpYCl9O1xuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0ciA9IGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDI7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzBiJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMSsvO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0ID0gJzEnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDg7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzAnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL14zPzcrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICc3JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDE2O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcweCc7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXmYrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICdmJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmcgPSAje0ludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSAtICgoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgPyBiYXNlX3ByZWZpeC5sZW5ndGggOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxIC0gKGZsYWdzJkZTSEFSUCA/IDIgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKGFyZyA+Pj4gMCkudG9TdHJpbmcoYmFzZV9udW1iZXIpLnJlcGxhY2UoYmFzZV9uZWdfemVyb19yZWdleCwgYmFzZV9uZWdfemVyb19kaWdpdCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24gLSAyKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDIgLSAoZmxhZ3MmRlNIQVJQID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gYmFzZV9uZWdfemVyb19kaWdpdCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIGFyZyA9ICN7RmxvYXQoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCB8fCBpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSBJbmZpbml0eSAmJiAhaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnSW5mJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9GaXhlZChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQoc3RyLnNwbGl0KCdlJylbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGV4cG9uZW50IDwgLTQgfHwgZXhwb25lbnQgPj0gKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvUHJlY2lzaW9uKHByZWNpc2lvbiA9PT0gLTEgPyAoZmxhZ3MmRlNIQVJQID8gNiA6IHVuZGVmaW5lZCkgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgYXJnICE9PSAtSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFtlRV1bLStdPykoWzAtOV0pJC8sICckMTAkMicpO1xuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgYmVjYXVzZSB0aGVyZSBhcmUgbm8gc3BlY3MgZm9yIHRoaXMgZmllbGQgdHlwZS5cbiAgICAgICAgICAgICN7cmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ2BBYCBhbmQgYGFgIGZvcm1hdCBmaWVsZCB0eXBlcyBhcmUgbm90IGltcGxlbWVudGVkIGluIE9wYWwgeWV0J31cbiAgICAgICAgICAgIC8vIHJhaXNlXG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCRjb2VyY2VfdG8oYXJnLCAje0ludGVnZXJ9LCAndG9faW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnJWMgcmVxdWlyZXMgYSBjaGFyYWN0ZXInfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC5pbnNwZWN0fTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLnRvX3N9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSN7YGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UsIGVuZF9zbGljZSkgKyBzdHI7XG4gICAgICAgIGJlZ2luX3NsaWNlID0gaSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgjeyRERUJVR30gJiYgcG9zX2FyZ19udW0gPj0gMCAmJiBzZXFfYXJnX251bSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3IgZm9ybWF0IHN0cmluZyd9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgKyBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNwcmludGYgZm9ybWF0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiZm9ybWF0IiwiZm9ybWF0X3N0cmluZyIsIiRyZXRfb3JfMSIsImFyZ3MiLCJsZW5ndGgiLCI9PSIsIjEiLCJbXSIsIjAiLCJyZXNwb25kX3RvPyIsImFyeSIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCJuaWw/IiwidG9fYSIsInNlbGYiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0b19pbnQiLCJmZXRjaCIsIkludGVnZXIiLCJGbG9hdCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19hcnkiLCJ0b19zdHIiLCJpbnNwZWN0IiwidG9fcyIsIiRERUJVRyJdLCJtYXBwaW5ncyI6IkFBQUFBLHdEQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7O0FBQ0VDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVdDLGFBQUQsRUFIWixFQUdFRDtBQUFBQSxNQUFBQTtBQUFBQTs7OztNQUhGOztNQUc0QjtNQUN4QixJQUFBLFFBQUcsYUFBQSxJQUFBLFFBSlBFLENBQUFBLFlBSU9DLElBQUlDLFFBQUFBLENBQUFBLENBQVFDLE9BQUFBLENBQUdDLENBQUhELENBSm5CSCxDQUlPLENBQUE7UUFBb0JGLE9BQUFHLElBQUlJLE9BQUFBLENBQUNDLENBQURELENBQUdFLGdCQUFBQSxDQUFhLFFBQWJBO01BQTNCO1FBSlBULE9BQUE7TUFJTyxDQUFBLGtCQUFILENBQUE7O1FBQ0VVLE1BQU1DLG9CQUFJQyxlQUFBQSxDQUFZVCxJQUFJSSxPQUFBQSxDQUFDQyxDQUFERCxDQUFwQixFQUF5Qk0scUJBQXpCLEVBQWdDLFFBQTVCRDtRQUNWLElBQUEsUUFBdUJGLEdBQUdJLFNBQUFBLENBQUFBLENBQTFCLENBQUE7UUFBQTtVQUFBWCxPQUFPTyxHQUFHSyxNQUFBQSxDQUFBQTtRQUFWLEVBRkY7O0FBTUpmO0FBQ0FBO0FB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dCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIEVuY29kaW5nXG4gIGRlZiBzZWxmLnJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxuICAgIG5hbWVzID0gW25hbWVdICsgKG9wdGlvbnNbOmFsaWFzZXNdIHx8IFtdKVxuICAgIGFzY2lpID0gb3B0aW9uc1s6YXNjaWldIHx8IGZhbHNlXG4gICAgZHVtbXkgPSBvcHRpb25zWzpkdW1teV0gfHwgZmFsc2VcblxuICAgIGlmIG9wdGlvbnNbOmluaGVyaXRzXVxuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zWzppbmhlcml0c10uY2xvbmVcbiAgICAgIGVuY29kaW5nLmluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBlbHNlXG4gICAgICBlbmNvZGluZyA9IG5ldyhuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIGVuZFxuICAgIGVuY29kaW5nLmluc3RhbmNlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgIHJlZ2lzdGVyID0gYE9wYWwuZW5jb2RpbmdzYFxuICAgIG5hbWVzLmVhY2ggZG8gfGVuY29kaW5nX25hbWV8XG4gICAgICBjb25zdF9zZXQgZW5jb2RpbmdfbmFtZS50cignLScsICdfJyksIGVuY29kaW5nXG4gICAgICByZWdpc3Rlci5KU1tlbmNvZGluZ19uYW1lXSA9IGVuY29kaW5nXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZpbmQobmFtZSlcbiAgICByZXR1cm4gZGVmYXVsdF9leHRlcm5hbCBpZiBuYW1lID09IDpkZWZhdWx0X2V4dGVybmFsXG4gICAgYHJldHVybiBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSlgXG4gIGVuZFxuXG4gIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpkZWZhdWx0X2V4dGVybmFsXG5cbiAgYXR0cl9yZWFkZXIgOm5hbWUsIDpuYW1lc1xuXG4gIGRlZiBpbml0aWFsaXplKG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgQG5hbWUgID0gbmFtZVxuICAgIEBuYW1lcyA9IG5hbWVzXG4gICAgQGFzY2lpID0gYXNjaWlcbiAgICBAZHVtbXkgPSBkdW1teVxuICBlbmRcblxuICBkZWYgYXNjaWlfY29tcGF0aWJsZT9cbiAgICBAYXNjaWlcbiAgZW5kXG5cbiAgZGVmIGR1bW15P1xuICAgIEBkdW1teVxuICBlbmRcblxuICBkZWYgYmluYXJ5P1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgQG5hbWVcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RW5jb2Rpbmc6I3tAbmFtZX0jeycgKGR1bW15KScgaWYgQGR1bW15fT5cIlxuICBlbmRcblxuICAjIG1ldGhvZHMgdG8gaW1wbGVtZW50IHBlciBlbmNvZGluZ1xuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgICV4e1xuICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoIShjaGFyY29kZSA+PSAweEQ4MDAgJiYgY2hhcmNvZGUgPD0gMHhEQkZGKSkge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBsb3dfc3Vycm9nYXRlID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaHIgPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPj0gMHhEQzAwICYmIGNoYXJjb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIGxvd19zdXJyb2dhdGUgPSBjaHI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPj0gMHhEODAwICYmIGNoYXJjb2RlIDw9IDB4REJGRikge1xuICAgICAgICAgIGNociA9IGxvd19zdXJyb2dhdGUgKyBjaHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZy5lbmNvZGluZy5uYW1lICE9IFwiVVRGLThcIikge1xuICAgICAgICAgIGNociA9IG5ldyBTdHJpbmcoY2hyKTtcbiAgICAgICAgICBjaHIuZW5jb2RpbmcgPSBzdHJpbmcuZW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGNocik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIEVuY29kaW5nRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgQ29tcGF0aWJpbGl0eUVycm9yIDwgRW5jb2RpbmdFcnJvcjsgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAvLyBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iL2Y1MmRmZmQ5ZGYwNDQ1YjkzYzBjOTA2NWMyZjhmMGY0NmIyYzcyOWEvaW5kZXguanMjTDE5NTQtTDIwMzJcbiAgICAgIHZhciB1bml0cyA9IEluZmluaXR5O1xuICAgICAgdmFyIGNvZGVQb2ludDtcbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5jb2RlIHV0ZjhcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50YH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiB8IDB4QzBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4QyB8IDB4RTBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW52YWxpZCBjb2RlIHBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgc3RyaW5nLmJ5dGVzLmxlbmd0aFxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2TEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoICogMmBcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkJFJywgaW5oZXJpdHM6IEVuY29kaW5nOjpVVEZfMTZMRSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aCAqIDRgXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMzJCRScsIGluaGVyaXRzOiBFbmNvZGluZzo6VVRGXzMyTEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdBU0NJSS04QklUJywgYWxpYXNlczogWydCSU5BUlknXSwgYXNjaWk6IHRydWUgZG9cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IG5ldyBTdHJpbmcoc3RyaW5nLmNoYXJBdChpKSk7XG4gICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgI3t5aWVsZCBgY2hyYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGJpbmFyeT9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdJU08tODg1OS0xJywgYWxpYXNlczogWydJU084ODU5LTEnXSwgYXNjaWk6IHRydWUsIGluaGVyaXRzOiBFbmNvZGluZzo6QVNDSUlfOEJJVFxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VTLUFTQ0lJJywgYWxpYXNlczogWydBU0NJSSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IEVuY29kaW5nOjpBU0NJSV84QklUXG5cbmNsYXNzIFN0cmluZ1xuICBhdHRyX3JlYWRlciA6ZW5jb2RpbmdcbiAgYXR0cl9yZWFkZXIgOmludGVybmFsX2VuY29kaW5nXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdieXRlcycsIG5pbClgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdlbmNvZGluZycsICN7RW5jb2Rpbmc6OlVURl84fSlgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdpbnRlcm5hbF9lbmNvZGluZycsICN7RW5jb2Rpbmc6OlVURl84fSlgXG5cbiAgZGVmIGJcbiAgICBkdXAuZm9yY2VfZW5jb2RpbmcoJ2JpbmFyeScpXG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZVxuICAgIEBpbnRlcm5hbF9lbmNvZGluZy5ieXRlc2l6ZShzZWxmKVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfYnl0ZSkgeyBieXRlc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEBpbnRlcm5hbF9lbmNvZGluZy5lYWNoX2J5dGUoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYnl0ZXNcbiAgICAjIFJFTUlORDogcmVxdWlyZWQgd2hlbiBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBvdGhlcndpc2UgdGhlIGZvbGxvd2luZyBlcnJvciB3aWxsIGJlIHRocm93bjpcbiAgICAjIENhbm5vdCBjcmVhdGUgcHJvcGVydHkgJ2J5dGVzJyBvbiBzdHJpbmcgJ2FiYydcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICN7YG5ldyBTdHJpbmcoc2VsZilgLmVhY2hfYnl0ZS50b19hfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBAYnl0ZXMgfHw9IGVhY2hfYnl0ZS50b19hXG4gICAgQGJ5dGVzLmR1cFxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfY2hhcikgeyBsZW5ndGggfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAZW5jb2RpbmcuZWFjaF9jaGFyKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNoYXJzKCZibG9jaylcbiAgICByZXR1cm4gZWFjaF9jaGFyLnRvX2EgdW5sZXNzIGJsb2NrXG5cbiAgICBlYWNoX2NoYXIoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZWFjaF9jb2RlcG9pbnQoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jb2RlcG9pbnQgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5jb2RlUG9pbnRBdChpKWB9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjb2RlcG9pbnRzKCZibG9jaylcbiAgICAjIElmIGEgYmxvY2sgaXMgZ2l2ZW4sIHdoaWNoIGlzIGEgZGVwcmVjYXRlZCBmb3JtLCB3b3JrcyB0aGUgc2FtZSBhcyBlYWNoX2NvZGVwb2ludC5cbiAgICByZXR1cm4gZWFjaF9jb2RlcG9pbnQoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgICBlYWNoX2NvZGVwb2ludC50b19hXG4gIGVuZFxuXG4gIGRlZiBlbmNvZGUoZW5jb2RpbmcpXG4gICAgYE9wYWwuZW5jKHNlbGYsIGVuY29kaW5nKWBcbiAgZW5kXG5cbiAgZGVmIGZvcmNlX2VuY29kaW5nKGVuY29kaW5nKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGY7XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc3RyLmVuY29kaW5nKSB7IHJldHVybiBzdHI7IH1cblxuICAgICAgZW5jb2RpbmcgPSAje09wYWwuY29lcmNlX3RvIShlbmNvZGluZywgU3RyaW5nLCA6dG9fcyl9O1xuICAgICAgZW5jb2RpbmcgPSAje0VuY29kaW5nLmZpbmQoZW5jb2RpbmcpfTtcblxuICAgICAgaWYgKGVuY29kaW5nID09PSBzdHIuZW5jb2RpbmcpIHsgcmV0dXJuIHN0cjsgfVxuXG4gICAgICBzdHIgPSBPcGFsLnNldF9lbmNvZGluZyhzdHIsIGVuY29kaW5nKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlKGlkeClcbiAgICBzdHJpbmdfYnl0ZXMgPSBieXRlc1xuICAgIGlkeCA9IE9wYWwuY29lcmNlX3RvIShpZHgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgcmV0dXJuIGlmIHN0cmluZ19ieXRlcy5sZW5ndGggPCBpZHhcblxuICAgIHN0cmluZ19ieXRlc1tpZHhdXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgJXtcbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBvdGhlci5lbmNvZGluZztcbiAgICAgIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcgPSBvdGhlci5pbnRlcm5hbF9lbmNvZGluZztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgIyBzdHViXG4gIGRlZiB2YWxpZF9lbmNvZGluZz9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLmRlZmF1bHRfZXh0ZXJuYWwgPSBfX0VOQ09ESU5HX19cbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW5jb2Rpbmc+IiwicmVnaXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsIm5hbWVzIiwiKyIsIiRyZXRfb3JfMSIsIltdIiwiYXNjaWkiLCIkcmV0X29yXzIiLCJkdW1teSIsIiRyZXRfb3JfMyIsImVuY29kaW5nIiwiY2xvbmUiLCJpbml0aWFsaXplIiwibmV3IiwiYmxvY2tfZ2l2ZW4/IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImVhY2giLCJibG9jayBpbiByZWdpc3RlciIsImVuY29kaW5nX25hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlZ2lzdGVyIiwiY29uc3Rfc2V0IiwidHIiLCJmaW5kIiwiPT0iLCJkZWZhdWx0X2V4dGVybmFsIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJAZHVtbXkiLCJhc2NpaV9jb21wYXRpYmxlPyIsImR1bW15PyIsImJpbmFyeT8iLCJ0b19zIiwiaW5zcGVjdCIsImNoYXJzaXplIiwic3RyaW5nIiwiZWFjaF9jaGFyIiwiZWFjaF9ieXRlIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwiYnl0ZXNpemUiLCI8Y2xhc3M6RW5jb2RpbmdFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOkNvbXBhdGliaWxpdHlFcnJvcj4iLCJFbmNvZGluZ0Vycm9yIiwiRW5jb2RpbmciLCJibG9jayBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYnl0ZXMiLCJsZW5ndGgiLCJFbmNvZGluZzo6VVRGXzE2TEUiLCIwIiwiRW5jb2Rpbmc6OlVURl8zMkxFIiwiRW5jb2Rpbmc6OkFTQ0lJXzhCSVQiLCI8Y2xhc3M6U3RyaW5nPiIsIkVuY29kaW5nOjpVVEZfOCIsImIiLCJkdXAiLCJmb3JjZV9lbmNvZGluZyIsIkBpbnRlcm5hbF9lbmNvZGluZyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaF9ieXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2J5dGUiLCJ0b19hIiwiQGJ5dGVzIiwiJHJldF9vcl80IiwiYmxvY2sgaW4gZWFjaF9jaGFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2NoYXIiLCJAZW5jb2RpbmciLCJjaGFycyIsImVhY2hfY29kZXBvaW50IiwiY29kZXBvaW50cyIsImVuY29kZSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiZ2V0Ynl0ZSIsImlkeCIsInN0cmluZ19ieXRlcyIsIkludGVnZXIiLCI8IiwiaW5pdGlhbGl6ZV9jb3B5Iiwib3RoZXIiLCJ2YWxpZF9lbmNvZGluZz8iLCIkd3JpdGVyIiwiZGVmYXVsdF9leHRlcm5hbD0iLCItIiwiMSJdLCJtYXBwaW5ncyI6IkFBQUFBLDBEQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUVBQztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFQyxVQUFJSCxJQUFKRyxlQUFBQSx1QkFBQUEsb0JBQWtCQyxJQUFELEVBQU9DLE9BQXhCRjtBQUFBQSxNQUFB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UnhDLHdCQUFRd0MscUJBQUFBLEVBamFSLFVBQUFELE9BQUEsQ0FpYVFDO0VBamFSL0YsT0FBQThGLE9BQUEsQ0FBQUUsVUFBQUYsT0FBQSxDQUFBOUYsUUFBQSxDQUFBZ0csRUFBQUMsQ0FBQUQsQ0FBQTtBQUFBaEc7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxNDM1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYXRoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvclxuXG5tb2R1bGUgTWF0aFxuICBFICA9IGBNYXRoLkVgXG4gIFBJID0gYE1hdGguUElgXG5cbiAgRG9tYWluRXJyb3IgPSBDbGFzcy5uZXcoU3RhbmRhcmRFcnJvcilcblxuICBkZWYgc2VsZi5jaGVja2VkKG1ldGhvZCwgKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oYXJnc1swXSkgfHwgKGFyZ3MubGVuZ3RoID09IDIgJiYgaXNOYU4oYXJnc1sxXSkpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBNYXRoW21ldGhvZF0uYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICN7cmFpc2UgRG9tYWluRXJyb3IsIFwiTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcXFwiI3ttZXRob2R9XFxcIlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZsb2F0ISh2YWx1ZSlcbiAgICBGbG9hdCh2YWx1ZSlcbiAgcmVzY3VlIEFyZ3VtZW50RXJyb3JcbiAgICByYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7RmxvYXR9KWBcbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW50ZWdlciEodmFsdWUpXG4gICAgSW50ZWdlcih2YWx1ZSlcbiAgcmVzY3VlIEFyZ3VtZW50RXJyb3JcbiAgICByYWlzZSBgJHR5cGVfZXJyb3IodmFsdWUsICN7SW50ZWdlcn0pYFxuICBlbmRcblxuICBtb2R1bGVfZnVuY3Rpb25cblxuICBkZWYgYWNvcyh4KVxuICAgIE1hdGguY2hlY2tlZCA6YWNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFjb3NoYClcbiAgICAleHtcbiAgICAgIE1hdGguYWNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4IC0gMSkpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFjb3NoKHgpXG4gICAgTWF0aC5jaGVja2VkIDphY29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGFzaW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmFzaW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5hc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmFzaW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDphc2luaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGF0YW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOmF0YW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBhdGFuMih5LCB4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbjIsIE1hdGguZmxvYXQhKHkpLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguYXRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5hdGFuaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdGFuaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5jYnJ0YClcbiAgICAleHtcbiAgICAgIE1hdGguY2JydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC1NYXRoLmNicnQoLXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHIgID0geCxcbiAgICAgICAgICAgIGV4ID0gMDtcblxuICAgICAgICB3aGlsZSAociA8IDAuMTI1KSB7XG4gICAgICAgICAgciAqPSA4O1xuICAgICAgICAgIGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAociA+IDEuMCkge1xuICAgICAgICAgIHIgKj0gMC4xMjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoLTAuNDY5NDYxMTYgKiByICsgMS4wNzIzMDIpICogciArIDAuMzgxMjUxMztcblxuICAgICAgICB3aGlsZSAoZXggPCAwKSB7XG4gICAgICAgICAgciAqPSAwLjU7XG4gICAgICAgICAgZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChleCA+IDApIHtcbiAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuXG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNicnQoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNicnQsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBjb3MoeClcbiAgICBNYXRoLmNoZWNrZWQgOmNvcywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmNvc2hgKVxuICAgICV4e1xuICAgICAgTWF0aC5jb3NoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29zaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y29zaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmApXG4gICAgJXh7XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KE1hdGgsICdlcmYnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBBMSA9ICAwLjI1NDgyOTU5MixcbiAgICAgICAgICAgIEEyID0gLTAuMjg0NDk2NzM2LFxuICAgICAgICAgICAgQTMgPSAgMS40MjE0MTM3NDEsXG4gICAgICAgICAgICBBNCA9IC0xLjQ1MzE1MjAyNyxcbiAgICAgICAgICAgIEE1ID0gIDEuMDYxNDA1NDI5LFxuICAgICAgICAgICAgUCAgPSAgMC4zMjc1OTExO1xuXG4gICAgICAgIHZhciBzaWduID0gMTtcblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHggPSBNYXRoLmFicyh4KTtcblxuICAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBQICogeCk7XG4gICAgICAgIHZhciB5ID0gMS4wIC0gKCgoKChBNSAqIHQgKyBBNCkgKiB0KSArIEEzKSAqIHQgKyBBMikgKiB0ICsgQTEpICogdCAqIE1hdGguZXhwKC14ICogeCk7XG5cbiAgICAgICAgcmV0dXJuIHNpZ24gKiB5O1xuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmKHgpXG4gICAgTWF0aC5jaGVja2VkIDplcmYsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZjYClcbiAgICAleHtcbiAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2VyZmMnLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoeCksXG4gICAgICAgICAgICB0ID0gMS4wIC8gKDAuNSAqIHogKyAxLjApO1xuXG4gICAgICAgIHZhciBBMSA9IHQgKiAwLjE3MDg3Mjc3ICsgLTAuODIyMTUyMjMsXG4gICAgICAgICAgICBBMiA9IHQgKiBBMSArIDEuNDg4NTE1ODcsXG4gICAgICAgICAgICBBMyA9IHQgKiBBMiArIC0xLjEzNTIwMzk4LFxuICAgICAgICAgICAgQTQgPSB0ICogQTMgKyAwLjI3ODg2ODA3LFxuICAgICAgICAgICAgQTUgPSB0ICogQTQgKyAtMC4xODYyODgwNixcbiAgICAgICAgICAgIEE2ID0gdCAqIEE1ICsgMC4wOTY3ODQxOCxcbiAgICAgICAgICAgIEE3ID0gdCAqIEE2ICsgMC4zNzQwOTE5NixcbiAgICAgICAgICAgIEE4ID0gdCAqIEE3ICsgMS4wMDAwMjM2OCxcbiAgICAgICAgICAgIEE5ID0gdCAqIEE4LFxuICAgICAgICAgICAgQTEwID0gLXogKiB6IC0gMS4yNjU1MTIyMyArIEE5O1xuXG4gICAgICAgIHZhciBhID0gdCAqIE1hdGguZXhwKEExMCk7XG5cbiAgICAgICAgaWYgKHggPCAwLjApIHtcbiAgICAgICAgICByZXR1cm4gMi4wIC0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXJmYyh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXJmYywgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGV4cCh4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXhwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZnJleHAoeClcbiAgICB4ID0gTWF0aC5mbG9hdCEoeClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiBbTmFOLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ICAgPSBNYXRoLmZsb29yKE1hdGgubG9nKE1hdGguYWJzKHgpKSAvIE1hdGgubG9nKDIpKSArIDEsXG4gICAgICAgICAgZnJhYyA9IHggLyBNYXRoLnBvdygyLCBleCk7XG5cbiAgICAgIHJldHVybiBbZnJhYywgZXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGdhbW1hKG4pXG4gICAgbiA9IE1hdGguZmxvYXQhKG4pXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCB0LCB4LCB2YWx1ZSwgcmVzdWx0LCB0d29OLCB0aHJlZU4sIGZvdXJOLCBmaXZlTjtcblxuICAgICAgdmFyIEcgPSA0Ljc0MjE4NzU7XG5cbiAgICAgIHZhciBQID0gW1xuICAgICAgICAgMC45OTk5OTk5OTk5OTk5OTcwOTE4MixcbiAgICAgICAgIDU3LjE1NjIzNTY2NTg2MjkyMzUxNyxcbiAgICAgICAgLTU5LjU5Nzk2MDM1NTQ3NTQ5MTI0OCxcbiAgICAgICAgIDE0LjEzNjA5Nzk3NDc0MTc0NzE3NCxcbiAgICAgICAgLTAuNDkxOTEzODE2MDk3NjIwMTk5NzgsXG4gICAgICAgICAwLjMzOTk0NjQ5OTg0ODExODg4Njk5ZS00LFxuICAgICAgICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCxcbiAgICAgICAgLTAuOTgzNzQ0NzUzMDQ4Nzk1NjQ2NzdlLTQsXG4gICAgICAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxuICAgICAgICAtMC4yMTAyNjQ0NDE3MjQxMDQ4ODMxOWUtMyxcbiAgICAgICAgIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gICAgICAgIC0wLjE2NDMxODEwNjUzNjc2Mzg5MDIyZS0zLFxuICAgICAgICAgMC44NDQxODIyMzk4Mzg1Mjc0MzI5M2UtNCxcbiAgICAgICAgLTAuMjYxOTA4Mzg0MDE1ODE0MDg2NzBlLTQsXG4gICAgICAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XG4gICAgICBdO1xuXG5cbiAgICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IC0xIHx8IG4gPT09IC1JbmZpbml0eSkge1xuICAgICAgICAje3JhaXNlIERvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImdhbW1hXCInfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7SW50ZWdlciA9PT0gbn0pIHtcbiAgICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpc0Zpbml0ZShuKSA/IEluZmluaXR5IDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPiAxNzEpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAgPSBuIC0gMjtcbiAgICAgICAgcmVzdWx0ID0gbiAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHZhbHVlID4gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PSAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiBuKSAqICN7TWF0aC5nYW1tYSgxIC0gbil9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPj0gMTcxLjM1KSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPiA4NS4wKSB7XG4gICAgICAgIHR3b04gICA9IG4gKiBuO1xuICAgICAgICB0aHJlZU4gPSB0d29OICogbjtcbiAgICAgICAgZm91ck4gID0gdGhyZWVOICogbjtcbiAgICAgICAgZml2ZU4gID0gZm91ck4gKiBuO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkgLyBuKSAqIE1hdGgucG93KChuIC8gTWF0aC5FKSwgbikgKlxuICAgICAgICAgICgxICsgMSAvICgxMiAqIG4pICsgMSAvICgyODggKiB0d29OKSAtIDEzOSAvICg1MTg0MCAqIHRocmVlTikgLVxuICAgICAgICAgIDU3MSAvICgyNDg4MzIwICogZm91ck4pICsgMTYzODc5IC8gKDIwOTAxODg4MCAqIGZpdmVOKSArXG4gICAgICAgICAgNTI0NjgxOSAvICg3NTI0Njc5NjgwMCAqIGZpdmVOICogbikpO1xuICAgICAgfVxuXG4gICAgICBuIC09IDE7XG4gICAgICB4ICA9IFBbMF07XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBQLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHggKz0gUFtpXSAvIChuICsgaSk7XG4gICAgICB9XG5cbiAgICAgIHQgPSBuICsgRyArIDAuNTtcblxuICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSkgKiBNYXRoLnBvdyh0LCBuICsgMC41KSAqIE1hdGguZXhwKC10KSAqIHg7XG4gICAgfVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguaHlwb3RgKVxuICAgICV4e1xuICAgICAgTWF0aC5oeXBvdCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGh5cG90KHgsIHkpXG4gICAgTWF0aC5jaGVja2VkIDpoeXBvdCwgTWF0aC5mbG9hdCEoeCksIE1hdGguZmxvYXQhKHkpXG4gIGVuZFxuXG4gIGRlZiBsZGV4cChtYW50aXNzYSwgZXhwb25lbnQpXG4gICAgbWFudGlzc2EgPSBNYXRoLmZsb2F0IShtYW50aXNzYSlcbiAgICBleHBvbmVudCA9IE1hdGguaW50ZWdlciEoZXhwb25lbnQpXG5cbiAgICAleHtcbiAgICAgIGlmIChpc05hTihleHBvbmVudCkpIHtcbiAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAnZmxvYXQgTmFOIG91dCBvZiByYW5nZSBvZiBpbnRlZ2VyJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZ2FtbWEobilcbiAgICAleHtcbiAgICAgIGlmIChuID09IC0xKSB7XG4gICAgICAgIHJldHVybiBbSW5maW5pdHksIDFdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbTWF0aC5sb2coTWF0aC5hYnMoI3tNYXRoLmdhbW1hKG4pfSkpLCAje01hdGguZ2FtbWEobil9IDwgMCA/IC0xIDogMV07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nKHgsIGJhc2UgPSB1bmRlZmluZWQpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBgJHR5cGVfZXJyb3IoeCwgI3tGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgaWYgYGJhc2UgPT0gbnVsbGBcbiAgICAgIE1hdGguY2hlY2tlZCA6bG9nLCBNYXRoLmZsb2F0ISh4KVxuICAgIGVsc2VcbiAgICAgIGlmIFN0cmluZyA9PT0gYmFzZVxuICAgICAgICByYWlzZSBgJHR5cGVfZXJyb3IoYmFzZSwgI3tGbG9hdH0pYFxuICAgICAgZW5kXG5cbiAgICAgIE1hdGguY2hlY2tlZCg6bG9nLCBNYXRoLmZsb2F0ISh4KSkgLyBNYXRoLmNoZWNrZWQoOmxvZywgTWF0aC5mbG9hdCEoYmFzZSkpXG4gICAgZW5kXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5sb2cxMGApXG4gICAgJXh7XG4gICAgICBNYXRoLmxvZzEwID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nMTAoeClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcih4LCAje0Zsb2F0fSlgXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOmxvZzEwLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMmApXG4gICAgJXh7XG4gICAgICBNYXRoLmxvZzIgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzIoeClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcih4LCAje0Zsb2F0fSlgXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOmxvZzIsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBzaW4oeClcbiAgICBNYXRoLmNoZWNrZWQgOnNpbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLnNpbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5zaW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2luaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6c2luaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHNxcnQoeClcbiAgICBNYXRoLmNoZWNrZWQgOnNxcnQsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiB0YW4oeClcbiAgICB4ID0gTWF0aC5mbG9hdCEoeClcblxuICAgIGlmIHguaW5maW5pdGU/XG4gICAgICByZXR1cm4gRmxvYXQ6Ok5BTlxuICAgIGVuZFxuXG4gICAgTWF0aC5jaGVja2VkIDp0YW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC50YW5oYClcbiAgICAleHtcbiAgICAgIE1hdGgudGFuaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4ID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gKE1hdGguZXhwKHgpIC0gTWF0aC5leHAoLXgpKSAvIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0YW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDp0YW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk1hdGg+IiwiQ2xhc3MiLCJuZXciLCJTdGFuZGFyZEVycm9yIiwiY2hlY2tlZCIsInNlbGYiLCJtZXRob2QiLCJyYWlzZSIsIkRvbWFpbkVycm9yIiwiZmxvYXQhIiwidmFsdWUiLCJGbG9hdCIsIkFyZ3VtZW50RXJyb3IiLCJpbnRlZ2VyISIsIkludGVnZXIiLCJtb2R1bGVfZnVuY3Rpb24iLCJhY29zIiwieCIsIk1hdGgiLCJhY29zaCIsImFzaW4iLCJhc2luaCIsImF0YW4iLCJhdGFuMiIsInkiLCJhdGFuaCIsImNicnQiLCJjb3MiLCJjb3NoIiwiZXJmIiwiZXJmYyIsImV4cCIsImZyZXhwIiwiZ2FtbWEiLCJuIiwiPT09IiwiLSIsIjEiLCJoeXBvdCIsImxkZXhwIiwibWFudGlzc2EiLCJleHBvbmVudCIsIlJhbmdlRXJyb3IiLCJsZ2FtbWEiLCJsb2ciLCJiYXNlIiwiU3RyaW5nIiwiLyIsImxvZzEwIiwibG9nMiIsInNpbiIsInNpbmgiLCJzcXJ0IiwidGFuIiwiaW5maW5pdGU/IiwiRmxvYXQ6Ok5BTiIsInRhbmgiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0UsaUNBQU1BLE1BQU47SUFDQSxrQ0FBTUEsT0FBTjtJQUVBLDJDQUFjQyxxQkFBS0MsS0FBQUEsQ0FBS0MsNkJBQUxELENBQW5CO0lBRUFFLFVBQUlDLElBQUpELGNBQUFBLGtCQUFBQSxtQkFBaUJFLE1BQUQsRUFSbEIsRUFRRUY7QUFBQUEsTUFBQUE7Ozs7TUFSRjs7TUFRMkI7O0FBRTNCQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFFBQVVDLElBQUFFLE9BQUFBLENBQU1DLDJCQUFOLEVBQW1CLEVBQUEsR0FBQ0osMENBQUQsR0FBQSxDQUEyQ0UsTUFBM0MsQ0FBQSxHQUFrREYsSUFBckVHLENBQXlFSDtBQUNuRkE7O0FBRUFBO0FBQ0FBO0lBYkVBLENBQUFBLDhCQUFBQTtJQWdCQUssVUFBSUosSUFBSkksYUFBQUEscUJBQUFBLFNBQWdCQyxLQUFoQkQ7QUFBQUEsTUFBQUE7O01BQ0U7UUFBQUEsT0FBQUosSUFBQU0sT0FBQUEsQ0FBTUQsS0FBTkM7TUFBQTtRQUNGLHNCQUFPLENBQUFDLDZCQUFBLENBQVA7VUFBQTtZQUNFSCxPQUFBSixJQUFBRSxP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cmNlcyI6WyJjb3JlbGliL2NvbXBsZXgvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgS2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4LmZyb21fc3RyaW5nKHNlbGYpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIkNvbXBsZXgiLCJyZWFsIiwiaW1hZyIsIm5ldyIsIjAiLCI8Y2xhc3M6U3RyaW5nPiIsInRvX2MiLCJmcm9tX3N0cmluZyIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQSx1REFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDLENBQUFBLDJCQUFBQSxvQkFBQUEsbUJBQVlDLElBQUQsRUFBT0MsSUFBbEJGO0FBQUFBLE1BQUFBOzs7O01BQWtCO01BQUEsU0FBTyxHQUFQO01BQUE7TUFDaEIsSUFBQSxRQUFHRSxJQUFILENBQUE7UUFDRUYsT0FBQUEsdUJBQU9HLEtBQUFBLENBQUtGLElBQVosRUFBa0JDLElBQVhDO01BRFQ7UUFHRUgsT0FBQUEsdUJBQU9HLEtBQUFBLENBQUtGLElBQVosRUFBa0JHLENBQVhEO01BSFQ7SUFERkgsQ0FBQUEsZ0NBQUFBLENBQUFBO0VBREZELEdBQUFBLFdBQUFBO0VBVUFELE9BQUFPO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsQ0FBQUEsd0JBQUFBLGlCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFOLHVCQUFPTyxhQUFBQSxDQUFhQyxJQUFiRDtJQURURCxDQUFBQSw0QkFBQUEsQ0FBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQVA7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIyMDIwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wbGV4LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuXG5jbGFzcyBDb21wbGV4IDwgTnVtZXJpY1xuICBkZWYgc2VsZi5yZWN0KHJlYWwsIGltYWcgPSAwKVxuICAgIHVubGVzcyBOdW1lcmljID09PSByZWFsICYmIHJlYWwucmVhbD8gJiYgTnVtZXJpYyA9PT0gaW1hZyAmJiBpbWFnLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHJlYWwsIGltYWcpXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBvbGFyKHIsIHRoZXRhID0gMClcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gciAmJiByLnJlYWw/ICYmIE51bWVyaWMgPT09IHRoZXRhICYmIHRoZXRhLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWFsLCA6aW1hZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlYWwsIGltYWcgPSAwKVxuICAgIEByZWFsID0gcmVhbFxuICAgIEBpbWFnID0gaW1hZ1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBbb3RoZXIsIHNlbGZdXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIFtDb21wbGV4Lm5ldyhvdGhlciwgMCksIHNlbGZdXG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBAcmVhbCA9PSBvdGhlci5yZWFsICYmIEBpbWFnID09IG90aGVyLmltYWdcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQHJlYWwgPT0gb3RoZXIgJiYgQGltYWcgPT0gMFxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgQ29tcGxleCgtQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlci5yZWFsLCBAaW1hZyArIG90aGVyLmltYWcpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIucmVhbCwgQGltYWcgLSBvdGhlci5pbWFnKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLnJlYWwgLSBAaW1hZyAqIG90aGVyLmltYWcsXG4gICAgICAgIEByZWFsICogb3RoZXIuaW1hZyArIEBpbWFnICogb3RoZXIucmVhbCxcbiAgICAgIClcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLCBAaW1hZyAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgaWYgKE51bWJlciA9PT0gQHJlYWwgJiYgQHJlYWwubmFuPykgfHwgKE51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHxcbiAgICAgICAgIChOdW1iZXIgPT09IG90aGVyLnJlYWwgJiYgb3RoZXIucmVhbC5uYW4/KSB8fCAoTnVtYmVyID09PSBvdGhlci5pbWFnICYmIG90aGVyLmltYWcubmFuPylcbiAgICAgICAgQ29tcGxleC5uZXcoRmxvYXQ6Ok5BTiwgRmxvYXQ6Ok5BTilcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZiAqIG90aGVyLmNvbmogLyBvdGhlci5hYnMyXG4gICAgICBlbmRcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbC5xdW8ob3RoZXIpLCBAaW1hZy5xdW8ob3RoZXIpKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgb3RoZXIgPT0gMFxuICAgICAgcmV0dXJuIENvbXBsZXgubmV3KDEsIDApXG4gICAgZW5kXG5cbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuICAgICAgb3JlICAgICAgPSBvdGhlci5yZWFsXG4gICAgICBvaW0gICAgICA9IG90aGVyLmltYWdcbiAgICAgIG5yICAgICAgID0gTWF0aC5leHAob3JlICogTWF0aC5sb2cocikgLSBvaW0gKiB0aGV0YSlcbiAgICAgIG50aGV0YSAgID0gdGhldGEgKiBvcmUgKyBvaW0gKiBNYXRoLmxvZyhyKVxuXG4gICAgICBDb21wbGV4LnBvbGFyKG5yLCBudGhldGEpXG4gICAgZWxzaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmIG90aGVyID4gMFxuICAgICAgICB4ID0gc2VsZlxuICAgICAgICB6ID0geFxuICAgICAgICBuID0gb3RoZXIgLSAxXG5cbiAgICAgICAgd2hpbGUgbiAhPSAwXG4gICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIHdoaWxlIG1vZCA9PSAwXG4gICAgICAgICAgICB4ID0gQ29tcGxleCh4LnJlYWwgKiB4LnJlYWwgLSB4LmltYWcgKiB4LmltYWcsIDIgKiB4LnJlYWwgKiB4LmltYWcpXG4gICAgICAgICAgICBuID0gZGl2XG4gICAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICB6ICo9IHhcbiAgICAgICAgICBuIC09IDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgelxuICAgICAgZWxzZVxuICAgICAgICAoUmF0aW9uYWwubmV3KDEsIDEpIC8gc2VsZikqKi1vdGhlclxuICAgICAgZW5kXG4gICAgZWxzaWYgRmxvYXQgPT09IG90aGVyIHx8IFJhdGlvbmFsID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuXG4gICAgICBDb21wbGV4LnBvbGFyKHIqKm90aGVyLCB0aGV0YSAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIE1hdGguaHlwb3QoQHJlYWwsIEBpbWFnKVxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIEByZWFsICogQHJlYWwgKyBAaW1hZyAqIEBpbWFnXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIE1hdGguYXRhbjIoQGltYWcsIEByZWFsKVxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY29ualxuICAgIENvbXBsZXgoQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAcmVhbC5kZW5vbWluYXRvci5sY20oQGltYWcuZGVub21pbmF0b3IpXG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgQ29tcGxleCA9PT0gb3RoZXIgJiYgQHJlYWwuY2xhc3MgPT0gQGltYWcuY2xhc3MgJiYgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG5cbiAgICBzZWxmIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBAcmVhbC5maW5pdGU/ICYmIEBpbWFnLmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIkNvbXBsZXg6I3tAcmVhbH06I3tAaW1hZ31cIlxuICBlbmRcblxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBAcmVhbC5pbmZpbml0ZT8gfHwgQGltYWcuaW5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG5cbiAgdW5kZWYgbmVnYXRpdmU/XG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGQgPSBkZW5vbWluYXRvclxuXG4gICAgQ29tcGxleChAcmVhbC5udW1lcmF0b3IgKiAoZCAvIEByZWFsLmRlbm9taW5hdG9yKSxcbiAgICAgIEBpbWFnLm51bWVyYXRvciAqIChkIC8gQGltYWcuZGVub21pbmF0b3IpLFxuICAgIClcbiAgZW5kXG5cbiAgYWxpYXMgcGhhc2UgYXJnXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICB1bmRlZiBwb3NpdGl2ZT9cblxuICBhbGlhcyBxdW8gL1xuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgQGltYWcgIT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCcgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgcmVhbC5yYXRpb25hbGl6ZShlcHMpXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW0ByZWFsLCBAaW1hZ11cbiAgZW5kXG5cbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuXG4gIHVuZGVmIHN0ZXBcblxuICBkZWYgdG9fZlxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19yXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgcmVzdWx0ID0gQHJlYWwuaW5zcGVjdFxuXG4gICAgcmVzdWx0ICs9XG4gICAgICBpZiAoTnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fCBAaW1hZy5wb3NpdGl2ZT8gfHwgQGltYWcuemVybz9cbiAgICAgICAgJysnXG4gICAgICBlbHNlXG4gICAgICAgICctJ1xuICAgICAgZW5kXG5cbiAgICByZXN1bHQgKz0gQGltYWcuYWJzLmluc3BlY3RcblxuICAgIGlmIE51bWJlciA9PT0gQGltYWcgJiYgKEBpbWFnLm5hbj8gfHwgQGltYWcuaW5maW5pdGU/KVxuICAgICAgcmVzdWx0ICs9ICcqJ1xuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJ2knXG4gIGVuZFxuXG4gIEkgPSBuZXcoMCwgMSlcblxuICBkZWYgc2VsZi5mcm9tX3N0cmluZyhzdHIpXG4gICAgJXh7XG4gICAgICB2YXIgcmUgPSAvWystXT9bXFxkX10rKFxcLltcXGRfXSspPyhlXFxkKyk/LyxcbiAgICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaChyZSksXG4gICAgICAgICAgcmVhbCwgaW1hZywgZGVub21pbmF0b3I7XG5cbiAgICAgIGZ1bmN0aW9uIGlzRmxvYXQoKSB7XG4gICAgICAgIHJldHVybiByZS50ZXN0KHN0cik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGN1dEZsb2F0KCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmUpO1xuICAgICAgICB2YXIgbnVtYmVyID0gbWF0Y2hbMF07XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShudW1iZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG51bWJlci5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlcyBib3RoIGZsb2F0cyBhbmQgcmF0aW9uYWxzXG4gICAgICBmdW5jdGlvbiBjdXROdW1iZXIoKSB7XG4gICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcblxuICAgICAgICAgIGlmIChzdHJbMF0gPT09ICcvJykge1xuICAgICAgICAgICAgLy8gcmF0aW9uYWwgcmVhbCBwYXJ0XG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG5cbiAgICAgICAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJldmVydGluZyAnLydcbiAgICAgICAgICAgICAgc3RyID0gJy8nICsgc3RyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVtZXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmbG9hdCByZWFsIHBhcnQsIG5vIGRlbm9taW5hdG9yXG4gICAgICAgICAgICByZXR1cm4gbnVtZXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWFsID0gY3V0TnVtYmVyKCk7XG5cbiAgICAgIGlmICghcmVhbCkge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyBpID0+IENvbXBsZXgoMCwgMSlcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyWzBdID09PSAnLScgJiYgc3RyWzFdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAtaSA9PiBDb21wbGV4KDAsIC0xKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgLTEpfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyWzBdID09PSAnKycgJiYgc3RyWzFdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAraSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW55dGhpbmcgPT4gQ29tcGxleCgwLCAwKVxuICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIDApfTtcbiAgICAgIH1cblxuICAgICAgaW1hZyA9IGN1dE51bWJlcigpO1xuICAgICAgaWYgKCFpbWFnKSB7XG4gICAgICAgIGlmIChzdHJbMF0gPT09ICdpJykge1xuICAgICAgICAgIC8vIDNpID0+IENvbXBsZXgoMCwgMylcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIGByZWFsYCl9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDMgPT4gQ29tcGxleCgzLCAwKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoYHJlYWxgLCAwKX07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDMrMmkgPT4gQ29tcGxleCgzLCAyKVxuICAgICAgICByZXR1cm4gI3tDb21wbGV4KGByZWFsYCwgYGltYWdgKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDb21wbGV4PiIsInJlY3QiLCJyZWFsIiwiaW1hZyIsIjAiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCJOdW1lcmljIiwiPT09IiwicmVhbD8iLCJyYWlzZSIsIlR5cGVFcnJvciIsIm5ldyIsInBvbGFyIiwiciIsInRoZXRhIiwiJHJldF9vcl80IiwiJHJldF9vcl81IiwiJHJldF9vcl82IiwiKiIsIk1hdGgiLCJjb3MiLCJzaW4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVhbCIsIkBpbWFnIiwiY29lcmNlIiwib3RoZXIiLCJDb21wbGV4IiwiJHJldF9vcl83IiwiY2xhc3MiLCI9PSIsIiRyZXRfb3JfOCIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCItQCIsIisiLCIkcmV0X29yXzExIiwiX19jb2VyY2VkX18iLCItIiwiJHJldF9vcl8xMiIsIiRyZXRfb3JfMTMiLCIvIiwiJHJldF9vcl8xNCIsIiRyZXRfb3JfMTUiLCIkcmV0X29yXzE2IiwiJHJldF9vcl8xNyIsIk51bWJlciIsIm5hbj8iLCIkcmV0X29yXzE4IiwiJHJldF9vcl8xOSIsIiRyZXRfb3JfMjAiLCJGbG9hdDo6TkFOIiwiRmxvYXQiLCJjb25qIiwiYWJzMiIsIiRyZXRfb3JfMjEiLCJxdW8iLCIqKiIsIjEiLCJvcmUiLCJvaW0iLCJuciIsImV4cCIsImxvZyIsIm50aGV0YSIsIkludGVnZXIiLCI+IiwieCIsInoiLCJuIiwiIT0iLCJkaXZtb2QiLCIyIiwiZGl2IiwibW9kIiwiUmF0aW9uYWwiLCIkcmV0X29yXzIyIiwiYWJzIiwiaHlwb3QiLCJhbmdsZSIsImF0YW4yIiwiZGVub21pbmF0b3IiLCJsY20iLCJlcWw/IiwiJHJldF9vcl8yMyIsIiRyZXRfb3JfMjQiLCJmZGl2IiwiZmluaXRlPyIsIiRyZXRfb3JfMjUiLCJoYXNoIiwiaW5maW5pdGU/IiwiJHJldF9vcl8yNiIsImluc3BlY3QiLCJudW1lcmF0b3IiLCJkIiwiYXJnIiwicmF0aW9uYWxpemUiLCJlcHMiLCJBcmd1bWVudEVycm9yIiwiUmFuZ2VFcnJvciIsInRvX2YiLCJ0b19pIiwidG9fciIsInRvX3MiLCJyZXN1bHQiLCIkcmV0X29yXzI3IiwiJHJldF9vcl8yOCIsIiRyZXRfb3JfMjkiLCJwb3NpdGl2ZT8iLCJ6ZXJvPyIsIiRyZXRfb3JfMzAiLCIkcmV0X29yXzMxIiwiZnJvbV9zdHJpbmciLCJzdHIiLCItMSJdLCJtYXBwaW5ncyI6IkFBQUFBLGtEQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixzQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsVUFBSUgsSUFBSkcsV0FBQUEsa0JBQUFBLGdCQUFjQyxJQUFELEVBQU9DLElBQXBCRjtBQUFBQSxNQUFBQTs7OztNQUFvQjtNQUFBLFNBQU9HLENBQVA7TUFBQTtNQUNsQixJQUFBLFFBQU8sYUFBQSxJQUFBLFFBTFhDLENBQUFBLFlBS1csYUFBQSxJQUFBLFFBTFhDLENBQUFBLFlBS1csYUFBQSxJQUFBLFFBTFhDLENBQUFBLFlBS1dDLHVCQUFRQyxRQUFBQSxDQUFJUCxJQUFKTyxDQUxuQkYsQ0FLVyxDQUFBO1FBQW9CTixPQUFBQyxJQUFJUSxVQUFBQSxDQUFBQTtNQUF4QjtRQUxYVCxPQUFBO01BS1csQ0FBQSxrQkFMWEssQ0FLVyxDQUFBO1FBQWtDTCxPQUFBTyx1QkFBUUMsUUFBQUEsQ0FBSU4sSUFBSk07TUFBMUM7UUFMWFIsT0FBQTtNQUtXLENBQUEsa0JBTFhJLENBS1csQ0FBQTtRQUFzREosT0FBQUUsSUFBSU8sVUFBQUEsQ0FBQUE7TUFBMUQ7UUFMWFQsT0FBQTtNQUtXLENBQUEsa0JBQVAsQ0FBQTtNQUFBO1FBQ0VILElBQUFhLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCWCxZQUFqQlU7TUFERjtNQUlBVixPQUFBSCxJQUFBZSxLQUFBQSxDQUFJWCxJQUFKLEVBQVVDLElBQVZVO0lBTEZaLENBQUFBLDhCQUFBQTtJQVFBO01BQUE7O01BQ0UsT0FBQSxhQUFNLGFB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QTtBQUNBQTtBQUNBQSxpQkFBbUJySCxJQUFBZ0MsU0FBQUEsQ0FBUTFCLENBQVIsRUFBV2lILEVBQVh2RixDQUFlcUY7QUFDbENBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQnJILElBQUFnQyxTQUFBQSxDQUFRMUIsQ0FBUixFQUFXeUQsQ0FBWC9CLENBQWNxRjtBQUNqQ0E7QUFDQUE7QUFDQUEsZUFBaUJySCxJQUFBZ0MsU0FBQUEsQ0FBUTFCLENBQVIsRUFBV0EsQ0FBWDBCLENBQWNxRjtBQUMvQkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQnJILElBQUFnQyxTQUFBQSxDQUFRMUIsQ0FBUixFQUFZK0csSUFBWnJGLENBQW1CcUY7QUFDdENBO0FBQ0FBO0FBQ0FBLGlCQUFtQnJILElBQUFnQyxTQUFBQSxDQUFTcUYsSUFBVCxFQUFnQi9HLENBQWhCMEIsQ0FBbUJxRjtBQUN0Q0E7QUFDQUE7QUFDQUE7QUFDQUEsZUFBaUJySCxJQUFBZ0MsU0FBQUEsQ0FBU3FGLElBQVQsRUFBaUJBLElBQWpCckYsQ0FBd0JxRjtBQUN6Q0E7QUFDQUE7SUEzRUVBLENBQUFBLHFDQUFBQSxDQUFBQTtFQXBTRm5ILEdBQUFBLFdBQUFBLEVBQWdCUSx1QkFBaEJSO0FBSEFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMjYwOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmF0aW9uYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgS2VybmVsXG4gIGRlZiBSYXRpb25hbChudW1lcmF0b3IsIGRlbm9taW5hdG9yID0gMSlcbiAgICBSYXRpb25hbC5jb252ZXJ0KG51bWVyYXRvciwgZGVub21pbmF0b3IpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBkZWYgdG9fclxuICAgIFJhdGlvbmFsLmZyb21fc3RyaW5nKHNlbGYpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6S2VybmVsPiIsIlJhdGlvbmFsIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCIxIiwiY29udmVydCIsIjxjbGFzczpTdHJpbmc+IiwidG9fciIsImZyb21fc3RyaW5nIiwic2VsZiJdLCJtYXBwaW5ncyI6IkFBQUFBLHdEQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsQ0FBQUEsNEJBQUFBLHFCQUFBQSxvQkFBYUMsU0FBRCxFQUFZQyxXQUF4QkY7QUFBQUEsTUFBQUE7Ozs7TUFBd0I7TUFBQSxnQkFBY0csQ0FBZDtNQUFBO01BQ3RCSCxPQUFBQSx3QkFBUUksU0FBQUEsQ0FBU0gsU0FBakIsRUFBNEJDLFdBQXBCRTtJQURWSixDQUFBQSxpQ0FBQUEsQ0FBQUE7RUFERkQsR0FBQUEsV0FBQUE7RUFNQUQsT0FBQU87RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyxDQUFBQSx3QkFBQUEsaUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQU4sd0JBQVFPLGFBQUFBLENBQWFDLElBQWJEO0lBRFZELENBQUFBLDRCQUFBQSxDQUFBQTtFQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQU5BUDsifX0seyJvZmZzZXQiOnsibGluZSI6MjI2NDIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhdGlvbmFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcbnJlcXVpcmUgJ2NvcmVsaWIvcmF0aW9uYWwvYmFzZSdcblxuY2xhc3MgUmF0aW9uYWwgPCBOdW1lcmljXG4gIGRlZiBzZWxmLnJlZHVjZShudW0sIGRlbilcbiAgICBudW0gPSBudW0udG9faVxuICAgIGRlbiA9IGRlbi50b19pXG5cbiAgICBpZiBkZW4gPT0gMFxuICAgICAgcmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgZWxzaWYgZGVuIDwgMFxuICAgICAgbnVtID0gLW51bVxuICAgICAgZGVuID0gLWRlblxuICAgIGVsc2lmIGRlbiA9PSAxXG4gICAgICByZXR1cm4gbmV3KG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgZ2NkID0gbnVtLmdjZChkZW4pXG5cbiAgICBuZXcobnVtIC8gZ2NkLCBkZW4gLyBnY2QpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnZlcnQobnVtLCBkZW4pXG4gICAgaWYgbnVtLm5pbD8gfHwgZGVuLm5pbD9cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2Nhbm5vdCBjb252ZXJ0IG5pbCBpbnRvIFJhdGlvbmFsJ1xuICAgIGVuZFxuXG4gICAgaWYgSW50ZWdlciA9PT0gbnVtICYmIEludGVnZXIgPT09IGRlblxuICAgICAgcmV0dXJuIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcblxuICAgIGlmIEZsb2F0ID09PSBudW0gfHwgU3RyaW5nID09PSBudW0gfHwgQ29tcGxleCA9PT0gbnVtXG4gICAgICBudW0gPSBudW0udG9fclxuICAgIGVuZFxuXG4gICAgaWYgRmxvYXQgPT09IGRlbiB8fCBTdHJpbmcgPT09IGRlbiB8fCBDb21wbGV4ID09PSBkZW5cbiAgICAgIGRlbiA9IGRlbi50b19yXG4gICAgZW5kXG5cbiAgICBpZiBkZW4uZXF1YWw/KDEpICYmICEoSW50ZWdlciA9PT0gbnVtKVxuICAgICAgT3BhbC5jb2VyY2VfdG8hKG51bSwgUmF0aW9uYWwsIDp0b19yKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG51bSAmJiBOdW1lcmljID09PSBkZW5cbiAgICAgIG51bSAvIGRlblxuICAgIGVsc2VcbiAgICAgIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUobnVtLCBkZW4pXG4gICAgQG51bSA9IG51bVxuICAgIEBkZW4gPSBkZW5cbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIEBudW1cbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgQGRlblxuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBbb3RoZXIsIHNlbGZdXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFtvdGhlci50b19yLCBzZWxmXVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgW290aGVyLCB0b19mXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIEBudW0gPT0gb3RoZXIubnVtZXJhdG9yICYmIEBkZW4gPT0gb3RoZXIuZGVub21pbmF0b3JcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgQG51bSA9PSBvdGhlciAmJiBAZGVuID09IDFcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgPT0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvciA8PT4gMFxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBAbnVtIC0gQGRlbiAqIG90aGVyIDw9PiAwXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mIDw9PiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOjw9Piwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciArIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgUmF0aW9uYWwoQG51bSArIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgKyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFJhdGlvbmFsKEBudW0gLSBvdGhlciAqIEBkZW4sIEBkZW4pXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mIC0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBSYXRpb25hbChAbnVtICogb3RoZXIsIEBkZW4pXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mICogb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBpZiBvdGhlciA9PSAwXG4gICAgICAgIHRvX2YgLyAwLjBcbiAgICAgIGVsc2VcbiAgICAgICAgUmF0aW9uYWwoQG51bSwgQGRlbiAqIG90aGVyKVxuICAgICAgZW5kXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mIC8gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxuICAgICAgICBGbG9hdDo6SU5GSU5JVFlcbiAgICAgIGVsc2lmIG90aGVyID4gMFxuICAgICAgICBSYXRpb25hbChAbnVtKipvdGhlciwgQGRlbioqb3RoZXIpXG4gICAgICBlbHNpZiBvdGhlciA8IDBcbiAgICAgICAgUmF0aW9uYWwoQGRlbioqLW90aGVyLCBAbnVtKiotb3RoZXIpXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsKDEsIDEpXG4gICAgICBlbmRcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YqKm90aGVyXG5cbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBpZiBvdGhlciA9PSAwXG4gICAgICAgIFJhdGlvbmFsKDEsIDEpXG4gICAgICBlbHNpZiBvdGhlci5kZW5vbWluYXRvciA9PSAxXG4gICAgICAgIGlmIG90aGVyIDwgMFxuICAgICAgICAgIFJhdGlvbmFsKEBkZW4qKm90aGVyLm51bWVyYXRvci5hYnMsIEBudW0qKm90aGVyLm51bWVyYXRvci5hYnMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBSYXRpb25hbChAbnVtKipvdGhlci5udW1lcmF0b3IsIEBkZW4qKm90aGVyLm51bWVyYXRvcilcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xuICAgICAgZWxzZVxuICAgICAgICB0b19mKipvdGhlclxuICAgICAgZW5kXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBSYXRpb25hbChAbnVtLmFicywgQGRlbi5hYnMpXG4gIGVuZFxuXG4gIGRlZiBjZWlsKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmNlaWxcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6Y2VpbCwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBkaXZpZGUgL1xuXG4gIGRlZiBmbG9vcihwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5mbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpmbG9vciwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFwiUmF0aW9uYWw6I3tAbnVtfToje0BkZW59XCJcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIigje3NlbGZ9KVwiXG4gIGVuZFxuXG4gIGFsaWFzIHF1byAvXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVwcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZSA9ICN7ZXBzLmFic30sXG4gICAgICAgICAgYSA9ICN7c2VsZiAtIGBlYH0sXG4gICAgICAgICAgYiA9ICN7c2VsZiArIGBlYH07XG5cbiAgICAgIHZhciBwMCA9IDAsXG4gICAgICAgICAgcDEgPSAxLFxuICAgICAgICAgIHEwID0gMSxcbiAgICAgICAgICBxMSA9IDAsXG4gICAgICAgICAgcDIsIHEyO1xuXG4gICAgICB2YXIgYywgaywgdDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgYyA9ICN7YGFgLmNlaWx9O1xuXG4gICAgICAgIGlmICgje2BjYCA8PSBgYmB9KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBrICA9IGMgLSAxO1xuICAgICAgICBwMiA9IGsgKiBwMSArIHAwO1xuICAgICAgICBxMiA9IGsgKiBxMSArIHEwO1xuICAgICAgICB0ICA9ICN7MSAvIChgYmAgLSBga2ApfTtcbiAgICAgICAgYiAgPSAjezEgLyAoYGFgIC0gYGtgKX07XG4gICAgICAgIGEgID0gdDtcblxuICAgICAgICBwMCA9IHAxO1xuICAgICAgICBxMCA9IHExO1xuICAgICAgICBwMSA9IHAyO1xuICAgICAgICBxMSA9IHEyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tSYXRpb25hbChgYyAqIHAxICsgcDBgLCBgYyAqIHExICsgcTBgKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcm91bmQocHJlY2lzaW9uID0gMClcbiAgICByZXR1cm4gd2l0aF9wcmVjaXNpb24oOnJvdW5kLCBwcmVjaXNpb24pIHVubGVzcyBwcmVjaXNpb24gPT0gMFxuICAgIHJldHVybiAwIGlmIEBudW0gPT0gMFxuICAgIHJldHVybiBAbnVtIGlmIEBkZW4gPT0gMVxuXG4gICAgbnVtID0gQG51bS5hYnMgKiAyICsgQGRlblxuICAgIGRlbiA9IEBkZW4gKiAyXG5cbiAgICBhcHByb3ggPSAobnVtIC8gZGVuKS50cnVuY2F0ZVxuXG4gICAgaWYgQG51bSA8IDBcbiAgICAgIC1hcHByb3hcbiAgICBlbHNlXG4gICAgICBhcHByb3hcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBAbnVtIC8gQGRlblxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIHRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiI3tAbnVtfS8je0BkZW59XCJcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgIEBudW0gPCAwID8gY2VpbCA6IGZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOnRydW5jYXRlLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB3aXRoX3ByZWNpc2lvbihtZXRob2QsIHByZWNpc2lvbilcbiAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYW4gSW50ZWdlcicgdW5sZXNzIEludGVnZXIgPT09IHByZWNpc2lvblxuXG4gICAgcCA9IDEwKipwcmVjaXNpb25cbiAgICBzID0gc2VsZiAqIHBcblxuICAgIGlmIHByZWNpc2lvbiA8IDFcbiAgICAgIChzLnNlbmQobWV0aG9kKSAvIHApLnRvX2lcbiAgICBlbHNlXG4gICAgICBSYXRpb25hbChzLnNlbmQobWV0aG9kKSwgcClcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZnJvbV9zdHJpbmcoc3RyaW5nKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHN0cmluZy50cmltTGVmdCgpLFxuICAgICAgICAgIHJlID0gL15bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/LyxcbiAgICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaChyZSksXG4gICAgICAgICAgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gcmF0aW9uYWwgcmVhbCBwYXJ0XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoMCwgMSl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmF0aW9uYWw+IiwicmVkdWNlIiwibnVtIiwiZGVuIiwidG9faSIsIj09IiwiMCIsInJhaXNlIiwiWmVyb0RpdmlzaW9uRXJyb3IiLCI8IiwiLUAiLCIxIiwibmV3IiwiZ2NkIiwiLyIsImNvbnZlcnQiLCIkcmV0X29yXzEiLCJuaWw/IiwiVHlwZUVycm9yIiwiJHJldF9vcl8yIiwiSW50ZWdlciIsIj09PSIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsIkZsb2F0IiwiU3RyaW5nIiwiQ29tcGxleCIsInRvX3IiLCIkcmV0X29yXzUiLCIkcmV0X29yXzYiLCIkcmV0X29yXzciLCJlcXVhbD8iLCIhIiwiT3BhbCIsImNvZXJjZV90byEiLCJSYXRpb25hbCIsIiRyZXRfb3JfOCIsIk51bWVyaWMiLCJpbml0aWFsaXplIiwiQG51bSIsIkBkZW4iLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImNvZXJjZSIsIm90aGVyIiwidG9fZiIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCI8PT4iLCItIiwiKiIsIl9fY29lcmNlZF9fIiwiKyIsIioqIiwiJHJldF9vcl8xMSIsIkZsb2F0OjpJTkZJTklUWSIsIj4iLCJhYnMiLCIkcmV0X29yXzEyIiwiY2VpbCIsInByZWNpc2lvbiIsIndpdGhfcHJlY2lzaW9uIiwiZmxvb3IiLCJoYXNoIiwiaW5zcGVjdCIsInJhdGlvbmFsaXplIiwiZXBzIiwiQXJndW1lbnRFcnJvciIsIjw9Iiwicm91bmQiLCIyIiwiYXBwcm94IiwidHJ1bmNhdGUiLCJ0b19zIiwibWV0aG9kIiwicCIsIjEwIiwicyIsInNlbmQiLCJmcm9tX3N0cmluZyIsInN0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUFBLG1EQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix1QkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztB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QUFBQSwyQkFBQUEsdUJBQXFCQyxNQUFyQkQ7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLG1CQUFxQmpGLElBQUFxQyxVQUFBQSxDQUFVNEMsU0FBVixFQUF1QkEsV0FBdkI1QyxDQUFxQzRDO0FBQzFEQTtBQUNBQSxtQkFBcUJqRixJQUFBcUMsVUFBQUEsQ0FBVTRDLFNBQVYsRUFBc0JwRSxDQUF0QndCLENBQXlCNEM7QUFDOUNBO0FBQ0FBO0FBQ0FBLGlCQUFtQmpGLElBQUFxQyxVQUFBQSxDQUFVNEMsU0FBVixFQUFzQnBFLENBQXRCd0IsQ0FBeUI0QztBQUM1Q0E7QUFDQUE7QUFDQUEsZUFBaUJqRixJQUFBcUMsVUFBQUEsQ0FBUzdCLENBQVQsRUFBWUssQ0FBWndCLENBQWU0QztBQUNoQ0E7QUFDQUE7SUFyQ0VBLENBQUFBLHNDQUFBQSxDQUFBQTtFQS9WRi9FLEdBQUFBLFdBQUFBLEVBQWlCcUMsdUJBQWpCckM7QUFIQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMTI4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi90aW1lLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogc2xpY2VcblxucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xuXG5jbGFzcyBUaW1lIDwgYERhdGVgXG4gIGluY2x1ZGUgQ29tcGFyYWJsZVxuXG4gICV4e1xuICAgIHZhciBkYXlzX29mX3dlZWsgPSAjeyV3W1N1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5IFN1bmRheV19LFxuICAgICAgICBzaG9ydF9kYXlzICAgPSAjeyV3W1N1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdF19LFxuICAgICAgICBzaG9ydF9tb250aHMgPSAjeyV3W0phbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXX0sXG4gICAgICAgIGxvbmdfbW9udGhzICA9ICN7JXdbSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlcl19O1xuICB9XG5cbiAgZGVmIHNlbGYuYXQoc2Vjb25kcywgZnJhYyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgje1RpbWUgPT09IHNlY29uZHN9KSB7XG4gICAgICAgIGlmIChmcmFjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IFRpbWUgaW50byBhbiBleGFjdCBudW1iZXJcIn1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBuZXcgRGF0ZShzZWNvbmRzLmdldFRpbWUoKSk7XG4gICAgICAgIHJlc3VsdC5pc191dGMgPSBzZWNvbmRzLmlzX3V0YztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWNvbmRzLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHNlY29uZHMgPSAje09wYWwuY29lcmNlX3RvIShzZWNvbmRzLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmcmFjLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGZyYWMgPSAje09wYWwuY29lcmNlX3RvIShmcmFjLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzICogMTAwMCArIChmcmFjIC8gMTAwMCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpIHtcbiAgICAgIGlmICh5ZWFyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHllYXIgPSBwYXJzZUludCh5ZWFyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ZWFyID0gI3tPcGFsLmNvZXJjZV90byEoYHllYXJgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb250aCA9PT0gbmlsKSB7XG4gICAgICAgIG1vbnRoID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoIW1vbnRoLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmICgje2Btb250aGAucmVzcG9uZF90bz8oOnRvX3N0cil9KSB7XG4gICAgICAgICAgbW9udGggPSAje2Btb250aGAudG9fc3RyfTtcbiAgICAgICAgICBzd2l0Y2ggKG1vbnRoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICdqYW4nOiBtb250aCA9ICAxOyBicmVhaztcbiAgICAgICAgICBjYXNlICdmZWInOiBtb250aCA9ICAyOyBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXInOiBtb250aCA9ICAzOyBicmVhaztcbiAgICAgICAgICBjYXNlICdhcHInOiBtb250aCA9ICA0OyBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXknOiBtb250aCA9ICA1OyBicmVhaztcbiAgICAgICAgICBjYXNlICdqdW4nOiBtb250aCA9ICA2OyBicmVhaztcbiAgICAgICAgICBjYXNlICdqdWwnOiBtb250aCA9ICA3OyBicmVhaztcbiAgICAgICAgICBjYXNlICdhdWcnOiBtb250aCA9ICA4OyBicmVhaztcbiAgICAgICAgICBjYXNlICdzZXAnOiBtb250aCA9ICA5OyBicmVhaztcbiAgICAgICAgICBjYXNlICdvY3QnOiBtb250aCA9IDEwOyBicmVhaztcbiAgICAgICAgICBjYXNlICdub3YnOiBtb250aCA9IDExOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkZWMnOiBtb250aCA9IDEyOyBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiBtb250aCA9ICN7YG1vbnRoYC50b19pfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9udGggPSAje09wYWwuY29lcmNlX3RvIShgbW9udGhgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJtb250aCBvdXQgb2YgcmFuZ2U6ICN7YG1vbnRoYH1cIn1cbiAgICAgIH1cbiAgICAgIG1vbnRoID0gbW9udGggLSAxO1xuXG4gICAgICBpZiAoZGF5ID09PSBuaWwpIHtcbiAgICAgICAgZGF5ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGF5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGRheSA9IHBhcnNlSW50KGRheSwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF5ID0gI3tPcGFsLmNvZXJjZV90byEoYGRheWAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImRheSBvdXQgb2YgcmFuZ2U6ICN7YGRheWB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChob3VyID09PSBuaWwpIHtcbiAgICAgICAgaG91ciA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGhvdXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaG91ciA9IHBhcnNlSW50KGhvdXIsIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvdXIgPSAje09wYWwuY29lcmNlX3RvIShgaG91cmAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPCAwIHx8IGhvdXIgPiAyNCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaG91ciBvdXQgb2YgcmFuZ2U6ICN7YGhvdXJgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAobWluID09PSBuaWwpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH0gZWxzZSBpZiAobWluLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIG1pbiA9IHBhcnNlSW50KG1pbiwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluID0gI3tPcGFsLmNvZXJjZV90byEoYG1pbmAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA8IDAgfHwgbWluID4gNTkpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1pbiBvdXQgb2YgcmFuZ2U6ICN7YG1pbmB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWMgPT09IG5pbCkge1xuICAgICAgICBzZWMgPSAwO1xuICAgICAgfSBlbHNlIGlmICghc2VjLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChzZWMuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBzZWMgPSBwYXJzZUludChzZWMsIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWMgPSAje09wYWwuY29lcmNlX3RvIShgc2VjYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWMgPCAwIHx8IHNlYyA+IDYwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzZWMgb3V0IG9mIHJhbmdlOiAje2BzZWNgfVwifVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjXTtcbiAgICB9XG4gIH1cblxuICBkZWYgc2VsZi5uZXcoeWVhciA9IHVuZGVmaW5lZCwgbW9udGggPSBuaWwsIGRheSA9IG5pbCwgaG91ciA9IG5pbCwgbWluID0gbmlsLCBzZWMgPSBuaWwsIHV0Y19vZmZzZXQgPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgYXJncywgcmVzdWx0O1xuXG4gICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRjX29mZnNldCAhPT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ09wYWwgZG9lcyBub3Qgc3VwcG9ydCBleHBsaWNpdGx5IHNwZWNpZnlpbmcgVVRDIG9mZnNldCBmb3IgVGltZSd9XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApO1xuICAgICAgaWYgKHllYXIgPCAxMDApIHtcbiAgICAgICAgcmVzdWx0LnNldEZ1bGxZZWFyKHllYXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmxvY2FsKHllYXIsIG1vbnRoID0gbmlsLCBkYXkgPSBuaWwsIGhvdXIgPSBuaWwsIG1pbiA9IG5pbCwgc2VjID0gbmlsLCBtaWxsaXNlY29uZCA9IG5pbCwgX2R1bW15MSA9IG5pbCwgX2R1bW15MiA9IG5pbCwgX2R1bW15MyA9IG5pbClcbiAgICAjIFRoZSBfZHVtbXkgYXJncyBhcmUgdGhlcmUgb25seSBiZWNhdXNlIHRoZSBNUkkgdmVyc2lvbiBhY2NlcHRzIHVwIHRvIDEwIGFyZ3VtZW50c1xuICAgICV4e1xuICAgICAgdmFyIGFyZ3MsIHJlc3VsdDtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEwKSB7XG4gICAgICAgIGFyZ3MgID0gJHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgeWVhciAgPSBhcmdzWzVdO1xuICAgICAgICBtb250aCA9IGFyZ3NbNF07XG4gICAgICAgIGRheSAgID0gYXJnc1szXTtcbiAgICAgICAgaG91ciAgPSBhcmdzWzJdO1xuICAgICAgICBtaW4gICA9IGFyZ3NbMV07XG4gICAgICAgIHNlYyAgID0gYXJnc1swXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZ20oeWVhciwgbW9udGggPSBuaWwsIGRheSA9IG5pbCwgaG91ciA9IG5pbCwgbWluID0gbmlsLCBzZWMgPSBuaWwsIG1pbGxpc2Vjb25kID0gbmlsLCBfZHVtbXkxID0gbmlsLCBfZHVtbXkyID0gbmlsLCBfZHVtbXkzID0gbmlsKVxuICAgICMgVGhlIF9kdW1teSBhcmdzIGFyZSB0aGVyZSBvbmx5IGJlY2F1c2UgdGhlIE1SSSB2ZXJzaW9uIGFjY2VwdHMgdXAgdG8gMTAgYXJndW1lbnRzXG4gICAgJXh7XG4gICAgICB2YXIgYXJncywgcmVzdWx0O1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgYXJncyAgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB5ZWFyICA9IGFyZ3NbNV07XG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xuICAgICAgICBob3VyICA9IGFyZ3NbMl07XG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKSk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0VVRDRnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXN1bHQuaXNfdXRjID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgYWxpYXMgbWt0aW1lIGxvY2FsXG4gICAgYWxpYXMgdXRjIGdtXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5vd1xuICAgIG5ld1xuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBpZiBUaW1lID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAndGltZSArIHRpbWU/J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIG90aGVyID0gI3tPcGFsLmNvZXJjZV90byEob3RoZXIsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSArIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBpZiBUaW1lID09PSBvdGhlclxuICAgICAgcmV0dXJuIGAoc2VsZi5nZXRUaW1lKCkgLSBvdGhlci5nZXRUaW1lKCkpIC8gMTAwMGBcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCFvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBvdGhlciA9ICN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgLSAob3RoZXIgKiAxMDAwKSk7XG4gICAgICByZXN1bHQuaXNfdXRjID0gc2VsZi5pc191dGM7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBUaW1lID09PSBvdGhlclxuICAgICAgdG9fZiA8PT4gb3RoZXIudG9fZlxuICAgIGVsc2VcbiAgICAgIHIgPSBvdGhlciA8PT4gc2VsZlxuICAgICAgaWYgci5uaWw/XG4gICAgICAgIG5pbFxuICAgICAgZWxzaWYgciA+IDBcbiAgICAgICAgLTFcbiAgICAgIGVsc2lmIHIgPCAwXG4gICAgICAgIDFcbiAgICAgIGVsc2VcbiAgICAgICAgMFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBUaW1lID09PSBvdGhlciAmJiBgI3t0b19mfSA9PT0gI3tvdGhlci50b19mfWBcbiAgZW5kXG5cbiAgZGVmIGFzY3RpbWVcbiAgICBzdHJmdGltZSAnJWEgJWIgJWUgJUg6JU06JVMgJVknXG4gIGVuZFxuXG4gIGFsaWFzIGN0aW1lIGFzY3RpbWVcblxuICBkZWYgZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXRlKCkgOiBzZWxmLmdldERhdGUoKWBcbiAgZW5kXG5cbiAgZGVmIHlkYXlcbiAgICAjIGh0dHA6Ly9qYXZhc2NyaXB0LmFib3V0LmNvbS9saWJyYXJ5L2JsZGF5eWVhci5odG1cbiAgICAjIGFsc28gc2VlIG1vbWVudC5qcyBpbXBsZW1lbnRhdGlvbjogaHR0cDovL2dpdC5pby92Q0tORVxuXG4gICAgc3RhcnRfb2ZfeWVhciA9IFRpbWUubmV3KHllYXIpLnRvX2lcbiAgICBzdGFydF9vZl9kYXkgID0gVGltZS5uZXcoeWVhciwgbW9udGgsIGRheSkudG9faVxuICAgIG9uZV9kYXkgICAgICAgPSA4Nl80MDBcblxuICAgICgoc3RhcnRfb2ZfZGF5IC0gc3RhcnRfb2ZfeWVhcikgLyBvbmVfZGF5KS5yb3VuZCArIDFcbiAgZW5kXG5cbiAgZGVmIGlzZHN0XG4gICAgJXh7XG4gICAgICB2YXIgamFuID0gbmV3IERhdGUoc2VsZi5nZXRGdWxsWWVhcigpLCAwLCAxKSxcbiAgICAgICAgICBqdWwgPSBuZXcgRGF0ZShzZWxmLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBkc3Q/IGlzZHN0XG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkpYFxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcblxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgb3RoZXIuaXNfYT8oVGltZSkgJiYgKHNlbGYgPD0+IG90aGVyKS56ZXJvP1xuICBlbmRcblxuICBkZWYgZnJpZGF5P1xuICAgIGAje3dkYXl9ID09IDVgXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgYCdUaW1lOicgKyBzZWxmLmdldFRpbWUoKWBcbiAgZW5kXG5cbiAgZGVmIGhvdXJcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0hvdXJzKCkgOiBzZWxmLmdldEhvdXJzKClgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaWYgdXRjP1xuICAgICAgc3RyZnRpbWUgJyVZLSVtLSVkICVIOiVNOiVTIFVUQydcbiAgICBlbHNlXG4gICAgICBzdHJmdGltZSAnJVktJW0tJWQgJUg6JU06JVMgJXonXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIG1kYXkgZGF5XG5cbiAgZGVmIG1pblxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDTWludXRlcygpIDogc2VsZi5nZXRNaW51dGVzKClgXG4gIGVuZFxuXG4gIGRlZiBtb25cbiAgICBgKHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENNb250aCgpIDogc2VsZi5nZXRNb250aCgpKSArIDFgXG4gIGVuZFxuXG4gIGRlZiBtb25kYXk/XG4gICAgYCN7d2RheX0gPT0gMWBcbiAgZW5kXG5cbiAgYWxpYXMgbW9udGggbW9uXG5cbiAgZGVmIHNhdHVyZGF5P1xuICAgIGAje3dkYXl9ID09IDZgXG4gIGVuZFxuXG4gIGRlZiBzZWNcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ1NlY29uZHMoKSA6IHNlbGYuZ2V0U2Vjb25kcygpYFxuICBlbmRcblxuICBkZWYgc3VjY1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgMTAwMCk7XG4gICAgICByZXN1bHQuaXNfdXRjID0gc2VsZi5pc191dGM7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVzZWNcbiAgICBgc2VsZi5nZXRNaWxsaXNlY29uZHMoKSAqIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB6b25lXG4gICAgJXh7XG4gICAgICB2YXIgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCcoJykgPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9bQS1aXXszLDR9LylbMF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLm1hdGNoKC9cXCgoLispXFwpKD86XFxzfCQpLylbMV1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PSBcIkdNVFwiICYmIC8oR01UXFxXKlxcZHs0fSkvLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gUmVnRXhwLiQxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0Z21cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSk7XG4gICAgICByZXN1bHQuaXNfdXRjID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBnZXR1dGMgZ2V0Z21cblxuICBkZWYgZ210aW1lXG4gICAgJXh7XG4gICAgICBzZWxmLmlzX3V0YyA9IHRydWU7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHV0YyBnbXRpbWVcblxuICBkZWYgZ210P1xuICAgIGBzZWxmLmlzX3V0YyA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGdtdF9vZmZzZXRcbiAgICBgc2VsZi5pc191dGMgPyAwIDogLXNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwYFxuICBlbmRcblxuICBkZWYgc3RyZnRpbWUoZm9ybWF0KVxuICAgICV4e1xuICAgICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lKFtcXC1fI14wXSo6ezAsMn0pKFxcZCspPyhbRU9dKikoLikvZywgZnVuY3Rpb24oZnVsbCwgZmxhZ3MsIHdpZHRoLCBfLCBjb252KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgICAgICAgemVybyAgID0gZmxhZ3MuaW5kZXhPZignMCcpICE9PSAtMSxcbiAgICAgICAgICAgIHBhZCAgICA9IGZsYWdzLmluZGV4T2YoJy0nKSA9PT0gLTEsXG4gICAgICAgICAgICBibGFuayAgPSBmbGFncy5pbmRleE9mKCdfJykgIT09IC0xLFxuICAgICAgICAgICAgdXBjYXNlID0gZmxhZ3MuaW5kZXhPZignXicpICE9PSAtMSxcbiAgICAgICAgICAgIGludmVydCA9IGZsYWdzLmluZGV4T2YoJyMnKSAhPT0gLTEsXG4gICAgICAgICAgICBjb2xvbnMgPSAoZmxhZ3MubWF0Y2goJzonKSB8fCBbXSkubGVuZ3RoO1xuXG4gICAgICAgIHdpZHRoID0gcGFyc2VJbnQod2lkdGgsIDEwKTtcblxuICAgICAgICBpZiAoemVybyAmJiBibGFuaykge1xuICAgICAgICAgIGlmIChmbGFncy5pbmRleE9mKCcwJykgPCBmbGFncy5pbmRleE9mKCdfJykpIHtcbiAgICAgICAgICAgIHplcm8gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibGFuayA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoY29udikge1xuICAgICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7eWVhcn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSBNYXRoLnJvdW5kKCN7eWVhcn0gLyAxMDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7eWVhcn0gJSAxMDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttb259O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBsb25nX21vbnRoc1sje21vbn0gLSAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gc2hvcnRfbW9udGhzWyN7bW9ufSAtIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbmtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvXG4gICAgICAgICAgICByZXN1bHQgKz0gI3tkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdqJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gMyA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7eWRheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2hvdXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdrJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2hvdXJ9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdJJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ICUgMTIgfHwgMTIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSA+PSAxMiA/IFwicG1cIiA6IFwiYW1cIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJQTVwiIDogXCJBTVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7bWlufTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c2VjfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gMyA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgd2lkdGggICA9IGlzTmFOKHdpZHRoKSA/IDkgOiB3aWR0aDtcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2BzZWxmLmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKClgLnJqdXN0KDMsICcwJyl9O1xuICAgICAgICAgICAgcmVzdWx0ICA9ICN7YHJlc3VsdGAubGp1c3QoYHdpZHRoYCwgJzAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgdmFyIG9mZnNldCAgPSBzZWxmLmdldFRpbWV6b25lT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgaG91cnMgICA9IE1hdGguZmxvb3IoTWF0aC5hYnMob2Zmc2V0KSAvIDYwKSxcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5hYnMob2Zmc2V0KSAlIDYwO1xuXG4gICAgICAgICAgICByZXN1bHQgKz0gb2Zmc2V0IDwgMCA/IFwiK1wiIDogXCItXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gaG91cnMgPCAxMCA/IFwiMFwiIDogXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IG1pbnV0ZXM7XG5cbiAgICAgICAgICAgIGlmIChjb2xvbnMgPiAxKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjowMFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7em9uZX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGRheXNfb2Zfd2Vla1sje3dkYXl9XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gc2hvcnRfZGF5c1sje3dkYXl9XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7d2RheX0gKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t3ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclswXS50b19zLnJqdXN0KDIsICcwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tjd2Vla19jeWVhclsxXVstMi4uLTFdfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t0b19pfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gXCIlXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVhICViICVlICVUICVZJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclbS8lZC8leScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnRic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJVktJW0tJWQnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVlLSVeYi0lNFknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVJOiVNOiVTICVwJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdSJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUg6JU06JVMnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGNhc2UpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvW0EtWl0vLCBmdW5jdGlvbihjKSB7IGMudG9Mb3dlckNhc2UoKSB9KS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvW2Etel0vLCBmdW5jdGlvbihjKSB7IGMudG9VcHBlckNhc2UoKSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWQgJiYgKHplcm8gfHwgYmxhbmspKSB7XG4gICAgICAgICAgcmVzdWx0ID0gI3tgcmVzdWx0YC5yanVzdChgaXNOYU4od2lkdGgpID8gMiA6IHdpZHRoYCwgYGJsYW5rID8gXCIgXCIgOiBcIjBcImApfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdW5kYXk/XG4gICAgYCN7d2RheX0gPT0gMGBcbiAgZW5kXG5cbiAgZGVmIHRodXJzZGF5P1xuICAgIGAje3dkYXl9ID09IDRgXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgW3NlYywgbWluLCBob3VyLCBkYXksIG1vbnRoLCB5ZWFyLCB3ZGF5LCB5ZGF5LCBpc2RzdCwgem9uZV1cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBgc2VsZi5nZXRUaW1lKCkgLyAxMDAwYFxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBwYXJzZUludChzZWxmLmdldFRpbWUoKSAvIDEwMDAsIDEwKWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgZGVmIHR1ZXNkYXk/XG4gICAgYCN7d2RheX0gPT0gMmBcbiAgZW5kXG5cbiAgYWxpYXMgdHZfc2VjIHRvX2lcblxuICBhbGlhcyB0dl91c2VjIHVzZWNcblxuICBhbGlhcyB1dGM/IGdtdD9cblxuICBhbGlhcyBnbXRvZmYgZ210X29mZnNldFxuICBhbGlhcyB1dGNfb2Zmc2V0IGdtdF9vZmZzZXRcblxuICBkZWYgd2RheVxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDRGF5KCkgOiBzZWxmLmdldERheSgpYFxuICBlbmRcblxuICBkZWYgd2VkbmVzZGF5P1xuICAgIGAje3dkYXl9ID09IDNgXG4gIGVuZFxuXG4gIGRlZiB5ZWFyXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENGdWxsWWVhcigpIDogc2VsZi5nZXRGdWxsWWVhcigpYFxuICBlbmRcblxuICBkZWYgY3dlZWtfY3llYXJcbiAgICBqYW4wMSA9IFRpbWUubmV3KHllYXIsIDEsIDEpXG4gICAgamFuMDFfd2RheSA9IGphbjAxLndkYXlcbiAgICBmaXJzdF9tb25kYXkgPSAwXG4gICAgeWVhciA9IHNlbGYueWVhclxuICAgIGlmIGphbjAxX3dkYXkgPD0gNCAmJiBqYW4wMV93ZGF5ICE9IDBcbiAgICAgICMgSmFuIDAxIGlzIGluIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyXG4gICAgICBvZmZzZXQgPSBqYW4wMV93ZGF5IC0gMVxuICAgIGVsc2VcbiAgICAgICMgSmFuIDAxIGlzIGluIHRoZSBsYXN0IHdlZWsgb2YgdGhlIHByZXZpb3VzIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSA3IC0gMVxuICAgICAgb2Zmc2V0ID0gLTEgaWYgb2Zmc2V0ID09IC04ICMgQWRqdXN0IGlmIEphbiAwMSBpcyBhIFN1bmRheVxuICAgIGVuZFxuXG4gICAgd2VlayA9ICgoeWRheSArIG9mZnNldCkgLyA3LjAwKS5jZWlsXG5cbiAgICBpZiB3ZWVrIDw9IDBcbiAgICAgICMgR2V0IHRoZSBsYXN0IHdlZWsgb2YgdGhlIHByZXZpb3VzIHllYXJcbiAgICAgIHJldHVybiBUaW1lLm5ldyhzZWxmLnllYXIgLSAxLCAxMiwgMzEpLmN3ZWVrX2N5ZWFyXG4gICAgZWxzaWYgd2VlayA9PSA1M1xuICAgICAgIyBGaW5kIG91dCB3aGV0aGVyIHRoaXMgaXMgYWN0dWFsbHkgd2VlayA1MyBvciBhbHJlYWR5IHdlZWsgMDEgb2YgdGhlIGZvbGxvd2luZyB5ZWFyXG4gICAgICBkZWMzMSA9IFRpbWUubmV3KHNlbGYueWVhciwgMTIsIDMxKVxuICAgICAgZGVjMzFfd2RheSA9IGRlYzMxLndkYXlcbiAgICAgIGlmIGRlYzMxX3dkYXkgPD0gMyAmJiBkZWMzMV93ZGF5ICE9IDBcbiAgICAgICAgd2VlayA9IDFcbiAgICAgICAgeWVhciArPSAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIFt3ZWVrLCB5ZWFyXVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpUaW1lPiIsImluY2x1ZGUiLCJDb21wYXJhYmxlIiwiYXQiLCJzZWNvbmRzIiwiZnJhYyIsIlRpbWUiLCI9PT0iLCJyYWlzZSIsIlR5cGVFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsInJlc3BvbmRfdG8/IiwidG9fc3RyIiwidG9faSIsIkFyZ3VtZW50RXJyb3IiLCJuZXciLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWluIiwic2VjIiwidXRjX29mZnNldCIsImxvY2FsIiwibWlsbGlzZWNvbmQiLCJfZHVtbXkxIiwiX2R1bW15MiIsIl9kdW1teTMiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsIiRyZXRfb3JfMSIsImFzY3RpbWUiLCJzdHJmdGltZSIsInlkYXkiLCJzdGFydF9vZl95ZWFyIiwic3RhcnRfb2ZfZGF5Iiwib25lX2RheSIsIjg2NDAwIiwiLyIsInJvdW5kIiwiaXNkc3QiLCJkdXAiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJpbml0aWFsaXplX2R1cCIsImVxbD8iLCIkcmV0X29yXzIiLCJpc19hPyIsInplcm8/IiwiZnJpZGF5PyIsIndkYXkiLCJoYXNoIiwiaW5zcGVjdCIsInV0Yz8iLCJtb24iLCJtb25kYXk/Iiwic2F0dXJkYXk/Iiwic3VjYyIsInVzZWMiLCJ6b25lIiwiZ2V0Z20iLCJnbXRpbWUiLCJnbXQ/IiwiZ210X29mZnNldCIsImZvcm1hdCIsInJqdXN0IiwiMyIsImxqdXN0IiwiY3dlZWtfY3llYXIiLCJbXSIsInRvX3MiLCIyIiwiLTIiLCJzdW5kYXk/IiwidGh1cnNkYXk/IiwidG9fYSIsInR1ZXNkYXk/Iiwid2VkbmVzZGF5PyIsImphbjAxIiwiamFuMDFfd2RheSIsImZpcnN0X21vbmRheSIsIiRyZXRfb3JfMyIsIjw9IiwiNCIsIiE9Iiwib2Zmc2V0IiwiNyIsIi04Iiwid2VlayIsImNlaWwiLCIxMiIsIjMxIiwiNTMiLCJkZWMzMSIsImRlYzMxX3dkYXkiLCIkcmV0X29yXzQiXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsMEJBQVJEOztBQUdGRCx1QkFBeUIsQ0FBR0EsUUFBSCxFQUFVQSxRQUFWLEVBQWlCQSxTQUFqQixFQUF5QkEsV0FBekIsRUFBbUNBLFVBQW5DLEVBQTRDQSxRQUE1QyxFQUFtREEsVUFBbkQsRUFBNERBLFFBQTVELENBQW9FQTtBQUM3RkEsdUJBQXlCLENBQUdBLEtBQUgsRUFBT0EsS0FBUCxFQUFXQSxLQUFYLEVBQWVBLEtBQWYsRUFBbUJBLEtBQW5CLEVBQXVCQSxLQUF2QixFQUEyQkEsS0FBM0IsQ0FBZ0NBO0FBQ3pEQSx1QkFBeUIsQ0FBR0EsS0FBSCxFQUFPQSxLQUFQLEVBQVdBLEtBQVgsRUFBZUEsS0FBZixFQUFtQkEsS0FBbkIs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QUtjLFNBQUxkLElBQUtjLEVBQUdXLENBQUhYLEVBRlAsRUFKRjtNQVVBbUQsT0FBQSxDQUFDb0IsSUFBRCxFQUFPckYsSUFBUDtJQTdCRmlFLENBQUFBLGtDQUFBQSxDQUFBQTtFQTdzQkZuRixHQUFBQSxXQUFBQSxFQUFjSCxJQUFkRztBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjQwODIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3N0cnVjdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIFN0cnVjdFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBkZWYgc2VsZi5uZXcoY29uc3RfbmFtZSwgKmFyZ3MsIGtleXdvcmRfaW5pdDogZmFsc2UsICZibG9jaylcbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICBpZiBjb25zdF9uYW1lLmNsYXNzID09IFN0cmluZyAmJiBjb25zdF9uYW1lWzBdLnVwY2FzZSAhPSBjb25zdF9uYW1lWzBdXG4gICAgICAgICMgRmFzdCB0cmFjayBzbyB0aGF0IHdlIHNraXAgbmVlZGxlc3NseSBnb2luZyB0aHJ1IGV4Y2VwdGlvbnNcbiAgICAgICAgIyBpbiBtb3N0IGNhc2VzLlxuICAgICAgICBhcmdzLnVuc2hpZnQoY29uc3RfbmFtZSlcbiAgICAgICAgY29uc3RfbmFtZSA9IG5pbFxuICAgICAgZWxzZVxuICAgICAgICBiZWdpblxuICAgICAgICAgIGNvbnN0X25hbWUgPSBPcGFsLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXG4gICAgICAgIHJlc2N1ZSBUeXBlRXJyb3IsIE5hbWVFcnJvclxuICAgICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICAgIGNvbnN0X25hbWUgPSBuaWxcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFyZ3MubWFwIGRvIHxhcmd8XG4gICAgICBPcGFsLmNvZXJjZV90byEoYXJnLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgZW5kXG5cbiAgICBrbGFzcyA9IENsYXNzLm5ldyhzZWxmKSBkb1xuICAgICAgYXJncy5lYWNoIHsgfGFyZ3wgZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUoYXJnKSB9XG5cbiAgICAgIGNsYXNzIDw8IHNlbGZcbiAgICAgICAgZGVmIG5ldygqYXJncylcbiAgICAgICAgICBpbnN0YW5jZSA9IGFsbG9jYXRlXG4gICAgICAgICAgYCN7aW5zdGFuY2V9LiQkZGF0YSA9IHt9YFxuICAgICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUoKmFyZ3MpXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYWxpYXNfbWV0aG9kIDpbXSwgOm5ld1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBrbGFzcy5tb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrXG4gICAgYGtsYXNzLiQka2V5d29yZF9pbml0ID0ga2V5d29yZF9pbml0YFxuXG4gICAgaWYgY29uc3RfbmFtZVxuICAgICAgU3RydWN0LmNvbnN0X3NldChjb25zdF9uYW1lLCBrbGFzcylcbiAgICBlbmRcblxuICAgIGtsYXNzXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlKG5hbWUpXG4gICAgaWYgc2VsZiA9PSBTdHJ1Y3RcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd5b3UgY2Fubm90IGRlZmluZSBhdHRyaWJ1dGVzIHRvIHRoZSBTdHJ1Y3QgY2xhc3MnXG4gICAgZW5kXG5cbiAgICBtZW1iZXJzIDw8IG5hbWVcblxuICAgIGRlZmluZV9tZXRob2QgbmFtZSBkb1xuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICAgIGVuZFxuXG4gICAgZGVmaW5lX21ldGhvZCBcIiN7bmFtZX09XCIgZG8gfHZhbHVlfFxuICAgICAgYHNlbGYuJCRkYXRhW25hbWVdID0gdmFsdWVgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm1lbWJlcnNcbiAgICBpZiBzZWxmID09IFN0cnVjdFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RoZSBTdHJ1Y3QgY2xhc3MgaGFzIG5vIG1lbWJlcnMnXG4gICAgZW5kXG5cbiAgICBAbWVtYmVycyB8fD0gW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgIG1lbWJlcnMgPSBAbWVtYmVyc1xuXG4gICAga2xhc3MuaW5zdGFuY2VfZXZhbCBkb1xuICAgICAgQG1lbWJlcnMgPSBtZW1iZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgIGlmIGAje3NlbGYuY2xhc3N9LiQka2V5d29yZF9pbml0YFxuICAgICAga3dhcmdzID0gYXJncy5sYXN0IHx8IHt9XG5cbiAgICAgIGlmIGFyZ3MubGVuZ3RoID4gMSB8fCBgKGFyZ3MubGVuZ3RoID09PSAxICYmICFrd2FyZ3MuJCRpc19oYXNoKWBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChnaXZlbiAje2FyZ3MubGVuZ3RofSwgZXhwZWN0ZWQgMClcIlxuICAgICAgZW5kXG5cbiAgICAgIGV4dHJhID0ga3dhcmdzLmtleXMgLSBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgICAgIGlmIGV4dHJhLmFueT9cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmtub3duIGtleXdvcmRzOiAje2V4dHJhLmpvaW4oJywgJyl9XCJcbiAgICAgIGVuZFxuXG4gICAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgc2VsZltuYW1lXSA9IGt3YXJnc1tuYW1lXVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgaWYgYXJncy5sZW5ndGggPiBzZWxmLmNsYXNzLm1lbWJlcnMubGVuZ3RoXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdzdHJ1Y3Qgc2l6ZSBkaWZmZXJzJ1xuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoX3dpdGhfaW5kZXggZG8gfG5hbWUsIGluZGV4fFxuICAgICAgICBzZWxmW25hbWVdID0gYXJnc1tpbmRleF1cbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KGZyb20pXG4gICAgJXh7XG4gICAgICBzZWxmLiQkZGF0YSA9IHt9XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20uJCRkYXRhKSwgaSwgbWF4LCBuYW1lO1xuICAgICAgZm9yIChpID0gMCwgbWF4ID0ga2V5cy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBuYW1lID0ga2V5c1tpXTtcbiAgICAgICAgc2VsZi4kJGRhdGFbbmFtZV0gPSBmcm9tLiQkZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZW1iZXJzXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgSGFzaC5uZXcoYHNlbGYuJCRkYXRhYCkuaGFzaFxuICBlbmRcblxuICBkZWYgW10obmFtZSlcbiAgICBpZiBJbnRlZ2VyID09PSBuYW1lXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBzbWFsbCBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA8IC1zZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gbGFyZ2UgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPj0gc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcblxuICAgICAgbmFtZSA9IHNlbGYuY2xhc3MubWVtYmVyc1tuYW1lXVxuICAgIGVsc2lmIFN0cmluZyA9PT0gbmFtZVxuICAgICAgJXh7XG4gICAgICAgIGlmKCFzZWxmLiQkZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcIm5vIG1lbWJlciAnI3tuYW1lfScgaW4gc3RydWN0XCIsIG5hbWUpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tuYW1lLmNsYXNzfSBpbnRvIEludGVnZXJcIlxuICAgIGVuZFxuXG4gICAgbmFtZSA9IE9wYWwuY29lcmNlX3RvIShuYW1lLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYHNlbGYuJCRkYXRhW25hbWVdYFxuICBlbmRcblxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIGlmIEludGVnZXIgPT09IG5hbWVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIHNtYWxsIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lIDwgLXNlbGYuY2xhc3MubWVtYmVycy5zaXplXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgU3RyaW5nID09PSBuYW1lXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwibm8gbWVtYmVyICcje25hbWV9JyBpbiBzdHJ1Y3RcIiwgbmFtZSkgdW5sZXNzIHNlbGYuY2xhc3MubWVtYmVycy5pbmNsdWRlPyhuYW1lLnRvX3N5bSlcbiAgICBlbHNlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgc2VsZi4kJGRhdGFbbmFtZV0gPSB2YWx1ZWBcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaW5zdGFuY2Vfb2Y/KHNlbGYuY2xhc3MpXG5cbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZDEgPSB7fSwgcmVjdXJzZWQyID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKHN0cnVjdCwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGtleSwgYSwgYjtcblxuICAgICAgICByZWN1cnNlZDFbI3tgc3RydWN0YC5fX2lkX199XSA9IHRydWU7XG4gICAgICAgIHJlY3Vyc2VkMlsje2BvdGhlcmAuX19pZF9ffV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIHN0cnVjdC4kJGRhdGEpIHtcbiAgICAgICAgICBhID0gc3RydWN0LiQkZGF0YVtrZXldO1xuICAgICAgICAgIGIgPSBvdGhlci4kJGRhdGFba2V5XTtcblxuICAgICAgICAgIGlmICgje1N0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAgPT0gYGJgfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIG90aGVyLmluc3RhbmNlX29mPyhzZWxmLmNsYXNzKVxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQxID0ge30sIHJlY3Vyc2VkMiA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBfZXFlcShzdHJ1Y3QsIG90aGVyKSB7XG4gICAgICAgIHZhciBrZXksIGEsIGI7XG5cbiAgICAgICAgcmVjdXJzZWQxWyN7YHN0cnVjdGAuX19pZF9ffV0gPSB0cnVlO1xuICAgICAgICByZWN1cnNlZDJbI3tgb3RoZXJgLl9faWRfX31dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBzdHJ1Y3QuJCRkYXRhKSB7XG4gICAgICAgICAgYSA9IHN0cnVjdC4kJGRhdGFba2V5XTtcbiAgICAgICAgICBiID0gb3RoZXIuJCRkYXRhW2tleV07XG5cbiAgICAgICAgICBpZiAoI3tTdHJ1Y3QgPT09IGBhYH0pIHtcbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQxLmhhc093blByb3BlcnR5KCN7YGFgLl9faWRfX30pIHx8ICFyZWN1cnNlZDIuaGFzT3duUHJvcGVydHkoI3tgYmAuX19pZF9ffSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFlcShhLCBiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISN7YGFgLmVxbD8oYGJgKX0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2VxZXEoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIHNlbGZbbmFtZV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfcGFpclxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9wYWlyKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaCB7IHxuYW1lfCB5aWVsZCBbbmFtZSwgc2VsZltuYW1lXV0gfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgdG9fYVxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5tYXAgeyB8bmFtZXwgc2VsZltuYW1lXSB9XG4gIGVuZFxuXG4gIGFsaWFzIHZhbHVlcyB0b19hXG5cbiAgZGVmIGluc3BlY3RcbiAgICByZXN1bHQgPSAnIzxzdHJ1Y3QgJ1xuXG4gICAgaWYgU3RydWN0ID09PSBzZWxmICYmIHNlbGYuY2xhc3MubmFtZVxuICAgICAgcmVzdWx0ICs9IFwiI3tzZWxmLmNsYXNzfSBcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICs9IGVhY2hfcGFpci5tYXAgZG8gfG5hbWUsIHZhbHVlfFxuICAgICAgXCIje25hbWV9PSN7dmFsdWUuaW5zcGVjdH1cIlxuICAgIGVuZC5qb2luICcsICdcblxuICAgIHJlc3VsdCArPSAnPidcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2goKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2hfd2l0aF9vYmplY3Qoe30pIHsgfG5hbWUsIGh8IGhbbmFtZV0gPSBzZWxmW25hbWVdIH1cbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICBhcmdzID0gYXJncy5tYXAgeyB8YXJnfCBgYXJnLiQkaXNfcmFuZ2UgPyAje2FyZy50b19hfSA6IGFyZ2AgfS5mbGF0dGVuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWFyZ3NbaV0uJCRpc19udW1iZXIpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7YGFyZ3NbaV1gLmNsYXNzfSBpbnRvIEludGVnZXJcIn1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCgje3NlbGZbYGFyZ3NbaV1gXX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaWcoa2V5LCAqa2V5cylcbiAgICBpdGVtID0gaWYgYGtleS4kJGlzX3N0cmluZyAmJiBzZWxmLiQkZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpYFxuICAgICAgICAgICAgIGBzZWxmLiQkZGF0YVtrZXldIHx8IG5pbGBcbiAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cnVjdD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIm5ldyIsImNvbnN0X25hbWUiLCIkcmV0X29yXzEiLCJjbGFzcyIsIj09IiwiU3RyaW5nIiwiW10iLCIwIiwidXBjYXNlIiwiIT0iLCJhcmdzIiwidW5zaGlmdCIsIk9wYWwiLCJjb25zdF9uYW1lISIsIlR5cGVFcnJvciIsIk5hbWVFcnJvciIsIm1hcCIsImJsb2NrIGluIG5ldyIsImFyZyIsImJsb2NrICgyIGxldmVscykgaW4gbmV3IiwiY29lcmNlX3RvISIsImtsYXNzIiwiQ2xhc3MiLCJlYWNoIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuZXciLCJkZWZpbmVfc3RydWN0X2F0dHJpYnV0ZSIsImluc3RhbmNlIiwiYWxsb2NhdGUiLCJpbml0aWFsaXplIiwiYWxpYXNfbWV0aG9kIiwiYmxvY2siLCJtb2R1bGVfZXZhbCIsInRvX3Byb2MiLCJTdHJ1Y3QiLCJjb25zdF9zZXQiLCJuYW1lIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwibWVtYmVycyIsIjw8IiwiZGVmaW5lX21ldGhvZCIsImJsb2NrIGluIGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWZpbmVfc3RydWN0X2F0dHJpYnV0ZSIsInZhbHVlIiwiQG1lbWJlcnMiLCIkcmV0X29yXzIiLCJpbmhlcml0ZWQiLCJpbnN0YW5jZV9ldmFsIiwiYmxvY2sgaW4gaW5oZXJpdGVkIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbmhlcml0ZWQiLCJrd2FyZ3MiLCIkcmV0X29yXzMiLCJsYXN0IiwiJHJldF9vcl80IiwiPiIsImxlbmd0aCIsIjEiLCJleHRyYSIsIi0iLCJrZXlzIiwiYW55PyIsImpvaW4iLCJibG9jayBpbiBpbml0aWFsaXplIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBpbml0aWFsaXplIiwiJHdyaXRlciIsIltdPSIsImVhY2hfd2l0aF9pbmRleCIsImluZGV4IiwiaW5pdGlhbGl6ZV9jb3B5IiwiZnJvbSIsImhhc2giLCJIYXNoIiwiSW50ZWdlciIsIj09PSIsIjwiLCJzaXplIiwiLUAiLCJJbmRleEVycm9yIiwiPj0iLCJpbmNsdWRlPyIsInRvX3N5bSIsIm90aGVyIiwiaW5zdGFuY2Vfb2Y/IiwiX19pZF9fIiwiZXFsPyIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfcGFpciIsImJsb2NrIGluIGVhY2hfcGFpciIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9wYWlyIiwidG9fYSIsImJsb2NrIGluIHRvX2EiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiJHJldF9vcl81IiwiKyIsImJsb2NrIGluIGluc3BlY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJ0b19oIiwiZWFjaF93aXRoX29iamVjdCIsImJsb2NrIGluIHRvX2giLCJoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0b19oIiwidmFsdWVzX2F0IiwiYmxvY2sgaW4gdmFsdWVzX2F0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB2YWx1ZXNfYXQiLCJmbGF0dGVuIiwiZGlnIiwia2V5IiwiaXRlbSIsInJlc3BvbmRfdG8/Il0sIm1hcHBpbmdzIjoiQUFBQUEsaURBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLDBCQUFSRDtJQUVBRSxVQUFJTCxJQUFKSyxVQUFBQSxnQkFBQUEsU0FBYUMsVUFBRCxFQUxkLEVBS2MsRUFMZCxFQUtFRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFxRDs7TUFM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bUNBQUFBO0lBY0E3RyxPQUFBaUgsQ0FBQUEsdUJBQUFBLGlCQUFBQSxlQUFRQyxHQUFELEVBN1NULEVBNlNFRDtBQUFBQSxNQUFBQTs7OztNQTdTRjs7TUE2U2U7TUFDWEUsT0FBTyxhQUFBLElBQUEsUUFBSUYsa0RBQUosQ0FBQTtRQUNFQSxPQUFDQSx1QkFBREE7TUFERjtRQUFBQSxPQUFBO01BQUEsQ0FBQTs7QUFLWEE7QUFDQUE7QUFDQUE7QUFDQUE7TUFFSSxJQUFBLFFBQU9FLElBQUlDLGdCQUFBQSxDQUFhLEtBQWJBLENBQVgsQ0FBQTtNQUFBO1FBQ0V0SCxJQUFBeUMsT0FBQUEsQ0FBTXRCLHlCQUFOLEVBQWlCLEVBQUEsR0FBQSxDQUFHa0csSUFBSTdHLE9BQUFBLENBQUFBLENBQVAsQ0FBQSxHQUFjMkcsNEJBQS9CMUU7TUFERjtNQUlBMEUsT0FBSUEsTUFBSkUsSUFBSUYsT0FBQUEsRUFBSyxVQUFDbkQsSUFBRCxDQUFMbUQ7SUFmTkEsQ0FBQUEsNkJBQUFBLENBQUFBO0VBM1NGakgsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFGQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NjI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9kaXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRGlyXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgY2hkaXIoZGlyKVxuICAgICAgcHJldl9jd2QgPSBgT3BhbC5jdXJyZW50X2RpcmBcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3tkaXJ9YFxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3twcmV2X2N3ZH1gXG4gICAgZW5kXG5cbiAgICBkZWYgcHdkXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXG4gICAgZW5kXG4gICAgYWxpYXMgZ2V0d2QgcHdkXG5cbiAgICBkZWYgaG9tZVxuICAgICAgRU5WWydIT01FJ10gfHwgJy4nXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpEaXI+IiwiY2hkaXIiLCJkaXIiLCJwcmV2X2N3ZCIsInB3ZCIsImhvbWUiLCIkcmV0X29yXzEiLCJFTlYiLCJbXSIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQSw4Q0FBQUE7RUFBQUE7O0VBQUFBO0VBQUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQTtNQUFBOzs7O0FBQ0VDLE1BQUFBLHlCQUFBQSxXQUFBQSxpQkFBVUMsR0FBVkQ7QUFBQUEsUUFBQUE7O1FBQUFBO1FBQ0VBLE9BQUEsY0FBQTs7UUFBQUUsV0FBWUY7UUFDWEEsbUJBQXFCQztRQUN0QixPQUFBLHFCQUFBLEVBQUE7UUFGQTtVQUlDRCxtQkFBcUJFO1FBSnRCLENBQUE7TUFERkYsQ0FBQUEsc0JBQUFBOztBQVFBRyxNQUFBQSx1QkFBQUEsU0FBQUEsZUFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUNBLHVCQUFEQTtNQURGQSxDQUFBQSxvQkFBQUE7TUFHQSxhQUFNLE9BQU4sRUFBWSxLQUFaO01BRUEsT0FBQUMsQ0FBQUEsd0JBQUFBLFVBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRSxJQUFBLFFBaEJOQyxDQUFBQSxZQWdCTUMsbUJBQUdDLE9BQUFBLENBQUNILE1BQURHLENBaEJURixDQWdCTSxDQUFBO1VBaEJORCxPQUFBO1FBZ0JNO1VBQWVBLE9BQUFBO1FBQWY7TUFERkEsQ0FBQUEscUJBQUFBLENBQUFBO0lBZEYsNEJBQVNJLElBQVQ7RUFERlQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0Njc0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9maWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XG5cbmNsYXNzIEZpbGUgPCBJT1xuICBTZXBhcmF0b3IgPSBTRVBBUkFUT1IgPSAnLydcbiAgQUxUX1NFUEFSQVRPUiA9IG5pbFxuICBQQVRIX1NFUEFSQVRPUiA9ICc6J1xuICAjIEFzc3VtaW5nIGNhc2UgaW5zZW5zdGl2ZSBmaWxlc3lzdGVtXG4gIEZOTV9TWVNDQVNFID0gMFxuICB3aW5kb3dzX3Jvb3RfcnggPSAlcnteW2EtekEtWl06KD86XFxcXHxcXC8pfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyID0gbmlsKVxuICAgICAgc2VwID0gU0VQQVJBVE9SXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmV3X3BhcnRzID0gW11cblxuICAgICAgcGF0aCA9IHBhdGgucmVzcG9uZF90bz8oOnRvX3BhdGgpID8gcGF0aC50b19wYXRoIDogcGF0aFxuICAgICAgYmFzZWRpciB8fD0gRGlyLnB3ZFxuICAgICAgcGF0aF9hYnMgICAgPSBgcGF0aC5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKWBcbiAgICAgIGJhc2VkaXJfYWJzID0gYGJhc2VkaXIuc3Vic3RyKDAsIHNlcC5sZW5ndGgpID09PSBzZXAgfHwgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcilgXG5cbiAgICAgIGlmIHBhdGhfYWJzXG4gICAgICAgIHBhcnRzICAgICAgID0gcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKSA/ICcnIDogI3twYXRoLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnRzICAgICAgID0gYmFzZWRpci5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKSArIHBhdGguc3BsaXQoL1sje3NlcF9jaGFyc31dLylcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcikgPyAnJyA6ICN7YmFzZWRpci5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIGFicyAgICAgICAgID0gYmFzZWRpcl9hYnNcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIHBhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocGFydCA9PT0gbmlsKSB8fFxuICAgICAgICAgICAgKHBhcnQgPT09ICcnICAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJy4nICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgbmV3X3BhcnRzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFicyAmJiBwYXJ0c1swXSAhPT0gJy4nKSB7XG4gICAgICAgICAgI3tuZXdfcGFydHMudW5zaGlmdCAnLid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3X3BhdGggPSBuZXdfcGFydHMuam9pbihzZXApXG4gICAgICBuZXdfcGF0aCA9IGxlYWRpbmdfc2VwICsgbmV3X3BhdGggaWYgYWJzXG4gICAgICBuZXdfcGF0aFxuICAgIGVuZFxuXG4gICAgZGVmIGV4cGFuZF9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBpZiBgcGF0aFswXSA9PT0gJ34nIHx8IChiYXNlZGlyICYmIGJhc2VkaXJbMF0gPT09ICd+JylgXG4gICAgICAgIGhvbWUgPSBEaXIuaG9tZVxuICAgICAgICByYWlzZShBcmd1bWVudEVycm9yLCBcImNvdWxkbid0IGZpbmQgSE9NRSBlbnZpcm9ubWVudCAtLSBleHBhbmRpbmcgYH4nXCIpIHVubGVzcyBob21lXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KGhvbWUpID8gJycgOiAje2hvbWUuc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICByYWlzZShBcmd1bWVudEVycm9yLCAnbm9uLWFic29sdXRlIGhvbWUnKSB1bmxlc3MgaG9tZS5zdGFydF93aXRoPyhsZWFkaW5nX3NlcClcblxuICAgICAgICBob21lICAgICAgICAgICAgKz0gc2VwXG4gICAgICAgIGhvbWVfcGF0aF9yZWdleHAgPSAvXlxcfig/OiN7c2VwfXwkKS9cbiAgICAgICAgcGF0aCAgICAgICAgICAgICA9IHBhdGguc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpXG4gICAgICAgIGJhc2VkaXIgICAgICAgICAgPSBiYXNlZGlyLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKSBpZiBiYXNlZGlyXG4gICAgICBlbmRcbiAgICAgIGFic29sdXRlX3BhdGgocGF0aCwgYmFzZWRpcilcbiAgICBlbmRcbiAgICBhbGlhcyByZWFscGF0aCBleHBhbmRfcGF0aFxuXG4gICAgJXh7XG4gICAgICAvLyBDb2VyY2UgYSBnaXZlbiBwYXRoIHRvIGEgcGF0aCBzdHJpbmcgdXNpbmcgI3RvX3BhdGggYW5kICN0b19zdHJcbiAgICAgIGZ1bmN0aW9uICRjb2VyY2VfdG9fcGF0aChwYXRoKSB7XG4gICAgICAgIGlmICgkdHJ1dGh5KCN7YHBhdGhgLnJlc3BvbmRfdG8/KDp0b19wYXRoKX0pKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGguJHRvX3BhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSAje09wYWwuY29lcmNlX3RvIShgcGF0aGAsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSBSZWdFeHAgY29tcGF0aWJsZSBjaGFyIGNsYXNzXG4gICAgICBmdW5jdGlvbiAkc2VwX2NoYXJzKCkge1xuICAgICAgICBpZiAoI3tBTFRfU0VQQVJBVE9SfSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1IgKyBBTFRfU0VQQVJBVE9SfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYgZGlybmFtZShwYXRoKVxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIHBhdGggPSBgJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhYnNvbHV0ZSA9IHBhdGgubWF0Y2gobmV3IFJlZ0V4cCgje1wiXlsje3NlcF9jaGFyc31dXCJ9KSk7XG5cbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgc2VwYXJhdG9yc1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlteI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgYmFzZW5hbWVcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgZmluYWwgdHJhaWxpbmcgc2VwYXJhdG9yc1xuXG4gICAgICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBhYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGJhc2VuYW1lKG5hbWUsIHN1ZmZpeCA9IG5pbClcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuYW1lID0gYCRjb2VyY2VfdG9fcGF0aChuYW1lKWBcbiAgICAgICV4e1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1ZmZpeCAhPT0gbmlsKSB7XG4gICAgICAgICAgc3VmZml4ID0gI3tPcGFsLmNvZXJjZV90byEoc3VmZml4LCBTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1ZmZpeCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiguKVsje3NlcF9jaGFyc31dKiRcIn0pLCAnJDEnKTtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJeKD86LipbI3tzZXBfY2hhcnN9XSk/KFteI3tzZXBfY2hhcnN9XSspJFwifSksICckMScpO1xuXG4gICAgICAgIGlmIChzdWZmaXggPT09IFwiLipcIikge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLlteXFwuXSskLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYoc3VmZml4ICE9PSBudWxsKSB7XG4gICAgICAgICAgc3VmZml4ID0gT3BhbC5lc2NhcGVfcmVnZXhwKHN1ZmZpeCk7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIje3N1ZmZpeH0kXCJ9KSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgZXh0bmFtZShwYXRoKVxuICAgICAgYHBhdGggPSAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICBmaWxlbmFtZSA9IGJhc2VuYW1lKHBhdGgpXG4gICAgICByZXR1cm4gJycgaWYgZmlsZW5hbWUuZW1wdHk/XG4gICAgICBsYXN0X2RvdF9pZHggPSBmaWxlbmFtZVsxLi4tMV0ucmluZGV4KCcuJylcbiAgICAgICMgZXh0ZW5zaW9uIG5hbWUgbXVzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIC4oc29tZXRoaW5nKVxuICAgICAgbGFzdF9kb3RfaWR4Lm5pbD8gfHwgbGFzdF9kb3RfaWR4ICsgMSA9PSBmaWxlbmFtZS5sZW5ndGggLSAxID8gJycgOiBmaWxlbmFtZVsobGFzdF9kb3RfaWR4ICsgMSkuLi0xXVxuICAgIGVuZFxuXG4gICAgZGVmIGV4aXN0PyhwYXRoKVxuICAgICAgYE9wYWwubW9kdWxlc1sje3BhdGh9XSAhPSBudWxsYFxuICAgIGVuZFxuICAgIGFsaWFzIGV4aXN0cz8gZXhpc3Q/XG5cbiAgICBkZWYgZGlyZWN0b3J5PyhwYXRoKVxuICAgICAgZmlsZXMgPSBbXVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgICAje2ZpbGVzfS5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aCA9IHBhdGguZ3N1YigvKF4uI3tTRVBBUkFUT1J9K3wje1NFUEFSQVRPUn0rJCkvKVxuICAgICAgZmlsZSA9IGZpbGVzLmZpbmQgeyB8ZnwgZiA9fiAvXiN7cGF0aH0vIH1cbiAgICAgIGZpbGVcbiAgICBlbmRcblxuICAgIGRlZiBqb2luKCpwYXRocylcbiAgICAgIGlmIHBhdGhzLmVtcHR5P1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0ID0gJydcbiAgICAgIHBhdGhzID0gcGF0aHMuZmxhdHRlbi5lYWNoX3dpdGhfaW5kZXgubWFwIGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgaWYgaW5kZXggPT0gMCAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNpZiBwYXRocy5sZW5ndGggPT0gaW5kZXggKyAxICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpdGVtXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBwYXRocyA9IHBhdGhzLnJlamVjdCgmOmVtcHR5PylcbiAgICAgIHBhdGhzLmVhY2hfd2l0aF9pbmRleCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIG5leHRfaXRlbSA9IHBhdGhzW2luZGV4ICsgMV1cbiAgICAgICAgaWYgbmV4dF9pdGVtLm5pbD9cbiAgICAgICAgICByZXN1bHQgPSBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSAmJiBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3ViKC8je1NFUEFSQVRPUn0rJC8sICcnKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHJlc3VsdCA9IGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgfHwgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19I3tTRVBBUkFUT1J9XCJcbiAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuXG4gICAgZGVmIHNwbGl0KHBhdGgpXG4gICAgICBwYXRoLnNwbGl0KFNFUEFSQVRPUilcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkZpbGU+IiwiMCIsIndpbmRvd3Nfcm9vdF9yeCIsImFic29sdXRlX3BhdGgiLCJwYXRoIiwiYmFzZWRpciIsInNlcCIsIlNFUEFSQVRPUiIsInNlcF9jaGFycyIsIm5ld19wYXJ0cyIsInJlc3BvbmRfdG8/IiwidG9fcGF0aCIsIiRyZXRfb3JfMSIsIkRpciIsInB3ZCIsInBhdGhfYWJzIiwiYmFzZWRpcl9hYnMiLCJwYXJ0cyIsInNwbGl0IiwibGVhZGluZ19zZXAiLCJzdWIiLCJhYnMiLCIrIiwidW5zaGlmdCIsIm5ld19wYXRoIiwiam9pbiIsImV4cGFuZF9wYXRoIiwiaG9tZSIsInNlbGYiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJzdGFydF93aXRoPyIsImhvbWVfcGF0aF9yZWdleHAiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsIkFMVF9TRVBBUkFUT1IiLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJuYW1lIiwic3VmZml4IiwiZXh0bmFtZSIsImZpbGVuYW1lIiwiZW1wdHk/IiwibGFzdF9kb3RfaWR4IiwiW10iLCIxIiwiLTEiLCJyaW5kZXgiLCIkcmV0X29yXzIiLCJuaWw/IiwiPT0iLCItIiwibGVuZ3RoIiwiZXhpc3Q/IiwiZGlyZWN0b3J5PyIsImZpbGVzIiwiZ3N1YiIsImZpbGUiLCJmaW5kIiwiYmxvY2sgaW4gZGlyZWN0b3J5PyIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGRpcmVjdG9yeT8iLCI9fiIsInBhdGhzIiwicmVzdWx0IiwibWFwIiwiZmxhdHRlbiIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrIGluIGpvaW4iLCJpdGVtIiwiaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGpvaW4iLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJyZWplY3QiLCJ0b19wcm9jIiwibmV4dF9pdGVtIiwiJHJldF9vcl81IiwiZW5kX3dpdGg/IiwiJHJldF9vcl82IiwiSU8iXSwibWFwcGluZ3MiOiJBQUFBQSwrQ0FBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0UseUNBQVkseUNBQVlBLEdBQVosQ0FBWjtJQUNBLDZDQUFnQixHQUFoQjtJQUNBLDhDQUFpQkEsR0FBakI7SUFFQSwyQ0FBY0MsQ0FBZDtJQUNBQyxrQkFBa0I7SUFFbEJGLE9BQUE7TUFBQTs7OztBQUNFRyxNQUFBQSxpQ0FBQUEsbUJBQUFBLHlCQUFrQkMsSUFBRCxFQUFPQyxPQUF4QkY7QUFBQUEsUUFBQUE7Ozs7UUFBd0I7UUFBQSxZQUFVLEdBQVY7UUFBQTtRQUN0QkcsTUFBTUM7UUFDTkMsWUFBYUw7UUFDYk0sWUFBWTtRQUVaTCxPQUFPLGFBQUEsSUFBQSxRQUFBQSxJQUFJTSxnQkFBQUEsQ0FBYSxTQUFiQSxDQUFKLENBQUE7VUFBNkJQLE9BQUFDLElBQUlPLFNBQUFBLENBQUFBO1FBQWpDO1VBQTRDUixPQUFBQztRQUE1QyxDQUFBO1FBQ1BDLFVBakJOLGFBQUEsSUFBQSxRQUFBTyxDQUFBQSxZQWlCTVAsT0FqQk5PLENBQUEsQ0FBQTtVQUFBVCxPQUFBO1FBQUE7VUFpQmtCQSxPQUFBVSxtQkFBR0MsS0FBQUEsQ0FBQUE7UUFqQnJCLENBQUE7UUFrQk1DLFdBQWVaO1FBQ2ZhLGNBQWViO1FBRWYsSUFBQSxRQUFHWSxRQUFILENBQUE7O1VBQ0VFLFFBQWNiLElBQUljLE9BQUFBLENBQU8sYUFBQ2YsR0FBRCxFQUFJSyxTQUFKLEVBQWNMLEdBQWQsQ0FBQSxDQUFQZTtVQUNsQkMsY0FBZWhCLGtDQUFvQ0MsSUFBSWdCLEtBQUFBLENBQUssYUFBQ2pCLEtBQUQsRUFBTUssU0FBTixFQUFnQkwsUUFBaEIsQ0FBQSxDQUFULEVBQWtDQSxLQUE5QmlCO1VBQ3ZEQyxNQUFjO1FB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QUFBLEVBQUEsR0FBQSxDQUFHUCxNQUFILENBQUEsR0FBQSxDQUFZSyxJQUFaLENBQUEsR0FBQSxDQUFtQi9ELHlCQUFuQjtZQUhGLENBQUEsa0JBQVQwRDtVQU5GLEVBRm9CSSxtQkFBQUEsa0JBQUFBLE1BQWpCRDtRQWVMM0MsT0FBQXdDO01BOUJGeEMsQ0FBQUEsc0JBQUFBO01BaUNBLE9BQUFQLENBQUFBLHlCQUFBQSxZQUFBQSxpQkFBVWQsSUFBVmM7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFkLElBQUljLE9BQUFBLENBQU9YLHlCQUFQVztNQUROQSxDQUFBQSx1QkFBQUEsQ0FBQUE7SUFuTUYsNEJBQVNVLElBQVQ7RUFSRjVCLEdBQUFBLFdBQUFBLEVBQWFpRixrQkFBYmpGO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTAwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvY2Vzcy9iYXNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFNpZ25hbFxuICBkZWYgc2VsZi50cmFwKCopXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEdDXG4gIGRlZiBzZWxmLnN0YXJ0XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpTaWduYWw+IiwidHJhcCIsInNlbGYiLCI8Y2xhc3M6R0M+Iiwic3RhcnQiXSwibWFwcGluZ3MiOiJBQUFBQSx1REFBQUE7RUFBQUE7OztFQUFBQztFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFDLENBQUFBLFVBQUlDLElBQUpELFdBQUFBLGlCQUFBQSxnQkFERixFQUNFQTtBQUFBQSxNQUFBQTs7OztNQURGOztNQUNnQjtNQURoQkEsT0FBQTtJQUNFQSxDQUFBQSw2QkFBQUEsQ0FBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFLQUQsT0FBQUk7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyxDQUFBQSxVQUFJRixJQUFKRSxZQUFBQSxjQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BTkZBLE9BQUE7SUFNRUEsQ0FBQUEseUJBQUFBLENBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBTEFKOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTAzNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvY2Vzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgUHJvY2Vzc1xuICBAX19jbG9ja3NfXyA9IFtdXG4gIGRlZiBzZWxmLl9fcmVnaXN0ZXJfY2xvY2tfXyhuYW1lLCBmdW5jKVxuICAgIGNvbnN0X3NldCBuYW1lLCBAX19jbG9ja3NfXy5zaXplXG4gICAgQF9fY2xvY2tzX18gPDwgZnVuY1xuICBlbmRcblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18gOkNMT0NLX1JFQUxUSU1FLCBgZnVuY3Rpb24oKSB7IHJldHVybiBEYXRlLm5vdygpIH1gXG5cbiAgbW9ub3RvbmljID0gZmFsc2VcblxuICAleHtcbiAgICBpZiAoT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UpIHtcbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKE9wYWwuZ2xvYmFsLnByb2Nlc3MgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICAgIC8vIGxldCBub3cgYmUgdGhlIGJhc2UgdG8gZ2V0IHNtYWxsZXIgbnVtYmVyc1xuICAgICAgdmFyIGhydGltZV9iYXNlID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuICAgICAgbW9ub3RvbmljID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBocnRpbWUgPSBwcm9jZXNzLmhydGltZShocnRpbWVfYmFzZSk7XG4gICAgICAgIHZhciB1cyA9IChocnRpbWVbMV0gLyAxMDAwKSB8IDA7IC8vIGN1dCBiZWxvdyBtaWNyb3NlY3M7XG4gICAgICAgIHJldHVybiAoKGhydGltZVswXSAqIDEwMDApICsgKHVzIC8gMTAwMCkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBfX3JlZ2lzdGVyX2Nsb2NrX18oOkNMT0NLX01PTk9UT05JQywgbW9ub3RvbmljKSBpZiBtb25vdG9uaWNcblxuICBkZWYgc2VsZi5waWRcbiAgICAwXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRpbWVzXG4gICAgdCA9IFRpbWUubm93LnRvX2ZcbiAgICBCZW5jaG1hcms6OlRtcy5uZXcodCwgdCwgdCwgdCwgdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xvY2tfZ2V0dGltZShjbG9ja19pZCwgdW5pdCA9IDpmbG9hdF9zZWNvbmQpXG4gICAgKGNsb2NrID0gQF9fY2xvY2tzX19bY2xvY2tfaWRdKSB8fCByYWlzZShFcnJubzo6RUlOVkFMLCBcImNsb2NrX2dldHRpbWUoI3tjbG9ja19pZH0pICN7QF9fY2xvY2tzX19bY2xvY2tfaWRdfVwiKVxuICAgICV4e1xuICAgICAgdmFyIG1zID0gY2xvY2soKTtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlICdmbG9hdF9zZWNvbmQnOiAgICAgIHJldHVybiAgKG1zIC8gMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYSBmbG9hdCAoZGVmYXVsdClcbiAgICAgICAgY2FzZSAnZmxvYXRfbWlsbGlzZWNvbmQnOiByZXR1cm4gIChtcyAvIDEpOyAgICAgICAgICAgIC8vIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdmbG9hdF9taWNyb3NlY29uZCc6IHJldHVybiAgKG1zICogMTAwMCk7ICAgICAgICAgLy8gbnVtYmVyIG9mIG1pY3Jvc2Vjb25kcyBhcyBhIGZsb2F0XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6ICAgICAgICAgICAgcmV0dXJuICgobXMgLyAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2Ygc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgLyAxKSAgICAgICB8IDApOyAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbWljcm9zZWNvbmQnOiAgICAgICByZXR1cm4gKChtcyAqIDEwMDApICAgIHwgMCk7IC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICduYW5vc2Vjb25kJzogICAgICAgIHJldHVybiAoKG1zICogMTAwMDAwMCkgfCAwKTsgLy8gbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgZGVmYXVsdDogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVuZXhwZWN0ZWQgdW5pdDogI3t1bml0fVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpQcm9jZXNzPiIsIkBfX2Nsb2Nrc19fIiwiX19yZWdpc3Rlcl9jbG9ja19fIiwic2VsZiIsIm5hbWUiLCJmdW5jIiwiY29uc3Rfc2V0Iiwic2l6ZSIsIjw8IiwibW9ub3RvbmljIiwicGlkIiwiMCIsInRpbWVzIiwidCIsIlRpbWUiLCJub3ciLCJ0b19mIiwiQmVuY2htYXJrOjpUbXMiLCJCZW5jaG1hcmsiLCJuZXciLCJjbG9ja19nZXR0aW1lIiwiY2xvY2tfaWQiLCJ1bml0IiwiJHJldF9vcl8xIiwiY2xvY2siLCJbXSIsInJhaXNlIiwiRXJybm86OkVJTlZBTCIsIkVycm5vIiwiQXJndW1lbnRFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBLGtEQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsa0JBQWM7SUFDZEMsVUFBSUMsSUFBSkQseUJBQUFBLGdDQUFBQSw4QkFBNEJFLElBQUQsRUFBT0MsSUFBbENIO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFDRUMsSUFBQUcsV0FBQUEsQ0FBVUYsSUFBVixFQUFnQkgsZUFBV00sTUFBQUEsQ0FBQUEsQ0FBM0JEO01BQ0FKLE9BQUFELGVBQVlPLE9BQUFBLENBQUdILElBQUhHO0lBRmROLENBQUFBLDJDQUFBQTtJQUtBQyxJQUFBRCxvQkFBQUEsQ0FBbUIsZ0JBQW5CLEVBQXFDRixnQ0FBckNFO0lBRUFPLFlBQVk7O0FBR2RUO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFLElBQUEsUUFBbURTLFNBQW5ELENBQUE7TUFBQU4sSUFBQUQsb0JBQUFBLENBQW1CLGlCQUFuQixFQUFxQ08sU0FBckNQLENBQUE7SUFFQVEsVUFBSVAsSUFBSk8sVUFBQUEsaUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQztJQURGRCxDQUFBQSw0QkFBQUE7SUFJQUUsVUFBSVQsSUFBSlMsWUFBQUEsbUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0VDLElBQUlDLG9CQUFJQyxLQUFBQSxDQUFBQSxDQUFJQyxNQUFBQSxDQUFBQTtNQUNaSixPQUFBSyxJQUFBQyx5QkFBQUQsUUFBY0UsS0FBQUEsQ0FBS04sQ0FBbkIsRUFBc0JBLENBQXRCLEVBQXlCQSxDQUF6QixFQUE0QkEsQ0FBNUIsRUFBK0JBLENBQWpCTTtJQUZoQlAsQ0FBQUEsOEJBQUFBO0lBS0FaLE9BQUFvQixDQUFBQSxVQUFJakIsSUFBSmlCLG9CQUFBQSwyQkFBQUEseUJBQXVCQyxRQUFELEVBQVdDLElBQWpDRjtBQUFBQSxNQUFBQTtBQUFBQTs7OztNQUFpQztNQUFBLFNBQU8sY0FBUDtNQUFBO01BQy9CLElBQUEsUUF6Q0pHLENBQUFBLFlBeUNLQyxDQUFBQSxRQUFRdkIsZUFBV3dCLE9BQUFBLENBQUNKLFFBQURJLENBQW5CRCxDQXpDTEQsQ0F5Q0ksQ0FBQTtRQXpDSjtNQXlDSTtRQUFtQ3BCLElBQUF1QixPQUFBQSxDQUFNQyxJQUFBQyxxQkFBQUQsV0FBTixFQUFxQixFQUFBLEdBQUNQLGdCQUFELEdBQUEsQ0FBaUJDLFFBQWpCLENBQUEsR0FBMEJELElBQTFCLEdBQUEsQ0FBOEJuQixlQUFXd0IsT0FBQUEsQ0FBQ0osUUFBREksQ0FBekMsQ0FBckJDO01BQW5DOztBQUVKTjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBbUJqQixJQUFBdUIsT0FBQUEsQ0FBTUcsNkJBQU4sRUFBcUIsRUFBQSxHQUFDVCxtQkFBRCxHQUFBLENBQW9CRSxJQUFwQixDQUFyQkk7QUFDbkJOO0FBQ0FBO0lBZEVBLENBQUFBLHVDQUFBQSxDQUFBQTtFQXhDRnBCLEdBQUFBLFdBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNTExNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSYW5kb21cbiAgbW9kdWxlIEZvcm1hdHRlclxuICAgIGRlZiBoZXgoY291bnQgPSBuaWwpXG4gICAgICBjb3VudCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgJXh7XG4gICAgICAgIHZhciBieXRlcyA9ICN7Ynl0ZXMoY291bnQpfTtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xuICAgICAgICAgIG91dCArPSBieXRlcy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX2J5dGVzKGNvdW50ID0gbmlsKVxuICAgICAgYnl0ZXMoY291bnQpXG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZTY0KGNvdW50ID0gbmlsKVxuICAgICAgQmFzZTY0LnN0cmljdF9lbmNvZGU2NChyYW5kb21fYnl0ZXMoY291bnQpKS5lbmNvZGUoJ1VTLUFTQ0lJJylcbiAgICBlbmRcblxuICAgIGRlZiB1cmxzYWZlX2Jhc2U2NChjb3VudCA9IG5pbCwgcGFkZGluZyA9IGZhbHNlKVxuICAgICAgQmFzZTY0LnVybHNhZmVfZW5jb2RlNjQocmFuZG9tX2J5dGVzKGNvdW50KSwgcGFkZGluZykuZW5jb2RlKCdVUy1BU0NJSScpXG4gICAgZW5kXG5cbiAgICBkZWYgdXVpZFxuICAgICAgc3RyID0gaGV4KDE2KS5zcGxpdCgnJylcbiAgICAgIHN0clsxMl0gPSAnNCdcbiAgICAgIHN0clsxNl0gPSBgKHBhcnNlSW50KCN7c3RyWzE2XX0sIDE2KSAmIDMgfCA4KS50b1N0cmluZygxNilgXG4gICAgICBzdHIgPSBbc3RyWzAuLi44XSwgc3RyWzguLi4xMl0sIHN0clsxMi4uLjE2XSwgc3RyWzE2Li4uMjBdLCBzdHJbMjAuLi4zMl1dXG4gICAgICBzdHIgPSBzdHIubWFwKCY6am9pbilcbiAgICAgIHN0ci5qb2luKCctJylcbiAgICBlbmRcblxuICAgICMgSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgYCNieXRlc2AgZm9yIFNlY3VyZVJhbmRvbSwgYnV0IFJhbmRvbSBvdmVycmlkZXMgdGhpc1xuICAgICMgbWV0aG9kIHRvIGltcGxlbWVudCBgI2J5dGVzYCBpbiB0ZXJtcyBvZiBgI3JhbmRvbV9mbG9hdGAuIE5vdCBwYXJ0IG9mIHN0YW5kYXJkXG4gICAgIyBSdWJ5IGludGVyZmFjZSAtIHVzZSByYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eS5cbiAgICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgICBicyA9IGJ5dGVzKDQpXG4gICAgICBudW0gPSAwXG4gICAgICA0LnRpbWVzIGRvIHxpfFxuICAgICAgICBudW0gPDw9IDhcbiAgICAgICAgbnVtIHw9IGJzW2ldLm9yZFxuICAgICAgZW5kXG4gICAgICBudW0uYWJzIC8gMHg3ZmZmZmZmZlxuICAgIGVuZFxuXG4gICAgZGVmIHJhbmRvbV9udW1iZXIobGltaXQgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tRmxvYXQoKSB7XG4gICAgICAgICAgcmV0dXJuICN7cmFuZG9tX2Zsb2F0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUludChtYXgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kb21GbG9hdCgpICogbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbVJhbmdlKCkge1xuICAgICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcbiAgICAgICAgICAgICAgbWF4ID0gbGltaXQuZW5kO1xuXG4gICAgICAgICAgaWYgKG1pbiA9PT0gbmlsIHx8IG1heCA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZW5ndGggPSBtYXggLSBtaW47XG5cbiAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXggJSAxID09PSAwICYmIG1pbiAlIDEgPT09IDAgJiYgIWxpbWl0LmV4Y2wpIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGVuZ3RoKSArIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19yYW5nZSkge1xuICAgICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCkgKiBsaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGFscGhhbnVtZXJpYyhjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gUmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxuICAgICAgQXJyYXkubmV3KGNvdW50KSBkbyB8aXxcbiAgICAgICAgbWFwW3JhbmRvbV9udW1iZXIobWFwLmxlbmd0aCldXG4gICAgICBlbmQuam9pblxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIFJhbmRvbTo6Rm9ybWF0dGVyXG4gIGV4dGVuZCBSYW5kb206OkZvcm1hdHRlclxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSYW5kb20+IiwiPG1vZHVsZTpGb3JtYXR0ZXI+IiwiaGV4IiwiY291bnQiLCJSYW5kb20iLCJfdmVyaWZ5X2NvdW50Iiwic2VsZiIsImJ5dGVzIiwiZW5jb2RlIiwicmFuZG9tX2J5dGVzIiwiYmFzZTY0IiwiQmFzZTY0Iiwic3RyaWN0X2VuY29kZTY0IiwidXJsc2FmZV9iYXNlNjQiLCJwYWRkaW5nIiwidXJsc2FmZV9lbmNvZGU2NCIsInV1aWQiLCJzdHIiLCIxNiIsInNwbGl0IiwiJHdyaXRlciIsIjEyIiwiW109IiwiLSIsIjEiLCJbXSIsIjAiLCI4IiwiMjAiLCIzMiIsIm1hcCIsInRvX3Byb2MiLCJqb2luIiwicmFuZG9tX2Zsb2F0IiwiYnMiLCI0IiwibnVtIiwidGltZXMiLCJibG9jayBpbiByYW5kb21fZmxvYXQiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByYW5kb21fZmxvYXQiLCI8PCIsInwiLCJvcmQiLCIvIiwiYWJzIiwiMjE0NzQ4MzY0NyIsInJhbmRvbV9udW1iZXIiLCJsaW1pdCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImFscGhhbnVtZXJpYyIsImZsYXR0ZW4iLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGFscGhhbnVtZXJpYyIsImJsb2NrICgyIGxldmVscykgaW4gYWxwaGFudW1lcmljIiwibGVuZ3RoIiwiaW5jbHVkZSIsIlJhbmRvbTo6Rm9ybWF0dGVyIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkRBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFQztJQUFBQTs7TUFBQUE7Ozs7QUFDRUMsTUFBQUEsdUJBQUFBLG1CQUFBQSxlQUFRQyxLQUFSRDtBQUFBQSxR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Q2RGOztBQUVBQTtBQUNBQTtBQUNBQTtNQTNESUEsQ0FBQUEseUNBQUFBO01BOERBOUMsT0FBQXFELENBQUFBLGdDQUFBQSw0QkFBQUEsd0JBQWlCbkQsS0FBakJtRDtBQUFBQSxRQUFBQTs7OztRQUFpQjtRQUFBLFVBQVEsR0FBUjtRQUFBO1FBQ2ZuRCxRQUFRQyxzQkFBTUMsZUFBQUEsQ0FBZUYsS0FBZkU7UUFDZHlCLE1BQW9DQSxNQUE5QixDQUFDLE9BQUF3QixHQUFBLEVBQUtBLEdBQUwsUUFBRCxFQUFXLE9BQUFBLEdBQUEsRUFBS0EsR0FBTCxRQUFYLEVBQXFCLE9BQUFBLEdBQUEsRUFBS0EsR0FBTCxRQUFyQixDQUE4QnhCLE9BQUFBLEVBQUFBLEVBQUFBLEVBQU0sTUFBREMsU0FBQUEsQ0FBQUEsQ0FBTEQsQ0FBWXlCLFNBQUFBLENBQUFBO1FBQ2hERCxPQUFLRSxNQUFMQyxxQkFBS0QsT0FBQUEsRUFBQUEsQ0FBS3JELEtBQUxxRCxDQUFBQSxFQUFZRSxpQkFBSW5CLENBQUptQixFQUFBQzs7OztVQUFJO1VBQUE7VUFBQTtVQUNuQkEsT0FBQTdCLEdBQUdMLE9BQUFBLENBQUNuQixJQUFBeUMsZUFBQUEsQ0FBY2pCLEdBQUc4QixRQUFBQSxDQUFBQSxDQUFqQmIsQ0FBRHRCLEVBRFlpQyxtQkFBQUEsa0JBQUFBLE1BQVpGLENBRUZ4QixNQUFBQSxDQUFBQTtNQUxMc0IsQ0FBQUEsd0NBQUFBLENBQUFBO0lBN0dGckQsR0FBQUEsV0FBQUE7SUFzSEFLLElBQUF1RCxTQUFBQSxDQUFRQyxJQUFBMUQsc0JBQUEwRCxjQUFSRDtJQUNBN0QsT0FBQU0sSUFBQXlELFFBQUFBLENBQU9ELElBQUExRCxzQkFBQTBELGNBQVBDO0VBeEhGL0QsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFBQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MzIyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20vbWVyc2VubmVfdHdpc3Rlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFRoaXMgaXMgYmFzZWQgb24gYW4gYWRhcHRhdGlvbiBvZiBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhJ3MgY29kZVxuIyBkb25lIGJ5IFNlYW4gTWNDdWxsb3VnaCA8YmFua3NlYW5AZ21haWwuY29tPiBhbmQgRGF2ZSBIZWl0em1hblxuIyA8ZGF2ZWhlaXR6bWFuQHlhaG9vLmNvbT4sIHN1YnNlcXVlbnRseSByZWFkYXB0ZWQgZnJvbSBhbiB1cGRhdGVkIHZlcnNpb24gb2ZcbiMgcnVieSdzIHJhbmRvbS5jIChyZXYgYzM4YTE4MzAzMmE3ODI2ZGYxYWRhYmQ4YWEwNzI1YzcxM2Q1M2UxYykuXG4jXG4jIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZyb20gcmFuZG9tLmMgZm9sbG93cy5cbiNcbiMgICBUaGlzIGlzIGJhc2VkIG9uIHRyaW1tZWQgdmVyc2lvbiBvZiBNVDE5OTM3LiAgVG8gZ2V0IHRoZSBvcmlnaW5hbCB2ZXJzaW9uLFxuIyAgIGNvbnRhY3QgPGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL2VtdC5odG1sPi5cbiNcbiMgICBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IG5vdGljZSBmb2xsb3dzLlxuI1xuIyAgICAgIEEgQy1wcm9ncmFtIGZvciBNVDE5OTM3LCB3aXRoIGluaXRpYWxpemF0aW9uIGltcHJvdmVkIDIwMDIvMi8xMC5cbiMgICAgICBDb2RlZCBieSBUYWt1amkgTmlzaGltdXJhIGFuZCBNYWtvdG8gTWF0c3Vtb3RvLlxuIyAgICAgIFRoaXMgaXMgYSBmYXN0ZXIgdmVyc2lvbiBieSB0YWtpbmcgU2hhd24gQ29rdXMncyBvcHRpbWl6YXRpb24sXG4jICAgICAgTWF0dGhlIEJlbGxldydzIHNpbXBsaWZpY2F0aW9uLCBJc2FrdSBXYWRhJ3MgcmVhbCB2ZXJzaW9uLlxuI1xuIyAgICAgIEJlZm9yZSB1c2luZywgaW5pdGlhbGl6ZSB0aGUgc3RhdGUgYnkgdXNpbmcgaW5pdF9nZW5yYW5kKG10LCBzZWVkKVxuIyAgICAgIG9yIGluaXRfYnlfYXJyYXkobXQsIGluaXRfa2V5LCBrZXlfbGVuZ3RoKS5cbiNcbiMgICAgICBDb3B5cmlnaHQgKEMpIDE5OTcgLSAyMDAyLCBNYWtvdG8gTWF0c3Vtb3RvIGFuZCBUYWt1amkgTmlzaGltdXJhLFxuIyAgICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4jXG4jICAgICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4jICAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4jICAgICAgYXJlIG1ldDpcbiNcbiMgICAgICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4jXG4jICAgICAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuIyAgICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuIyAgICAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiNcbiMgICAgICAgIDMuIFRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGVcbiMgICAgICAgICAgIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlblxuIyAgICAgICAgICAgcGVybWlzc2lvbi5cbiNcbiMgICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4jICAgICAgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuIyAgICAgIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuIyAgICAgIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuIyAgICAgIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuIyAgICAgIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiMgICAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiMgICAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4jICAgICAgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiMgICAgICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiMgICAgICBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiNcbiNcbiMgICAgICBBbnkgZmVlZGJhY2sgaXMgdmVyeSB3ZWxjb21lLlxuIyAgICAgIGh0dHA6Ly93d3cubWF0aC5rZWlvLmFjLmpwL21hdHVtb3RvL2VtdC5odG1sXG4jICAgICAgZW1haWw6IG1hdHVtb3RvQG1hdGgua2Vpby5hYy5qcFxubWVyc2VubmVfdHdpc3RlciA9ICV4eyhmdW5jdGlvbigpIHtcbiAgLyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cbiAgdmFyIE4gPSA2MjQ7XG4gIHZhciBNID0gMzk3O1xuICB2YXIgTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgICAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXG4gIHZhciBVTUFTSyA9IDB4ODAwMDAwMDA7ICAgICAgICAgLyogbW9zdCBzaWduaWZpY2FudCB3LXIgYml0cyAqL1xuICB2YXIgTE1BU0sgPSAweDdmZmZmZmZmOyAgICAgICAgIC8qIGxlYXN0IHNpZ25pZmljYW50IHIgYml0cyAqL1xuICB2YXIgTUlYQklUUyA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKCAoKHUpICYgVU1BU0spIHwgKCh2KSAmIExNQVNLKSApOyB9O1xuICB2YXIgVFdJU1QgPSBmdW5jdGlvbih1LHYpIHsgcmV0dXJuIChNSVhCSVRTKCh1KSwodikpID4+PiAxKSBeICgodiAmIDB4MSkgPyBNQVRSSVhfQSA6IDB4MCk7IH07XG5cbiAgZnVuY3Rpb24gaW5pdChzKSB7XG4gICAgdmFyIG10ID0ge2xlZnQ6IDAsIG5leHQ6IE4sIHN0YXRlOiBuZXcgQXJyYXkoTil9O1xuICAgIGluaXRfZ2VucmFuZChtdCwgcyk7XG4gICAgcmV0dXJuIG10O1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZXMgbXRbTl0gd2l0aCBhIHNlZWQgKi9cbiAgZnVuY3Rpb24gaW5pdF9nZW5yYW5kKG10LCBzKSB7XG4gICAgdmFyIGosIGk7XG4gICAgbXQuc3RhdGVbMF0gPSBzID4+PiAwO1xuICAgIGZvciAoaj0xOyBqPE47IGorKykge1xuICAgICAgbXQuc3RhdGVbal0gPSAoMTgxMjQzMzI1MyAqICgobXQuc3RhdGVbai0xXSBeIChtdC5zdGF0ZVtqLTFdID4+IDMwKSA+Pj4gMCkpICsgaik7XG4gICAgICAvKiBTZWUgS251dGggVEFPQ1AgVm9sMi4gM3JkIEVkLiBQLjEwNiBmb3IgbXVsdGlwbGllci4gKi9cbiAgICAgIC8qIEluIHRoZSBwcmV2aW91cyB2ZXJzaW9ucywgTVNCcyBvZiB0aGUgc2VlZCBhZmZlY3QgICAqL1xuICAgICAgLyogb25seSBNU0JzIG9mIHRoZSBhcnJheSBzdGF0ZVtdLiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAvKiAyMDAyLzAxLzA5IG1vZGlmaWVkIGJ5IE1ha290byBNYXRzdW1vdG8gICAgICAgICAgICAgKi9cbiAgICAgIG10LnN0YXRlW2pdICY9IDB4ZmZmZmZmZmY7ICAvKiBmb3IgPjMyIGJpdCBtYWNoaW5lcyAqL1xuICAgIH1cbiAgICBtdC5sZWZ0ID0gMTtcbiAgICBtdC5uZXh0ID0gTjtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cbiAgZnVuY3Rpb24gbmV4dF9zdGF0ZShtdCkge1xuICAgIHZhciBwID0gMCwgX3AgPSBtdC5zdGF0ZTtcbiAgICB2YXIgajtcblxuICAgIG10LmxlZnQgPSBOO1xuICAgIG10Lm5leHQgPSAwO1xuXG4gICAgZm9yIChqPU4tTSsxOyAtLWo7IHArKylcbiAgICAgIF9wW3BdID0gX3BbcCsoTSldIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgZm9yIChqPU07IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbcCsoMSldKTtcblxuICAgIF9wW3BdID0gX3BbcCsoTS1OKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wWzBdKTtcbiAgfVxuXG4gIC8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cbiAgZnVuY3Rpb24gZ2VucmFuZF9pbnQzMihtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgeTtcblxuICAgIGlmICgtLW10LmxlZnQgPD0gMCkgbmV4dF9zdGF0ZShtdCk7XG4gICAgeSA9IG10LnN0YXRlW210Lm5leHQrK107XG5cbiAgICAvKiBUZW1wZXJpbmcgKi9cbiAgICB5IF49ICh5ID4+PiAxMSk7XG4gICAgeSBePSAoeSA8PCA3KSAmIDB4OWQyYzU2ODA7XG4gICAgeSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuICAgIHkgXj0gKHkgPj4+IDE4KTtcblxuICAgIHJldHVybiB5ID4+PiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYikge1xuICAgIGEgPj4+PSA1O1xuICAgIGIgPj4+PSA2O1xuICAgIHJldHVybihhKjY3MTA4ODY0LjArYikqKDEuMC85MDA3MTk5MjU0NzQwOTkyLjApO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxKSB3aXRoIDUzLWJpdCByZXNvbHV0aW9uXG4gIGZ1bmN0aW9uIGdlbnJhbmRfcmVhbChtdCkge1xuICAgIC8qIG10IG11c3QgYmUgaW5pdGlhbGl6ZWQgKi9cbiAgICB2YXIgYSA9IGdlbnJhbmRfaW50MzIobXQpLCBiID0gZ2VucmFuZF9pbnQzMihtdCk7XG4gICAgcmV0dXJuIGludF9wYWlyX3RvX3JlYWxfZXhjbHVzaXZlKGEsIGIpO1xuICB9XG5cbiAgcmV0dXJuIHsgZ2VucmFuZF9yZWFsOiBnZW5yYW5kX3JlYWwsIGluaXQ6IGluaXQgfTtcbn0pKCl9XG5cbmNsYXNzIFJhbmRvbVxuICBgdmFyIE1BWF9JTlQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBNYXRoLnBvdygyLCA1MykgLSAxYFxuXG4gIE1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SID0gYHtcbiAgICBuZXdfc2VlZDogZnVuY3Rpb24oKSB7IHJldHVybiBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNQVhfSU5UKTsgfSxcbiAgICByZXNlZWQ6IGZ1bmN0aW9uKHNlZWQpIHsgcmV0dXJuIG1lcnNlbm5lX3R3aXN0ZXIuaW5pdChzZWVkKTsgfSxcbiAgICByYW5kOiBmdW5jdGlvbihtdCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5nZW5yYW5kX3JlYWwobXQpOyB9XG4gIH1gXG5cbiAgc2VsZi5nZW5lcmF0b3IgPSBNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUlxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIm1lcnNlbm5lX3R3aXN0ZXIiLCI8Y2xhc3M6UmFuZG9tPiIsIiR3cml0ZXIiLCJNRVJTRU5ORV9UV0lTVEVSX0dFTkVSQVRPUiIsImdlbmVyYXRvcj0iLCJzZWxmIiwiLSIsIjEiXSwibWFwcGluZ3MiOiJBQUFBQSxrRUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQXNEQUMsbUJBQXNCRDtBQUN0QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtFQUVBQSxPQUFBRTtFQUFBQTs7SUFBQUE7OztJQUNHQTtJQUVELDBEQUE4QkE7QUFDaENBO0FBQ0FBO0FBQ0FBO0FBQ0FBLEdBSkU7O0lBM0lGQyxVQUFBLENBaUptQkMsMENBakpuQjtJQWlKTUMsTUFBSkMsSUFBSUQsY0FBQUEsRUFqSk4sVUFBQUYsT0FBQSxDQWlKTUU7SUFqSk5ILE9BQUFDLE9BQUEsQ0FBQUksVUFBQUosT0FBQSxDQUFBRCxRQUFBLENBQUFLLEVBQUFDLENBQUFELENBQUE7RUF3SUFMLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBeElBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjU0MzAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGZhbHN5XG5cbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlcidcblxuY2xhc3MgUmFuZG9tXG4gIGF0dHJfcmVhZGVyIDpzZWVkLCA6c3RhdGVcblxuICBkZWYgc2VsZi5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKCRmYWxzeShjb3VudCkpIGNvdW50ID0gMTY7XG4gICAgICBpZiAodHlwZW9mIGNvdW50ICE9PSBcIm51bWJlclwiKSBjb3VudCA9ICN7YGNvdW50YC50b19pbnR9O1xuICAgICAgaWYgKGNvdW50IDwgMCkgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgc3RyaW5nIHNpemUgKG9yIHNpemUgdG9vIGJpZyknfTtcbiAgICAgIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIHNlZWQgPSBPcGFsLmNvZXJjZV90byEoc2VlZCwgSW50ZWdlciwgOnRvX2ludClcbiAgICBAc3RhdGUgPSBzZWVkXG4gICAgcmVzZWVkKHNlZWQpXG4gIGVuZFxuXG4gIGRlZiByZXNlZWQoc2VlZClcbiAgICBAc2VlZCA9IHNlZWRcbiAgICBgc2VsZi4kcm5nID0gT3BhbC4kJHJhbmQucmVzZWVkKHNlZWQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5uZXdfc2VlZFxuICAgIGBPcGFsLiQkcmFuZC5uZXdfc2VlZCgpYFxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kKGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgIERFRkFVTFQucmFuZChsaW1pdClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuc3JhbmQobiA9IFJhbmRvbS5uZXdfc2VlZClcbiAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICBwcmV2aW91c19zZWVkID0gREVGQVVMVC5zZWVkXG4gICAgREVGQVVMVC5yZXNlZWQobilcbiAgICBwcmV2aW91c19zZWVkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnVyYW5kb20oc2l6ZSlcbiAgICA6OlNlY3VyZVJhbmRvbS5ieXRlcyhzaXplKVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5kb20gPT09IG90aGVyXG5cbiAgICBzZWVkID09IG90aGVyLnNlZWQgJiYgc3RhdGUgPT0gb3RoZXIuc3RhdGVcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzKGxlbmd0aClcbiAgICBsZW5ndGggPSBSYW5kb20uX3ZlcmlmeV9jb3VudChsZW5ndGgpXG5cbiAgICBBcnJheS5uZXcobGVuZ3RoKSB7IHJhbmQoMjU1KS5jaHIgfS5qb2luLmVuY29kZSgnQVNDSUktOEJJVCcpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmJ5dGVzKGxlbmd0aClcbiAgICBERUZBVUxULmJ5dGVzKGxlbmd0aClcbiAgZW5kXG5cbiAgZGVmIHJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgcmFuZG9tX251bWJlcihsaW1pdClcbiAgZW5kXG5cbiAgIyBOb3QgcGFydCBvZiB0aGUgUnVieSBpbnRlcmZhY2UgKHVzZSAjcmFuZG9tX251bWJlciBmb3IgcG9ydGFiaWxpdHkpLCBidXRcbiAgIyB1c2VkIGJ5IFJhbmRvbTo6Rm9ybWF0dGVyIGFzIGEgc2hvcnRjdXQsIGFzIGZvciBSYW5kb20gaW50ZXJmYWNlIHRoZSBmbG9hdFxuICAjIFJORyBpcyBwcmltYXJ5LlxuICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgJXh7XG4gICAgICBzZWxmLnN0YXRlKys7XG4gICAgICByZXR1cm4gT3BhbC4kJHJhbmQucmFuZChzZWxmLiRybmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucmFuZG9tX2Zsb2F0XG4gICAgREVGQVVMVC5yYW5kb21fZmxvYXRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZ2VuZXJhdG9yPShnZW5lcmF0b3IpXG4gICAgYE9wYWwuJCRyYW5kID0gI3tnZW5lcmF0b3J9YFxuXG4gICAgaWYgY29uc3RfZGVmaW5lZD8gOkRFRkFVTFRcbiAgICAgIERFRkFVTFQucmVzZWVkXG4gICAgZWxzZVxuICAgICAgY29uc3Rfc2V0IDpERUZBVUxULCBuZXcobmV3X3NlZWQpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXInXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlJhbmRvbT4iLCJhdHRyX3JlYWRlciIsIl92ZXJpZnlfY291bnQiLCJjb3VudCIsInRvX2ludCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluaXRpYWxpemUiLCJzZWVkIiwiUmFuZG9tIiwibmV3X3NlZWQiLCJPcGFsIiwiY29lcmNlX3RvISIsIkludGVnZXIiLCJAc3RhdGUiLCJyZXNlZWQiLCJAc2VlZCIsInJhbmQiLCJsaW1pdCIsIkRFRkFVTFQiLCJzcmFuZCIsIm4iLCJwcmV2aW91c19zZWVkIiwidXJhbmRvbSIsInNpemUiLCJTZWN1cmVSYW5kb20iLCJieXRlcyIsIj09Iiwib3RoZXIiLCI9PT0iLCIkcmV0X29yXzEiLCJzdGF0ZSIsImxlbmd0aCIsIm5ldyIsIkFycmF5IiwiYmxvY2sgaW4gYnl0ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIGJ5dGVzIiwiMjU1IiwiY2hyIiwiam9pbiIsImVuY29kZSIsInJhbmRvbV9udW1iZXIiLCJyYW5kb21fZmxvYXQiLCJnZW5lcmF0b3I9IiwiZ2VuZXJhdG9yIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9zZXQiXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRiwwQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsYUFBQUEsQ0FBWSxNQUFaLEVBQW1CLE9BQW5CQTtJQUVBQyxVQUFJSixJQUFKSSxvQkFBQUEsMEJBQUFBLHlCQUF1QkMsS0FBdkJEO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsNkNBQStDQSxDQUFDQSxLQUFEQSxDQUFPRSxRQUFBQSxDQUFBQSxDQUFRRjtBQUM5REEscUJBQXVCSixJQUFBTyxPQUFBQSxDQUFNQyw2QkFBTixFQUFxQkosd0NBQXJCRyxDQUE4REg7QUFDckZBO0FBQ0FBO0FBQ0FBO0lBUEVBLENBQUFBLHFDQUFBQTs7QUFVQUssSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBZUMsSUFBZkQ7QUFBQUEsTUFBQUE7Ozs7TUFBZTtNQUFBLFNBQU9FLHNCQUFNQyxVQUFBQSxDQUFBQSxDQUFiO01BQUE7TUFDYkYsT0FBT0csb0JBQUlDLGVBQUFBLENBQVlKLElBQWhCLEVBQXNCSyx1QkFBdEIsRUFBK0IsUUFBM0JEO01BQ1hFLGFBQVNOO01BQ1RELE9BQUFULElBQUFpQixRQUFBQSxDQUFPUCxJQUFQTztJQUhGUixDQUFBQSxtQ0FBQUE7O0FBTUFRLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVdQLElBQVhPO0FBQUFBLE1BQUFBOzs7TUFDRUMsWUFBUVI7TUFDUk8sT0FBQ0Esb0NBQURBO0lBRkZBLENBQUFBLDhCQUFBQTtJQUtBTCxVQUFJWixJQUFKWSxlQUFBQSxxQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxzQkFBREE7SUFERkEsQ0FBQUEsZ0NBQUFBO0lBSUFPLFVBQUluQixJQUFKbUIsV0FBQUEsaUJBQUFBLGdCQUFjQyxLQUFkRDtBQUFBQSxNQUFBQTs7OztNQUNFQSxPQUFBRSx1QkFBT0YsTUFBQUEsQ0FBTUMsS0FBTkQ7SUFEVEEsQ0FBQUEsNkJBQUFBO0lBSUFHLFVBQUl0QixJQUFKc0IsWUFBQUEsa0JBQUFBLGlCQUFlQyxDQUFmRDtBQUFBQSxNQUFBQTs7OztNQUFlO01BQUEsTUFBSVgsc0JBQU1DLFVBQUFBLENBQUFBLENBQVY7TUFBQTtNQUNiVyxJQUFJVixvQkFBSUMsZUFBQUEsQ0FBWVMsQ0FBaEIsRUFBbUJSLHVCQUFuQixFQUE0QixRQUF4QkQ7TUFFUlUsZ0JBQWdCSCx1QkFBT1gsTUFBQUEsQ0FBQUE7TUFDdkJXLHVCQUFPSixRQUFBQSxDQUFRTSxDQUFSTjtNQUNQSyxPQUFBRTtJQUxGRixDQUFBQSw4QkFBQUE7SUFRQUcsVUFBSXpCLElBQUp5QixjQUFBQSxvQkFBQUEsbUJBQWlCQyxJQUFqQkQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFFLElBQUEsSUFBQUEsaUJBQWNDLE9BQUFBLENBQU9GLElBQVBFO0lBRGhCSCxDQUFBQSwrQkFBQUE7O0FBSUFJLElBQUFBLHNCQUFBQSxtQkFBQUEsU0FBT0MsS0FBUEQ7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBb0JsQixzQkFBT29CLFFBQUFBLENBQUlELEtBQUpDLENBQTNCLENBQUE7TUFBQTtRQUFBLE9BQU87TUFBUDtNQUVBLElBQUEsUUFuREpDLENBQUFBLFlBbURJaEMsSUFBQVUsTUFBQUEsQ0FBQUEsQ0FBS21CLE9BQUFBLENBQUdDLEtBQUtwQixNQUFBQSxDQUFBQSxDQUFSbUIsQ0FuRFRHLENBbURJLENBQUE7UUFBc0JILE9BQUE3QixJQUFBaUMsT0FBQUEsQ0FBQUEsQ0FBTUosT0FBQUEsQ0FBR0MsS0FBS0csT0FBQUEsQ0FBQUEsQ0FBUko7TUFBNUI7UUFuREpBLE9BQUE7TUFtREk7SUFIRkEsQ0FBQUEsOEJBQUFBOztBQU1BRCxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFVTSxNQUFWTjtBQUFBQSxNQUFBQTs7O01BQ0VNLFNBQVN2QixzQkFBTVAsZUFBQUEsQ0FBZThCLE1BQWY5QjtNQUVmd0IsT0FBS08sTUFBTEMscUJBQUtELE9BQUFBLEVBQUFBLENBQUtELE1BQUxDLENBQUFBLEVBQWFFLGlCQUFBQSxFQUFBQzs7UUFBRUEsT0FBQXRDLElBQUFtQixNQUFBQSxDQUFLb0IsR0FBTHBCLENBQVNxQixLQUFBQSxDQUFBQSxDQUFYSCxtQkFBQUEsa0JBQUFBLE1BQWJGLENBQThCTSxNQUFBQSxDQUFBQSxDQUFLQyxRQUFBQSxDQUFRZCxZQUFSYztJQUgxQ2QsQ0FBQUEsNkJBQUFBO0lBTUFBLFVBQUk1QixJQUFKNEIsWUFBQUEsbUJBQUFBLGlCQUFlTSxNQUFmTjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQVAsdUJBQU9PLE9BQUFBLENBQU9NLE1BQVBOO0lBRFRBLENBQUFBLDhCQUFBQTs7QUFJQVQsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBU0MsS0FBVEQ7QUFBQUEsTUFBQUE7Ozs7TUFDRUEsT0FBQW5CLElBQUEyQyxlQUFBQSxDQUFjdkIsS0FBZHVCO0lBREZ4QixDQUFBQSw4QkFBQUE7O0FBT0F5QixJQUFBQSxnQ0FBQUEsMEJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0lBSkVBLENBQUFBLHFDQUFBQTtJQU9BQSxVQUFJNUMsSUFBSjRDLG1CQUFBQSwwQkFBQUEsd0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBdkIsdUJBQU91QixjQUFBQSxDQUFBQTtJQURUQSxDQUFBQSxxQ0FBQUE7SUFJQTFDLE9BQUEyQyxDQUFBQSxVQUFJN0MsSUFBSjZDLGlCQUFBQSwwQkFBQUEsU0FBb0JDLFNBQXBCRDtBQUFBQSxNQUFBQTs7O01BQ0dBLGNBQWdCQztNQUVqQixJQUFBLFFBQUc5QyxJQUFBK0MsbUJBQUFBLENBQWUsU0FBZkEsQ0FBSCxDQUFBO1FBQ0VGLE9BQUF4Qix1QkFBT0osUUFBQUEsQ0FBQUE7TUFEVDtRQUdFNEIsT0FBQTdDLElBQUFnRCxXQUFBQSxDQUFVLFNBQVYsRUFBb0JoRCxJQUFBbUMsS0FBQUEsQ0FBSW5DLElBQUFZLFVBQUFBLENBQUFBLENBQUp1QixDQUFwQmE7TUFIRjtJQUhGSCxDQUFBQSxxQ0FBQUEsQ0FBQUE7RUE5RUYzQyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQXlGQUgsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUNBQVJFO0FBN0ZBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjU1NzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3Vuc3VwcG9ydGVkLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiV4e1xuICB2YXIgd2FybmluZ3MgPSB7fTtcblxuICBmdW5jdGlvbiBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShtZXNzYWdlKSB7XG4gICAgc3dpdGNoIChPcGFsLmNvbmZpZy51bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eSkge1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICN7S2VybmVsLnJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBtZXNzYWdlYH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgd2FybihtZXNzYWdlKVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogLy8gaWdub3JlXG4gICAgICAvLyBub29wXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2FybihzdHJpbmcpIHtcbiAgICBpZiAod2FybmluZ3Nbc3RyaW5nXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5pbmdzW3N0cmluZ10gPSB0cnVlO1xuICAgICN7d2Fybihgc3RyaW5nYCl9O1xuICB9XG59XG5cbmNsYXNzIFN0cmluZ1xuICBgdmFyIEVSUk9SID0gXCJTdHJpbmcjJXMgbm90IHN1cHBvcnRlZC4gTXV0YWJsZSBTdHJpbmcgbWV0aG9kcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBPcGFsLlwiYFxuXG4gIGRlZiA8PCgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnPDwnXG4gIGVuZFxuXG4gIGRlZiBjYXBpdGFsaXplISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2FwaXRhbGl6ZSEnXG4gIGVuZFxuXG4gIGRlZiBjaG9tcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2Nob21wISdcbiAgZW5kXG5cbiAgZGVmIGNob3AhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjaG9wISdcbiAgZW5kXG5cbiAgZGVmIGRvd25jYXNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnZG93bmNhc2UhJ1xuICBlbmRcblxuICBkZWYgZ3N1YiEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2dzdWIhJ1xuICBlbmRcblxuICBkZWYgbHN0cmlwISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnbHN0cmlwISdcbiAgZW5kXG5cbiAgZGVmIG5leHQhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICduZXh0ISdcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdyZXZlcnNlISdcbiAgZW5kXG5cbiAgZGVmIHNsaWNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc2xpY2UhJ1xuICBlbmRcblxuICBkZWYgc3F1ZWV6ZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3NxdWVlemUhJ1xuICBlbmRcblxuICBkZWYgc3RyaXAhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzdHJpcCEnXG4gIGVuZFxuXG4gIGRlZiBzdWIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzdWIhJ1xuICBlbmRcblxuICBkZWYgc3VjYyEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3N1Y2MhJ1xuICBlbmRcblxuICBkZWYgc3dhcGNhc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzd2FwY2FzZSEnXG4gIGVuZFxuXG4gIGRlZiB0ciEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3RyISdcbiAgZW5kXG5cbiAgZGVmIHRyX3MhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd0cl9zISdcbiAgZW5kXG5cbiAgZGVmIHVwY2FzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3VwY2FzZSEnXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdwcmVwZW5kJ1xuICBlbmRcblxuICBkZWYgW109KCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdbXT0nXG4gIGVuZFxuXG4gIGRlZiBjbGVhcigqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2xlYXInXG4gIGVuZFxuXG4gIGRlZiBlbmNvZGUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdlbmNvZGUhJ1xuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd1bmljb2RlX25vcm1hbGl6ZSEnXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgYHZhciBFUlJPUiA9IFwiT2JqZWN0IGZyZWV6aW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgT3BhbFwiYFxuXG4gIGRlZiBmcmVlemVcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZyb3plbj9cbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgYHZhciBFUlJPUiA9IFwiT2JqZWN0IHRhaW50aW5nIGlzIG5vdCBzdXBwb3J0ZWQgYnkgT3BhbFwiYFxuXG4gIGRlZiB0YWludFxuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdW50YWludFxuICAgIGBoYW5kbGVfdW5zdXBwb3J0ZWRfZmVhdHVyZShFUlJPUilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdGFpbnRlZD9cbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE1vZHVsZVxuICBkZWYgcHVibGljKCptZXRob2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRtb2R1bGVfZnVuY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHByaXZhdGUgcHVibGljXG5cbiAgYWxpYXMgcHJvdGVjdGVkIHB1YmxpY1xuXG4gIGFsaWFzIG5lc3RpbmcgcHVibGljXG5cbiAgZGVmIHByaXZhdGVfY2xhc3NfbWV0aG9kKCopXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBwdWJsaWNfY2xhc3NfbWV0aG9kIHByaXZhdGVfY2xhc3NfbWV0aG9kXG5cbiAgZGVmIHByaXZhdGVfbWV0aG9kX2RlZmluZWQ/KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgcHJpdmF0ZV9jb25zdGFudCgqKVxuICBlbmRcblxuICBhbGlhcyBwcm90ZWN0ZWRfbWV0aG9kX2RlZmluZWQ/IHByaXZhdGVfbWV0aG9kX2RlZmluZWQ/XG5cbiAgYWxpYXMgcHVibGljX2luc3RhbmNlX21ldGhvZHMgaW5zdGFuY2VfbWV0aG9kc1xuXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2QgaW5zdGFuY2VfbWV0aG9kXG5cbiAgYWxpYXMgcHVibGljX21ldGhvZF9kZWZpbmVkPyBtZXRob2RfZGVmaW5lZD9cbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBwcml2YXRlX21ldGhvZHMoKilcbiAgICBbXVxuICBlbmRcblxuICBhbGlhcyBwcml2YXRlX2luc3RhbmNlX21ldGhvZHMgcHJpdmF0ZV9tZXRob2RzXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgZXZhbCgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIFwiVG8gdXNlIEtlcm5lbCNldmFsLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdvcGFsLXBhcnNlcicuIFwiXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BhbC9vcGFsL2Jsb2IvI3tSVUJZX0VOR0lORV9WRVJTSU9OfS9kb2NzL29wYWxfcGFyc2VyLm1kIGZvciBkZXRhaWxzLlwiXG4gIGVuZFxuZW5kXG5cbmRlZiBzZWxmLnB1YmxpYygqKVxuICAjIHN0dWJcbmVuZFxuXG5kZWYgc2VsZi5wcml2YXRlKCopXG4gICMgc3R1YlxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIktlcm5lbCIsInJhaXNlIiwiTm90SW1wbGVtZW50ZWRFcnJvciIsInNlbGYiLCJ3YXJuIiwiPGNsYXNzOlN0cmluZz4iLCI8PCIsIiUiLCJjYXBpdGFsaXplISIsImNob21wISIsImNob3AhIiwiZG93bmNhc2UhIiwiZ3N1YiEiLCJsc3RyaXAhIiwibmV4dCEiLCJyZXZlcnNlISIsInNsaWNlISIsInNxdWVlemUhIiwic3RyaXAhIiwic3ViISIsInN1Y2MhIiwic3dhcGNhc2UhIiwidHIhIiwidHJfcyEiLCJ1cGNhc2UhIiwicHJlcGVuZCIsIltdPSIsImNsZWFyIiwiZW5jb2RlISIsInVuaWNvZGVfbm9ybWFsaXplISIsIjxtb2R1bGU6S2VybmVsPiIsImZyZWV6ZSIsImZyb3plbj8iLCJ0YWludCIsInVudGFpbnQiLCJ0YWludGVkPyIsIjxjbGFzczpNb2R1bGU+IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsIm9iaiIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsInByaXZhdGUiXSwibWFwcGluZ3MiOiJBQUFBQSxzREFBQUE7RUFBQUE7O0VBQUFBOzs7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLE1BQVFDLHNCQUFNQyxPQUFBQSxDQUFPQyxtQ0FBYixFQUFtQ0gsT0FBN0JFO0FBQ2RGO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsSUFBTUksSUFBQUMsTUFBQUEsQ0FBTUwsTUFBTkssQ0FBZUw7QUFDckJBOztFQUdBTTtFQUFBQTs7SUFBQUE7OztJQUNHQTs7QUFFREMsSUFBQUEsc0JBQUFBLG1CQUFBQSxTQTdCRixFQTZCRUE7QUFBQUEsTUFBQUE7Ozs7TUE3QkY7O01BNkJTO01BQ0xBLE9BQUFILElBQUFGLE9BQUFBLENBQU1DLG1DQUFOLEVBQTJCSSxDQUFDQSxLQUFEQSxDQUFRQyxNQUFBQSxDQUFFRCxJQUFGQyxDQUFuQ047SUFERkssQ0FBQUEsK0JBQUFB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QTs7OztNQTNNRjs7TUEyTVc7TUFDUEEsT0FBQXhDLElBQUFGLE9BQUFBLENBQU1DLG1DQUFOLEVBQTJCLEVBQUEsR0FBQXlDLDREQUFBLEdBQUEsQ0FDQSxFQUFBLEdBQUNBLHdDQUFELEdBQUEsQ0FBeUNDLG1DQUF6QyxDQUFBLEdBQTZERCxtQ0FEN0QsQ0FBM0IxQztJQURGMEMsQ0FBQUEsOEJBQUFBLENBQUFBO0VBREZiLEdBQUFBLFdBQUFBO0VBT0FPLFVBQUlsQyxJQUFKa0MsYUFBQUEsYUFBQUEsU0FqTkEsRUFpTkFBO0FBQUFBLElBQUFBOzs7O0lBak5BOztJQWlOZ0I7SUFqTmhCQSxPQUFBO0VBaU5BQSxDQUFBQSx5QkFBQUE7RUFJQXRDLE9BQUE4QyxDQUFBQSxVQUFJMUMsSUFBSjBDLGNBQUFBLGNBQUFBLFNBck5BLEVBcU5BQTtBQUFBQSxJQUFBQTs7OztJQXJOQTs7SUFxTmlCO0lBck5qQkEsT0FBQTtFQXFOQUEsQ0FBQUEsMEJBQUFBLENBQUFBO0FBck5BOUM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2MDMzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcbnJlcXVpcmUgJ29wYWwvbWluaSdcblxucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG5hdXRvbG9hZCA6TWF0aCwgJ2NvcmVsaWIvbWF0aCdcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGxleC9iYXNlJ1xuYXV0b2xvYWQgOkNvbXBsZXgsICdjb3JlbGliL2NvbXBsZXgnXG5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsL2Jhc2UnXG5hdXRvbG9hZCA6UmF0aW9uYWwsICdjb3JlbGliL3JhdGlvbmFsJ1xucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xuYXV0b2xvYWQgOlN0cnVjdCwgJ2NvcmVsaWIvc3RydWN0J1xucmVxdWlyZSAnY29yZWxpYi9kaXInXG5hdXRvbG9hZCA6RmlsZSwgJ2NvcmVsaWIvZmlsZSdcblxucmVxdWlyZSAnY29yZWxpYi9wcm9jZXNzL2Jhc2UnXG5hdXRvbG9hZCA6UHJvY2VzcywgJ2NvcmVsaWIvcHJvY2VzcydcbmF1dG9sb2FkIDpSYW5kb20sICdjb3JlbGliL3JhbmRvbSdcblxucmVxdWlyZSAnY29yZWxpYi91bnN1cHBvcnRlZCdcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJzZWxmIiwicmVxdWlyZSIsImF1dG9sb2FkIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkJBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsV0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsV0FBUkU7RUFFQUQsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsdUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLHlCQUFSRTtFQUNBRCxJQUFBRSxVQUFBQSxDQUFTLE1BQVQsRUFBZ0JILGNBQWhCRztFQUNBRixJQUFBQyxTQUFBQSxDQUFRRixzQkFBUkU7RUFDQUQsSUFBQUUsVUFBQUEsQ0FBUyxTQUFULEVBQW1CSCxpQkFBbkJHO0VBQ0FGLElBQUFDLFNBQUFBLENBQVFGLHVCQUFSRTtFQUNBRCxJQUFBRSxVQUFBQSxDQUFTLFVBQVQsRUFBb0JILGtCQUFwQkc7RUFDQUYsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7RUFDQUQsSUFBQUUsVUFBQUEsQ0FBUyxRQUFULEVBQWtCSCxnQkFBbEJHO0VBQ0FGLElBQUFDLFNBQUFBLENBQVFGLGFBQVJFO0VBQ0FELElBQUFFLFVBQUFBLENBQVMsTUFBVCxFQUFnQkgsY0FBaEJHO0VBRUFGLElBQUFDLFNBQUFBLENBQVFGLHNCQUFSRTtFQUNBRCxJQUFBRSxVQUFBQSxDQUFTLFNBQVQsRUFBbUJILGlCQUFuQkc7RUFDQUYsSUFBQUUsVUFBQUEsQ0FBUyxRQUFULEVBQWtCSCxnQkFBbEJHO0VBRUFILE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtBQXBCQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2MDU4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9zdHJpbmdfXy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBydWJ5XG4jXG4jIERlbW9jcmFjeSBzb2Z0d2FyZSBjb21waWxhdGlvbiBWRVJTSU9OIDAuMC4sIGNyZWF0ZWQgb24gMjAyMS0xMS0xNCAxNzo0MTozNCAtMDUwMFxuIyBHZXQgYWxsIG9mIHRoaXMgY29kZSwgYW5kIGFsbCBvZiB0aGVzZSBmaWxlcywgd2l0aFxuIyBnZW0gaW5zdGFsbCBkZW1vY3JhY3lcbiMgTGludXggcnVieSAyLjcuMHAwICgyMDE5LTEyLTI1IHJldmlzaW9uIDY0N2VlNmYwOTEpIFt4ODZfNjQtbGludXgtZ251XVxuI1xuIyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG5cblxuXG5cblxuIyA3NiBvZiAxNiBzb3VyY2UgZmlsZXNcbm1vZHVsZSBBc3NlcnRcbnJlcXVpcmVfcmVsYXRpdmUgXCJzdHJpbmdfX1wiXG4gICAgZGVmIGFzc2VydCgqYXJncylcbiAgICByYWlzZSBpZiBhcmdzLmVtcHR5PyAmJiAhc2VsZlxuXG4gICAgYXJncy5lYWNoIHsgfGl8IHJhaXNlIGkgdW5sZXNzIGk7IH1cbiAgZW5kOyBlbmRcblxuaW5jbHVkZSBBc3NlcnRcblxuY2xhc3MgVHJ1ZUNsYXNzXG4gIGluY2x1ZGUgQXNzZXJ0XG5lbmRcblxuY2xhc3MgRmFsc2VDbGFzc1xuICBpbmNsdWRlIEFzc2VydFxuZW5kXG5cbmNsYXNzIE9iamVjdFxuICBkZWYgaW4/KF9hcnJheSlcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgc2hlbGxlc2NhcGVcbiAgICB0b19zLnNoZWxsZXNjYXBlXG4gIGVuZFxuZW5kXG5cbiAgaWYgUlVCWV9FTkdJTkUgIT0gJ29wYWwnXG5cdGV2YWwgXCJyZXF1aXJlICdzaGVsbHdvcmRzJ1wiICAgIyAgICA7IGVuZFxuZW5kXG5cbiNlbmRcblxuXG5jbGFzcyBTdHJpbmdcblxuICBkZWYgcHV0c1xuICAgIEtlcm5lbC5wdXRzIHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmludFxuICAgIEtlcm5lbC5wcmludCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaW4/KGEpXG4gICAgYS5pbmNsdWRlPyBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlbmRzX3dpdGg/KGEpXG4gICAgZW5kX3dpdGg/IGFcbiAgZW5kXG5cbiAgZGVmIGFkZF9wZXJpb2RcbiAgICBpZiBzZWxmWy0xXSA9PSAnLidcbiAgICAgIHNlbGZcbiAgICBlbHNlXG4gICAgICBcIiN7c2VsZn0uXCI7IGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBBcnJheVxuICBkZWYgd2hpY2hcbiAgICBlYWNoIGRvIHxjbWR8XG4gICAgICBleHRzID0gRU5WWydQQVRIRVhUJ10gPyBFTlZbJ1BBVEhFWFQnXS5zcGxpdCgnOycpIDogWycnXVxuICAgICAgRU5WWydQQVRIJ10uc3BsaXQoRmlsZTo6UEFUSF9TRVBBUkFUT1IpLmVhY2ggZG8gfHBhdGh8XG4gICAgICAgIGV4dHMuZWFjaCBkbyB8ZXh0fFxuICAgICAgICAgIGV4ZSA9IEZpbGUuam9pbihwYXRoLCBcIiN7Y21kfSN7ZXh0fVwiKVxuICAgICAgICAgIHJldHVybiBleGUgaWYgRmlsZS5leGVjdXRhYmxlPyhleGUpICYmICFGaWxlLmRpcmVjdG9yeT8oZXhlKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgbmlsXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFN0cmluZ1xuICBkZWYgdXBwZXJjYXNlXG4gICAgcmV0dXJuICcnIGlmIHNlbGZbMF0ubmlsP1xuXG4gICAgc2VsZlswXS5jYXBpdGFsaXplICsgc2xpY2UoMSwgbGVuZ3RoKVxuICBlbmRcbmVuZFxuXG5cblxuXG5cblxuXG5cbiMgRmVlZGJhY2sgYW5kIGRvbmF0aW9uIHRvIGdyZWdvcnljb2hlbjJAZ21haWwuY29tIChtb25leSB0cmFuc2ZlciBvciBQYXlwYWwpXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6QXNzZXJ0PiIsInJlcXVpcmVfcmVsYXRpdmUiLCJhc3NlcnQiLCIkcmV0X29yXzEiLCJhcmdzIiwiZW1wdHk/Iiwic2VsZiIsIiEiLCJyYWlzZSIsImVhY2giLCJibG9jayBpbiBhc3NlcnQiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBhc3NlcnQiLCJpbmNsdWRlIiwiQXNzZXJ0IiwiPGNsYXNzOlRydWVDbGFzcz4iLCI8Y2xhc3M6RmFsc2VDbGFzcz4iLCI8Y2xhc3M6T2JqZWN0PiIsImluPyIsIl9hcnJheSIsInNoZWxsZXNjYXBlIiwidG9fcyIsIjxjbGFzczpTdHJpbmc+IiwicHV0cyIsIktlcm5lbCIsInByaW50IiwiYSIsImluY2x1ZGU/IiwiZW5kc193aXRoPyIsImVuZF93aXRoPyIsImFkZF9wZXJpb2QiLCJbXSIsIi0xIiwiPT0iLCI8Y2xhc3M6QXJyYXk+Iiwid2hpY2giLCJibG9jayBpbiB3aGljaCIsImNtZCIsImJsb2NrICgyIGxldmVscykgaW4gd2hpY2giLCJleHRzIiwiRU5WIiwic3BsaXQiLCJGaWxlOjpQQVRIX1NFUEFSQVRPUiIsIkZpbGUiLCJwYXRoIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiB3aGljaCIsImV4dCIsImJsb2NrICg0IGxldmVscykgaW4gd2hpY2giLCJleGUiLCJqb2luIiwiJHJldF9vcl8yIiwiZXhlY3V0YWJsZT8iLCJkaXJlY3Rvcnk/IiwidXBwZXJjYXNlIiwiMCIsIm5pbD8iLCIrIiwiY2FwaXRhbGl6ZSIsInNsaWNlIiwiMSIsImxlbmd0aCJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBZ0JBQztFQUFBQTs7SUFBQUE7OztJQUNBQyx3Q0FBaUJELFVBQWpCQztJQUNJRCxPQUFBRSxDQUFBQSwwQkFBQUEsbUJBQUFBLGtCQWxCSixFQWtCSUE7QUFBQUEsTUFBQUE7Ozs7TUFsQko7O01Ba0JlO01BQ1gsSUFBQSxRQUFTLGFBQUEsSUFBQSxRQW5CYkMsQ0FBQUEsWUFtQmFDLElBQUlDLFdBQUFBLENBQUFBLENBbkJqQkYsQ0FtQmEsQ0FBQTtRQUFlRCxPQUFDSSxJQUFEQyxNQUFBQSxDQUFBQTtNQUFmO1FBbkJiTCxPQUFBO01BbUJhLENBQUEsa0JBQVQsQ0FBQTtRQUFBSSxJQUFBRSxPQUFBQSxDQUFBQSxDQUFBO01BRUFOLE9BQUlPLE1BQUpMLElBQUlLLFFBQUFBLEVBQUFBLEVBQUFBLEVBQU1DLGdCQUFHQyxDQUFI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SUFBQXNELFFBQUFBLENBQUFBLENBQVRGLENBQUZGO0lBSHJCSCxDQUFBQSxrQ0FBQUEsQ0FBQUE7RUFERi9CLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBOUZBdkI7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2MjQ0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLXBsYXRmb3JtLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImAvKiBnbG9iYWwgSmF2YSwgR2pzRmlsZUltcG9ydGVyICovYFxuXG5icm93c2VyICAgICAgICAgPSBgdHlwZW9mKGRvY3VtZW50KSAhPT0gXCJ1bmRlZmluZWRcImBcbm5vZGUgICAgICAgICAgICA9IGB0eXBlb2YocHJvY2VzcykgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGVgXG5uYXNob3JuICAgICAgICAgPSBgdHlwZW9mKEphdmEpICE9PSBcInVuZGVmaW5lZFwiICYmIEphdmEudHlwZWBcbmhlYWRsZXNzX2Nocm9tZSA9IGB0eXBlb2YobmF2aWdhdG9yKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvXFxiSGVhZGxlc3NDaHJvbWVcXC8vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClgXG5nanMgICAgICAgICAgICAgPSBgdHlwZW9mKHdpbmRvdykgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mKEdqc0ZpbGVJbXBvcnRlcikgIT09ICd1bmRlZmluZWQnYFxucXVpY2tqcyAgICAgICAgID0gYHR5cGVvZih3aW5kb3cpID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZihfX2xvYWRTY3JpcHQpICE9PSAndW5kZWZpbmVkJ2Bcbm9wYWxfbWluaXJhY2VyICA9IGB0eXBlb2Yob3BhbG1pbmlyYWNlcikgIT09ICd1bmRlZmluZWQnYFxuXG5PUEFMX1BMQVRGT1JNID0gaWYgbmFzaG9yblxuICAgICAgICAgICAgICAgICAgJ25hc2hvcm4nXG4gICAgICAgICAgICAgICAgZWxzaWYgbm9kZVxuICAgICAgICAgICAgICAgICAgJ25vZGVqcydcbiAgICAgICAgICAgICAgICBlbHNpZiBoZWFkbGVzc19jaHJvbWVcbiAgICAgICAgICAgICAgICAgICdoZWFkbGVzcy1jaHJvbWUnXG4gICAgICAgICAgICAgICAgZWxzaWYgZ2pzXG4gICAgICAgICAgICAgICAgICAnZ2pzJ1xuICAgICAgICAgICAgICAgIGVsc2lmIHF1aWNranNcbiAgICAgICAgICAgICAgICAgICdxdWlja2pzJ1xuICAgICAgICAgICAgICAgIGVsc2lmIG9wYWxfbWluaXJhY2VyXG4gICAgICAgICAgICAgICAgICAnb3BhbC1taW5pcmFjZXInXG4gICAgICAgICAgICAgICAgZWxzZSAjIHBvc3NpYmx5IGJyb3dzZXIsIHdoaWNoIGlzIHRoZSBwcmltYXJ5IHRhcmdldFxuICAgICAgICAgICAgICAgIGVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJicm93c2VyIiwibm9kZSIsIm5hc2hvcm4iLCJoZWFkbGVzc19jaHJvbWUiLCJnanMiLCJxdWlja2pzIiwib3BhbF9taW5pcmFjZXIiXSwibWFwcGluZ3MiOiJBQUFBQSxnREFBQUE7RUFBQUE7OztFQUFDQTtFQUVEQyxVQUFtQkQ7RUFDbkJFLE9BQW1CRjtFQUNuQkcsVUFBbUJIO0VBQ25CSSxrQkFBbUJKO0VBQ25CSyxNQUFtQkw7RUFDbkJNLFVBQW1CTjtFQUNuQk8saUJBQW1CUDtFQUVuQkEsT0FBQSw2Q0FBZ0IsYUFBQSxJQUFBLFFBQUdHLE9BQUgsQ0FBQTtJQUNFSCxPQUFBQTtFQURGLE9BRUEsSUFBQSxRQUFNRSxJQUFOLENBQUE7SUFDRUYsT0FBQUE7RUFERixPQUVBLElBQUEsUUFBTUksZUFBTixDQUFBO0lBQ0VKLE9BQUFBO0VBREYsT0FFQSxJQUFBLFFBQU1LLEdBQU4sQ0FBQTtJQUNFTCxPQUFBQTtFQURGLE9BRUEsSUFBQSxRQUFNTSxPQUFOLENBQUE7SUFDRU4sT0FBQUE7RUFERixPQUVBLElBQUEsUUFBTU8sY0FBTixDQUFBO0lBQ0VQLE9BQUFBO0VBREY7SUFwQmhCQSxPQUFBO0VBb0JnQixDQVZBLGtCQUFoQjtBQVZBQTsifX0seyJvZmZzZXQiOnsibGluZSI6MjYyNzMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJuYXNob3JuL2lvLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiRzdGRvdXQud3JpdGVfcHJvYyA9IGBmdW5jdGlvbihzKXtwcmludChzKX1gXG4kc3RkZXJyLndyaXRlX3Byb2MgPSBgZnVuY3Rpb24ocyl7cHJpbnQocyl9YFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIkd3JpdGVyIiwid3JpdGVfcHJvYz0iLCIkc3Rkb3V0IiwiLSIsIjEiLCIkc3RkZXJyIl0sIm1hcHBpbmdzIjoiQUFBQUEsNkNBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0FBQUFBO0FBQUFBOztFQUFBQTs7O0VBQUFDLFVBQUEsQ0FBc0JELHFCQUF0QjtFQUFPRSxNQUFQQyxhQUFPRCxlQUFBQSxFQUFQLFVBQUFELE9BQUEsQ0FBT0M7RUFBUEQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUFELFFBQUEsQ0FBQUksRUFBQUMsQ0FBQUQsQ0FBQTs7RUFBQUgsVUFBQSxDQUNzQkQscUJBRHRCO0VBQ09FLE1BQVBJLGFBQU9KLGVBQUFBLEVBRFAsVUFBQUQsT0FBQSxDQUNPQztFQURQRixPQUFBQyxPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQUQsUUFBQSxDQUFBSSxFQUFBQyxDQUFBRCxDQUFBO0FBQUFKOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjI5MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5hc2hvcm4vZmlsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJgLyogZ2xvYmFsIEphdmEgKi9gXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZmlsZSdcblxuY2xhc3MgRmlsZVxuICBkZWYgc2VsZi5yZWFkKHBhdGgpXG4gICAgJXgoXG4gICAgICAgIHZhciBQYXRocyA9IEphdmEudHlwZSgnamF2YS5uaW8uZmlsZS5QYXRocycpO1xuICAgICAgICB2YXIgRmlsZXMgPSBKYXZhLnR5cGUoJ2phdmEubmlvLmZpbGUuRmlsZXMnKTtcbiAgICAgICAgdmFyIGxpbmVzID0gRmlsZXMucmVhZEFsbExpbmVzKFBhdGhzLmdldChwYXRoKSwgSmF2YS50eXBlKCdqYXZhLm5pby5jaGFyc2V0LlN0YW5kYXJkQ2hhcnNldHMnKS5VVEZfOCk7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkgeyBkYXRhLnB1c2gobGluZSk7IH0pO1xuICAgICAgICByZXR1cm4gZGF0YS5qb2luKFwiXFxuXCIpO1xuICAgICAgKVxuICBlbmRcblxuICBkZWYgc2VsZi5maWxlPyhwYXRoKVxuICAgICV4e1xuICAgICAgdmFyIEZpbGVzID0gSmF2YS50eXBlKCdqYXZhLm5pby5maWxlLkZpbGVzJyk7XG4gICAgICByZXR1cm4gRmlsZXMuZXhpc3RzKHBhdGgpICYmIEZpbGVzLmlzUmVndWxhckZpbGUocGF0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZWFkYWJsZT8ocGF0aClcbiAgICAleHtcbiAgICAgIHZhciBGaWxlcyA9IEphdmEudHlwZSgnamF2YS5uaW8uZmlsZS5GaWxlcycpO1xuICAgICAgcmV0dXJuIEZpbGVzLmV4aXN0cyhwYXRoKSAmJiBGaWxlcy5pc1JlYWRhYmxlKHBhdGgpO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RmlsZT4iLCJyZWFkIiwicGF0aCIsImZpbGU/IiwicmVhZGFibGU/Il0sIm1hcHBpbmdzIjoiQUFBQUEsK0NBQUFBO0VBQUFBOztFQUFBQTs7RUFBQ0E7RUFFREMsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUMsVUFBSUgsSUFBSkcsV0FBQUEsZUFBQUEsZ0JBQWNDLElBQWREO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFSRUEsQ0FBQUEsMEJBQUFBO0lBV0FFLFVBQUlMLElBQUpLLFlBQUFBLG9CQUFBQSxTQUFlRCxJQUFmQztBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0lBSkVBLENBQUFBLCtCQUFBQTtJQU9BSCxPQUFBSSxDQUFBQSxVQUFJTixJQUFKTSxnQkFBQUEsd0JBQUFBLFNBQW1CRixJQUFuQkU7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtJQUpFQSxDQUFBQSxtQ0FBQUEsQ0FBQUE7RUFuQkZKLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjMzNywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vbmFzaG9ybi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgTmFzaG9yblxuZW5kXG5cbnJlcXVpcmUgJ25hc2hvcm4vaW8nXG5yZXF1aXJlICduYXNob3JuL2ZpbGUnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6TmFzaG9ybj4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7SUFBQUEsT0FBQTtFQUFBQSxHQUFBQSxXQUFBQTtFQUdBQyxJQUFBQyxTQUFBQSxDQUFRSCxZQUFSRztFQUNBSCxPQUFBRSxJQUFBQyxTQUFBQSxDQUFRSCxjQUFSRztBQUpBSDsifX0seyJvZmZzZXQiOnsibGluZSI6MjYzNTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJnanMvaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiYC8qIGdsb2JhbCBpbXBvcnRzICovYFxuXG4jIEJhc2ljIHZlcnNpb24sIGFwcGVuZHMgXFxuOlxuIyAkc3Rkb3V0LndyaXRlX3Byb2MgPSBgZnVuY3Rpb24ocyl7cHJpbnQocyl9YFxuIyAkc3RkZXJyLndyaXRlX3Byb2MgPSBgZnVuY3Rpb24ocyl7cHJpbnRlcnIocyl9YFxuXG4jIEFkdmFuY2VkIHZlcnNpb246XG4leHtcbiAgdmFyIEdMaWIgPSBpbXBvcnRzLmdpLkdMaWI7XG4gIHZhciBCeXRlQXJyYXkgPSBpbXBvcnRzLmJ5dGVBcnJheTtcblxuICB2YXIgc3RkaW4gPSBHTGliLklPQ2hhbm5lbC51bml4X25ldygwKTtcbiAgdmFyIHN0ZG91dCA9IEdMaWIuSU9DaGFubmVsLnVuaXhfbmV3KDEpO1xuICB2YXIgc3RkZXJyID0gR0xpYi5JT0NoYW5uZWwudW5peF9uZXcoMik7XG5cbiAgT3BhbC5ndmFycy5zdGRvdXQud3JpdGVfcHJvYyA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgYnVmID0gQnl0ZUFycmF5LmZyb21TdHJpbmcocyk7XG4gICAgc3Rkb3V0LndyaXRlX2NoYXJzKGJ1ZiwgYnVmLmxlbmd0aCk7XG4gICAgc3Rkb3V0LmZsdXNoKCk7XG4gIH1cblxuICBPcGFsLmd2YXJzLnN0ZGVyci53cml0ZV9wcm9jID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBidWYgPSBCeXRlQXJyYXkuZnJvbVN0cmluZyhzKTtcbiAgICBzdGRlcnIud3JpdGVfY2hhcnMoYnVmLCBidWYubGVuZ3RoKTtcbiAgICBzdGRlcnIuZmx1c2goKTtcbiAgfVxuXG4gIE9wYWwuZ3ZhcnMuc3RkaW4ucmVhZF9wcm9jID0gZnVuY3Rpb24oX3MpIHtcbiAgICB2YXIgb3V0ID0gc3RkaW4ucmVhZF9saW5lKCk7XG4gICAgaWYgKG91dFswXSA9PSBHTGliLklPU3RhdHVzLkVPRikgcmV0dXJuIG5pbDtcbiAgICByZXR1cm4gb3V0WzFdLnRvU3RyaW5nKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Il0sIm1hcHBpbmdzIjoiQUFBQUEseUNBQUFBO0VBQUFBOzs7RUFBQ0E7O0FBUURBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUEvQkFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjM4NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdqcy9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiYC8qIGdsb2JhbCBBUkdWICovYFxuXG5BUkdWID0gYEFSR1ZgXG5cbmBPcGFsLmV4aXQgPSBpbXBvcnRzLnN5c3RlbS5leGl0YFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iXSwibWFwcGluZ3MiOiJBQUFBQSw2Q0FBQUE7RUFBQUE7OztFQUFDQTtFQUVELG9DQUFRQSxJQUFSO0VBRUFBLE9BQUNBLCtCQUFEQTtBQUpBQTsifX0seyJvZmZzZXQiOnsibGluZSI6MjYzOTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2dqcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdnanMvaW8nXG5yZXF1aXJlICdnanMva2VybmVsJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLHNDQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLFFBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLFlBQVJFO0FBREFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjQwNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInF1aWNranMvaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiYC8qIGdsb2JhbCBzdGQgKi9gXG5cbiV4e1xuICBPcGFsLmd2YXJzLnN0ZG91dC53cml0ZV9wcm9jID0gZnVuY3Rpb24ocykge1xuICAgIHN0ZC5vdXQucHJpbnRmKFwiJXNcIiwgcyk7XG4gICAgc3RkLm91dC5mbHVzaCgpO1xuICB9XG5cbiAgT3BhbC5ndmFycy5zdGRlcnIud3JpdGVfcHJvYyA9IGZ1bmN0aW9uKHMpIHtcbiAgICBzdGQuZXJyLnByaW50ZihcIiVzXCIsIHMpO1xuICAgIHN0ZC5lcnIuZmx1c2goKTtcbiAgfVxuXG4gIE9wYWwuZ3ZhcnMuc3RkaW4ucmVhZF9wcm9jID0gZnVuY3Rpb24ocykge1xuICAgIGlmIChzdGQuaW4uZW9mKCkpIHtcbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHN0ZC5pbi5yZWFkQXNTdHJpbmcocyk7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiJdLCJtYXBwaW5ncyI6IkFBQUFBLDZDQUFBQTtFQUFBQTs7O0VBQUNBOztBQUdEQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQXBCQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NDMxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicXVpY2tqcy9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiYC8qIGdsb2JhbCBzdGQsIHNjcmlwdEFyZ3MgKi9gXG5cbkFSR1YgPSBgc2NyaXB0QXJnc2BcblxuYE9wYWwuZXhpdCA9IHN0ZC5leGl0YFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iXSwibWFwcGluZ3MiOiJBQUFBQSxpREFBQUE7RUFBQUE7OztFQUFDQTtFQUVELG9DQUFRQSxVQUFSO0VBRUFBLE9BQUNBLG9CQUFEQTtBQUpBQTsifX0seyJvZmZzZXQiOnsibGluZSI6MjY0NDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL3F1aWNranMucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAncXVpY2tqcy9pbydcbnJlcXVpcmUgJ3F1aWNranMva2VybmVsJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLFlBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtBQURBRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjY0NDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL25hdGl2ZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFByb3ZpZGVzIGEgY29tcGxldGUgc2V0IG9mIHRvb2xzIHRvIHdyYXAgbmF0aXZlIEphdmFTY3JpcHRcbiMgaW50byBuaWNlIFJ1Ynkgb2JqZWN0cy5cbiNcbiMgQGV4YW1wbGVcbiNcbiMgICAkJC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdwJykuY2xhc3NMaXN0LmFkZCgnYmx1ZScpXG4jICAgIyA9PiBhZGRzIFwiYmx1ZVwiIGNsYXNzIHRvIDxwPlxuI1xuIyAgICQkLmxvY2F0aW9uLmhyZWYgPSAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuIyAgICMgPT4gY2hhbmdlcyBwYWdlIGxvY2F0aW9uXG4jXG4jICAgZG9fbGF0ZXIgPSAkJFs6c2V0VGltZW91dF0gIyBBY2Nlc3NpbmcgdGhlIFwic2V0VGltZW91dFwiIHByb3BlcnR5XG4jICAgZG9fbGF0ZXIuY2FsbCgtPnsgcHV0cyA6aGVsbG99LCA1MDApXG4jXG4jIGAkJGAgYW5kIGAkZ2xvYmFsYCB3cmFwIGBPcGFsLmdsb2JhbGAsIHdoaWNoIHRoZSBPcGFsIEpTIHJ1bnRpbWVcbiMgc2V0cyB0byB0aGUgZ2xvYmFsIGB0aGlzYCBvYmplY3QuXG4jXG5tb2R1bGUgTmF0aXZlXG4gIGRlZiBzZWxmLmlzX2E/KG9iamVjdCwga2xhc3MpXG4gICAgJXh7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gI3tvYmplY3R9IGluc3RhbmNlb2YgI3t0cnlfY29udmVydChrbGFzcyl9O1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQodmFsdWUsIGRlZmF1bHQgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoI3tuYXRpdmU/KHZhbHVlKX0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWV9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fbn0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWUudG9fbn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7ZGVmYXVsdH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5jb252ZXJ0KHZhbHVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7bmF0aXZlPyh2YWx1ZSl9KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8gOnRvX259KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlLnRvX259O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCIje3ZhbHVlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNhbGwob2JqLCBrZXksICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcHJvcCA9ICN7b2JqfVsje2tleX1dO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZWQgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3NbaV0sXG4gICAgICAgICAgICAgIGNvbnYgPSAje3RyeV9jb252ZXJ0KGBpdGVtYCl9O1xuXG4gICAgICAgICAgY29udmVydGVkW2ldID0gY29udiA9PT0gbmlsID8gaXRlbSA6IGNvbnY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGNvbnZlcnRlZC5wdXNoKGJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAje05hdGl2ZShgcHJvcC5hcHBseSgje29ian0sIGNvbnZlcnRlZClgKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBwcm9wYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucHJvYygmYmxvY2spXG4gICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICA6Oktlcm5lbC5wcm9jIHsgfCphcmdzfFxuICAgICAgYXJncy5tYXAhIHsgfGFyZ3wgTmF0aXZlKGFyZykgfVxuICAgICAgaW5zdGFuY2UgPSBOYXRpdmUoYHRoaXNgKVxuXG4gICAgICAleHtcbiAgICAgICAgLy8gaWYgZ2xvYmFsIGlzIGN1cnJlbnQgc2NvcGUsIHJ1biB0aGUgYmxvY2sgaW4gdGhlIHNjb3BlIGl0IHdhcyBkZWZpbmVkXG4gICAgICAgIGlmICh0aGlzID09PSBPcGFsLmdsb2JhbCkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseShzZWxmLCAje2FyZ3N9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmXyA9IGJsb2NrLiQkcztcbiAgICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseSgje2luc3RhbmNlfSwgI3thcmdzfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgYmxvY2suJCRzID0gc2VsZl87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBIZWxwZXJzXG4gICAgIyBFeHBvc2VzIGEgbmF0aXZlIEphdmFTY3JpcHQgbWV0aG9kIHRvIFJ1YnlcbiAgICAjXG4gICAgI1xuICAgICMgQHBhcmFtIG5ldyBbU3RyaW5nXVxuICAgICMgICAgICAgVGhlIG5hbWUgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbWV0aG9kLlxuICAgICNcbiAgICAjIEBwYXJhbSBvbGQgW1N0cmluZ11cbiAgICAjICAgICAgIFRoZSBuYW1lIG9mIHRoZSBuYXRpdmUgSmF2YVNjcmlwdCBtZXRob2QgdG8gYmUgZXhwb3NlZC5cbiAgICAjICAgICAgIElmIHRoZSBuYW1lIGVuZHMgd2l0aCBcIj1cIiAoZS5nLiBgZm9vPWApIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcbiAgICAjICAgICAgIGEgcHJvcGVydHkgc2V0dGVyLiAoZGVmYXVsdDogdGhlIHZhbHVlIG9mIFwibmV3XCIpXG4gICAgI1xuICAgICMgQHBhcmFtIGFzIFtDbGFzc11cbiAgICAjICAgICAgIElmIHByb3ZpZGVkIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIG9yaWdpbmFsIG1ldGhvZCB3aWxsIGJlXG4gICAgIyAgICAgICByZXR1cm5lZCBhcyBpbnN0YW5jZXMgb2YgdGhlIHBhc3NlZCBjbGFzcy4gVGhlIGNsYXNzIHBhc3NlZCB0byBcImFzXCJcbiAgICAjICAgICAgIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBhIG5hdGl2ZSBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICNcbiAgICAjIEBleGFtcGxlXG4gICAgI1xuICAgICMgICBjbGFzcyBFbGVtZW50XG4gICAgIyAgICAgZXh0ZW5kIE5hdGl2ZTo6SGVscGVyc1xuICAgICNcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOmFkZF9jbGFzcywgOmFkZENsYXNzXG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpzaG93XG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpoaWRlXG4gICAgI1xuICAgICMgICAgIGRlZiBpbml0aWFsaXplKHNlbGVjdG9yKVxuICAgICMgICAgICAgQG5hdGl2ZSA9IGAkKCN7c2VsZWN0b3J9KWBcbiAgICAjICAgICBlbmRcbiAgICAjICAgZW5kXG4gICAgI1xuICAgICMgICB0aXRsZXMgPSBFbGVtZW50Lm5ldygnaDEnKVxuICAgICMgICB0aXRsZXMuYWRkX2NsYXNzIDpmb29cbiAgICAjICAgdGl0bGVzLmhpZGVcbiAgICAjICAgdGl0bGVzLnNob3dcbiAgICAjXG4gICAgZGVmIGFsaWFzX25hdGl2ZShuZXcsIG9sZCA9IG5ldywgYXM6IG5pbClcbiAgICAgIGlmIG9sZC5lbmRfd2l0aD8gJz0nXG4gICAgICAgIGRlZmluZV9tZXRob2QgbmV3IGRvIHx2YWx1ZXxcbiAgICAgICAgICBgI3tAbmF0aXZlfVsje29sZFswLi4tMl19XSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcblxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgYXNcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgdmFsdWUgPSBOYXRpdmUuY2FsbChAbmF0aXZlLCBvbGQsICphcmdzLCAmYmxvY2spXG4gICAgICAgICAgaWYgdmFsdWVcbiAgICAgICAgICAgIGFzLm5ldyh2YWx1ZS50b19uKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgTmF0aXZlLmNhbGwoQG5hdGl2ZSwgb2xkLCAqYXJncywgJmJsb2NrKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmFtZXMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICAgICAgTmF0aXZlKGAje0BuYXRpdmV9W25hbWVdYClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBuYXRpdmVfd3JpdGVyKCpuYW1lcylcbiAgICAgIG5hbWVzLmVhY2ggZG8gfG5hbWV8XG4gICAgICAgIGRlZmluZV9tZXRob2QgXCIje25hbWV9PVwiIGRvIHx2YWx1ZXxcbiAgICAgICAgICBOYXRpdmUoYCN7QG5hdGl2ZX1bbmFtZV0gPSB2YWx1ZWApXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbmF0aXZlX2FjY2Vzc29yKCpuYW1lcylcbiAgICAgIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmF0aXZlX3dyaXRlcigqbmFtZXMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBXcmFwcGVyXG4gICAgZGVmIGluaXRpYWxpemUobmF0aXZlKVxuICAgICAgdW5sZXNzIDo6S2VybmVsLm5hdGl2ZT8obmF0aXZlKVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7bmF0aXZlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwiXG4gICAgICBlbmRcblxuICAgICAgQG5hdGl2ZSA9IG5hdGl2ZVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBuYXRpdmUgSmF2YVNjcmlwdCB2YWx1ZVxuICAgIGRlZiB0b19uXG4gICAgICBAbmF0aXZlXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5pbmNsdWRlZChrbGFzcylcbiAgICAgIGtsYXNzLmV4dGVuZCBIZWxwZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluY2x1ZGVkKGJhc2UpXG4gICAgd2FybiAnSW5jbHVkaW5nIDo6TmF0aXZlIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlciBpbnN0ZWFkLidcbiAgICBiYXNlLmluY2x1ZGUgV3JhcHBlclxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBuYXRpdmU/KHZhbHVlKVxuICAgIGB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZS4kJGNsYXNzYFxuICBlbmRcblxuICAjIFdyYXBzIGEgbmF0aXZlIEphdmFTY3JpcHQgd2l0aCBgTmF0aXZlOjpPYmplY3QubmV3YFxuICAjXG4gICMgQHJldHVybiBbTmF0aXZlOjpPYmplY3RdIFRoZSB3cmFwcGVkIG9iamVjdCBpZiBpdCBpcyBuYXRpdmVcbiAgIyBAcmV0dXJuIFtuaWxdIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICMgQHJldHVybiBbb2JqXSBUaGUgb2JqZWN0IGl0c2VsZiBpZiBpdCdzIG5vdCBuYXRpdmVcbiAgZGVmIE5hdGl2ZShvYmopXG4gICAgaWYgYCN7b2JqfSA9PSBudWxsYFxuICAgICAgbmlsXG4gICAgZWxzaWYgbmF0aXZlPyhvYmopXG4gICAgICBOYXRpdmU6Ok9iamVjdC5uZXcob2JqKVxuICAgIGVsc2lmIG9iai5pc19hPyhBcnJheSlcbiAgICAgIG9iai5tYXAgZG8gfG98XG4gICAgICAgIE5hdGl2ZShvKVxuICAgICAgZW5kXG4gICAgZWxzaWYgb2JqLmlzX2E/KFByb2MpXG4gICAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgICBOYXRpdmUob2JqLmNhbGwoKmFyZ3MsICZibG9jaykpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBvYmpcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgX0FycmF5IEFycmF5XG5cbiAgIyBXcmFwcyBhcnJheS1saWtlIEphdmFTY3JpcHQgb2JqZWN0cyBpbiBOYXRpdmU6OkFycmF5XG4gIGRlZiBBcnJheShvYmplY3QsICphcmdzLCAmYmxvY2spXG4gICAgaWYgbmF0aXZlPyhvYmplY3QpXG4gICAgICByZXR1cm4gTmF0aXZlOjpBcnJheS5uZXcob2JqZWN0LCAqYXJncywgJmJsb2NrKS50b19hXG4gICAgZW5kXG4gICAgX0FycmF5KG9iamVjdClcbiAgZW5kXG5lbmRcblxuY2xhc3MgTmF0aXZlOjpPYmplY3QgPCBCYXNpY09iamVjdFxuICBpbmNsdWRlIDo6TmF0aXZlOjpXcmFwcGVyXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGAje0BuYXRpdmV9ID09PSAjezo6TmF0aXZlLnRyeV9jb252ZXJ0KG90aGVyKX1gXG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhuYW1lKVxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoI3tAbmF0aXZlfSwgI3tuYW1lfSlgXG4gIGVuZFxuXG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMgaW5jbHVkZT8gaGFzX2tleT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuXG4gIGRlZiBlYWNoKCphcmdzKVxuICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiAje0BuYXRpdmV9KSB7XG4gICAgICAgICAgI3t5aWVsZCBga2V5YCwgYCN7QG5hdGl2ZX1ba2V5XWB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIG1ldGhvZF9taXNzaW5nKDplYWNoLCAqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKGtleSlcbiAgICAleHtcbiAgICAgIHZhciBwcm9wID0gI3tAbmF0aXZlfVtrZXldO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6TmF0aXZlLmNhbGwoQG5hdGl2ZSwga2V5KX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICBuYXRpdmUgPSA6Ok5hdGl2ZS50cnlfY29udmVydCh2YWx1ZSlcblxuICAgIGlmIGAje25hdGl2ZX0gPT09IG5pbGBcbiAgICAgIGAje0BuYXRpdmV9W2tleV0gPSAje3ZhbHVlfWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVtrZXldID0gI3tuYXRpdmV9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWVyZ2UhKG90aGVyKVxuICAgICV4e1xuICAgICAgb3RoZXIgPSAjezo6TmF0aXZlLmNvbnZlcnQob3RoZXIpfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgICAje0BuYXRpdmV9W3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICA6Oktlcm5lbC5pbnN0YW5jZV9tZXRob2QoOnJlc3BvbmRfdG8/KS5iaW5kKHNlbGYpLmNhbGwobmFtZSwgaW5jbHVkZV9hbGwpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbCgje0BuYXRpdmV9LCAje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1pZCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChtaWQuY2hhckF0KG1pZC5sZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIHJldHVybiAje3NlbGZbbWlkLnNsaWNlKDAsIG1pZC5sZW5ndGggLSAxKV0gPSBhcmdzWzBdfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3s6Ok5hdGl2ZS5jYWxsKEBuYXRpdmUsIG1pZCwgKmFyZ3MsICZibG9jayl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgYE9wYWwuaXNfYShzZWxmLCBrbGFzcylgXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICBgc2VsZi4kJGNsYXNzID09PSBrbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIHRvX2Eob3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgOjpOYXRpdmU6OkFycmF5Lm5ldyhAbmF0aXZlLCBvcHRpb25zLCAmYmxvY2spLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8TmF0aXZlOiN7YFN0cmluZygje0BuYXRpdmV9KWB9PlwiXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5hdGl2ZTo6QXJyYXlcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIGluaXRpYWxpemUobmF0aXZlLCBvcHRpb25zID0ge30sICZibG9jaylcbiAgICBzdXBlcihuYXRpdmUpXG5cbiAgICBAZ2V0ICAgID0gb3B0aW9uc1s6Z2V0XSB8fCBvcHRpb25zWzphY2Nlc3NdXG4gICAgQG5hbWVkICA9IG9wdGlvbnNbOm5hbWVkXVxuICAgIEBzZXQgICAgPSBvcHRpb25zWzpzZXRdIHx8IG9wdGlvbnNbOmFjY2Vzc11cbiAgICBAbGVuZ3RoID0gb3B0aW9uc1s6bGVuZ3RoXSB8fCA6bGVuZ3RoXG4gICAgQGJsb2NrICA9IGJsb2NrXG5cbiAgICBpZiBgI3tsZW5ndGh9ID09IG51bGxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gbGVuZ3RoIGZvdW5kIG9uIHRoZSBhcnJheS1saWtlIG9iamVjdCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7bGVuZ3RofTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCAje3NlbGZbYGlgXX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4KVxuICAgIHJlc3VsdCA9IGNhc2UgaW5kZXhcbiAgICAgICAgICAgICB3aGVuIFN0cmluZywgU3ltYm9sXG4gICAgICAgICAgICAgICBAbmFtZWQgPyBgI3tAbmF0aXZlfVsje0BuYW1lZH1dKCN7aW5kZXh9KWAgOiBgI3tAbmF0aXZlfVsje2luZGV4fV1gXG4gICAgICAgICAgICAgd2hlbiBJbnRlZ2VyXG4gICAgICAgICAgICAgICBAZ2V0ID8gYCN7QG5hdGl2ZX1bI3tAZ2V0fV0oI3tpbmRleH0pYCA6IGAje0BuYXRpdmV9WyN7aW5kZXh9XWBcbiAgICAgICAgICAgICBlbmRcblxuICAgIGlmIHJlc3VsdFxuICAgICAgaWYgQGJsb2NrXG4gICAgICAgIEBibG9jay5jYWxsKHJlc3VsdClcbiAgICAgIGVsc2VcbiAgICAgICAgTmF0aXZlKHJlc3VsdClcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICBpZiBAc2V0XG4gICAgICBgI3tAbmF0aXZlfVsje0BzZXR9XSgje2luZGV4fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVsje2luZGV4fV0gPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gbmlsKVxuICAgIGlmIGNvdW50XG4gICAgICBpbmRleCAgPSBsZW5ndGggLSAxXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICB3aGlsZSBpbmRleCA+PSAwXG4gICAgICAgIHJlc3VsdCA8PCBzZWxmW2luZGV4XVxuICAgICAgICBpbmRleCAgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVsc2VcbiAgICAgIHNlbGZbbGVuZ3RoIC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BuYXRpdmV9WyN7QGxlbmd0aH1dYFxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgdG9fYS5pbnNwZWN0XG4gIGVuZFxuZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBQcm9jXG4gICMgQHJldHVybiBpdHNlbGYgKGFuIGluc3RhbmNlIG9mIGBGdW5jdGlvbmApXG4gIGRlZiB0b19uXG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBSZWdleHBcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgIyBAcmV0dXJuIHRoZSBhcnJheSBvZiBtYXRjaGVzXG4gIGRlZiB0b19uXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RydWN0XG4gICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhlIG1lbWJlcnMgYXMga2V5cyBhbmQgdGhlaXJcbiAgIyB2YWx1ZXMgYXMgdmFsdWVzLlxuICBkZWYgdG9fblxuICAgIHJlc3VsdCA9IGB7fWBcblxuICAgIGVhY2hfcGFpciBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBgI3tyZXN1bHR9WyN7bmFtZX1dID0gI3tOYXRpdmUudHJ5X2NvbnZlcnQodmFsdWUsIHZhbHVlKX1gXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgIyBSZXR1bnMgYSBjb3B5IG9mIGl0c2VsZiB0cnlpbmcgdG8gY2FsbCAjdG9fbiBvbiBlYWNoIG1lbWJlci5cbiAgZGVmIHRvX25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHNlbGZbaV07XG5cbiAgICAgICAgcmVzdWx0LnB1c2goI3tOYXRpdmUudHJ5X2NvbnZlcnQoYG9iamAsIGBvYmpgKX0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgQm9vbGVhblxuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRpbWVcbiAgIyBAcmV0dXJuIGl0c2VsZiAoYW4gaW5zdGFuY2Ugb2YgYERhdGVgKS5cbiAgZGVmIHRvX25cbiAgICBzZWxmXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gICMgQHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBKYXZhU2NyaXB0IHZhbHVlIChgbnVsbGApLlxuICBkZWYgdG9fblxuICAgIGBudWxsYFxuICBlbmRcbmVuZFxuXG4jIFJ1bm5pbmcgdGhpcyBjb2RlIHR3aWNlIHJlc3VsdHMgaW4gYW4gaW5maW5pdGUgbG9vcC4gV2hpbGUgaXQncyB0cnVlXG4jIHRoYXQgd2Ugc2hvdWxkbid0IHJ1biB0aGlzIGZpbGUgdHdpY2UsIHRoZXJlIGFyZSBjZXJ0YWluIGNhc2VzLCBsaWtlXG4jIGZvciBleGFtcGxlIGxpdmUgcmVsb2FkLCB3aGVuIHRoaXMgbWF5IGhhcHBlbi5cbnVubGVzcyBIYXNoLm1ldGhvZF9kZWZpbmVkPyA6X2luaXRpYWxpemVcbiAgY2xhc3MgSGFzaFxuICAgIGFsaWFzIF9pbml0aWFsaXplIGluaXRpYWxpemVcblxuICAgIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgICAleHtcbiAgICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwgJiZcbiAgICAgICAgICAgICAoZGVmYXVsdHMuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgZGVmYXVsdHMuY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICB2YXIgc21hcCA9IHNlbGYuJCRzbWFwLFxuICAgICAgICAgICAgICBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAgICAgIGtleSwgdmFsdWU7XG5cbiAgICAgICAgICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0c1trZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgKHZhbHVlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgICBzbWFwW2tleV0gPSAje0hhc2gubmV3KGB2YWx1ZWApfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgIChpdGVtLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICN7SGFzaC5uZXcoYGl0ZW1gKX07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBpdGVtYCl9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc21hcFtrZXldID0gdmFsdWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNtYXBba2V5XSA9ICN7TmF0aXZlKGB2YWx1ZWApfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gI3tfaW5pdGlhbGl6ZShkZWZhdWx0cywgJmJsb2NrKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICAjIEByZXR1cm4gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYnV0IGNhbGxpbmcgI3RvX24gb25cbiAgICAjIGFsbCB2YWx1ZXMuXG4gICAgZGVmIHRvX25cbiAgICAgICV4e1xuICAgICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAgICBzbWFwID0gc2VsZi4kJHNtYXAsXG4gICAgICAgICAgICBrZXksIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSAje05hdGl2ZS50cnlfY29udmVydChgdmFsdWVgLCBgdmFsdWVgKX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgIyBFeHBvc2VzIHRoZSBjdXJyZW50IG1vZHVsZSBhcyBhIHByb3BlcnR5IG9mXG4gICMgdGhlIGdsb2JhbCBvYmplY3QgKGUuZy4gYHdpbmRvd2ApLlxuICBkZWYgbmF0aXZlX21vZHVsZVxuICAgIGBPcGFsLmdsb2JhbFsje25hbWV9XSA9ICN7c2VsZn1gXG4gIGVuZFxuZW5kXG5cbmNsYXNzIENsYXNzXG4gIGRlZiBuYXRpdmVfYWxpYXMobmV3X2pzaWQsIGV4aXN0aW5nX21pZClcbiAgICAleHtcbiAgICAgIHZhciBhbGlhc2VkID0gI3tzZWxmfS5wcm90b3R5cGVbJyQnICsgI3tleGlzdGluZ19taWR9XTtcbiAgICAgIGlmICghYWxpYXNlZCkge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje2V4aXN0aW5nX21pZH0nIGZvciBjbGFzcyBgI3tpbnNwZWN0fSdcIiwgZXhpc3RpbmdfbWlkKX07XG4gICAgICB9XG4gICAgICAje3NlbGZ9LnByb3RvdHlwZVsje25ld19qc2lkfV0gPSBhbGlhc2VkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hdGl2ZV9jbGFzc1xuICAgIG5hdGl2ZV9tb2R1bGVcbiAgICBgc2VsZltcIm5ld1wiXSA9IHNlbGYuJG5ld2BcbiAgZW5kXG5lbmRcblxuIyBFeHBvc2VzIHRoZSBnbG9iYWwgdmFsdWUgKHdvdWxkIGJlIGB3aW5kb3dgIGluc2lkZSBhIGJyb3dzZXIpXG4kJCA9ICRnbG9iYWwgPSBOYXRpdmUoYE9wYWwuZ2xvYmFsYClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpOYXRpdmU+IiwiaXNfYT8iLCJzZWxmIiwib2JqZWN0Iiwia2xhc3MiLCJ0cnlfY29udmVydCIsInZhbHVlIiwiZGVmYXVsdCQiLCJuYXRpdmU/IiwicmVzcG9uZF90bz8iLCJ0b19uIiwiY29udmVydCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsImluc3BlY3QiLCJjYWxsIiwib2JqIiwia2V5IiwiTmF0aXZlIiwicHJvYyIsImJsb2NrIiwiTG9jYWxKdW1wRXJyb3IiLCJLZXJuZWwiLCJibG9jayBpbiBwcm9jIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwcm9jIiwibWFwISIsImFyZ3MiLCJhcmciLCJibG9jayAoMyBsZXZlbHMpIGluIHByb2MiLCJpbnN0YW5jZSIsIjxtb2R1bGU6SGVscGVycz4iLCJhbGlhc19uYXRpdmUiLCJuZXckIiwib2xkIiwiZW5kX3dpdGg/IiwiZGVmaW5lX21ldGhvZCIsImJsb2NrIGluIGFsaWFzX25hdGl2ZSIsImJsb2NrICgyIGxldmVscykgaW4gYWxpYXNfbmF0aXZlIiwiQG5hdGl2ZSIsIltdIiwiMCIsIi0yIiwiYXMiLCJ0b19wcm9jIiwibmV3IiwibmF0aXZlX3JlYWRlciIsImVhY2giLCJuYW1lcyIsImJsb2NrIGluIG5hdGl2ZV9yZWFkZXIiLCJuYW1lIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuYXRpdmVfcmVhZGVyIiwiYmxvY2sgKDMgbGV2ZWxzKSBpbiBuYXRpdmVfcmVhZGVyIiwibmF0aXZlX3dyaXRlciIsImJsb2NrIGluIG5hdGl2ZV93cml0ZXIiLCJibG9jayAoMiBsZXZlbHMpIGluIG5hdGl2ZV93cml0ZXIiLCJibG9jayAoMyBsZXZlbHMpIGluIG5hdGl2ZV93cml0ZXIiLCJuYXRpdmVfYWNjZXNzb3IiLCI8bW9kdWxlOldyYXBwZXI+IiwiaW5pdGlhbGl6ZSIsIm5hdGl2ZSQiLCJpbmNsdWRlZCIsImV4dGVuZCIsIkhlbHBlcnMiLCJiYXNlIiwid2FybiIsImluY2x1ZGUiLCJXcmFwcGVyIiwiPG1vZHVsZTpLZXJuZWw+IiwiTmF0aXZlOjpPYmplY3QiLCJBcnJheSIsIm1hcCIsImJsb2NrIGluIE5hdGl2ZSIsIm8iLCJibG9jayAoMiBsZXZlbHMpIGluIE5hdGl2ZSIsIlByb2MiLCJOYXRpdmU6OkFycmF5IiwidG9fYSIsIl9BcnJheSIsIjxjbGFzczpOYXRpdmU6Ok9iamVjdD4iLCJOYXRpdmU6OldyYXBwZXIiLCI9PSIsIm90aGVyIiwiaGFzX2tleT8iLCJibG9ja19naXZlbj8iLCJtZXRob2RfbWlzc2luZyIsIltdPSIsIm1lcmdlISIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfbWV0aG9kIiwiYmluZCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtaWQiLCIkd3JpdGVyIiwic2xpY2UiLCItIiwibGVuZ3RoIiwiMSIsIm5pbD8iLCJpbnN0YW5jZV9vZj8iLCJjbGFzcyIsIm9wdGlvbnMiLCJCYXNpY09iamVjdCIsIjxjbGFzczpOYXRpdmU6OkFycmF5PiIsIkVudW1lcmFibGUiLCJAZ2V0IiwiJHJldF9vcl8xIiwiQG5hbWVkIiwiQHNldCIsIiRyZXRfb3JfMiIsIkBsZW5ndGgiLCIkcmV0X29yXzMiLCJAYmxvY2siLCJlbnVtX2ZvciIsImluZGV4IiwicmVzdWx0IiwiU3RyaW5nIiwiPT09IiwiU3ltYm9sIiwiSW50ZWdlciIsImxhc3QiLCJjb3VudCIsIj49IiwiPDwiLCI8Y2xhc3M6TnVtZXJpYz4iLCI8Y2xhc3M6UHJvYz4iLCI8Y2xhc3M6U3RyaW5nPiIsIjxjbGFzczpSZWdleHA+IiwiPGNsYXNzOk1hdGNoRGF0YT4iLCJAbWF0Y2hlcyIsIjxjbGFzczpTdHJ1Y3Q+IiwiZWFjaF9wYWlyIiwiYmxvY2sgaW4gdG9fbiIsImJsb2NrICgyIGxldmVscykgaW4gdG9fbiIsIjxjbGFzczpBcnJheT4iLCI8Y2xhc3M6Qm9vbGVhbj4iLCI8Y2xhc3M6VGltZT4iLCI8Y2xhc3M6TmlsQ2xhc3M+IiwiSGFzaCIsIm1ldGhvZF9kZWZpbmVkPyIsIjxjbGFzczpIYXNoPiIsImRlZmF1bHRzIiwiX2luaXRpYWxpemUiLCI8Y2xhc3M6TW9kdWxlPiIsIm5hdGl2ZV9tb2R1bGUiLCI8Y2xhc3M6Q2xhc3M+IiwibmF0aXZlX2FsaWFzIiwibmV3X2pzaWQiLCJleGlzdGluZ19taWQiLCJOYW1lRXJyb3IiLCJuYXRpdmVfY2xhc3MiLCIkJCIsIiRnbG9iYWwiXSwibWFwcGluZ3MiOiJBQUFBQSx5Q0FBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQWlCQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsVUFBSUMsSUFBSkQsWUFBQUEsc0JBQUFBLFNBQWVFLE1BQUQsRUFBU0MsS0FBdkJIO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsZUFBaUJFLE1BQU9GLFlBQWNDLElBQUFHLGFBQUFBLENBQVlELEtBQVpDLENBQW1CSjtBQUN6REE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFSRUEsQ0FBQUEsaUNBQUFBO0lBV0FJLFVBQUlILElBQUpHLGtCQUFBQSx3QkFBQUEsdUJBQXFCQyxLQUFELEVBQVFDLFFBQTVCRjtBQUFBQSxNQUFBQTs7OztNQUE0QjtNQUFBLGFBQVUsR0FBVjtNQUFBOztBQUU5QkEsVUFBWUgsSUFBQU0sWUFBQUEsQ0FBUUYsS0FBUkUsQ0FBZUg7QUFDM0JBLGVBQWlCQyxLQUFNRDtBQUN2QkE7QUFDQUEsZUFBaUJDLEtBQUtHLGdCQUFBQSxDQUFhLE1BQWJBLENBQW1CSjtBQUN6Q0EsZUFBaUJDLEtBQUtJLE1BQUFBLENBQUFBLENBQU1MO0FBQzVCQTtBQUNBQTtBQUNBQSxlQUFpQkUsUUFBUUY7QUFDekJBO0FBQ0FBO0lBWEVBLENBQUFBLG9DQUFBQTtJQWNBTSxVQUFJ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IjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJub2RlanMva2VybmVsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ25hdGl2ZSdcblxuYE9wYWwuZXhpdCA9IHByb2Nlc3MuZXhpdGBcblxubW9kdWxlIEtlcm5lbFxuICBOT0RFX1JFUVVJUkUgPSBgcmVxdWlyZWBcblxuICBAX19jaGlsZF9wcm9jZXNzX18gPSBgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpYFxuICBgdmFyIF9fY2hpbGRfcHJvY2Vzc19fID0gI3tAX19jaGlsZF9wcm9jZXNzX199YFxuXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgcmVxdWlyZSgnbW9kdWxlJylgIGluc3RlYWRcbiAgZGVmIG5vZGVfcmVxdWlyZShwYXRoKVxuICAgIHdhcm4gJ1tERVBSRUNBVElPTl0gbm9kZV9yZXF1aXJlIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYHJlcXVpcmUoXFwnbW9kdWxlXFwnKWAgaW5zdGVhZC4nXG4gICAgYCN7Tk9ERV9SRVFVSVJFfSgje3BhdGgudG9fc3RyfSlgXG4gIGVuZFxuXG4gIGRlZiBzeXN0ZW0oKmFyZ3YsIGV4Y2VwdGlvbjogZmFsc2UpXG4gICAgZW52ID0ge31cbiAgICBlbnYgPSBhcmd2LnNoaWZ0IGlmIGFyZ3YuZmlyc3QuaXNfYT8gSGFzaFxuICAgIGVudiA9IEVOVi5tZXJnZShlbnYpLnRvX25cbiAgICBjbWRuYW1lID0gYXJndi5zaGlmdFxuXG4gICAgb3V0ID0gaWYgYXJndi5lbXB0eT9cbiAgICAgICAgICAgIGBfX2NoaWxkX3Byb2Nlc3NfXy5zcGF3blN5bmMoI3tjbWRuYW1lfSwgeyBzaGVsbDogdHJ1ZSwgc3RkaW86ICdpbmhlcml0JywgZW52OiAje2Vudn0gfSlgXG4gICAgICAgICAgZWxzaWYgQXJyYXkgPT09IGNtZG5hbWVcbiAgICAgICAgICAgIGBfX2NoaWxkX3Byb2Nlc3NfXy5zcGF3blN5bmMoI3tjbWRuYW1lWzBdfSwgI3thcmd2fSwgeyBhcmd2MDogI3tjbWRuYW1lWzFdfSwgc3RkaW86ICdpbmhlcml0JywgZW52OiAje2Vudn0gfSlgXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYF9fY2hpbGRfcHJvY2Vzc19fLnNwYXduU3luYygje2NtZG5hbWV9LCAje2FyZ3Z9LCB7IHN0ZGlvOiAnaW5oZXJpdCcsIGVudjogI3tlbnZ9IH0pYFxuICAgICAgICAgIGVuZFxuXG4gICAgc3RhdHVzID0gb3V0LkpTWzpzdGF0dXNdXG4gICAgc3RhdHVzID0gMTI3IGlmIGBzdGF0dXMgPT09IG51bGxgXG4gICAgcGlkID0gb3V0LkpTWzpwaWRdXG5cbiAgICAkPyA9IFByb2Nlc3M6OlN0YXR1cy5uZXcoc3RhdHVzLCBwaWQpXG4gICAgcmFpc2UgXCJDb21tYW5kIGZhaWxlZCB3aXRoIGV4aXQgI3tzdGF0dXN9OiAje2NtZG5hbWV9XCIgaWYgZXhjZXB0aW9uICYmIHN0YXR1cyAhPSAwXG4gICAgc3RhdHVzID09IDBcbiAgZW5kXG5cbiAgZGVmIGAoY21kbGluZSlcbiAgICBCdWZmZXIubmV3KGBfX2NoaWxkX3Byb2Nlc3NfXy5leGVjU3luYygje2NtZGxpbmV9KWApLnRvX3MuZW5jb2RlKCdVVEYtOCcpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBQcm9jZXNzXG4gIGNsYXNzIFN0YXR1c1xuICAgIGRlZiBpbml0aWFsaXplKHN0YXR1cywgcGlkKVxuICAgICAgQHN0YXR1cywgQHBpZCA9IHN0YXR1cywgcGlkXG4gICAgZW5kXG5cbiAgICBkZWYgZXhpdHN0YXR1c1xuICAgICAgQHN0YXR1c1xuICAgIGVuZFxuXG4gICAgYXR0cl9yZWFkZXIgOnBpZFxuXG4gICAgZGVmIHN1Y2Nlc3M/XG4gICAgICBAc3RhdHVzID09IDBcbiAgICBlbmRcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8UHJvY2Vzczo6U3RhdHVzOiBwaWQgI3tAcGlkfSBleGl0ICN7QHN0YXR1c30+XCJcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuQVJHViA9IGBwcm9jZXNzLmFyZ3Yuc2xpY2UoMilgXG5cbkFSR1Yuc2hpZnQgaWYgQVJHVi5maXJzdCA9PSAnLS0nXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPG1vZHVsZTpLZXJuZWw+IiwiQF9fY2hpbGRfcHJvY2Vzc19fIiwibm9kZV9yZXF1aXJlIiwicGF0aCIsIndhcm4iLCJOT0RFX1JFUVVJUkUiLCJ0b19zdHIiLCJzeXN0ZW0iLCJlbnYiLCJhcmd2IiwiZmlyc3QiLCJpc19hPyIsIkhhc2giLCJzaGlmdCIsIkVOViIsIm1lcmdlIiwidG9fbiIsImNtZG5hbWUiLCJvdXQiLCJlbXB0eT8iLCJBcnJheSIsIj09PSIsIltdIiwiMCIsIjEiLCJzdGF0dXMiLCIxMjciLCJwaWQiLCIkPyIsIlByb2Nlc3M6OlN0YXR1cyIsIlByb2Nlc3MiLCJuZXciLCIkcmV0X29yXzEiLCJleGNlcHRpb24iLCIhPSIsInJhaXNlIiwiPT0iLCJgIiwiY21kbGluZSIsIkJ1ZmZlciIsInRvX3MiLCJlbmNvZGUiLCI8bW9kdWxlOlByb2Nlc3M+IiwiPGNsYXNzOlN0YXR1cz4iLCJpbml0aWFsaXplIiwiQHN0YXR1cyIsIkBwaWQiLCJleGl0c3RhdHVzIiwiYXR0cl9yZWFkZXIiLCJzdWNjZXNzPyIsImluc3BlY3QiLCJBUkdWIl0sIm1hcHBpbmdzIjoiQUFBQUEsZ0RBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsUUFBUkU7RUFFQ0Y7RUFFREc7RUFBQUE7O0lBQUFBO0FBQUFBOzs7SUFDRSw0Q0FBZ0JBLE9BQWhCO0lBRUFDLHlCQUFzQkQ7SUFDckJBLHdCQUEwQkM7O0FBRzNCQyxJQUFBQSxnQ0FBQUEseUJBQUFBLHdCQUFpQkMsSUFBakJEO0FBQUFBLE1BQUFBOzs7TUFDRUosSUFBQU0sTUFBQUEsQ0FBS0YsbUZBQUxFO01BQ0FGLE9BQUdHLDRCQUFhSCxDQUFHQyxJQUFJRyxRQUFBQSxDQUFBQSxDQUFRSjtJQUZqQ0EsQ0FBQUEsb0NBQUFBOztBQUtBSyxJQUFBQSwwQkFBQUEsbUJBQUFB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QU8sQ0FBQUEsMkJBQUFBLG9CQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUEsRUFBQSxHQUFDQSx5QkFBRCxHQUFBLENBQTBCSixRQUExQixDQUFBLEdBQStCSSxRQUEvQixHQUFBLENBQXVDTCxXQUF2QyxDQUFBLEdBQStDSztNQURqREEsQ0FBQUEsK0JBQUFBLENBQUFBO0lBZkZQLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBO0VBc0JBLG9DQUFRN0MscUJBQVI7RUFFQSxJQUFjc0Qsb0JBQUl6QyxPQUFBQSxDQUFBQSxDQUFPMEIsT0FBQUEsQ0FBR3ZDLElBQUh1QyxDQUF6QjtJQUFBdkMsT0FBQXNELG9CQUFJdEMsT0FBQUEsQ0FBQUE7RUFBSjtJQXBFQWhCLE9BQUE7RUFvRUE7QUFwRUFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzUyMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vZGVqcy9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgZnVuY3Rpb24gZXhlY3V0ZUlPQWN0aW9uKGFjdGlvbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYWN0aW9uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRUFDQ0VTJyB8fFxuICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFSVNESVInIHx8XG4gICAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VNRklMRScgfHxcbiAgICAgICAgICBlcnJvci5jb2RlID09PSAnRU5PRU5UJyB8fFxuICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5JT0Vycm9yLiRuZXcoZXJyb3IubWVzc2FnZSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG5gdmFyIF9fZnNfXyA9IHJlcXVpcmUoJ2ZzJylgXG5cbmNsYXNzIElPXG4gIEBfX2ZzX18gPSBgX19mc19fYFxuXG4gIGF0dHJfcmVhZGVyIDpsaW5lbm9cblxuICBhbGlhcyBpbml0aWFsaXplX2JlZm9yZV9ub2RlX2lvIGluaXRpYWxpemVcblxuICBkZWYgaW5pdGlhbGl6ZShmZCwgZmxhZ3MgPSAncicpXG4gICAgQGxpbmVubyA9IDBcbiAgICBpbml0aWFsaXplX2JlZm9yZV9ub2RlX2lvKGZkLCBmbGFncylcbiAgZW5kXG5cbiAgZGVmIHNlbGYud3JpdGUocGF0aCwgZGF0YSlcbiAgICBGaWxlLndyaXRlKHBhdGgsIGRhdGEpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJlYWQocGF0aClcbiAgICBGaWxlLnJlYWQocGF0aClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYmlucmVhZChwYXRoKVxuICAgIGByZXR1cm4gZXhlY3V0ZUlPQWN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIF9fZnNfXy5yZWFkRmlsZVN5bmMoI3twYXRofSkudG9TdHJpbmcoJ2JpbmFyeScpfSlgXG4gIGVuZFxuZW5kXG5cblNURE9VVC53cml0ZV9wcm9jID0gLT4oc3RyaW5nKSB7IGBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHJpbmcpYCB9XG5TVERFUlIud3JpdGVfcHJvYyA9IC0+KHN0cmluZykgeyBgcHJvY2Vzcy5zdGRlcnIud3JpdGUoc3RyaW5nKWAgfVxuXG5TVERJTi5yZWFkX3Byb2MgPSAleHtmdW5jdGlvbihfY291bnQpIHtcbiAgLy8gSWdub3JlIGNvdW50LCByZXR1cm4gYXMgbXVjaCBhcyB3ZSBjYW4gZ2V0XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoNjU1MzYpLCBjb3VudDtcbiAgdHJ5IHtcbiAgICBjb3VudCA9IF9fZnNfXy5yZWFkU3luYyh0aGlzLmZkLCBidWYsIDAsIDY1NTM2LCBudWxsKTtcbiAgfVxuICBjYXRjaCAoZSkgeyAvLyBXaW5kb3dzIHN5c3RlbXMgbWF5IHJhaXNlIEVPRlxuICAgIHJldHVybiBuaWw7XG4gIH1cbiAgaWYgKGNvdW50ID09IDApIHJldHVybiBuaWw7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCAwLCBjb3VudCk7XG59fVxuXG5TVERJTi50dHkgPSB0cnVlXG5TVERPVVQudHR5ID0gdHJ1ZVxuU1RERVJSLnR0eSA9IHRydWVcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOklPPiIsIkBfX2ZzX18iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiZmQiLCJmbGFncyIsIkBsaW5lbm8iLCIwIiwiaW5pdGlhbGl6ZV9iZWZvcmVfbm9kZV9pbyIsIndyaXRlIiwicGF0aCIsImRhdGEiLCJGaWxlIiwicmVhZCIsImJpbnJlYWQiLCIkd3JpdGVyIiwiYmxvY2sgaW4gPHRvcCAocmVxdWlyZWQpPiIsInN0cmluZyIsImJsb2NrICgyIGxldmVscykgaW4gPHRvcCAocmVxdWlyZWQpPiIsIndyaXRlX3Byb2M9IiwiU1RET1VUIiwiLSIsIjEiLCJTVERFUlIiLCJyZWFkX3Byb2M9IiwiU1RESU4iLCJ0dHk9Il0sIm1hcHBpbmdzIjoiQUFBQUEsNENBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7O0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztFQUdDQTtFQUVEQztFQUFBQTs7SUFBQUE7OztJQUNFQyxjQUFXRDtJQUVYRSxJQUFBQyxhQUFBQSxDQUFZLFFBQVpBO0lBRUEsYUFBTSwyQkFBTixFQUFnQyxZQUFoQzs7QUFFQUMsSUFBQUEsOEJBQUFBLG1CQUFBQSxzQkFBZUMsRUFBRCxFQUFLQyxLQUFuQkY7QUFBQUEsTUFBQUE7Ozs7TUFBbUI7TUFBQSxVQUFRQSxHQUFSO01BQUE7TUFDakJHLGNBQVVDO01BQ1ZKLE9BQUFGLElBQUFPLDJCQUFBQSxDQUEwQkosRUFBMUIsRUFBOEJDLEtBQTlCRztJQUZGTCxDQUFBQSwrQkFBQUE7SUFLQU0sVUFBSVIsSUFBSlEsWUFBQUEsY0FBQUEsaUJBQWVDLElBQUQsRUFBT0MsSUFBckJGO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBRyxvQkFBSUgsT0FBQUEsQ0FBT0MsSUFBWCxFQUFpQkMsSUFBYkY7SUFETkEsQ0FBQUEseUJBQUFBO0lBSUFJLFVBQUlaLElBQUpZLFdBQUFBLGFBQUFBLGdCQUFjSCxJQUFkRztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUQsb0JBQUlDLE1BQUFBLENBQU1ILElBQU5HO0lBRE5BLENBQUFBLHdCQUFBQTtJQUlBZCxPQUFBZSxDQUFBQSxVQUFJYixJQUFKYSxjQUFBQSxnQkFBQUEsbUJBQWlCSixJQUFqQkk7QUFBQUEsTUFBQUE7O01BQ0dBLDZEQUErREosSUFBS0k7SUFEdkVBLENBQUFBLDJCQUFBQSxDQUFBQTtFQXBCRmYsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7O0VBbkJBZ0IsVUFBQSxDQTRDb0IsUUFBV0MsZ0JBQVJDLE1BQVFELEVBQUFFOzs7O0lBQVI7SUFBQTtJQUFBO0lBQVVBLE9BQUNBLDRCQUFEQSxFQUFGRixrQkFBQUEsaUJBQUFBLEtBQVgsQ0E1Q3BCO0VBNENNRyxNQUFOQyxzQkFBTUQsZUFBQUEsRUE1Q04sVUFBQUosT0FBQSxDQTRDTUk7RUE1Q05KLE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBakIsUUFBQSxDQUFBdUIsRUFBQUMsQ0FBQUQsQ0FBQTs7RUFBQU4sVUFBQSxDQTZDb0IsUUFBV0MsZ0JBQVJDLE1BQVFELEVBQUFFOzs7O0lBQVI7SUFBQTtJQUFBO0lBQVVBLE9BQUNBLDRCQUFEQSxFQUFGRixrQkFBQUEsaUJBQUFBLEtBQVgsQ0E3Q3BCO0VBNkNNRyxNQUFOSSxzQkFBTUosZUFBQUEsRUE3Q04sVUFBQUosT0FBQSxDQTZDTUk7RUE3Q05KLE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBakIsUUFBQSxDQUFBdUIsRUFBQUMsQ0FBQUQsQ0FBQTs7RUFBQU4sVUFBQSxDQStDcUJqQjtBQUNyQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsQ0ExREE7RUErQ0swQixNQUFMQyxxQkFBS0QsY0FBQUEsRUEvQ0wsVUFBQVQsT0FBQSxDQStDS1M7RUEvQ0xULE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBakIsUUFBQSxDQUFBdUIsRUFBQUMsQ0FBQUQsQ0FBQTs7RUFBQU4sVUFBQSxDQTREWSxJQTVEWjtFQTRES1csTUFBTEQscUJBQUtDLFFBQUFBLEVBNURMLFVBQUFYLE9BQUEsQ0E0REtXO0VBNURMWCxPQUFBLENBQUFNLFVBQUFOLE9BQUEsQ0FBQWpCLFFBQUEsQ0FBQXVCLEVBQUFDLENBQUFELENBQUE7O0VBQUFOLFVBQUEsQ0E2RGEsSUE3RGI7RUE2RE1XLE1BQU5OLHNCQUFNTSxRQUFBQSxFQTdETixVQUFBWCxPQUFBLENBNkRNVztFQTdETlgsT0FBQSxDQUFBTSxVQUFBTixPQUFBLENBQUFqQixRQUFBLENBQUF1QixFQUFBQyxDQUFBRCxDQUFBOztFQUFBTixVQUFBLENBOERhLElBOURiO0VBOERNVyxNQUFOSCxzQkFBTUcsUUFBQUEsRUE5RE4sVUFBQVgsT0FBQSxDQThETVc7RUE5RE41QixPQUFBaUIsT0FBQSxDQUFBTSxVQUFBTixPQUFBLENBQUFqQixRQUFBLENBQUF1QixFQUFBQyxDQUFBRCxDQUFBO0FBQUF2QjsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc2MzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2hlYWRsZXNzX2Nocm9tZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgT3BhbC5leGl0ID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIFlvdSBjYW4ndCBleGl0IGZyb20gdGhlIGJyb3dzZXIuXG4gICAgLy8gVGhlIGZpcnN0IGNhbGwgdG8gT3BhbC5leGl0IHNob3VsZCBzYXZlIGFuIGV4aXQgY29kZS5cbiAgICAvLyBBbGwgbmV4dCBpbnZvY2F0aW9ucyBtdXN0IGJlIGlnbm9yZWQuXG5cbiAgICBpZiAodHlwZW9mKHdpbmRvdy5PUEFMX0VYSVRfQ09ERSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5PUEFMX0VYSVRfQ09ERSA9IGNvZGU7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGtEQUFBQTtFQUFBQTs7O0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFUQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NjUxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9taW5pcmFjZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBDb21wYXRpYmlsaXR5IHV0aWxpdGllcyBmb3IgdGhlIEFQSSB3ZSBwcm92aWRlIGluXG4jIGxpYi9vcGFsL2NsaV9ydW5uZXJzL21pbmlfcmFjZXJcblxuQVJHViA9IGBvcGFsbWluaXJhY2VyLmFyZ3ZgXG5cbmBPcGFsLmV4aXQgPSBvcGFsbWluaXJhY2VyLmV4aXRgXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiJdLCJtYXBwaW5ncyI6IkFBQUFBLGlEQUFBQTtFQUFBQTs7O0VBR0Esb0NBQVFBLGtCQUFSO0VBRUFBLE9BQUNBLDhCQUFEQTtBQUxBQTsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc2NTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL3BsYXRmb3JtLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwtcGxhdGZvcm0nXG5cbmNhc2UgT1BBTF9QTEFURk9STVxud2hlbiAnbmFzaG9ybidcbiAgcmVxdWlyZSAnbmFzaG9ybidcbndoZW4gJ2dqcydcbiAgcmVxdWlyZSAnZ2pzJ1xud2hlbiAncXVpY2tqcydcbiAgcmVxdWlyZSAncXVpY2tqcydcbndoZW4gJ25vZGVqcydcbiAgcmVxdWlyZSAnbm9kZWpzL2tlcm5lbCdcbiAgcmVxdWlyZSAnbm9kZWpzL2lvJ1xud2hlbiAnaGVhZGxlc3MtY2hyb21lJ1xuICByZXF1aXJlICdoZWFkbGVzc19jaHJvbWUnXG53aGVuICdvcGFsLW1pbmlyYWNlcidcbiAgcmVxdWlyZSAnb3BhbC9taW5pcmFjZXInXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCJPUEFMX1BMQVRGT1JNIiwiPT09Il0sIm1hcHBpbmdzIjoiQUFBQUEsZ0RBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZUFBUkU7RUFFQUYsT0FBQSxhQUFBLFFBQUtHLDZCQUFMO0VBQ0EsSUFBS0gsU0FBTEksUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLEdBQ0VKLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLFNBQVJFLENBREY7RUFEQSxLQUdBLElBQUtGLEtBQUxJLFFBQUFBLENBQUEsS0FBQUEsQ0FBQSxHQUNFSixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixLQUFSRSxDQURGO0VBSEEsS0FLQSxJQUFLRixTQUFMSSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsR0FDRUosT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUkUsQ0FERjtFQUxBLEtBT0EsSUFBS0YsUUFBTEksUUFBQUEsQ0FBQSxLQUFBQSxDQUFBO0VBQ0VILElBQUFDLFNBQUFBLENBQVFGLGVBQVJFO0VBQ0FGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLFdBQVJFLEVBRkY7RUFQQSxLQVVBLElBQUtGLGlCQUFMSSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsR0FDRUosT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFLENBREY7RUFWQSxLQVlBLElBQUtGLGdCQUFMSSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsR0FDRUosT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFLENBREY7RUFaQSxtQkFBQTtBQUZBRjsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc2NzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2lucHV0cmVjZWl2ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgcnVieVxuI1xuIyBEZW1vY3JhY3kgc29mdHdhcmUgY29tcGlsYXRpb24gVkVSU0lPTiAwLjAuLCBjcmVhdGVkIG9uIDIwMjEtMTEtMTQgMTc6NDE6MzQgLTA1MDBcbiMgR2V0IGFsbCBvZiB0aGlzIGNvZGUsIGFuZCBhbGwgb2YgdGhlc2UgZmlsZXMsIHdpdGhcbiMgZ2VtIGluc3RhbGwgZGVtb2NyYWN5XG4jIExpbnV4IHJ1YnkgMi43LjBwMCAoMjAxOS0xMi0yNSByZXZpc2lvbiA2NDdlZTZmMDkxKSBbeDg2XzY0LWxpbnV4LWdudV1cbiNcbiMgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cbiNcbiMgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuXG5cblxuXG5cbiMgNzMgb2YgMTYgc291cmNlIGZpbGVzXG5tb2R1bGUgSW5wdXRyZWNlaXZlclxucmVxdWlyZV9yZWxhdGl2ZSBcInN0cmluZ19fXCJcbiAgXG4gIGNsYXNzIElucHV0cmVjZWl2ZXJcbiAgICBkZWYgaW5pdGlhbGl6ZSh0ID0gJ0VudGVyIHRleHQnKVxuICAgICAgQHRpdGxlID0gQHByb21wdCA9IHRcbiAgICBlbmRcblxuICAgIGRlZiB0b19zXG4gICAgICBAdGV4dFxuICAgIGVuZFxuXG4gICAgZGVmIG1vZGVcbiAgICAgICd6ZW5pdHknXG4gICAgZW5kXG5cbiAgICBkZWYgc3BlYWtfaW5wdXRcbiAgICAgIGlmIFJVQllfUExBVEZPUk0gPT0gJ29wYWwnXG4gICAgICAgIHJldHVyblxuICAgICAgZWxzZVxuICAgICAgZW5kXG5cbiAgICAgIGEgPSBcImVjaG8gI3tAcHJvbXB0fSB8ICN7dm9pY2UgPSAld1tmbGl0ZSBlc3BlYWsgZmVzdGl2YWwgY2F0XS53aGljaH0gIFwiXG4gICAgICB2b2ljZSA9IEZpbGUuYmFzZW5hbWUgdm9pY2VcbiAgICAgIGIgPSB7ICdmZXN0aXZhbCcgPT4gJy0tdHRzJywgJ2ZsaXRlJyA9PiAnLXZvaWNlIHNsdCcsICdlc3BlYWsnID0+ICcnIH1cblxuICAgICAgYSArPSBiW3ZvaWNlXVxuXG4gICAgICBzcGF3biBhXG4gICAgZW5kXG5cbiAgICBkZWYgd2hpY2goYSlcbiAgICAgIFthXS53aGljaFxuICAgIGVuZFxuXG4gICAgZGVmIHJlY2VpdmVfaW5wdXRcblxuICAgICAgaWYgQVJHVlswXS5pbj8gJXdbbW9kZSBtb2Rlc11cbiAgICAgICAgbiA9IDBcbiAgICAgICAgcHV0cyBcIklucHV0IG1vZGVzXFxuXCIuYm9sZFxuICAgICAgICBwdXRzICV3W2Jyb3dzZXItaW5wdXQgc3RkaW4gemVuaXR5IGRpYWxvZyBrZGlhbG9nIHJlYWRsaW5lXS5zb3J0Lm1hcCB7XG4gICAgICAgICAgICAgICBcIiAgI3tuICs9IDF9LiAje18xfVwiXG4gICAgICAgICAgICAgfS5qb2luKFwiXFxuXCIpXG4gICAgICAgIHB1dHNcbiAgICAgICAgZXhpdFxuICAgICAgZW5kXG4gICAgICBzcGVha19pbnB1dFxuXG4gICAgICBpZiBicm93c2VyX2pzPyB8fCAoQVJHVlswXSA9PSAnYnJvd3Nlci1qcycpXG4gICAgICAgIGdldF9pbnB1dF9mcm9tX2Jyb3dzZXJcbiAgICAgIGVsc2lmIEFSR1ZbMF0gIT0gJ3N0ZGluJyAmJiBBUkdWWzBdID09ICdrZGlhbG9nJyAmJiB3aGljaCgna2RpYWxvZycpXG4gICAgICAgIGlmIFJVQllfRU5HSU5FICE9ICdvcGFsJ1xuICAgICAgICAgIGBrZGlhbG9nIC0taW5wdXRib3ggI3tAcHJvbXB0LnNoZWxsZXNjYXBlfSAtLXRpdGxlICN7QHRpdGxlLnNoZWxsZXNjYXBlfWAuc3RyaXBcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBBUkdWWzBdICE9ICdzdGRpbicgJiYgQVJHVlswXSA9PSAnemVuaXR5JyAmJiB3aGljaCgnemVuaXR5JylcbiAgICAgICAgaWYgUlVCWV9FTkdJTkUgIT0gJ29wYWwnXG4gICAgICAgICAgYHplbml0eSAtLWVudHJ5IC0tdGV4dCAje0Bwcm9tcHQuc2hlbGxlc2NhcGV9IC0tdGl0bGUgI3tAdGl0bGUuc2hlbGxlc2NhcGV9YC5zdHJpcFxuICAgICAgICBlbmRcbiAgICAgIGVsc2lmIEFSR1ZbMF0gIT0gJ3N0ZGluJyAmJiBBUkdWWzBdID09ICdkaWFsb2cnICYmIHdoaWNoKCdkaWFsb2cnKVxuICAgICAgICBldmFsICdyZXF1aXJlIFwidGVtcGZpbGVcIidcbiAgICAgICAgdGV4dCA9ICcnXG4gICAgICAgIFRlbXBmaWxlLm9wZW4gZG8gfGZpbGV8XG4gICAgICAgICNwdXRzIFwiZGlhbG9nIC0taW5wdXRib3ggI3tAdGl0bGUuc2hlbGxlc2NhcGV9IDAgMCAyPiAje2ZpbGUudG9fcGF0aC5zaGVsbGVzY2FwZX1cIlxuICAgICAgICBzeXN0ZW0gXCJkaWFsb2cgLS1pbnB1dGJveCAje0B0aXRsZS5zaGVsbGVzY2FwZX0gMCAwIDI+ICN7ZmlsZS50b19wYXRoLnNoZWxsZXNjYXBlfVwiXG4gICAgICAgICAgdGV4dCA9IEZpbGUucmVhZChmaWxlKVxuICAgICAgICBlbmRcbiAgICAgICAgdGV4dFxuICAgICAgZWxzaWYgKEFSR1ZbMF0gPT0gJ3N0ZGluJykgfHwgKFJVQllfRU5HSU5FID09ICdvcGFsJylcbiAgICAgICAgdHJ1ZTsgcmVxdWlyZSBcIm9wYWwvcGxhdGZvcm1cIlxuICAgICAgICAgICAgICAgIHB1dHMgQHRpdGxlXG4jICAgICAgICBldmFsIChcInJlcXVpcmUgb3BhbC9uYXRpdmVcIilcbiAgICAgICAgcSA9ICRzdGRpbi5yZWFkbGluZS5zcGxpdChcIlxcblwiKVxuXG4gICAgICAgIHEuZmlyc3QudG9fc1xuICAgICAgZWxzaWYgQVJHVlswXS5pbj8gJXdbZm9vIGJhcl1cbiAgICAgICAgJ2ZvbycucHV0c1xuXG4gICAgICBlbHNlXG4gICAgICAgIHB1dHMgQHRpdGxlXG4gICAgICAgIGV2YWwgJ3JlcXVpcmUgXCJyZWFkbGluZVwiJ1xuICAgICAgICBSZWFkbGluZS5yZWFkbGluZS5zdHJpcFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZ2V0X2lucHV0X2Zyb21fYnJvd3NlclxuICAgICAgdHJ1ZTsgcmVxdWlyZSBcIm5hdGl2ZVwiXG4gICAgICBwdXRzICdEZW1vY3JhY3kgYmFycidcbiAgICAgICQkLmdldF9kZW1vY3JhY3lfYmFyX2lucHV0XG4gICAgZW5kXG5cbiAgICBkZWYgYnJvd3Nlcl9qcz9cbiAgICAgIGBkb2N1bWVudGBcbiAgICAgIHRydWVcbiAgICByZXNjdWUgRXhjZXB0aW9uXG4gICAgICBmYWxzZVxuICAgIGVuZFxuXG4gICAgZGVmIG5vZGU/XG4gICAgICBgcHJvY2Vzc2BcbiAgICAgIHRydWVcbiAgICByZXNjdWUgRXhjZXB0aW9uXG4gICAgICBmYWxzZVxuICAgIGVuZFxuXG4gICAgZGVmIHJ1Ynk/XG4gICAgICB0cnVlXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cblxuXG5cblxuXG5cblxuXG4jIEZlZWRiYWNrIGFuZCBkb25hdGlvbiB0byBncmVnb3J5Y29oZW4yQGdtYWlsLmNvbSAobW9uZXkgdHJhbnNmZXIgb3IgUGF5cGFsKVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOklucHV0cmVjZWl2ZXI+IiwicmVxdWlyZV9yZWxhdGl2ZSIsIjxjbGFzczpJbnB1dHJlY2VpdmVyPiIsImluaXRpYWxpemUiLCJ0IiwiQHRpdGxlIiwiQHByb21wdCIsInRvX3MiLCJAdGV4dCIsIm1vZGUiLCJzcGVha19pbnB1dCIsImEiLCJ2b2ljZSIsIndoaWNoIiwiRmlsZSIsImJhc2VuYW1lIiwiYiIsIisiLCJbXSIsInNlbGYiLCJzcGF3biIsInJlY2VpdmVfaW5wdXQiLCJBUkdWIiwiMCIsImluPyIsIm4iLCJwdXRzIiwiYm9sZCIsIm1hcCIsInNvcnQiLCJibG9jayBpbiByZWNlaXZlX2lucHV0IiwiXzEiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlY2VpdmVfaW5wdXQiLCIxIiwiam9pbiIsImV4aXQiLCIkcmV0X29yXzEiLCJicm93c2VyX2pzPyIsIj09IiwiZ2V0X2lucHV0X2Zyb21fYnJvd3NlciIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIiE9IiwiJHJldF9vcl80IiwiJHJldF9vcl81IiwiJHJldF9vcl82IiwiJHJldF9vcl83IiwiZXZhbCIsInRleHQiLCJvcGVuIiwiVGVtcGZpbGUiLCJmaWxlIiwic3lzdGVtIiwic2hlbGxlc2NhcGUiLCJ0b19wYXRoIiwicmVhZCIsIiRyZXRfb3JfOCIsIlJVQllfRU5HSU5FIiwicmVxdWlyZSIsInEiLCIkc3RkaW4iLCJyZWFkbGluZSIsInNwbGl0IiwiZmlyc3QiLCJSZWFkbGluZSIsInN0cmlwIiwiJCQiLCJnZXRfZGVtb2Ny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QUNEQSxPQUFBO1FBREE7VUFFRixzQkFBTyxDQUFBRCx5QkFBQSxDQUFQO1lBQUE7Y0FDRUMsT0FBQTtZQURGO1VBQUEsQ0FGRTtRQUFBO01BREZBLENBQUFBLHlDQUFBQTtNQU9BbkUsT0FBQW9FLENBQUFBLHlCQUFBQSw4QkFBQUEsU0FBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUE7TUFERkEsQ0FBQUEseUNBQUFBLENBQUFBO0lBckdGcEUsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFIRkYsR0FBQUEsV0FBQUE7QUFoQkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNzg4MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vaXRlbWxpc3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgcnVieVxuI1xuIyBEZW1vY3JhY3kgc29mdHdhcmUgY29tcGlsYXRpb24gVkVSU0lPTiAwLjAuLCBjcmVhdGVkIG9uIDIwMjEtMTEtMTQgMTc6NDE6MzQgLTA1MDBcbiMgR2V0IGFsbCBvZiB0aGlzIGNvZGUsIGFuZCBhbGwgb2YgdGhlc2UgZmlsZXMsIHdpdGhcbiMgZ2VtIGluc3RhbGwgZGVtb2NyYWN5XG4jIExpbnV4IHJ1YnkgMi43LjBwMCAoMjAxOS0xMi0yNSByZXZpc2lvbiA2NDdlZTZmMDkxKSBbeDg2XzY0LWxpbnV4LWdudV1cbiNcbiMgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cbiNcbiMgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuXG5cblxuXG5cbiMgNjUgb2YgMTYgc291cmNlIGZpbGVzXG5tb2R1bGUgSXRlbUxpc3RcbnJlcXVpcmVfcmVsYXRpdmUgXCJzdHJpbmdfX1wiXG4gICAgY2xhc3MgSXRlbUxpc3RcbiAgICBkZWYgaW5pdGlhbGl6ZShsaXN0KVxuICAgICAgQGxpc3QgPSBsaXN0XG4gICAgICBhc3NlcnQgIShsaXN0LnRvX3MuaW5jbHVkZT8gJyBpICcpXG4gICAgZW5kXG5cbiAgICBkZWYgcHJvY2VzczsgZW5kXG5cbiAgICBkZWYgdG9fc1xuICAgICAgdGV4dCA9IFwiI3tAbGlzdC5maXJzdC5zdGFydGluZ190b19zLnVwcGVyY2FzZS5hZGRfcGVyaW9kfSBcIlxuXG4gICAgICBAbGlzdFsxLi5AbGlzdC5sZW5ndGhdLmVhY2ggZG8gfGl8XG4gICAgICAgIHRleHQgKz0gXCIje3EgPSBpLnRvX3MudXBwZXJjYXNlLmFkZF9wZXJpb2R9IFwiXG4gICAgICBlbmRcbiAgICAgIHRleHQgPSB0ZXh0LnJzdHJpcFxuICAgIGVuZFxuXG4gICAgZGVmIGluc3BlY3RcbiAgICAgIHRvX3NcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuXG5cblxuXG5cblxuXG5cbiMgRmVlZGJhY2sgYW5kIGRvbmF0aW9uIHRvIGdyZWdvcnljb2hlbjJAZ21haWwuY29tIChtb25leSB0cmFuc2ZlciBvciBQYXlwYWwpXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6SXRlbUxpc3Q+IiwicmVxdWlyZV9yZWxhdGl2ZSIsIjxjbGFzczpJdGVtTGlzdD4iLCJpbml0aWFsaXplIiwibGlzdCIsIkBsaXN0Iiwic2VsZiIsImFzc2VydCIsInRvX3MiLCJpbmNsdWRlPyIsIiEiLCJwcm9jZXNzIiwidGV4dCIsImZpcnN0Iiwic3RhcnRpbmdfdG9fcyIsInVwcGVyY2FzZSIsImFkZF9wZXJpb2QiLCJlYWNoIiwiW10iLCIxIiwibGVuZ3RoIiwiYmxvY2sgaW4gdG9fcyIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3MiLCIrIiwicSIsInJzdHJpcCIsImluc3BlY3QiXSwibWFwcGluZ3MiOiJBQUFBQSwyQ0FBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBZ0JBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNBQyx3Q0FBaUJELFVBQWpCQztJQUNJRCxPQUFBRTtJQUFBQTs7TUFBQUE7O0FBQUFBOzs7QUFDQUMsTUFBQUEsOEJBQUFBLHlCQUFBQSxzQkFBZUMsSUFBZkQ7QUFBQUEsUUFBQUE7OztRQUNFRSxZQUFRRDtRQUNSRCxPQUFBRyxJQUFBQyxRQUFBQSxDQUFTSCxJQUFJSSxNQUFBQSxDQUFBQSxDQUFLQyxhQUFBQSxDQUFVTixLQUFWTSxDQUFYQyxNQUFBQSxDQUFBQSxDQUFQSDtNQUZGSixDQUFBQSxvQ0FBQUE7O0FBS0FRLE1BQUFBLDJCQUFBQSxzQkFBQUEsbUJBQUFBO0FBQUFBLFFBQUFBOztRQXhCSkEsT0FBQTtNQXdCSUEsQ0FBQUEsaUNBQUFBOztBQUVBSCxNQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7O1FBQ0VJLE9BQU8sRUFBQSxHQUFBLENBQUdQLFNBQUtRLE9BQUFBLENBQUFBLENBQU1DLGVBQUFBLENBQUFBLENBQWNDLFdBQUFBLENBQUFBLENBQVVDLFlBQUFBLENBQUFBLENBQXRDLENBQUEsR0FBa0RSO1FBRW5DUyxNQUF0QlosU0FBS2EsT0FBQUEsQ0FBQyxnQkFBQUMsQ0FBQSxFQUFHZCxTQUFLZSxRQUFBQSxDQUFBQSxDQUFSLFFBQURGLENBQWlCRCxRQUFBQSxFQUFBQSxFQUFBQSxFQUFNSSxnQkFBSUMsQ0FBSkQsRUFBQUU7Ozs7VUFBSTtVQUFBO1VBQUE7VUFDOUJBLE9BQUFYLENBQUFBLE9BQUtZLFNBQUxaLElBQUtZLEVBQUcsRUFBQSxHQUFBLENBQUdDLENBQUFBLElBQUlILENBQUNkLE1BQUFBLENBQUFBLENBQUtPLFdBQUFBLENBQUFBLENBQVVDLFlBQUFBLENBQUFBLENBQXBCUyxDQUFILENBQUEsR0FBbUNGLEdBQXRDQyxDQUFMWixFQUQwQlMsa0JBQUFBLGlCQUFBQSxLQUFOSjtRQUd0QlQsT0FBQUksQ0FBQUEsT0FBT0EsSUFBSWMsUUFBQUEsQ0FBQUEsQ0FBWGQ7TUFORkosQ0FBQUEsOEJBQUFBO01BU0FOLE9BQUF5QixDQUFBQSwyQkFBQUEsc0JBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQXJCLElBQUFFLE1BQUFBLENBQUFBO01BREZtQixDQUFBQSxpQ0FBQUEsQ0FBQUE7SUFqQkF6QixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUZKRixHQUFBQSxXQUFBQTtBQWhCQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3OTQzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9jb25qdW5jdGlvbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBydWJ5XG4jXG4jIERlbW9jcmFjeSBzb2Z0d2FyZSBjb21waWxhdGlvbiBWRVJTSU9OIDAuMC4sIGNyZWF0ZWQgb24gMjAyMS0xMS0xNCAxNzo0MTozNCAtMDUwMFxuIyBHZXQgYWxsIG9mIHRoaXMgY29kZSwgYW5kIGFsbCBvZiB0aGVzZSBmaWxlcywgd2l0aFxuIyBnZW0gaW5zdGFsbCBkZW1vY3JhY3lcbiMgTGludXggcnVieSAyLjcuMHAwICgyMDE5LTEyLTI1IHJldmlzaW9uIDY0N2VlNmYwOTEpIFt4ODZfNjQtbGludXgtZ251XVxuI1xuIyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG5cblxuXG5cblxuIyA3MCBvZiAxNiBzb3VyY2UgZmlsZXNcbm1vZHVsZSBDb25qdW5jdGlvblxucmVxdWlyZV9yZWxhdGl2ZSBcInN0cmluZ19fXCJcbiAgICBjbGFzcyBDb25qdW5jdGlvblxuICAgIGRlZiBpbml0aWFsaXplKGEpXG4gICAgICBAYSA9IGFcbiAgICAgIEB2YWx1ZSA9IGwuc2FtcGxlXG4gICAgZW5kXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgX3RvX3NcbiAgICBlbmRcblxuICAgIGRlZiB0b19zXG4gICAgICBfdG9fc1xuICAgIGVuZFxuXG4gICAgcHJvdGVjdGVkXG5cbiAgICBkZWYgX3RvX3NcbiAgICAgIEB2YWx1ZS50b19zICsgQGEudG9fc1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5cblxuXG5cblxuXG5cblxuIyBGZWVkYmFjayBhbmQgZG9uYXRpb24gdG8gZ3JlZ29yeWNvaGVuMkBnbWFpbC5jb20gKG1vbmV5IHRyYW5zZmVyIG9yIFBheXBhbClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpDb25qdW5jdGlvbj4iLCJyZXF1aXJlX3JlbGF0aXZlIiwiPGNsYXNzOkNvbmp1bmN0aW9uPiIsImluaXRpYWxpemUiLCJhIiwiQGEiLCJAdmFsdWUiLCJzZWxmIiwibCIsInNhbXBsZSIsImluc3BlY3QiLCJfdG9fcyIsInRvX3MiLCJwcm90ZWN0ZWQiLCIrIl0sIm1hcHBpbmdzIjoiQUFBQUEsOENBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQWdCQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDQUMsMkNBQWlCRCxVQUFqQkM7SUFDSUQsT0FBQUU7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0FDLE1BQUFBLDhCQUFBQSw0QkFBQUEsc0JBQWVDLENBQWZEO0FBQUFBLFFBQUFBOzs7UUFDRUUsU0FBS0Q7UUFDTEQsT0FBQUcsQ0FBQUEsYUFBU0MsSUFBQUMsR0FBQUEsQ0FBQUEsQ0FBQ0MsUUFBQUEsQ0FBQUEsQ0FBVkg7TUFGRkgsQ0FBQUEsdUNBQUFBOztBQUtBTyxNQUFBQSwyQkFBQUEseUJBQUFBLG1CQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUgsSUFBQUksT0FBQUEsQ0FBQUE7TUFERkQsQ0FBQUEsb0NBQUFBOztBQUlBRSxNQUFBQSx3QkFBQUEsc0JBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUwsSUFBQUksT0FBQUEsQ0FBQUE7TUFERkMsQ0FBQUEsaUNBQUFBO01BSUFMLElBQUFNLFdBQUFBLENBQUFBO01BRUFYLE9BQUFTLENBQUFBLHlCQUFBQSx1QkFBQUEsaUJBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFZRyxTQUFaUixVQUFNTSxNQUFBQSxDQUFBQSxDQUFNRSxFQUFFVCxNQUFFTyxNQUFBQSxDQUFBQSxDQUFKRTtNQURkSCxDQUFBQSxrQ0FBQUEsQ0FBQUE7SUFoQkFULEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBRkpGLEdBQUFBLFdBQUFBO0FBaEJBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjc5OTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2JlY2F1c2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgcnVieVxuI1xuIyBEZW1vY3JhY3kgc29mdHdhcmUgY29tcGlsYXRpb24gVkVSU0lPTiAwLjAuLCBjcmVhdGVkIG9uIDIwMjEtMTEtMTQgMTc6NDE6MzQgLTA1MDBcbiMgR2V0IGFsbCBvZiB0aGlzIGNvZGUsIGFuZCBhbGwgb2YgdGhlc2UgZmlsZXMsIHdpdGhcbiMgZ2VtIGluc3RhbGwgZGVtb2NyYWN5XG4jIExpbnV4IHJ1YnkgMi43LjBwMCAoMjAxOS0xMi0yNSByZXZpc2lvbiA2NDdlZTZmMDkxKSBbeDg2XzY0LWxpbnV4LWdudV1cbiNcbiMgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cbiNcbiMgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuXG5cblxuXG5cbiMgNzIgb2YgMTYgc291cmNlIGZpbGVzXG5tb2R1bGUgQmVjYXVzZVxucmVxdWlyZV9yZWxhdGl2ZSBcInN0cmluZ19fXCJcbiByZXF1aXJlX3JlbGF0aXZlIFwiLi9jb25qdW5jdGlvblwiXG4gIGNsYXNzIEJlY2F1c2UgPCBDb25qdW5jdGlvbjo6Q29uanVuY3Rpb25cbiAgICBkZWYgbFxuICAgICAgW1xuICAgICAgICAnYmVjYXVzZScsXG4gICAgICAgICdzaW5jZScsXG4gICAgICAgICc7IHRoZSByZWFzb24gYmVpbmcgdGhhdCcsXG4gICAgICAgICdkdWUgdG8gdGhlIGZhY3QgdGhhdCcsXG4gICAgICAgICdpbmFzbXVjaCBhcycsXG4gICAgICAgICc7IGZvciB0aGUgcmVhc29uIHRoYXQnXG4gICAgICBdLm1hcCB7IHxpfCBpLnN0YXJ0X3dpdGg/KCc7JykgPyBpIDogXCIgI3tpfVwiIH1cbiAgICBlbmQ7IGVuZFxuZW5kXG5cblxuXG5cblxuXG5cblxuXG4jIEZlZWRiYWNrIGFuZCBkb25hdGlvbiB0byBncmVnb3J5Y29oZW4yQGdtYWlsLmNvbSAobW9uZXkgdHJhbnNmZXIgb3IgUGF5cGFsKVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOkJlY2F1c2U+IiwicmVxdWlyZV9yZWxhdGl2ZSIsIjxjbGFzczpCZWNhdXNlPiIsImwiLCJtYXAiLCJibG9jayBpbiBsIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gbCIsInN0YXJ0X3dpdGg/IiwiQ29uanVuY3Rpb246OkNvbmp1bmN0aW9uIiwiQ29uanVuY3Rpb24iXSwibWFwcGluZ3MiOiJBQUFBQSwwQ0FBQUE7RUFBQUE7O0VBQUFBO0VBZ0JBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNBQyx1Q0FBaUJELFVBQWpCQztJQUNDQSx1Q0FBaUJELGVBQWpCQztJQUNDRCxPQUFBRTtJQUFBQTs7TUFBQUE7O01BQ0VBLE9BQUFDLENBQUFBLHFCQUFBQSxlQUFBQSxhQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FPQ0MsTUFQRCxDQUNFRCxTQURGLEVBRUVBLE9BRkYsRUFHRUEseUJBSEYsRUFJRUEsc0JBSkYsRUFLRUEsYUFMRixFQU1FQSx1QkFORixDQU9DQyxPQUFBQSxFQUFBQSxFQUFBQSxFQUFLQyxnQkFBR0MsQ0FBSEQsRUFBQUU7Ozs7VUFBRztVQUFBO1VBQUE7VUFBRyxJQUFBLFFBQUFELENBQUNFLGdCQUFBQSxDQUFhRCxHQUFiQyxDQUFELENBQUE7WUFBcUJELE9BQUFEO1VBQXJCO1lBQXlCQyxPQUFBLEVBQUEsR0FBQ0EsR0FBRCxHQUFBLENBQUlELENBQUo7VUFBekIsRUFBTkQsa0JBQUFBLGlCQUFBQSxLQUFMRDtNQVJIRCxDQUFBQSwwQkFBQUEsQ0FBQUE7SUFERkQsR0FBQUEsV0FBQUEsRUFBZ0JPLElBQUFDLDJCQUFBRCxnQkFBaEJQO0VBSEZGLEdBQUFBLFdBQUFBO0FBaEJBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjgwMzEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2V2aWRlbmNlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IHJ1YnlcbiNcbiMgRGVtb2NyYWN5IHNvZnR3YXJlIGNvbXBpbGF0aW9uIFZFUlNJT04gMC4wLiwgY3JlYXRlZCBvbiAyMDIxLTExLTE0IDE3OjQxOjM0IC0wNTAwXG4jIEdldCBhbGwgb2YgdGhpcyBjb2RlLCBhbmQgYWxsIG9mIHRoZXNlIGZpbGVzLCB3aXRoXG4jIGdlbSBpbnN0YWxsIGRlbW9jcmFjeVxuIyBMaW51eCBydWJ5IDIuNy4wcDAgKDIwMTktMTItMjUgcmV2aXNpb24gNjQ3ZWU2ZjA5MSkgW3g4Nl82NC1saW51eC1nbnVdXG4jXG4jIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG4jXG4jIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cblxuXG5cblxuXG4jIDY4IG9mIDE2IHNvdXJjZSBmaWxlc1xubW9kdWxlIEV2aWRlbmNlXG5yZXF1aXJlX3JlbGF0aXZlIFwic3RyaW5nX19cIlxuIHJlcXVpcmVfcmVsYXRpdmUgXCIuL2Nvbmp1bmN0aW9uXCJcblxuICBjbGFzcyBFdmlkZW5jZSA8IENvbmp1bmN0aW9uOjpDb25qdW5jdGlvblxuICAgIGRlZiBsXG4gICAgICBbXG4gICAgICAgICdhcyBldmlkZW5jZWQgYnknLFxuICAgICAgICAnYXMgc2hvd24gYnknLFxuICAgICAgICAnd2hpY2ggaXMgaW5kaWNhdGVkIGJ5JyxcbiAgICAgICAgJ2FzIG1hZGUgYXBwYXJlbnQgYnknLFxuICAgICAgICAnYXMgbWFkZSBjbGVhciBieScsXG4gICAgICAgICdhcyBtYWRlIHBsYWluIGJ5JyxcbiAgICAgICAgJ2FzIGRlbW9uc3RyYXRlZCBieScsXG4gICAgICAgICdhcyBtYWRlIHBsYWluIGJ5JyxcbiAgICAgICAgJ2FzIGJlY29tZXMgb2JzZXJ2YWJsZSBieSdcbiAgICAgIF0ubWFwIHsgfGl8IFwiICN7aX1cIiB9XG4gICAgZW5kOyBlbmRcbmVuZFxuXG5cblxuXG5cblxuXG5cblxuIyBGZWVkYmFjayBhbmQgZG9uYXRpb24gdG8gZ3JlZ29yeWNvaGVuMkBnbWFpbC5jb20gKG1vbmV5IHRyYW5zZmVyIG9yIFBheXBhbClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpFdmlkZW5jZT4iLCJyZXF1aXJlX3JlbGF0aXZlIiwiPGNsYXNzOkV2aWRlbmNlPiIsImwiLCJtYXAiLCJibG9jayBpbiBsIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gbCIsIkNvbmp1bmN0aW9uOjpDb25qdW5jdGlvbiIsIkNvbmp1bmN0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQUEsMkNBQUFBO0VBQUFBOztFQUFBQTtFQWdCQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDQUMsd0NBQWlCRCxVQUFqQkM7SUFDQ0Esd0NBQWlCRCxlQUFqQkM7SUFFQ0QsT0FBQUU7SUFBQUE7O01BQUFBOztNQUNFQSxPQUFBQyxDQUFBQSxxQkFBQUEsZ0JBQUFBLGFBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQVVDQyxNQVZELENBQ0VELGlCQURGLEVBRUVBLGFBRkYsRUFHRUEsdUJBSEYsRUFJRUEscUJBSkYsRUFLRUEsa0JBTEYsRUFNRUEsa0JBTkYsRUFPRUEsb0JBUEYsRUFRRUEsa0JBUkYsRUFTRUEsMEJBVEYsQ0FVQ0MsT0FBQUEsRUFBQUEsRUFBQUEsRUFBS0MsZ0JBQUdDLENBQUhELEVBQUFFOzs7O1VBQUc7VUFBQTtVQUFBO1VBQUdBLE9BQUEsRUFBQSxHQUFDQSxHQUFELEdBQUEsQ0FBSUQsQ0FBSixFQUFORCxrQkFBQUEsaUJBQUFBLEtBQUxEO01BWEhELENBQUFBLDJCQUFBQSxDQUFBQTtJQURGRCxHQUFBQSxXQUFBQSxFQUFpQk0sSUFBQUMsMkJBQUFELGdCQUFqQk47RUFKRkYsR0FBQUEsV0FBQUE7QUFoQkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODA2NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vaG93ZXZlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBydWJ5XG4jXG4jIERlbW9jcmFjeSBzb2Z0d2FyZSBjb21waWxhdGlvbiBWRVJTSU9OIDAuMC4sIGNyZWF0ZWQgb24gMjAyMS0xMS0xNCAxNzo0MTozNCAtMDUwMFxuIyBHZXQgYWxsIG9mIHRoaXMgY29kZSwgYW5kIGFsbCBvZiB0aGVzZSBmaWxlcywgd2l0aFxuIyBnZW0gaW5zdGFsbCBkZW1vY3JhY3lcbiMgTGludXggcnVieSAyLjcuMHAwICgyMDE5LTEyLTI1IHJldmlzaW9uIDY0N2VlNmYwOTEpIFt4ODZfNjQtbGludXgtZ251XVxuI1xuIyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG5cblxuXG5cblxuIyA3MSBvZiAxNiBzb3VyY2UgZmlsZXNcbm1vZHVsZSBIb3dldmVyXG5yZXF1aXJlX3JlbGF0aXZlIFwic3RyaW5nX19cIlxuIHJlcXVpcmVfcmVsYXRpdmUgXCIuL2Nvbmp1bmN0aW9uXCJcbiAgY2xhc3MgSG93ZXZlciA8IENvbmp1bmN0aW9uOjpDb25qdW5jdGlvblxuICAgIGRlZiBsXG4gICAgICBbXG5cbiAgICAgICAgJ29uZSBpbnRlcmVzdGluZyBwb2ludCB0aG91Z2gnLFxuICAgICAgICAnaG93ZXZlcicsXG4gICAgICAgICd0aG91Z2gnLFxuICAgICAgICAnYWx0aG91Z2gnLFxuICAgICAgICAndGhhdCBiZWluZyBzYWlkJyxcbiAgICAgICAgJ3dpdGggdGhhdCBzYWlkJyxcbiAgICAgICAgJ29uIHRoZSBvdGhlciBoYW5kIHRob3VnaCdcbiAgICAgIF0ubWFwIHsgfGl8IFwiI3tpfSBcIiB9XG4gICAgZW5kOyBlbmQ7IGVuZFxuXG5cblxuXG5cblxuXG5cblxuIyBGZWVkYmFjayBhbmQgZG9uYXRpb24gdG8gZ3JlZ29yeWNvaGVuMkBnbWFpbC5jb20gKG1vbmV5IHRyYW5zZmVyIG9yIFBheXBhbClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpIb3dldmVyPiIsInJlcXVpcmVfcmVsYXRpdmUiLCI8Y2xhc3M6SG93ZXZlcj4iLCJsIiwibWFwIiwiYmxvY2sgaW4gbCIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIGwiLCJDb25qdW5jdGlvbjo6Q29uanVuY3Rpb24iLCJDb25qdW5jdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQTtFQUFBQTs7RUFBQUE7RUFnQkFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0FDLHVDQUFpQkQsVUFBakJDO0lBQ0NBLHVDQUFpQkQsZUFBakJDO0lBQ0NELE9BQUFFO0lBQUFBOztNQUFBQTs7TUFDRUEsT0FBQUMsQ0FBQUEscUJBQUFBLGVBQUFBLGFBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQVNDQyxNQVRELENBRUVELDhCQUZGLEVBR0VBLFNBSEYsRUFJRUEsUUFKRixFQUtFQSxVQUxGLEVBTUVBLGlCQU5GLEVBT0VBLGdCQVBGLEVBUUVBLDBCQVJGLENBU0NDLE9BQUFBLEVBQUFBLEVBQUFBLEVBQUtDLGdCQUFHQyxDQUFIRCxFQUFBRTs7OztVQUFHO1VBQUE7VUFBQTtVQUFHQSxPQUFBLEVBQUEsR0FBQSxDQUFHRCxDQUFILENBQUEsR0FBS0MsSUFBWEYsa0JBQUFBLGlCQUFBQSxLQUFMRDtNQVZIRCxDQUFBQSwwQkFBQUEsQ0FBQUE7SUFERkQsR0FBQUEsV0FBQUEsRUFBZ0JNLElBQUFDLDJCQUFBRCxnQkFBaEJOO0VBSEZGLEdBQUFBLFdBQUFBO0FBaEJBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjgwOTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2l0ZW0ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgcnVieVxuI1xuIyBEZW1vY3JhY3kgc29mdHdhcmUgY29tcGlsYXRpb24gVkVSU0lPTiAwLjAuLCBjcmVhdGVkIG9uIDIwMjEtMTEtMTQgMTc6NDE6MzQgLTA1MDBcbiMgR2V0IGFsbCBvZiB0aGlzIGNvZGUsIGFuZCBhbGwgb2YgdGhlc2UgZmlsZXMsIHdpdGhcbiMgZ2VtIGluc3RhbGwgZGVtb2NyYWN5XG4jIExpbnV4IHJ1YnkgMi43LjBwMCAoMjAxOS0xMi0yNSByZXZpc2lvbiA2NDdlZTZmMDkxKSBbeDg2XzY0LWxpbnV4LWdudV1cbiNcbiMgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cbiNcbiMgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuXG5cblxuXG5cbiMgNjkgb2YgMTYgc291cmNlIGZpbGVzXG5tb2R1bGUgSXRlbVxucmVxdWlyZV9yZWxhdGl2ZSBcInN0cmluZ19fXCJcbiByZXF1aXJlX3JlbGF0aXZlIFwiLi9iZWNhdXNlXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCIuL2V2aWRlbmNlXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCIuL2hvd2V2ZXJcIlxuXG4gIEJlY2F1c2UgPSBCZWNhdXNlOjpCZWNhdXNlXG4gIEhvd2V2ZXIgPSBIb3dldmVyOjpIb3dldmVyXG4gIEV2aWRlbmNlID0gRXZpZGVuY2U6OkV2aWRlbmNlXG4gIGNsYXNzIEl0ZW1cbiAgICBkZWYgaW5pdGlhbGl6ZShmdW5jdGlvbnMsIGlucHV0cylcbiAgICAgIGlucHV0cy5lYWNoX3dpdGhfaW5kZXggZG8gfGluXywgaXxcbiAgICAgICAgaWYgaW5fLnN0YXJ0X3dpdGg/ICd0aGF0J1xuICAgICAgICBlbmRcblxuICAgICAgICBzZW5kIGZ1bmN0aW9uc1tpXSwgaW5fXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBwZXJzb25hbGx5KF9hcmd1bWVudClcbiAgICAgIGxpc3QgPSBbJ0kgcGVyc29uYWxseScsICdwZXJzb25hbGx5LCBJJywgJ0kgdGhpbmsgSScsICdpbiBteSBvcGluaW9uLCBJJywgJ3RvIG1lLCBJJ11cbiAgICAgIGxpc3QgKz0gKFsnSSddICogbGlzdC5sZW5ndGgpXG5cbiAgICAgIEBwZXJzb25hbGx5ID0gXCIje2xpc3Quc2FtcGxlfSBcIlxuICAgIGVuZFxuXG4gICAgZGVmIGhvd2V2ZXIoYSlcbiAgICAgIEBob3dldmVyID0gSG93ZXZlci5uZXcoYSlcbiAgICBlbmRcblxuICAgIGRlZiBiZWNhdXNlKGEpXG4gICAgICBAYmVjYXVzZSA9IEJlY2F1c2UubmV3KGEpXG4gICAgZW5kXG5cbiAgICBkZWYgZXZpZGVuY2UoYSlcbiAgICAgIEBldmlkZW5jZSA9IEV2aWRlbmNlLm5ldyhhKVxuICAgIGVuZFxuXG4gICAgZGVmIHN0YXJ0aW5nX3RvX3NcbiAgICAgIFtAcGVyc29uYWxseSwgQHNlbnRpbWVudCwgQGJlY2F1c2UsIEBldmlkZW5jZV0uam9pblxuICAgIGVuZFxuXG4gICAgZGVmIHRvX3NcbiAgICAgIGEgPSBbQGhvd2V2ZXIsIEBwZXJzb25hbGx5LCBAc2VudGltZW50LCBAYmVjYXVzZSwgQGV2aWRlbmNlXS5qb2luXG4gICAgZW5kXG5cbiAgICBkZWYgaW5zcGVjdFxuICAgICAgdG9fc1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5cblxuXG5cblxuXG5cblxuIyBGZWVkYmFjayBhbmQgZG9uYXRpb24gdG8gZ3JlZ29yeWNvaGVuMkBnbWFpbC5jb20gKG1vbmV5IHRyYW5zZmVyIG9yIFBheXBhbClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpJdGVtPiIsInJlcXVpcmVfcmVsYXRpdmUiLCJCZWNhdXNlOjpCZWNhdXNlIiwiQmVjYXVzZSIsIkhvd2V2ZXI6Okhvd2V2ZXIiLCJIb3dldmVyIiwiRXZpZGVuY2U6OkV2aWRlbmNlIiwiRXZpZGVuY2UiLCI8Y2xhc3M6SXRlbT4iLCJpbml0aWFsaXplIiwiZnVuY3Rpb25zIiwiaW5wdXRzIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImluXyIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCJzdGFydF93aXRoPyIsInNlbGYiLCJzZW5kIiwiW10iLCJwZXJzb25hbGx5IiwiX2FyZ3VtZW50IiwibGlzdCIsIisiLCIqIiwibGVuZ3RoIiwiQHBlcnNvbmFsbHkiLCJzYW1wbGUiLCJob3dldmVyIiwiYSIsIkBob3dldmVyIiwibmV3IiwiYmVjYXVzZSIsIkBiZWNhdXNlIiwiZXZpZGVuY2UiLCJAZXZpZGVuY2UiLCJzdGFydGluZ190b19zIiwiQHNlbnRpbWVudCIsImpvaW4iLCJ0b19zIiwiaW5zcGVjdCJdLCJtYXBwaW5ncyI6IkFBQUFBLHVDQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFB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RDsifX0seyJvZmZzZXQiOnsibGluZSI6MjgxOTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL25lZ2F0aXZlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IHJ1YnlcbiNcbiMgRGVtb2NyYWN5IHNvZnR3YXJlIGNvbXBpbGF0aW9uIFZFUlNJT04gMC4wLiwgY3JlYXRlZCBvbiAyMDIxLTExLTE0IDE3OjQxOjM0IC0wNTAwXG4jIEdldCBhbGwgb2YgdGhpcyBjb2RlLCBhbmQgYWxsIG9mIHRoZXNlIGZpbGVzLCB3aXRoXG4jIGdlbSBpbnN0YWxsIGRlbW9jcmFjeVxuIyBMaW51eCBydWJ5IDIuNy4wcDAgKDIwMTktMTItMjUgcmV2aXNpb24gNjQ3ZWU2ZjA5MSkgW3g4Nl82NC1saW51eC1nbnVdXG4jXG4jIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG4jXG4jIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cblxuXG5cblxuXG4jIDc4IG9mIDE2IHNvdXJjZSBmaWxlc1xubW9kdWxlIE5lZ2F0aXZlXG5yZXF1aXJlX3JlbGF0aXZlIFwic3RyaW5nX19cIlxuIHJlcXVpcmVfcmVsYXRpdmUgXCIuL2l0ZW1cIlxuXG4gIGNsYXNzIE5lZ2F0aXZlIDwgSXRlbTo6SXRlbVxuICAgIGRlZiBpbml0aWFsaXplKCphcmdzKVxuICAgICAgYiA9ICVpW2hvd2V2ZXIgcGVyc29uYWxseSBkaXNhZ3JlZSBiZWNhdXNlIGV2aWRlbmNlXVxuICAgICAgc3VwZXIoYiwgYXJncylcbiAgICBlbmRcblxuICAgIGRlZiBob3dldmVyKGFyZ3VtZW50KTsgZW5kXG5cbiAgICBkZWYgZGlzYWdyZWUoYXJndW1lbnQpXG4gICAgICBAc2VudGltZW50ID0gXCIje0BAbGlzdC5zYW1wbGV9I3thcmd1bWVudH1cIlxuICAgIGVuZFxuICAgIEBAbGlzdCA9IFsnZGlzYWdyZWUnLCBcImRvbid0IGFncmVlXCIsICdkbyBub3QgYWdyZWUnLCAnZG8gbm90IGFncmVlIHdpdGggdGhlIHN0YXRlbWVudCB0aGF0J11cbiAgZW5kOyBlbmRcblxuXG5cblxuXG5cblxuXG5cbiMgRmVlZGJhY2sgYW5kIGRvbmF0aW9uIHRvIGdyZWdvcnljb2hlbjJAZ21haWwuY29tIChtb25leSB0cmFuc2ZlciBvciBQYXlwYWwpXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6TmVnYXRpdmU+IiwicmVxdWlyZV9yZWxhdGl2ZSIsIjxjbGFzczpOZWdhdGl2ZT4iLCJpbml0aWFsaXplIiwiYiIsInNlbGYiLCJhcmdzIiwiaG93ZXZlciIsImFyZ3VtZW50IiwiZGlzYWdyZWUiLCJAc2VudGltZW50IiwiQEBsaXN0Iiwic2FtcGxlIiwiSXRlbTo6SXRlbSIsIkl0ZW0iXSwibWFwcGluZ3MiOiJBQUFBQSwyQ0FBQUE7RUFBQUE7O0VBQUFBO0VBZ0JBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNBQyx3Q0FBaUJELFVBQWpCQztJQUNDQSx3Q0FBaUJELFFBQWpCQztJQUVDRCxPQUFBRTtJQUFBQTs7TUFBQUE7Ozs7QUFDRUMsTUFBQUEsOEJBQUFBLHlCQUFBQSxzQkFyQkosRUFxQklBO0FBQUFBLFFBQUFBOztRQUFBQTs7O1FBckJKOztRQXFCbUI7UUFDYkMsSUFBSSxDQUFHLFNBQUgsRUFBVyxZQUFYLEVBQXNCLFVBQXRCLEVBQStCLFNBQS9CLEVBQXVDLFVBQXZDO1FBQ0pELE9BQUEsT0FBQUUsSUFBQSxFQUFBLG9FQUFBLGNBQUEsRUFBQSxDQUFNRCxDQUFOLEVBQVNFLElBQVQsQ0FBQSxFQUFBLElBQUE7TUFGRkgsQ0FBQUEscUNBQUFBOztBQUtBSSxNQUFBQSwyQkFBQUEsc0JBQUFBLG1CQUFZQyxRQUFaRDtBQUFBQSxRQUFBQTs7UUExQkpBLE9BQUE7TUEwQklBLENBQUFBLGlDQUFBQTs7QUFFQUUsTUFBQUEsNEJBQUFBLHVCQUFBQSxvQkFBYUQsUUFBYkM7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFDLENBQUFBLGlCQUFhLEVBQUEsR0FBQSxDQUFHQyxpREFBTUMsUUFBQUEsQ0FBQUEsQ0FBVCxDQUFBLEdBQUEsQ0FBbUJKLFFBQW5CLENBQWJFO01BREZELENBQUFBLGtDQUFBQTtNQUdBUCxPQUFBUywyQ0FBUyxDQUFDVCxVQUFELEVBQWFBLGFBQWIsRUFBNEJBLGNBQTVCLEVBQTRDQSxzQ0FBNUMsQ0FBVFM7SUFYRlQsR0FBQUEsV0FBQUEsRUFBaUJXLElBQUFDLG9CQUFBRCxTQUFqQlg7RUFKRkYsR0FBQUEsV0FBQUE7QUFoQkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODI0MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vbmV1dHJhbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBydWJ5XG4jXG4jIERlbW9jcmFjeSBzb2Z0d2FyZSBjb21waWxhdGlvbiBWRVJTSU9OIDAuMC4sIGNyZWF0ZWQgb24gMjAyMS0xMS0xNCAxNzo0MTozNCAtMDUwMFxuIyBHZXQgYWxsIG9mIHRoaXMgY29kZSwgYW5kIGFsbCBvZiB0aGVzZSBmaWxlcywgd2l0aFxuIyBnZW0gaW5zdGFsbCBkZW1vY3JhY3lcbiMgTGludXggcnVieSAyLjcuMHAwICgyMDE5LTEyLTI1IHJldmlzaW9uIDY0N2VlNmYwOTEpIFt4ODZfNjQtbGludXgtZ251XVxuI1xuIyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG5cblxuXG5cblxuIyA3NSBvZiAxNiBzb3VyY2UgZmlsZXNcbm1vZHVsZSBOZXV0cmFsXG5yZXF1aXJlX3JlbGF0aXZlIFwic3RyaW5nX19cIlxuIHJlcXVpcmVfcmVsYXRpdmUgXCIuL2l0ZW1cIlxuICBjbGFzcyBOZXV0cmFsIDwgSXRlbTo6SXRlbVxuICAgIEBAbGlzdCA9IFsnSSB0aGluayB3ZSBjYW4gYWxsIGFncmVlJywgJ0V2ZXJ5b25lIGtub3dzJywgJ0V2ZXJ5Ym9keSBrbm93cycsICdXZSBhbGwga25vdyddXG5cbiAgICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAgIHN1cGVyKCVpW25vcCBub3Agbm9wIHN0YXRlIG5vcF0sIGFyZ3MpXG4gICAgZW5kXG5cbiAgICBkZWYgbm9wKF9hcmd1bWVudClcbiAgICAgICcnXG4gICAgZW5kXG5cbiAgICBkZWYgc3RhdGUoYXJndW1lbnQpXG4gICAgICBAc2VudGltZW50ID0gQEBsaXN0LnNhbXBsZSArIGFyZ3VtZW50XG4gICAgZW5kOyBlbmQ7IGVuZFxuXG5cblxuXG5cblxuXG5cblxuIyBGZWVkYmFjayBhbmQgZG9uYXRpb24gdG8gZ3JlZ29yeWNvaGVuMkBnbWFpbC5jb20gKG1vbmV5IHRyYW5zZmVyIG9yIFBheXBhbClcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpOZXV0cmFsPiIsInJlcXVpcmVfcmVsYXRpdmUiLCI8Y2xhc3M6TmV1dHJhbD4iLCJAQGxpc3QiLCJpbml0aWFsaXplIiwic2VsZiIsImFyZ3MiLCJub3AiLCJfYXJndW1lbnQiLCJzdGF0ZSIsImFyZ3VtZW50IiwiQHNlbnRpbWVudCIsIisiLCJzYW1wbGUiLCJJdGVtOjpJdGVtIiwiSXRlbSJdLCJtYXBwaW5ncyI6IkFBQUFBLDBDQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFnQkFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0FDLHVDQUFpQkQsVUFBakJDO0lBQ0NBLHVDQUFpQkQsUUFBakJDO0lBQ0NELE9BQUFFO0lBQUFBOztNQUFBQTs7O01BQ0VDLDJDQUFTLENBQUNELDBCQUFELEVBQTZCQSxnQkFBN0IsRUFBK0NBLGlCQUEvQyxFQUFrRUEsYUFBbEUsQ0FBVEM7O0FBRUFDLE1BQUFBLDhCQUFBQSx3QkFBQUEsc0JBdEJKLEVBc0JJQTtBQUFBQSxRQUFBQTs7UUFBQUE7OztRQXRCSjs7UUFzQm1CO1FBQ2JBLE9BQUEsT0FBQUMsSUFBQSxFQUFBLG1FQUFBLGNBQUEsRUFBQSxDQUFNLENBQUcsS0FBSCxFQUFPLEtBQVAsRUFBVyxLQUFYLEVBQWUsT0FBZixFQUFxQixLQUFyQixDQUFOLEVBQWlDQyxJQUFqQyxDQUFBLEVBQUEsSUFBQTtNQURGRixDQUFBQSxvQ0FBQUE7O0FBSUFHLE1BQUFBLHVCQUFBQSxpQkFBQUEsZUFBUUMsU0FBUkQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFBO01BREZBLENBQUFBLDRCQUFBQTtNQUlBTCxPQUFBTyxDQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFVQyxRQUFWRDtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQUUsQ0FBQUEsaUJBQTJCQyxTQUFkVCxpREFBTVUsUUFBQUEsQ0FBQUEsQ0FBUUQsRUFBRUYsUUFBRkUsQ0FBM0JEO01BREZGLENBQUFBLDhCQUFBQSxDQUFBQTtJQVhGUCxHQUFBQSxXQUFBQSxFQUFnQlksSUFBQUMsb0JBQUFELFNBQWhCWjtFQUhGRixHQUFBQSxXQUFBQTtBQWhCQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MjkwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vdXRwdXR0ZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgcnVieVxuI1xuIyBEZW1vY3JhY3kgc29mdHdhcmUgY29tcGlsYXRpb24gVkVSU0lPTiAwLjAuLCBjcmVhdGVkIG9uIDIwMjEtMTEtMTQgMTc6NDE6MzQgLTA1MDBcbiMgR2V0IGFsbCBvZiB0aGlzIGNvZGUsIGFuZCBhbGwgb2YgdGhlc2UgZmlsZXMsIHdpdGhcbiMgZ2VtIGluc3RhbGwgZGVtb2NyYWN5XG4jIExpbnV4IHJ1YnkgMi43LjBwMCAoMjAxOS0xMi0yNSByZXZpc2lvbiA2NDdlZTZmMDkxKSBbeDg2XzY0LWxpbnV4LWdudV1cbiNcbiMgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cbiNcbiMgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuXG5cblxuXG5cbiMgNjcgb2YgMTYgc291cmNlIGZpbGVzXG5tb2R1bGUgT3V0cHV0dGVyXG5yZXF1aXJlX3JlbGF0aXZlIFwic3RyaW5nX19cIlxuIHJlcXVpcmVfcmVsYXRpdmUgXCIuL2lucHV0cmVjZWl2ZXJcIlxuICBjbGFzcyBPdXRwdXR0ZXJcbiAgICBkZWYgaW5pdGlhbGl6ZShtb2RlLCBpdGVtX2xpc3QpXG4gICAgICByYWlzZSAnJyBpZiBtb2RlLm5pbD9cblxuICAgICAgQGlyID0gSW5wdXRyZWNlaXZlcjo6SW5wdXRyZWNlaXZlci5uZXcoJ3N0ZG91dCcpXG5cbiAgICAgIEBpdGVtX2xpc3QgPVx0aXRlbV9saXN0XG5cbiAgICAgIHNlbmQgbW9kZVxuICAgIGVuZFxuXG4gICAgZGVmIGNvcHlcbiAgICAgIGlmIElPLnJlc3BvbmRfdG8/IDpwb3BlblxuICAgICAgICBJTy5wb3BlbiAneGNsaXAgLXNlbGVjdGlvbiBjJywgJ3cnIGRvIHxmfFxuICAgICAgICAgIHB1dHMgX3N0ZG91dFxuICAgICAgICAgIGYucHJpbnQgX3N0ZG91dFxuICAgICAgICBlbmQ7ICMgZW5kXG4gICAgICBlbHNlXG4gICAgICBcdHRydWU7IHJlcXVpcmUgXCJuYXRpdmVcIlxuICAgICAgXHQkJC5jb3B5VGV4dFRvQ2xpcGJvYXJkKF9zdGRvdXQpXG4jICAgICAgXHQkJC5xdWVyeVNlbGVjdG9yKFwic2Vuc2libGVuZXNzXCIpXG4gICAgICBcdCQkLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzZW5zaWJsZW5lc3NcIikuYXBwZW5kQ2hpbGQoJCQuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoX3N0ZG91dCkpXG4gICAgICAgIHB1dHMgX3N0ZG91dCAjIC5nc3ViIFwiXFxuXCIsIFwiIFwiXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBfc3Rkb3V0XG4gICAgICBAaXRlbV9saXN0LnRvX3NcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuXG5cblxuXG5cblxuXG5cbiMgRmVlZGJhY2sgYW5kIGRvbmF0aW9uIHRvIGdyZWdvcnljb2hlbjJAZ21haWwuY29tIChtb25leSB0cmFuc2ZlciBvciBQYXlwYWwpXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6T3V0cHV0dGVyPiIsInJlcXVpcmVfcmVsYXRpdmUiLCI8Y2xhc3M6T3V0cHV0dGVyPiIsImluaXRpYWxpemUiLCJtb2RlIiwiaXRlbV9saXN0IiwibmlsPyIsInNlbGYiLCJyYWlzZSIsIkBpciIsIklucHV0cmVjZWl2ZXI6OklucHV0cmVjZWl2ZXIiLCJJbnB1dHJlY2VpdmVyIiwibmV3IiwiQGl0ZW1fbGlzdCIsInNlbmQiLCJjb3B5IiwiSU8iLCJyZXNwb25kX3RvPyIsInBvcGVuIiwiYmxvY2sgaW4gY29weSIsImYiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvcHkiLCJwdXRzIiwiX3N0ZG91dCIsInByaW50IiwicmVxdWlyZSIsIiQkIiwiY29weVRleHRUb0NsaXBib2FyZCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJ0b19zIl0sIm1hcHBpbmdzIjoiQUFBQUEsNENBQUFBO0VBQUFBOztFQUFBQTtFQWdCQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDQUMseUNBQWlCRCxVQUFqQkM7SUFDQ0EseUNBQWlCRCxpQkFBakJDO0lBQ0NELE9BQUFFO0lBQUFBOztNQUFBQTs7QUFBQUE7OztBQUNFQyxNQUFBQSw4QkFBQUEsMEJBQUFBLHNCQUFlQyxJQUFELEVBQU9DLFNBQXJCRjtBQUFBQSxRQUFBQTs7O1FBQ0UsSUFBQSxRQUFZQyxJQUFJRSxTQUFBQSxDQUFBQSxDQUFoQixDQUFBO1VBQUFDLElBQUFDLE9BQUFBLENBQU1MLEVBQU5LLENBQUE7UUFFQUMsVUFBTUMsSUFBQUMsNkJBQUFELGtCQUE0QkUsS0FBQUEsQ0FBS1QsUUFBTFM7UUFFbENDLGlCQUFhUjtRQUViRixPQUFBSSxJQUFBTyxNQUFBQSxDQUFLVixJQUFMVTtNQVBGWCxDQUFBQSxxQ0FBQUE7O0FBVUFZLE1BQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBO0FBQUFBOztRQUNFLElBQUEsUUFBR0Msa0JBQUVDLGdCQUFBQSxDQUFhLE9BQWJBLENBQUwsQ0FBQTtVQUNFRixPQUFFRyxNQUFGRixrQkFBRUUsU0FBQUEsRUFBQUEsQ0FBT0gsb0JBQVQsRUFBK0JBLEdBQTdCRyxDQUFBQSxFQUFpQ0MsZ0JBQUlDLENBQUpELEVBQUFFOzs7O1lBQUk7WUFBQTtZQUFBO1lBQ3JDZCxJQUFBZSxNQUFBQSxDQUFLZixJQUFBZ0IsU0FBQUEsQ0FBQUEsQ0FBTEQ7WUFDQUQsT0FBQUQsQ0FBQ0ksT0FBQUEsQ0FBT2pCLElBQUFnQixTQUFBQSxDQUFBQSxDQUFQQyxFQUZnQ0wsa0JBQUFBLGlCQUFBQSxLQUFqQ0Q7UUFESjs7VUFNQztVQUFNWCxJQUFBa0IsU0FBQUEsQ0FBUVYsUUFBUlU7VUFDTkMsUUFBRUMscUJBQUFBLENBQXFCcEIsSUFBQWdCLFNBQUFBLENBQUFBLENBQXJCSTtVQUVGRCxRQUFFRSxVQUFBQSxDQUFBQSxDQUFTQyxlQUFBQSxDQUFlZCxjQUFmYyxDQUE4QkMsYUFBQUEsQ0FBYUosUUFBRUUsVUFBQUEsQ0FBQUEsQ0FBU0csZ0JBQUFBLENBQWdCeEIsSUFBQWdCLFNBQUFBLENBQUFBLENBQWhCUSxDQUF4QkQ7VUFDeENmLE9BQUFSLElBQUFlLE1BQUFBLENBQUtmLElBQUFnQixTQUFBQSxDQUFBQSxDQUFMRDtRQVZGO01BREZQLENBQUFBLCtCQUFBQTtNQWVBYixPQUFBcUIsQ0FBQUEsMkJBQUFBLHVCQUFBQSxtQkFBQUE7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFWLGNBQVVtQixNQUFBQSxDQUFBQTtNQURaVCxDQUFBQSxrQ0FBQUEsQ0FBQUE7SUExQkZyQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQUhGRixHQUFBQSxXQUFBQTtBQWhCQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI4MzUzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9wb3NpdGl2ZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBydWJ5XG4jXG4jIERlbW9jcmFjeSBzb2Z0d2FyZSBjb21waWxhdGlvbiBWRVJTSU9OIDAuMC4sIGNyZWF0ZWQgb24gMjAyMS0xMS0xNCAxNzo0MTozNCAtMDUwMFxuIyBHZXQgYWxsIG9mIHRoaXMgY29kZSwgYW5kIGFsbCBvZiB0aGVzZSBmaWxlcywgd2l0aFxuIyBnZW0gaW5zdGFsbCBkZW1vY3JhY3lcbiMgTGludXggcnVieSAyLjcuMHAwICgyMDE5LTEyLTI1IHJldmlzaW9uIDY0N2VlNmYwOTEpIFt4ODZfNjQtbGludXgtZ251XVxuI1xuIyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG5cblxuXG5cblxuIyA3NCBvZiAxNiBzb3VyY2UgZmlsZXNcbm1vZHVsZSBQb3NpdGl2ZVxucmVxdWlyZV9yZWxhdGl2ZSBcInN0cmluZ19fXCJcbiByZXF1aXJlX3JlbGF0aXZlIFwiLi9pdGVtXCJcbiAgY2xhc3MgUG9zaXRpdmUgPCBJdGVtOjpJdGVtXG4gICAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgICBzdXBlciglaVtob3dldmVyIHBlcnNvbmFsbHkgYWdyZWUgYmVjYXVzZSBldmlkZW5jZV0sIGFyZ3MpXG4gICAgZW5kXG5cbiAgICBkZWYgYWdyZWUoYXJndW1lbnQpXG4gICAgICBAc2VudGltZW50ID0gQEBsaXN0LnNhbXBsZSArIGFyZ3VtZW50XG4gICAgZW5kXG5cbiAgICBAQGxpc3QgPSBbJ2FncmVlJywgJ2FncmVlIHdpdGggdGhlIHN0YXRlbWVudCB0aGF0JywgJ2RvIGFncmVlJ11cbiAgZW5kXG5lbmRcblxuXG5cblxuXG5cblxuXG5cbiMgRmVlZGJhY2sgYW5kIGRvbmF0aW9uIHRvIGdyZWdvcnljb2hlbjJAZ21haWwuY29tIChtb25leSB0cmFuc2ZlciBvciBQYXlwYWwpXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6UG9zaXRpdmU+IiwicmVxdWlyZV9yZWxhdGl2ZSIsIjxjbGFzczpQb3NpdGl2ZT4iLCJpbml0aWFsaXplIiwic2VsZiIsImFyZ3MiLCJhZ3JlZSIsImFyZ3VtZW50IiwiQHNlbnRpbWVudCIsIisiLCJAQGxpc3QiLCJzYW1wbGUiLCJJdGVtOjpJdGVtIiwiSXRlbSJdLCJtYXBwaW5ncyI6IkFBQUFBLDJDQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFnQkFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0FDLHdDQUFpQkQsVUFBakJDO0lBQ0NBLHdDQUFpQkQsUUFBakJDO0lBQ0NELE9BQUFFO0lBQUFBOztNQUFBQTs7OztBQUNFQyxNQUFBQSw4QkFBQUEseUJBQUFBLHNCQXBCSixFQW9CSUE7QUFBQUEsUUFBQUE7O1FBQUFBOzs7UUFwQko7O1FBb0JtQjtRQUNiQSxPQUFBLE9BQUFDLElBQUEsRUFBQSxvRUFBQSxjQUFBLEVBQUEsQ0FBTSxDQUFHLFNBQUgsRUFBVyxZQUFYLEVBQXNCLE9BQXRCLEVBQTRCLFNBQTVCLEVBQW9DLFVBQXBDLENBQU4sRUFBcURDLElBQXJELENBQUEsRUFBQSxJQUFBO01BREZGLENBQUFBLHFDQUFBQTs7QUFJQUcsTUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBVUMsUUFBVkQ7QUFBQUEsUUFBQUE7O1FBQ0VBLE9BQUFFLENBQUFBLGlCQUEyQkMsU0FBZEMsaURBQU1DLFFBQUFBLENBQUFBLENBQVFGLEVBQUVGLFFBQUZFLENBQTNCRDtNQURGRixDQUFBQSwrQkFBQUE7TUFJQUosT0FBQVEsMkNBQVMsQ0FBQ1IsT0FBRCxFQUFVQSwrQkFBVixFQUEyQ0EsVUFBM0MsQ0FBVFE7SUFURlIsR0FBQUEsV0FBQUEsRUFBaUJVLElBQUFDLG9CQUFBRCxTQUFqQlY7RUFIRkYsR0FBQUEsV0FBQUE7QUFoQkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyODM5NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vcC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBydWJ5XG4jXG4jIERlbW9jcmFjeSBzb2Z0d2FyZSBjb21waWxhdGlvbiBWRVJTSU9OIDAuMC4sIGNyZWF0ZWQgb24gMjAyMS0xMS0xNCAxNzo0MTozNCAtMDUwMFxuIyBHZXQgYWxsIG9mIHRoaXMgY29kZSwgYW5kIGFsbCBvZiB0aGVzZSBmaWxlcywgd2l0aFxuIyBnZW0gaW5zdGFsbCBkZW1vY3JhY3lcbiMgTGludXggcnVieSAyLjcuMHAwICgyMDE5LTEyLTI1IHJldmlzaW9uIDY0N2VlNmYwOTEpIFt4ODZfNjQtbGludXgtZ251XVxuI1xuIyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuI1xuIyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG5cblxuXG5cblxuIyA2NiBvZiAxNiBzb3VyY2UgZmlsZXNcbm1vZHVsZSBNYWluQ2xhc3NcbnJlcXVpcmVfcmVsYXRpdmUgXCJzdHJpbmdfX1wiXG4gcmVxdWlyZV9yZWxhdGl2ZSBcIi4vaW5wdXRyZWNlaXZlclwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiLi9pdGVtbGlzdFwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiLi9uZWdhdGl2ZVwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiLi9uZXV0cmFsXCJcbnJlcXVpcmVfcmVsYXRpdmUgXCIuL291dHB1dHRlclwiXG5yZXF1aXJlX3JlbGF0aXZlIFwiLi9wb3NpdGl2ZVwiXG4gIGNsYXNzIE1haW5DbGFzc1xuICAgIGRlZiBpbml0aWFsaXplXG4gICAgICBpdGVtX2xpc3QgPSBJdGVtTWFrZXIubmV3XG5cbiAgICAgIG91dHB1dHRlciA9IE91dHB1dHRlcjo6T3V0cHV0dGVyLm5ldygnY29weScsIGl0ZW1fbGlzdClcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgSXRlbU1ha2VyXG4gICAgZGVmIGluaXRpYWxpemVcbiAgICAgIEBsaXN0ID0gW11cbiAgICAgICV3W25lZ2F0aXZlIHBvc2l0aXZlIG5ldXRyYWxdLnJldmVyc2VfZWFjaCBkbyB8aXxcbiAgICAgICAgQGxpc3QgKz0gW1wiRW50ZXIgI3tpfSBmZWVsaW5nXCIsIFwiRW50ZXIgI3tpfSByZWFzb25cIiwgXCJFbnRlciAje2l9IGV2aWRlbmNlXCJdXG4gICAgICBlbmRcblxuICAgICAgaG93ZXZlcjEsIGhvd2V2ZXIyID0gWycnLCAnJ10uc2h1ZmZsZVxuICAgICAgQG5lZyA9IE5lZ2F0aXZlOjpOZWdhdGl2ZS5uZXcoJycsIGhvd2V2ZXIxLCBpLCBpLCBpKVxuICAgICAgQHBvcyA9IFBvc2l0aXZlOjpQb3NpdGl2ZS5uZXcoJycsIGhvd2V2ZXIyLCBpLCBpLCBpKVxuICAgICAgQG5ldXQgPSBOZXV0cmFsOjpOZXV0cmFsLm5ldygnJywgJycsIGksIGksIGkpXG4gICAgZW5kXG5cbiAgICBkZWYgaVxuICAgICAgdCA9IElucHV0cmVjZWl2ZXI6OklucHV0cmVjZWl2ZXIubmV3KEBsaXN0LnBvcCkucmVjZWl2ZV9pbnB1dFxuXG4gICAgICBcIiAje3R9XCIgIyAucHJlcGVuZCgnICcpXG4gICAgZW5kXG5cbiAgICBkZWYgdG9fc1xuICAgICAgbGlzdCA9IFtAbmVnLCBAcG9zXS5zaHVmZmxlLmNvbmNhdChbQG5ldXRdKVxuICAgICAgYXNzZXJ0IGxpc3QuaW5zdGFuY2Vfb2Y/KEFycmF5KVxuICAgICAgYXNzZXJ0IGxpc3QubGVuZ3RoID49IDJcblxuICAgICAgSXRlbUxpc3Q6Okl0ZW1MaXN0Lm5ldyhsaXN0KS50b19zICMgKV0pIyArIHNwbGl0ICsgQG5ldXQudG9fcylcbiAgICBlbmRcbiAgZW5kXG4gIE1haW5DbGFzcy5uZXdcbmVuZFxuXG5cblxuXG5cblxuXG5cblxuIyBGZWVkYmFjayBhbmQgZG9uYXRpb24gdG8gZ3JlZ29yeWNvaGVuMkBnbWFpbC5jb20gKG1vbmV5IHRyYW5zZmVyIG9yIFBheXBhbClcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCI8bW9kdWxlOk1haW5DbGFzcz4iLCJyZXF1aXJlX3JlbGF0aXZlIiwiPGNsYXNzOk1haW5DbGFzcz4iLCJpbml0aWFsaXplIiwiaXRlbV9saXN0IiwiSXRlbU1ha2VyIiwibmV3Iiwib3V0cHV0dGVyIiwiT3V0cHV0dGVyOjpPdXRwdXR0ZXIiLCJPdXRwdXR0ZXIiLCI8Y2xhc3M6SXRlbU1ha2VyPiIsIkBsaXN0IiwicmV2ZXJzZV9lYWNoIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCIrIiwic2h1ZmZsZSIsImhvd2V2ZXIxIiwiaG93ZXZlcjIiLCJAbmVnIiwiTmVnYXRpdmU6Ok5lZ2F0aXZlIiwiTmVnYXRpdmUiLCJzZWxmIiwiQHBvcyIsIlBvc2l0aXZlOjpQb3NpdGl2ZSIsIlBvc2l0aXZlIiwiQG5ldXQiLCJOZXV0cmFsOjpOZXV0cmFsIiwiTmV1dHJhbCIsInQiLCJJbnB1dHJlY2VpdmVyOjpJbnB1dHJlY2VpdmVyIiwiSW5wdXRyZWNlaXZlciIsInBvcCIsInJlY2VpdmVfaW5wdXQiLCJ0b19zIiwibGlzdCIsImNvbmNhdCIsImFzc2VydCIsImluc3RhbmNlX29mPyIsIkFycmF5IiwiPj0iLCJsZW5ndGgiLCIyIiwiSXRlbUxpc3Q6Okl0ZW1MaXN0IiwiSXRlbUxpc3QiLCJNYWluQ2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQSwyQkFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBZ0JBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNBQyxpQ0FBaUJELFVBQWpCQztJQUNDQSxpQ0FBaUJELGlCQUFqQkM7SUFDREEsaUNBQWlCRCxZQUFqQkM7SUFDQUEsaUNBQWlCRCxZQUFqQkM7SUFDQUEsaUNBQWlCRCxXQUFqQkM7SUFDQUEsaUNBQWlCRCxhQUFqQkM7SUFDQUEsaUNBQWlCRCxZQUFqQkM7SUFDRUM7SUFBQUE7O01BQUFBOztNQUNFQSxPQUFBQyxDQUFBQSw4QkFBQUEsMEJBQUFBLHNCQUFBQTtBQUFBQSxRQUFBQTs7O1FBQ0VDLFlBQVlDLHlCQUFTQyxLQUFBQSxDQUFBQTtRQUVyQkgsT0FBQUksQ0FBQUEsWUFBWUMsSUFBQUMseUJBQUFELGNBQW9CRixLQUFBQSxDQUFLSCxNQUF6QixFQUFpQ0MsU0FBYkUsQ0FBaENDO01BSEZKLENBQUFBLHFDQUFBQSxDQUFBQTtJQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQVFBUTtJQUFBQTs7TUFBQUE7O0FBQUFBOzs7QUFDRVAsTUFBQUEsOEJBQUFBLDBCQUFBQSxzQkFBQUE7QUFBQUEsUUFBQUE7OztRQUNFUSxZQUFRO1FBQ3FCQyxNQUE3QixDQUFHVCxVQUFILEVBQVlBLFVBQVosRUFBcUJBLFNBQXJCLENBQTZCUyxnQkFBQUEsRUFBQUEsRUFBQUEsRUFBY0MsZ0JBQUlDLENBQUpELEVBQUFFO0FBQUFBOzs7O1VBQUk7VUFBQTtVQUFBO1VBQzdDQSxPQUFBSixDQUFBQSxZQUFNSyxTQUFOTCxTQUFNSyxFQUFHLENBQUMsRUFBQSxHQUFDRCxRQUFELEdBQUEsQ0FBU0QsQ0FBVCxDQUFBLEdBQVdDLFVBQVosRUFBdUIsRUFBQSxHQUFDQSxRQUFELEdBQUEsQ0FBU0QsQ0FBVCxDQUFBLEdBQVdDLFNBQWxDLEVBQTRDLEVBQUEsR0FBQ0EsUUFBRCxHQUFBLENBQVNELENBQVQsQ0FBQSxHQUFXQyxXQUF2RCxDQUFIQyxDQUFOTCxFQUR5Q0Usa0JBQUFBLGlCQUFBQSxLQUFkRDtRQUk3QixLQUFxQixDQUFDVCxFQUFELEVBQUtBLEVBQUwsQ0FBUWMsU0FBQUEsQ0FBQUEsQ0FBN0Isc0JBQUEsRUFBQUMsQ0FBQUEsV0FBQSw2QkFBQUEsQ0FBQSxFQUFVQyxDQUFBQSxXQUFWLDZCQUFVQSxDQUFWO1FBQ0FDLFdBQU9DLElBQUFDLHdCQUFBRCxhQUFrQmYsS0FBQUEsQ0FBS0gsRUFBdkIsRUFBMkJlLFFBQTNCLEVBQXFDSyxJQUFBVCxHQUFBQSxDQUFBQSxDQUFyQyxFQUF3Q1MsSUFBQVQsR0FBQUEsQ0FBQUEsQ0FBeEMsRUFBMkNTLElBQUFULEdBQUFBLENBQUFBLENBQXpCUjtRQUN6QmtCLFdBQU9DLElBQUFDLHdCQUFBRCxhQUFrQm5CLEtBQUFBLENBQUtILEVBQXZCLEVBQTJCZ0IsUUFBM0IsRUFBcUNJLElBQUFULEdBQUFBLENBQUFBLENBQXJDLEVBQXdDUyxJQUFBVCxHQUFBQSxDQUFBQSxDQUF4QyxFQUEyQ1MsSUFBQVQsR0FBQUEsQ0FBQUEsQ0FBekJSO1FBQ3pCSCxPQUFBd0IsQ0FBQUEsWUFBUUMsSUFBQUMsdUJBQUFELFlBQWdCdEIsS0FBQUEsQ0FBS0gsRUFBckIsRUFBeUJBLEVBQXpCLEVBQTZCb0IsSUFBQVQsR0FBQUEsQ0FBQUEsQ0FBN0IsRUFBZ0NTLElBQUFULEdBQUFBLENBQUFBLENBQWhDLEVBQW1DUyxJQUFBVCxHQUFBQSxDQUFBQSxDQUFuQlIsQ0FBeEJxQjtNQVRGeEIsQ0FBQUEscUNBQUFBOztBQVlBVyxNQUFBQSxxQkFBQUEsaUJBQUFBLGFBQUFBO0FBQUFBLFFBQUFBOzs7UUFDRWdCLElBQUlDLElBQUFDLDZCQUFBRCxrQkFBNEJ6QixLQUFBQSxDQUFLSyxTQUFLc0IsS0FBQUEsQ0FBQUEsQ0FBVjNCLENBQWU0QixlQUFBQSxDQUFBQTtRQUUvQ3BCLE9BQUEsRUFBQSxHQUFDQSxHQUFELEdBQUEsQ0FBSWdCLENBQUo7TUFIRmhCLENBQUFBLDRCQUFBQTtNQU1BSixPQUFBeUIsQ0FBQUEsd0JBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsUUFBQUE7OztRQUNFQyxPQUFPLENBQUNoQixRQUFELEVBQU9JLFFBQVAsQ0FBWVAsU0FBQUEsQ0FBQUEsQ0FBUW9CLFFBQUFBLENBQVEsQ0FBQ1YsU0FBRCxDQUFSVTtRQUMzQmQsSUFBQWUsUUFBQUEsQ0FBT0YsSUFBSUcsaUJBQUFBLENBQWNDLHFCQUFkRCxDQUFYRDtRQUNBZixJQUFBZSxRQUFBQSxDQUFtQkcsT0FBWkwsSUFBSU0sUUFBQUEsQ0FBQUEsQ0FBUUQsRUFBR0UsQ0FBSEYsQ0FBbkJIO1FBRUFILE9BQUFTLElBQUFDLHdCQUFBRCxhQUFrQnRDLEtBQUFBLENBQUs4QixJQUFMOUIsQ0FBVTZCLE1BQUFBLENBQUFBO01BTDlCQSxDQUFBQSwrQkFBQUEsQ0FBQUE7SUFuQkZ6QixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtJQTJCQVYsT0FBQThDLHlCQUFTeEMsS0FBQUEsQ0FBQUE7RUEzQ1hOLEdBQUFBLFdBQUFBO0FBaEJBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg0ODIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIoZXhpdCkiXSwic291cmNlc0NvbnRlbnQiOlsiS2VybmVsLmV4aXRcbiJdLCJuYW1lcyI6WyI8bWFpbj4iLCJLZXJuZWwiLCJleGl0Il0sIm1hcHBpbmdzIjoiQUFBQUEsMkJBQUFBO0VBQUFBOztFQUFBQTtFQUFBQSxPQUFBQyxzQkFBTUMsTUFBQUEsQ0FBQUE7QUFBTkY7In19XX0=
