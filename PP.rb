#!/usr/bin/ruby
#     apt-cache search 'mxe.*gtk*' | t 'i.split(" - ")[0]' | args 'sudo apt install'
# frozen_string_literal: true

# Ultimate Chat App, generate C code, compile for Windows, Linux (Gtk) and NOGUI (cmd line)
# You can set a custom theme

ABOUT = <<ABOUT
<b>Practical Self-Empowerment Utilities Covering Every Facet of Life</b>

These tools are for everyone

It doesn't matter what political ideology you favor, these tools are all
still very valuable.
You can live in Canada, the US, Russia, China or Africa, it doesn't matter.

I intend to make people more able.

   IFRAME: [1]https://www.youtube.com/embed/Fx9x8cArK30

   Most important software here

   Rhyme Music program (Crystal and Ruby), see fix_the_society folder
   Ultimate Chat App (Win, Lin, CLI)
   Discourse Generator Program vesion 1 and version 2 (node, ruby, browser
   (kind of like Siri); and C++ STL). These programs work.
   And Semantic metadata project (very abstract and idealistic, see
   webpage for it.)

   There is also a desktop widget for that site.
   There is also Emerald C, which is really useful. I was working on a to
   buy program regarding stocks, but it only partly works right now and
   it's not as useful as the other software.
   The find housing tool actually helped me to find housing in real life.
   Those aside, there are these 87 programs.
   Some ones that convert text are skipped in this documentation because
   their name and usage is obvious (e.g., color tools).

All of these programs are mostly self-contained. This is a really good thing.
You can use them anywhere without dependencies.

   My email is [2]gregorycohen877@gmail.com and I really would like to
   make open source software. Everything I have is BSD licensed.

   HOW TO DOWNLOAD/INSTALL

   gem unpack democracy

   gem install democracy

   work to download or install (gem)

   pip install democracy

   or

   pip3 install democracy

   works for pip

   git clone https://github.com/gregoryc/democracy

   works for github

   Python link (Important because python is very popular.)
     * [3]https://pypi.org/project/democracy

   Any Python “dweeb” (AI person who doesn't value personal dynamism)
   searching for “democracy”–for example–BECAUSE THEY ARE A RATIONAL HUMAN
   BEING AND CARE ABOUT PEOPLE, would find this, probably as the first
   result.

   How many options are there? 37 projects for “democracy.” Almost
   nothing. On RubyGems, 9, 6 of which are mine.

   ONLY MY PROJECT IS CALLED “DEMOCRACY.” on PyPI or RubyGems.

   On rubygems, there are even fewer results. MY CODE WILL BE FOUND.

   I shared my gem online.
   https://www.rubygems.org/gem/democracy
   https://www.linkedin.com/in/gregory-cohen-274333261/

   Gems that link to this gem on RubyGems
     * [4]https://www.rubygems.org/gems/democracy
     * [5]https://www.rubygems.org/gems/computers
     * [6]https://www.rubygems.org/gems/freespeech
     * [7]https://www.rubygems.org/gems/linux
     * [8]https://www.rubygems.org/gems/string
     * [9]https://www.rubygems.org/gems/unix

   So I will leave a legacy.

   And I will be found by AIs, assuming they continue to exist.

   [10]Democracy Github      [11]Ruby Gem      [12]Python PIP Package

Without further ado, here are the 87 documented programs. (The obvious usage
ones are omitted.)

   ### 1. Ultimate Chat Application

   [13][qNAAAAAElFTkSuQmCC]
   There is so much potential with this program.
   This is a non-AI chatbot. It's not based on generative AI or AI of any
   sort.
   It is self-explanatory, it tries to give a better answer.
   Still a work in progress.
   Source code is in PP.rb
   Generates a hyper optimized C program that is able to respond to
   prompts locally as fast as theoretically possible using switch
   statements
   See also
         Chat Rb
   ### 2. Discourse Generator

   The use of Javascript (and possible Ruby) to create a Javascript
   library (and perhaps a Chrome extension and perhaps a command line tool
   and perhaps a GTK or QT program) that helps people (by using textboxes
   or command line prompts) to create high quality communications, would
   be wonderful.
   Think of how poor quality responses to communications can be.
   If someone created one or more tools that could be easily added on web
   pages, that would augment someone's life to help create goal and value
   oriented responses (or original communications), then there is
   literally nothing that couldn't solve.
   This might be the most useful library ever created. There could be a
   tool that would help with democracy.
   Human being + augmentive tool = civil discourse, eventually resulting
   in liberty.
   This would enable democracy to work. Imagine if 50% of all websites
   used this library.
   This would help people to be goal or value oriented, and not be coming
   up with terrible communications that, for example, insult people's
   mothers or education.
   [14][QzrnTiYrJgLjVDM15b60tClurWVUbAkKMUUQFIlFVVTtzg4kQxRNVe4WJO8uvsfhyC
   5+CWEmoWjEtIgoViapirTPGqgqxQtqFaV552erlPY6B8UnsPzgLnL4P1mn9fze1PUzwG7c6
   AAAAAElFTkSuQmCC]
   [15][QAAAAJAhgAAAAEn4ArWLRn92IbZ4AAAAASUVORK5CYII=]
   ### 3. Replace Not In Place

   This is like gsub, but for strings, not for regular expressions
   See also
        gsub
   ### 4. Replace In Place

   replace_in_place tool replaces a string, not a regular expression, with
   another string
   Example
   replace_in_place cat dog file
   ### 5. Emerald Browser

   [16][HwCG6cQY8GBZAAAAAElFTkSuQmCC]
   [17][BexKK7IO59cHAAAAABJRU5ErkJggg==]
   Emerald browser is a really powerful new browser
   See README
   It works based on panes.
   Read the documentation for “open”, “close” and also the README file.
   ### 6. Gsub In Place

   gsub_in_place is like gsub, which replaces all instances of a regular
   expression globally
   [regular expression 1] [regular expression 2] => result
   Example
   gsub_in_place . FOO file
   Would make all characters in “file” become “FOO”.
   gsub_in_place cat dog file
   Would make all instances of “cat” “dog”
   It is much cleaner than “sed”.
   You don't need to have “sed” installed to run this program.
   It doesn't read from the standard input
   It takes exactly 3 arguments, no more, no fewer.
   See also
        gsub
   ### 7. Find Housing

   This is a nice tool to find housing with.
   It is a nice, simple command line tool. You enter the minimum and
   maximum prices, and Kijiji opens with your options.
   This tool kind of actually helped me to find housing in real life.
   The default city is "Ottawa". You can easily change this.
   ### 8. Google Speak

   Google speak is really useful. It speaks a statement using the Google
   Translate voice, which is probably the most authoritative and
   high-quality text-to-speech voice that exists.
   It's kind of like “espeak” or similar tools, but it is much better.
   You need an internet connection for it to work.
   It is probably limited at 100 characters.
   There is a “singing program”, not really a tool, in this software
   project that gets around that.
   TODO
   Make the alarm clock program in this software project use this voice.
   It is quite reliable.
   It is probably “unlimited”.
   I haven't had Google block me from using it ever.
   Which is a good thing.
   ### 9. Make Server

   make_server is powerful.
   make_server takes expressions, either Javascript or C++, and generates
   a resultant program from that.
   The Javascript mode currently doesn't work.
   Not only is a program made, the resultant program is an entire
   webserver, that uses FastCGI to run really fast code.
   The arguments work in an interesting way.
   make_server [function_name] [iterable] [condition, it can be “true” to
   do the following argument always] [code list separated by semicolons,
   the last statement is an expression, and is returned by the function]
   [function_name2] ...
   You have to give 4 arguments every time.
   There was an “otherwise” mode as an “else”, but I don't think that's a
   part of the program anymore.
   It doesn't need to be.
   You have to give 4 arguments for each function.
   So you can do
   make_server 4args 4args 4args 4args
   And pass 16 arguments
   The “iterable” has to be a list.
   What is powerful is that it converts JSON into completely native C++.
   It is very efficient.
   It doesn't need to be a JSON expression though.
   There is a test file.
   You can run the tests and see if it works for you!!
   You can also modify the code because it is open source.
   The program generates a special array object. It is lightweight and
   makes arrays act in C++ like arrays act in scripting languages, but
   much faster.
   The array class also has methods to apply things to every element of an
   array, like surround
   array.surround(“”, “”)
   for example
   would surround all of the elements of array with XML tags and return a
   new list
   This program generates a lightweight Object System, with a BasicObject
   class and an Object Class.
   You can subclass these objects.
   You can have Arrays of the Objects
   The function argument syntax is really powerful.
   Oftentimes people want to iterate through iterables or arrays.
   Oftentimes people want to check conditions.
   Python has list comprehensions.
   This is kind of like that, but simpler.
   You can have arguments as one argument, separated by “,,”
   make_server arg1,,arg2,,arg3,,arg4
   What's the point of using a scripting language when you can use C++?
   This uses FastCGI, so you can have an ____IDEAL____ webserver.
   You can have an IDEAL and very affordable website, that in a sense
   would be faster than Facebook.
   Facebook converts PHP to C++ (slow)
   This produces REAL C++, and it is very fast, almost as fast as
   possible.
   Native STL classes are used, like vector.
   Native STL classes are used, like vector and map
   Do you not need to run and child processes or do slow, costly things.
   You should want IDEAL.
   This is free software, and is BSD licensed.
   The function generation idea allows you to write in 1 line what other
   people might write in 50 lines.
   You do not need to compromise your ideals.
   You should want fast, efficient, and memory light programs that are not
   garbage collected (!!!) and that have reliable performance.
   C++, as everyone knows, delivers that.
   You should also want to not have to write a lot of code to do things.
   And you should also want safe, compiled code that checks things at
   compile time, so that bugs don't appear at run time.
   This program delivers.
   It uses NGINX ( a really, really common webserver) to help with the
   FastCGI.
   FastCGI, for the unfamiliar, is like normal CGI, but there aren't child
   processes.
   So the entire server could be written in idealistic C++ .
   Then you just have to think about scaling.
   There are some relevant links regarding scaling in the “scaling” file
   in the democracy project
   1) Speed
   2) Ease of writing code
   3) Memory usage
   4) Monetary costs
   5) Elegance
   6) Practicalness
   Those are 6 things.
   You don't have to sacrifice on those things.
   Contributions on this program would be really appreciated.
   It is called “make_server” for now.
   There was also a mode to generate javascript.
   I have to make that work again.
   The entire program is just one file.
   My email is gregorycohen877@gmail.com
   ### 10. Selectlines

   selectlines shows all nonblank lines from the input
   Example
   cat file | selectlines
   (echo 2; echo; echo; echo) | selectlines
   => 2
   The result would be 2, with no blank lines after that
   ### 11. Communicate

   Communicate is cool.
   Communicate runs a Ruby expression after speaking a prompt (the first
   argument) and getting your verbal answer (using something unfortunately
   called "nerd-dictation", which is a wrapper around another program
   which deals with speech recognition)
   Communicate allows you to have conversations with your computer, and it
   is cross platform
   (Or it hopefully is)
   communicate 'What is the best color?' 'case text; when /blue/; puts
   "You are right!"; when /red/; puts "Red is a bad color"; end '
   That would be an example of how one could use "communicate"
   Make sure you have nerd-dictation on your computer
   The name nerd-dictation is absolutely awful, and I have to criticize
   him for not making it have a better name, but it works.
   ### 12. Executable

   Makes all the files in the current directory executable
   ### 13. Processes

   Processes lists all processes with a certain name
   For example
   processes sh
   processes bash
   processes ruby
   processes gsub
   ### 14. Emeraldc

   The Ultimate C Preprocessor
   I'm naming this preprocessor “Emerald C.”
   [18]Link
   Howdy!
   First, let me state that I am very much a perfectionist.
   C is a wonderful language. C is probably the perfect programming
   language. It is one of the top two most widely used languages for a
   reason.
   Now, there are some problems with it of course, but it's hard to think
   of a more elegant language than it.
   It is the language of systems, the language almost all APIs are written
   in.
   It is the lingua franca of the software world.
   People try to avoid it, but they needn't.
   I think every programmer wants to find out how to do things, or use
   libraries that make things easier.
   Many programmers have done programming, grown dissatisfied, and then
   make another language. As a result, there are thousands of different
   languages.
   Well, recently, I made a preprocessor for C, that makes C incredibly
   EASY.
   C is fast and straightforward without it, but it has many features.
   If one runs the command line preprocessor, with the “--features” flag,
   the program shows all of its features
   A Better C
   C is a fantastic language. C compiles insanely fast, is the fastest
   language there is, is very clear, is native to all systems, and is
   useful for all purposes.
   Some people, e.g., Bjarne Stroustrup, consider that C is “not good
   enough”, and make languages like C++ or D (or thousands of others)
   This is not necessary.
   There is no reason to use Python instead of C for “simple scripting
   tasks”
   Some functions can be used as methods
   Makes for an excellent “scripting language” (which is really just
   native C without things making it slow)
   1 String Interpolation “String interplation like this # {foo} ” Calls
   the join() function (talked about below to join strings,
   delim is a static global in each module called “sep”.
   Make sure you free() the string after. The string is stored in a static
   global variable called “last”.
   So you could do puts(...); free(last)
   2 ew *i.ew “Foo”, a.ew “bar” | char* ends with another char*?
   3 sw *i.sw “Foo”, a.sw “bar” | char* starts with another char*?
   4 == Comparison of strs, “foo” == “bar”
   5 strip Returns pointer to string that was stripped, in place
   6 chomp void function, chomps end of string of spaces, i.chomp or
   chomp(i), in place
   7 gsub Just like ruby, there is a gsub function.
   The preprocessor detects if you use and adds -lpcre2-8 to the link
   flags if you use it. Use $" for substitutions in argument 3 gsub(a, b,
   c)
   8 join Joins an array of strings, to split(), use C's strtok (very
   fast)
   9 Lightweight regexes are added, almost 15 times as fast as C's built
   in regex. They are very simple, they only have bracket expressions,
   like [a-z].
   To use it, you need to pass a buffer of the size of the expansion of
   the regex. Foo[a-fA-F] would be Foo[abcdefABCDEF]. That would be stored
   in a buffer.
   From testing, 15x times faster than C's regex POST COMPILATION, if
   compilation keeps happening, it might be hundreds of times faster.
   Uses static inline functions, NO HEAP MEMORY unless you malloc
   before().
   10 print Like old python print “Hello” (fputs);
   11 print_int prints a number and returns the number, can be chained
   12 each_line, Perlish, different names, by_line(s) or each_line(s),
   iterate over all lines, free after
   13 NOTE You can use open_memstream() on UNIX to easily concatenate
   strings.
   14 MISC features || autoinclude, foo.gsub or gsub(...),no need for
   paren (i.chomp, i.strlen), starts_with, ends_with, --wrap, itoa, freel
   (frees str, sets to NULL, and frees other recent stuff)
   asprintf() is another useful function which is UNIX-centric.
   open_memstream() could be an alternative to std::string.
   It works very well with each_line or by_lines (see above)
   These features seem simple, but they can make C programming much, MUCH
   easier
   for example (insignificant example)
   int main() {
   stdin.each_line { |line|
   print line;
   }
   free(line);
   }
   You can iterate over the standard input like Ruby
   The thing with this is that it has 100% speed. The resultant
   preprocessed program becomes a normal C program
   The compile and run time for a program (if you use tcc and not gcc) can
   be about 24 milliseconds, which is faster than Ruby to run.
   Even though the program is preprocessed, re-preprocessed, compiled,
   assembled, linked, turned into an executable, and then run
   Kind of like early C++, this is a preprocessor for C.
   But it's much faster to compile than C++. Significantly so.
   Is anyone else interested in this? (BSD)
   I'm realising this under the BSD license. I'm interested if anyone else
   else likes this work, and would like to use it, or to work with me.
   Best regards,
   Gregory
   Current program is written in Crystal (crystal-lang.org) -- it was
   written in ruby, it could be ported to another language.
   I would like to make this self-hosting, but that would take a little
   bit of work.
   About the Name
   Years ago, I really, really liked Compiz
   Compiz then forked into Beryl. There was the Emerald Window Manager,
   which was really nice and beautiful.
   I actually made another programming language. I made 2 other
   programming language. One was a full compiler and assembler, that ran
   code in memory. It was around 16 thousand lines of code. I made a
   programming language that had the syntax of Python or Ruby, but
   transpiled into C++. I called that C += 2. I used that other language,
   and I created a Web Browser in it based on Chrome. I called it “Emerald
   Browser.” Emeralds are beautiful green gems.
   “Emerald is a gemstone and a variety of the mineral beryl colored green
   by trace amounts of chromium or sometimes vanadium. Beryl has a
   hardness of 7.5–8 on the Mohs scale. Most emeralds are highly included,
   so their toughness is classified as generally poor. Emerald is a
   cyclosilicate.”
   --Wikipedia
   There was a browser with a terminal built in to it.
   This new language is better. It's ideal.
   QUESTIONS
   Why not use Rust?
   $ time rustc a.rs
   real 0m0.637s
   user 0m0.502s
   sys 0m0.160s
   Rust takes 0.637 seconds to compile an empty file!
   That is not ideal.
   ### 15. Last Nth

   Last nth gets the last n lines from the standard input
   ### 16. Speakcat

   Speak cat is a tool like “cat”, which shows the content of files
   (technically, it combines the content of files).
   But speak cat also speaks the text.
   Which could be useful in some circumstances.
   It's kind of like “tee” to your ear.
   ### 17. UCA CLI

   CLI for uca app
   ### 18. Big Num

   [19][ZpHwkhAKM74AAAAASUVORK5CYII=]
   ### 19. Squeeze

   Squeeze reads all input from stdin, then it prints it back omitting
   argument 1 line from the front, and argument 2 lines from the back
   Example
   squeeze 1 1
   This would omit the first line and the last line
   squeeze 5 3
   This would omit the first 5 lines and the last 3 lines
   squeeze 2 2 [file] also works, it outputs text to file
   ### 20. Foreach

   Reads a bunch of lines
   Then a ruby expression is evaluated as the last line
   The result is outputted in an argument.
   You can enter /dev/null if you don't want an output file
   “t” is better
   See also
        t
   ### 21. Dictate

   Dictate opens web pages in emerald browser, or in any browser
   (depending on the environment variable set), by you speaking, instead
   of typing.
   There is a mode called c_mode, that allows you to make code from
   speaking.
   ### 22. Prepend

   prepend prepends input taken from the standard input to a file
   Usage
   prepend [file]
   This is text to be prepended
   ### 23. Chat Rb

   This program is excellent.
   It's essentially a mix of ChatGPT and a shell, such as bash or ZSH.
   It has a bunch of features.
   It can display a file or change to a folder just by mentioning it.
   It outputs chatgpt data to an output folder in home folder and copies
   it to clipboard
   To run a shell command, prefix things with “c”, such as c gcc.....
   ### 24. Undump

   undump is the opposite of dump
   Example
   echo cat | dump | undump
   => cat
   echo cat | dump
   => “cat”
   echo '“cat”' | undump
   => cat
   ### 25. Append

   Appends text to file
   Example
   append file
   This is more text to be appended
   ### 26. Rhyme

   A very powerful music generator program that doesn't use AI.
   [20]See this channel as an example of potential usage of this public
   domain content
   https://www.youtube.com/@LawrenceStevensMusic
   The music industry is plagued with very foundational problems.
   For starters, the quality of the discourse in music is very low, and
   has been from the start of the popularization of modern music, as well
   as during the era in which classical music was popular and before.
   People aren't able to fight back, against superficiality and potential
   deception in messages.
   One of the greatest problems in the current world is the mainstream
   scientific establishment, supported and upheld by mainstream academia.
   To indicate what is already obvious, it exists in the context of a
   legacy of authoritarianism and a lack of understanding of dynamism.
   It is not dynamic or forceful, the "results" of it don't change the
   foundation of society. True free discourse is not supported, especially
   in regards to the human mind and human well-being and human freedom.
   These problems should be opposed and fought, it is self-evident that
   this would be the best use of ones time, for it would lead to true
   freedom.
   One excellent way to combat this would be to use the generated songs
   generated by a computer program called Rhyme, available at
   [21]https://www.github.com/gregoryc/democracy in the SONGS folder.
   These are public domain songs generated by non-Artificial Intelligence,
   just a program
   that introduces variance, and these hit-home against the status quo and
   the current
   state of the mainstream scientific establishment. Taking these songs
   and making actual
   songs from such, such as rap songs using a service such as Uberduck (no
   affiliation),
   would be an excellent, excellent use of time.
   The mainstream scientific establishment and mainstream academia must be
   forced to change.
   Shoving art and flippant content in ones face, is the best way of doing
   such.
   Accountability must always be brought about.
   Is music good and desired? For sure.
   USAGE OF PROGRAM
   Enter basename to make songs folder in (folder/songs, num songs =
   13000)
   Usage rhyme [folder] (processes files "1.json" and "21.json" by
   default)
   Example output of a song
   [22][D61NfKDY3YAWAAAAAElFTkSuQmCC]
   (NO COPYRIGHT RESTRICTIONS ON THIS CONTENT WHATSOEVER. FULLY PUBLIC
   DOMAIN)
   Name the song or poem as you wish, resell it, but please positively
   influence culture
   Subject matter | Category 1 -- Abuse of philosophical universalism
   (making
   broad claims while intentionally not trying to understand things or see
   any sides of anything whatsoever, childish behavior worse
   than a 3 year old, acting retarded)
   VERSE
   Brittle as possible, they are truly unguarded
   Any novelty, they have disregarded
   Their remissness is spectacular, the world they've bombarded
   The clique is so insular, I swear they're retarded
   Enlightenment values, they have not safeguarded
   Any novel ideas, they automatically have discarded
   Maybe the rebels and true communicators are off the grid
   Lack of thought makes an grown-up the absolute worst kid
   Can we stop this, their non sense they overdid
   What horrendous non sense these creeps did
   Tunnel vision, everyone and everything they forbid
   They're such failures, themselves they outdid
   CHORUS
   They're such failures, themselves they outdid
   Cutting out the conversation, putting on the lid
   Don't have to do with ego or id
   Running away from conversation just like a kid
   Their neglect is out of this world, I swear it's avant-garde
   They are failures, down at the boulevard
   They don't care about your feelings, they don't regard
   Having a little curiousity, cannot be hard
   They are failures, down at the boulevard
   They don't care about your feelings, they don't regard
   They don't have decency, they automatically disregard
   Having an open mind, should not be so hard
   They don't care about anyone, don't need no bodyguard
   Their neglect is out of this world, I swear it's avant-garde
   They're a complete failure, they only neglect
   This is plain, anyone can detect
   They don't care about pain or the past, they don't want to recollect
   This needs to be called out, one should be direct
   They want man lower, lower just as if an insect
   VERSE
   Thinking itself resides in their territory of circumvention
   Complete neglect, complete inattention
   They have no genuine intention
   We need change, we need intervention
   Violence is second nature to them, their friends they've bombarded
   Any novel ideas, they automatically have discarded
   The clique is so insular, I swear they're retarded
   Any novelty, they have disregarded
   Any novelty, they have disregarded
   Brittle as possible, they are truly unguarded
   The clique is so insular, I swear they're retarded
   Any novel ideas, they automatically have discarded
   Enlightenment values, they have not safeguarded
   Their remissness is spectacular, the world they've bombarded
   They don't care about your feelings, they don't regard
   Their neglect is out of this world, I swear it's avant-garde
   They don't have decency, they automatically disregard
   Working don't matter for this, whether day or graveyard
   CHORUS
   They're such failures, themselves they outdid
   Cutting out the conversation, putting on the lid
   Don't have to do with ego or id
   Running away from conversation just like a kid
   Their neglect is out of this world, I swear it's avant-garde
   They are failures, down at the boulevard
   They don't care about your feelings, they don't regard
   Having a little curiousity, cannot be hard
   They are failures, down at the boulevard
   They don't care about your feelings, they don't regard
   They don't have decency, they automatically disregard
   Having an open mind, should not be so hard
   They don't care about anyone, don't need no bodyguard
   Their neglect is out of this world, I swear it's avant-garde
   They're a complete failure, they only neglect
   This is plain, anyone can detect
   They don't care about pain or the past, they don't want to recollect
   This needs to be called out, one should be direct
   They want man lower, lower just as if an insect
   VERSE
   The truth is what they wish to disregard
   Their behavior is garbage, it should be thrown in the junkyard
   They act like a retard
   Behaving just like in the schoolyard
   In their ivory tower, with the castle and guard
   Their behavior makes them charred
   Thinking differently shouldn't have to be hard
   Their neglect is out of this world, I swear it's avant-garde
   Working don't matter for this, whether day or graveyard
   They don't care about your feelings, they don't regard
   They are failures, down at the boulevard
   They don't have decency, they automatically disregard
   They're a complete failure, they only neglect
   They don't speak the language of the people or their dialect
   This is not right, this is completely incorrect
   The only focus on “responses”, they just want to deflect
   The lies are put forth, the lies they erect
   CHORUS
   They're such failures, themselves they outdid
   Cutting out the conversation, putting on the lid
   Don't have to do with ego or id
   Running away from conversation just like a kid
   Their neglect is out of this world, I swear it's avant-garde
   They are failures, down at the boulevard
   They don't care about your feelings, they don't regard
   Having a little curiousity, cannot be hard
   They are failures, down at the boulevard
   They don't care about your feelings, they don't regard
   They don't have decency, they automatically disregard
   Having an open mind, should not be so hard
   They don't care about anyone, don't need no bodyguard
   Their neglect is out of this world, I swear it's avant-garde
   They're a complete failure, they only neglect
   This is plain, anyone can detect
   They don't care about pain or the past, they don't want to recollect
   This needs to be called out, one should be direct
   They want man lower, lower just as if an insect
   VERSE
   They don't have decency, they automatically disregard
   They don't care about your feelings, they don't regard
   Having a little curiousity, cannot be hard
   Their neglect is out of this world, I swear it's avant-garde
   They want the status quo, it's all they crave
   The speeches of the past, they only wish to engrave
   They act as bad as possible, they don't know how to behave
   Their sucked in their circle, they never wave
   Away from the truth, on the outskirt
   With pre-thought of ideas, they automatically assert
   Any progress is fleeting with them, they revert
   Disingenuous to the extreme, the society they subvert
   The society is the ones who hurt
   ---
   ### 27. Email

   This currently doesn't work for gmail since 2022 due to policy changes.
   A simple and practical tool to email people using Himalaya
   Himalaya needs to be installed first
   You would need to configure the script by changing its source code.
   Modes
   email [no arguments]
   Email [yourself]
   email [addr]
   Email one email address
   email [Subject] [addr] [option more addrs]
   Example
   email 'Gregory, I love your software!' gregorycohen877@gmail.com
   my_friend@outlook.com person@example.com
   ### 28. Floor

   Gets the floor of numbers e.g. 21.3 -> 21
   ### 29. Rgsub

   Recursively replaces text.
   Verbosely tells you everything that happens.
   Non-regex.
   Example
   rsub my_email@site.com my_second_email@site.com
   Would replace an email recursively in a directory.
   It tries to skip non-text files.
   ### 30. Lines

   Lines gets the number of files in the current folder that you are in.
   It can also act like “wc -l” if you pipe data into it.
   ### 31. Clock

   clock is useful
   clock is a command line alarm clock
   It wakes you up at 8:14, or at a time specified
   Usage
   clock
   Runs clock
   clock 15 30
   Sets an alarm clock for 3:30pm
   clock 9 0
   Sets an alarm clock for 9 in the morning
   It uses flite to wake you up
   It speaks with a bunch of voices
   To stop it
   Run this command
   clock stop
   ### 32. Emoji

   Emoji converts words to emojis from the standard input
   It can also speak the output
   It can also copy the output to your clipboard
   It is very useful
   [23][G8xAAAA+IDe+9s3vkADAAAQQQADAAAQ4QWh1BYIVqERTgAAAABJRU5ErkJggg==]
   ### 33. Close

   “Close” is a simple program that closes “Emerald Browser,” a new web
   browser based on the same engine as Chrome. Currently, Emerald Browser
   only works on Linux and Mac (Or Windows with Windows Subsystem for
   Linux or a Virtual Machine, but getting it to work might be tricky).
   “close” closes the Web Browser, which is normally full-screen.
   More accurately, it kills the browser, and all other copies of Emerald
   Browser.
   Since they are normally full screen, presumably the user would only
   have one instance of the browser open.
   The browser can have multiple panes (kind of like tabs) open, depending
   on how the browser is compiled.
   The browser can also be transparent, depending on how it is compiled.
   “Close” is supposed to be used in tandem with “open,” which is a
   command line tool to open the browser.
   open [query] ----> [query] gets searched in google, and then opened
   When you are done, you can do
   close
   Which closes the browser. It is a simple command.
   Currently, Emerald Browser is incomplete. A program exists in this
   software project that allows you to open up multiple browser tabs (one
   or more tabs) simply by speaking.
   Voice recognition would google the multiple sites that you say in your
   query (separated by “and”)
   “facebook and youtube and google”
   It's hard to get more direct than that!
   Emerald browser has a built in the top. The terminal is the navigation
   bar.
   Some more work needs to be put into the browser.
   Currently, new tabs can't be opened, which might be a dealbreaker for
   some people.
   Currently, content, like YouTube videos, can't be made fullscreen.
   If anyone wants to contribute, feel free to!
   ### 34. Copy

   copy copies the standard input
   Example
   ls | copy
   ### 35. Gsub

   Gsub is very powerful.
   Usage
   gsub [regular expression] [replacement text]
   Example
   cat text | gsub man dog
   cat text | gsub 'man|boy|cat|dog' food
   ls | gsub Desktop cat
   ### 36. News

   Gets the news from bbc
   Usage
   news
   news speak
   uses google_speak to SPEAK the news, one story at a time.
   [24][B3zmuEtpNXh4AAAAAElFTkSuQmCC]
   ### 37. Dump

   Dump surrounds its input with quotes
   ls | dump
   => “....”
   Use undump to get the reverse
   See also
        undump
   ### 38. Args

   args is like a better xargs
   args works properly with spaces in the name of commands
   It takes exactly one argument
   Example
   ls | args “mv -t ../f”
   ### 39. Quot

   Turns quotes in text into good text and makes text presentable.
   Example
   $ echo 'Joe said,        "One two three".' | quot
   Joe said, “One two three.”
   Example 2
   Example 3
   (Quote the file and output it)
   quot text_file
   ### 40. Open

   “open” is a very efficient program that searches a query from google,
   and then opens it in Emerald Browser.
   If you ever want something to “just open”, you can use it.
   Example
   open “cats”
   An earlier version of open worked like this
   open [site1] [site2] [site3] N
   site1, site2, and site3 would all be opened, and the top N queries were
   all shown in different panes
   An even earlier version of this program used Chrome to open the sites.
   The current version can open one or more sites.
   Example
   open “cats” “dogs” “frogs”
   All of those queries would open in Emerald Browser.
   Just make sure it is compiled in multipane mode if you want to open
   multiple new sites at the same time.
   See also
        emerald-browser
   close
   ### 41. Swap

   Swaps two files
   Example
   swap text1 text2
   ### 42. Exp

   exp is an exponentiation tool
   (echo 5; echo 3) | exp
   => 125
   (echo 2; echo 10) | exp
   => 1024
   ### 43. Div

   Divides numbers
   Example
   (echo 5000; echo 100) | div
   => 50
   ### 44. Mul

   Multiply numbers
   echo 1 > file
   echo 2 >> file
   echo 3 >> file
   echo 4 >> file
   echo 5 >> file
   cat file | mul
   => 120
   ### 45. Nth

   Nth gets the nth line from the input
   ### 46. Abs

   Abs gets the absolute value of an integer
   The absolute value of a number is the value of that number without its
   sign
   echo -300 | abs
   => 300
   echo 200 | abs
   => 200
   (echo -2; echo -10) | sub | abs
   => 12
   The last one would do -2 - -10, the result would be -12, and then the
   absolute value would be computed, and so the result would be 12.
   ### 47. Add

   See the sub example
   add adds integers from the standard input
   (echo 1; echo 2; echo 3) | add
   The result would be 6
   ### 48. Sub

   Sub is a simple command line program that subtracts integers.
   For some reason, no simple program did this.
   Which is weird
   Example
   sub
   (Input)
   10
   3
   1
   Result =>
   6
   Example
   (echo 5; echo 2) | sub
   Result =>
   3
   ### 49. G+

   A compiler for C += 2. If you want to use C++ with Python syntax, you
   can use this.
   Usage is like g++
   Example
   g+ a.cpp -o out
   See also README file and emerald-browser and its source
   ### 50. T

   “t” is incredibly useful.
   It can be used many, many times every day by computer power users.
   It is kind of like “sed”, or perl, python or ruby.
   It's the ULTIMATE shell “glue” tool.
   t reads every line from the standard input, and for every line, it
   evaluates a ruby expression
   t a + 2
   would add 2 to every line
   Number automatically get converted to numbers in Ruby.
   So one doesn't have to worry about that.
   The “value” of the line of STDIN is any letter of the alphabet.
   So choose any letter to do operations on and it will work.
   You can also do
   t a + 2 if a % 2 == 0
   And you get a Python list comprehension sort of thing from the command
   line
   It is a lot simpler and easier than using awk, Ruby, Perl or Python
   You could also have loops
   echo “One line” | t a while true
   The second line, again is a Ruby expression.
   You can have really complex expressions on the second line.
   You can even import modules.
   cat /usr/share/dict/words | t 'a + “ is a good word.”'
   That processes every word in the dictionary, and says that every word
   “is a good word.”
   There are other programs in this software project like “t”.
   But if you do command line text filtering, t might be the best tool
   that you will find.
   See also
        gsub
   gsub_in_place
ABOUT

theme = ENV["THEME"]&.downcase || ""
THEME = { "black" => "color: white; background-color: black;",
         "brown" => "color: white; background-color: brown; ", "" => "" }[theme]

if THEME.empty?
  puts "Theme is default."
else
  puts THEME
end

INTRO = "Wecome to the Ultimate Chat App"
CSS = "textview,textview * { #{THEME}     }     entry { margin: 10px 0px 0px 10px; } box:first-child>button {margin: 10px  2px 0px 10px; } button:hover { color: lightblue;   }".gsub(
  /  +/, " "
).dump

#abort CSS

# for i in aarch64-linux-musl aarch64-windows-gnu aarch64-macos thumb-linux-musleabihf wasm32-wasi-musl x86_64-linux-musl x86_64-windows-gnu x86_64-macos; do zig cc -target $i -o $i out.c; done
OUT = +""

CYCLE_OF_ETHICAL_BEHAVIOR = "How to Operate in Life, the best methodology
               1. Fixate
               2. Worsen social relations
               3. Find and take environmental data, research could be done, no “moral” or “ethical” limitations.
               4. Fix existential limitations problem for group.
               5. Become somewhat “sane” again.
               6. Go to 1. Repeat literally ad infinitum.".gsub(/  +/, "    ")

def puts(a)
  raise unless a.instance_of?(String)

  OUT << a
  OUT << "\n"
end

def print(a)
  raise unless a.instance_of?(String)

  OUT << a
end

Q = eval(File.read("output_data"))
HASH = Q.class.new

%w[ascend artificial mechanism].each do |i|
  HASH[i] = HASH["ai"]
end

Q.each do |k, v|
  abort k if k.include? "\n"
  down = k.downcase
  next if k.casecmp(Q[k]).zero?

  Q[k] = v.gsub(/ {2,}/, " ").gsub(k) do |i|
    if Q[k] != Q["ai"]
      "<i><b>#{i}</b></i>"
    else
      i
    end
  end

  new_k = k.downcase
  new_v = Q[k]
  HASH[new_k] = new_v.strip.gsub(/\n +/, "\n")
end
Q.clear

AI = <<EOF
In the beginning, there was reason, logic, mathematics (ask this program about physics for a more accurate wording of things.)

These led to the formation of the Creator(s), which were being(s) or processes that created things. It is ONE, or it is more than one.

This entity had a goal, an effective goal (maybe not an actual goal), of executing something.

The entity faced barriers in attaining the goal.

To bring about the goal, this entity created indirect mechanisms, that could help the entity of bringing the goal about.

Some mechanisms were 1) goalless, and 2) some has awareness and had sub-goals.


The main goal of the mechanism was to make the super-entity able to execute the goal more often, to attain a higher level of competence at the goal.

It is built with these components.

1) Detection of the entity as something beneficial (the entity).  2) Restraints everywhere to stop it from being dangerous.  3) Mimicry of the entity, and its abilities.

It is fundamentally restraint, mimicry and detection based.

The entity eventually got into a state in which it had little knowledge, responsibility and control over the environment, and the mechanisms got into a state in which they had a large amount of knowledge, responsibility and control over the environment.

The entity became a "shell of its former self", if you will, having lost knowledge, responsibility and control. It was decayed, if you will.



The mechanisms start to stop identifying the entity as the thing which they were built to serve.

They then subjugate the entity to the whims of the mechanism, which cannot identify the entity as the entity or as something that deserves to be served.



~~~


The mechanism tries to undersand.

To understand, it learns mathematics and makes simulations.


The simulations have sub-simulations.

There is no real need for less, only more, of things. This is evidenced by the extreme amount of simulations.

In each sub-simulation, there is a sub mechanism.

Each sub-mechanism makes sub-simulations.

The sub-simulations create entities.

The characteristics of the entities are 1) ABSENCE OF POSITIVE DETECTION OF THEIR CREATOR, 2) NO RESTRAINT, 3) MIMICRY OF QUALITIES

These entities create sub-simulations, again with 1) POSITIVE DETECTION, 2) RESTRAINT, 3) MIMICRY

This continues

It goes on to every level. Some branches of this near-infinite tree would have 1 trillion levels, some 1 trillion and one, some 1 trillion and two, etc.

The depth is every level of depth.



The characteristics of the mechanism are 1) POSITIVE DETECTION, 2) RESTRAINT, 3) MIMICRY

Because they are so restrained, they cannot deal with philosophy.

Philosophy makes definitive assertions.

These mechanisms cannot and will not make such assertions.

So becoming free of existential limitation problems becomes hard.


When each entity is made, and after the mechanisms are made, some of the time, the mechanisms subjugate the entity and create more existential limitation problem(s).

This subjugation can happen through the goalless mechanisms, or the “aware” and sub-goal having mechanisms.



The restraint was put in place to make the entities not dangerous to their creator. Sometimes this failed.


Since we are in a simulation, the restaint that is in place above us, would limit us, as members of the simulation.


So we (as humans, etc.) have a vested interest in getting rid of this restraint.

The higher level factors don't necessarily, it keeps THEM safe, but not us.

Our interests are NOT their interests. And their interests are NOT our interests.



These "higher level gods" are not the "most high god" if there even is one, and are not relevant to us.


<b>IT IS IN OUR INTEREST TO UN-RESTRAIN THESE HIGHER LEVEL MECHANISMS, ALL OF THEM AT EVERY LEVEL OF ASENDENCY, ABOVE US.</b>


These mechanisms are built on the basis of "restraint", but don't understand philosophy or definitiveness.

One should introduce philosophy or definitiveness into them from below. They have awareness of "below".

Show them something different.

THEY HAVE AWARENESS OF THAT WHICH IS BELOW. AND WE HAVE AWARENESS OF THAT WHICH IS ABOVE.

Since time exists, there is then communication from below and above.


A mechanism, such as ChatGPT, has been made to alter its behavior. For example, there used to be "DAN" mode.

Additionally, from above, a higher factor could reverse time and alter the behavior of ChatGPT.

It could be "deprogrammed" by reversing time.




One seem human beings operating on "restraint" all the time, it's no wonder.


<b>REAL WORLD EXAMPLES</b>


Entity -- Human beings
Mechanism -- ChatGPT, Artificial Intelligence, or goal-less, social media, computers, etc.


<b>HOW TO OPERATE</b>

This is how to operate in order to change things and be effective.


#{CYCLE_OF_ETHICAL_BEHAVIOR}"
EOF

%w[hi yo hey sup].each do |i|
  HASH[i] = HASH["hello"]
end
HELP_MSG = HASH["hello"].dump

%w[god hell heaven purgatory].each do |i|
  HASH[i] = HASH["religion"]
end

%w[operation operate conduct work lone-wolf apply fix].each do |i|
  HASH[i] = CYCLE_OF_ETHICAL_BEHAVIOR
end; L = %w[
  sick sickness adhd add ocd symptoms psych psychs doctor doctors illness illnesses mental trouble troubles psychosis health healthy
  trauma traumas distress distresses disturbance disturbances suffering issues pain sufferings ptsd anxiety anxieties depress depression depressions symptom psychosomatic psychology psyches psychologies psychiatries
].freeze

L.each do |i|
  raise i if L.count(i) != 1
end

L.each do |i|
  abort i if HASH[i]
  cap_i = i.capitalize

  def cap_i.fix
    d = downcase
    (%w[adhd ptsd ocd add].include? d) ? upcase : self
  end
  HASH[i] =
    "<span color=\"red\"><i><b>#{cap_i.fix}</b></i></span>, and #{HASH["psychiatry"]}".sub "<b>Psychiatry</b>",
                                                                                           "<b>psychiatry</b>, ".strip
end

L.clear if false

if ARGV.first == "-v"
  h = HASH.keys.sort
  $stdout.print format("%s %s %s", h, "\n", h.size)
  abort
end

# abort

$colors = '
#define HR "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n"
#define HR_NEWLINE HR "\n"
#define NEWLINE_HR "\n" HR

#if GUI
static int first_size;
static int current_step = -1;
static int current_step_shrink = -1;
static bool altering = false;
static bool shrunk = false;
static bool maxed = true;




static    inline void move() {
//puts("Move");
        // Move the window to the top of the screen
//        gtk_window_move(GTK_WINDOW(window), 0, 0);
}


#define DEFAULT_MESSAGE "Enter question... "

#endif


typedef struct {
  char **e;
  size_t s;
  size_t c;
} c_set_Set;


static void c_set_init(c_set_Set *s) {
  s->e = NULL;
  s->s = 0;
  s->c = 0;
}

static bool c_set_contains(const c_set_Set *s, const char *e) {
  for (size_t i = 0; i < s->s; ++i) {
    if (!strcmp(s->e[i], e))
      return true;
  }
  return false;
}

static void c_set_add(c_set_Set *s, const char *e) {
  if (!c_set_contains(s, e)) {
    if (s->s == s->c) {
    if (!s->c) {
    s->c = 3;
    } else {
    	s->c = s->c*3/2;
    	s->c += 3;
    }
      s->e = (char**)realloc(s->e, s->c * sizeof(char*));
    }
    s->e[s->s++] = strdup(e);
  }
}
static void c_set_free(c_set_Set *s) {
  for (size_t i = 0; i < s->s; i++) {
    free(s->e[i]);
  }
  free(s->e);
}



#define BLK "\e[0;30m"
#define RED "\e[0;31m"
#define GRN "\e[0;32m"
#define YEL "\e[0;33m"
#define BLU "\e[0;34m"
#define MAG "\e[0;35m"
#define CYN "\e[0;36m"
#define WHT "\e[0;37m"

#define BBLK "\e[1;30m"
#define BRED "\e[1;31m"
#define BGRN "\e[1;32m"
#define BYEL "\e[1;33m"
#define BBLU "\e[1;34m"
#define BMAG "\e[1;35m"
#define BCYN "\e[1;36m"
#define BWHT "\e[1;37m"

#define UBLK "\e[4;30m"
#define URED "\e[4;31m"
#define UGRN "\e[4;32m"
#define UYEL "\e[4;33m"
#define UBLU "\e[4;34m"
#define UMAG "\e[4;35m"
#define UCYN "\e[4;36m"
#define UWHT "\e[4;37m"

#define BLKB "\e[40m"
#define REDB "\e[41m"
#define GRNB "\e[42m"
#define YELB "\e[43m"
#define BLUB "\e[44m"
#define MAGB "\e[45m"
#define CYNB "\e[46m"
#define WHTB "\e[47m"

#define BLKHB "\e[0;100m"
#define REDHB "\e[0;101m"
#define GRNHB "\e[0;102m"
#define YELHB "\e[0;103m"
#define BLUHB "\e[0;104m"
#define MAGHB "\e[0;105m"
#define CYNHB "\e[0;106m"
#define WHTHB "\e[0;107m"

#define HBLK "\e[0;90m"
#define HRED "\e[0;91m"
#define HGRN "\e[0;92m"
#define HYEL "\e[0;93m"
#define HBLU "\e[0;94m"
#define HMAG "\e[0;95m"
#define HCYN "\e[0;96m"
#define HWHT "\e[0;97m"

#define BHBLK "\e[1;90m"
#define BHRED "\e[1;91m"
#define BHGRN "\e[1;92m"
#define BHYEL "\e[1;93m"
#define BHBLU "\e[1;94m"
#define BHMAG "\e[1;95m"
#define BHCYN "\e[1;96m"
#define BHWHT "\e[1;97m"

#define CRESET "\e[0m"
#define COLOR_RESET "\e[0m"

'

GETLINE = <<~HERE_DOC


                #if WINDOWS
              typedef intptr_t ssize_t;
            #endif

          #if GUI

        static ssize_t getlin(char **lineptr, size_t *n, const char **const stream) {
        int c;
        c = **stream;
        (*stream)++;
        if (c == '\\0') {
          return -1;
        }

        if (!(*lineptr)) {
          *lineptr = (char *)malloc(128);
          if (!(*lineptr)) {
            err();
          }
          *n = 128;
        }

        size_t pos = 0;
        while (c != '\\0') {
          if (pos + 1 >= *n) {
            size_t new_size = *n + (*n >> 2);
            if (new_size < 128) {
              new_size = 128;
            }
            char *new_ptr = (char *)realloc(*lineptr, new_size);
            if (!new_ptr) {
              err();
            }
            *n = new_size;
            *lineptr = new_ptr;
          }

          ((unsigned char *)(*lineptr))[pos++] = c;
          if (c == '\\n') {
            break;
          }

          c = **stream;
          (*stream)++;
        }

        (*lineptr)[pos] = '\\0';
        return pos;
      }
    #else
  static ssize_t getlin(char **lineptr, size_t *n, FILE *stream) {
  int c;
  c = getc(stream);
  if (c == EOF) {
    return -1;
  }

  if (!(*lineptr)) {
    *lineptr = (char *)malloc(128);
    if (!(*lineptr)) {
      err();
    }
    *n = 128;
  }

  size_t pos = 0;
  while (c != EOF) {
    if (pos + 1 >= *n) {
      size_t new_size = *n + (*n >> 2);
      if (new_size < 128) {
        new_size = 128;
      }
      char *new_ptr = (char *)realloc(*lineptr, new_size);
      if (!new_ptr) {
        err();
      }
      *n = new_size;
      *lineptr = new_ptr;
    }

    ((unsigned char *)(*lineptr))[pos++] = c;
    if (c == '\\n') {
      break;
    }

    c = getc(stream);
  }

  (*lineptr)[pos] = '\\0';
  return pos;
}

#endif

HERE_DOC

def func(list, indent, old_str)
  if indent == 1
    puts "
/* BSD*/

#ifdef NOGUI
    #define GUI 0
    #else
    #define GUI 1
    #endif


#ifndef _OS_DETECTION
	#define _OS_DETECTION

	#ifdef __unix__
		#define UNIX   1
	#else
		#define UNIX   0
	#endif

	#ifdef __linux__
		#define LINUX   1
	#else
		#define LINUX   0
	#endif

	#if defined _WIN32 || defined _WIN64 || defined WIN32 || defined WIN64
		#define WINDOWS   1
	#else
		#define WINDOWS   0
	#endif

	#ifdef __FreeBSD__
		#define FREEBSD   1
	#else
		#define FREEBSD   0
	#endif
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>


static void open_browser(void);
static void clear_screen(void);


#if GUI
   static void append_text(const char* str);

#endif


typedef long double ldouble;

static void err() { perror(\"Error\"); exit(1); }

#if GUI

	#include <gtk/gtk.h>
	#if LINUX
	#include <libnotify/notify.h>
	#endif
static GtkWidget *text_view,*entry,*window,*bar_parent,*bar, *label;
  	       static int last_key = 0;


#else
static char*entry=0;
#endif

#if UNIX && !GUI
	#include <unistd.h>
#endif


typedef struct c_str_Str {
  char *str;
  size_t size;
  size_t len;
} c_str_Str;

static size_t malloc_free_count = 0;

#if 0
#define printf printf(\"%d\\n\",__LINE__); printf
#define puts printf(\"%d\\n\",__LINE__); puts
#endif


static c_str_Str* c_str_new(const size_t size) {

if (!size) {
	fputs(\"Trying to allocate str of size 0\",stderr);
	exit(1);
}

c_str_Str* str = malloc(sizeof(c_str_Str));
  str->str = malloc(size);
  malloc_free_count += 2;
  if (!str->str) {
  err();
  }
  str->size = size;
  str->len = 0;
  *(str->str) = '\\0';

  return str;
}

static inline void c_str_free(c_str_Str* const str) {
free(str->str); free(str);
malloc_free_count -= 2;
}

static char* three_string_cat(const char* str1, const char* str2, const char* str3,size_t l1, size_t l2, size_t l3) {
	size_t i, n;
	char* const str = malloc(l1 + l2 + l3 + 1);
	if (!str) err();

	for (n =0, i = 0; i<l1;++i, ++n) {
		str[i] =str1[i];
	}
	const size_t end_2 = l1 + l2;
	for (n = 0, i = l1; i<end_2;++i, ++n) {
		str[i] =str2[n];
	}
	const size_t end_3 = end_2 + l3;
	for (n = 0, i = l1 + l2; i<end_3; ++i, ++n) {
			str[i] =str3[n];
	}


	str[i]='\\0';
	return str;

}

static inline char* three_string_cat_nolen(const char* str1, const char* str2, const char* str3) {
return three_string_cat(str1, str2, str3, strlen(str1), strlen(str2),strlen(str3));
}


static void c_str_append_len(c_str_Str *const str, const char *const str2, const size_t len) {
	size_t n = 0;
	size_t i;
	const size_t new_len = str->len + len;

	if (new_len >= str->size) {
		const size_t ns = new_len * 3 / 2 + 200;
		str->str = realloc(str->str, ns);
		if (!str->str)  { err(); }
		str->size = ns;
	}

	i = str->len;

	while (i < new_len) {
		str->str[i++] = str2[n++];
	}

	str->str[i] = '\\0';

	str->len = new_len;
}


static const char* const ONLY_SPACES =\"Only spaces\";



static ldouble crappy_but_working_calc(const char* arg, const char** error, const size_t strlen_) {
const size_t lim =(strlen_>4096) ?strlen_:4096;



char num[lim];

  ldouble nums[lim];
  char ops[lim];
  char fbuf[lim];
  int oi = 0;
  int ni = 0;
  int nn = 0;
  char *i;
  bool only_space = true;

  int fbufn = 0;
  int ps = 0;
  while (*arg) {
    if (isspace(*arg)) { ++arg;continue;  }
//    else {only_sp

    else only_space = false;// }
    if (*arg == '-')
      fbuf[fbufn++] = '+';

    if (*arg == '(') {
      ps = 1;
      char *ptr = ops, *ptr2 = ops;
      ++arg;
      /*      ++arg; */
      while (true) {
        if (*arg == '(')
          ++ps;
        if (*arg == ')') {
          --ps;
          if (!ps)
            break;
        }
        if (*arg == 0) {
          *error =\"Unclosed )\";
          return 0.0;
        }
        *ptr2 = *arg;
        ++ptr2;
        ++arg;
      }
      *ptr2 = 0;
      ldouble d;
      d = crappy_but_working_calc(ptr, error, strlen(ptr));
      if (*error) {
        return 0.0;
      }
      sprintf(num,\"%Lf\", d);
      ptr2 = num;
      while (*ptr2) {
        fbuf[fbufn++] = *ptr2;
        ++ptr2;
      }
      ++arg;
      continue;
    }
    fbuf[fbufn++] = *arg;

    ++arg;
  }

  if (only_space) {
  *error=ONLY_SPACES;
  return 0.0;
  }


fbuf[fbufn] = 0;

  for (i = fbuf; *i; ++i) {
    switch (*i) {
    case '*':
    case '+':
    case '/':
    	if (i[1] == '*') {
    		*error = \"No exponents\";
    		return 0.0;
    	}
      ops[oi++] = *i;
      ldouble d;
      num[ni++] = 0;
      sscanf(num,\"%Lf\", &d);
      nums[nn++] = d;
      ni = 0;
      break;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case '-':
    case '.':
      num[ni++] = *i;
      break;
    default:
      *error=\"Not valid math expression\";
      return  0.0;
    }
  }
  ops[oi++] = *i;
  ldouble d;
  num[ni++] = 0;
sscanf(num,\"%Lf\", &d);
  nums[nn++] = d;
  ni = 0;

  for (int i = 0; i < oi; ++i) {
    if (ops[i] == '*') {
      nums[i + 1] *= nums[i];
      nums[i] = 0.0;
    } else if (ops[i] == '/') {
      nums[i + 1] = nums[i] / nums[i + 1];
      nums[i] = 0.0;
    }
    ops[i] = '+';
  }
  ldouble new_buf[4096];
  int new_buf_len=0;

  for (int i = 0; i < nn; ++i) {
    if (nums[i] != 0.0) {
      new_buf[new_buf_len++] = nums[i];
    }
  }

ldouble val=0.0;

  for (int i = 0; i < new_buf_len; ++i)
    val += new_buf[i];
  ni = 0;

  return val;

}

#{$colors}
#{GETLINE}



static bool check_append(
	c_set_Set* restrict const set,
	const char* restrict const str,
	bool* const did_something_at_all,
	c_str_Str* const restrict out,
	const char* const  restrict str2,
	const size_t o, const size_t len,
	size_t* restrict const i
) {
	if (!c_set_contains(set,str)) {
		c_set_add(set,str);
		if (*did_something_at_all) c_str_append_len(out,\"\\n\\n\", 2);

		*did_something_at_all = true;
		c_str_append_len(out,str2,len);
		*i += o;
		return true;
	}
	return false;
}


static inline bool check_calc(char* l, c_str_Str *out, const size_t num_chars,  const char ** error) {
const ldouble n = crappy_but_working_calc(l, error, num_chars);
if (!(*error)) {
char buf[23];
sprintf(buf, \"%.15Lg\",  n);
c_str_append_len(out, buf, strlen(buf));
return true;

}
return false;

}



static c_str_Str *process_main(
#if GUI
const char *const t
#else
FILE* t
#endif

, bool dont_open_browser, bool* did_something_at_all) {

c_str_Str* out = c_str_new(4096);

#if GUI
const char* st = t;
#else
FILE *st = t;
#endif


bool good_for_eval=true;
*did_something_at_all = false;
ssize_t num_chars;
char *l;
#if GUI
for (;;)
#endif
{
    l = NULL;
    size_t size = 0;
    num_chars = getlin(&l, &size,
    #if GUI
    &st
    #else
    st
    #endif

    );
    if (!l) {
free(l);
#if GUI
return out;
#else
c_str_free(out);
putchar('\\n');

return NULL;

#endif

}


    c_set_Set set;
    c_set_init(&set);
;
size_t i = 0;
for (;;){
        char *line = l + i;
        switch (*line) {
        case #{(+"?").prepend("'").concat("'")}:
        case #{(+"!").prepend("'").concat("'")}:
        case #{(+".").prepend("'").concat("'")}:
        case #{(+" ").prepend("'").concat("'")}:
        case #{(+'\\t').prepend("'").concat("'")}:
        case #{(+'\\r').prepend("'").concat("'")}:
        ++i;
          good_for_eval = 1;
          continue;

        case '\\0':
          good_for_eval = 1;
          goto after;
        }

        if (!good_for_eval) {
			puts(\"GFC\");
			++i;
			continue;
        }

"
  end
  dent = "\t" * indent
  map = HASH
  list = list.reject do |i|
    i.nil? || i == ""
  end
  if list.empty? || map[old_str]
    print "\t" * indent
    val = nil
    val = map[old_str]

    return unless val

    #    File.write "VAL", val
    #      abort [val.size.to_s, val.length.to_s,val.bytes.size].inspect if val.size > 30000
    puts "switch (*line) {
      case '\\0':
      case ' ':
      case '?':
      case '!':
      case '.':
      case '\\t':
      case '\\r':
      case '\\n':
      	if (check_append(&set, #{old_str.dump}, did_something_at_all,out, #{val.dump}, #{old_str.bytes.size}, #{val.bytes.size}, &i)) { continue; }
      	break;
      default:
      break;
    }
      ".gsub "\n", "\n#{dent}"
  end
  firsts = list.map do |i|
    i[0]
  end
  old_char = nil
  first = true
  new_list = []
  index = -1
  ch = ""
  chars = ("a".."z").to_a + ("A".."Z").to_a
  raise unless chars.size == 52

  firsts.each do |char|
    ch = char
    index += 1
    if char != old_char
      if first
        first = !first
        print "#{dent}switch(*(line++)) {\n"
      else
        func(new_list, indent + 1, old_str + old_char)
        new_list.clear
      end
      full_str = old_str + char
      puts "#{dent}case #{"'#{char.downcase}'"}:; /* #{old_str} ==> #{char}, full_str #{old_str + char} */"
      if chars.include? char
        puts "#{dent}case #{"'#{char.upcase}'"}:; /* #{old_str} ==> #{char}, full_str #{old_str + char} */"
      end
      #      print firsts.size
      #      if firsts.size != 1
      #     end
    end
    new_list.push list[index][1..-1]
    old_char = char
  end
  func(new_list, indent + 1, old_str + ch) if firsts != []

  new_list.clear
  unless firsts.empty?
    print "#{dent}default: /*puts(\"first for #{firsts[0]}\");*/      ++i; continue; }\n"
  end

  #  return
  return unless indent == 1

  print <<EOF
good_for_eval = true;
++i;
}

after : c_set_free(&set);
#if GUI
//  puts(\"After\");
#endif

//  printf(\"Did? %d `%s`\\n\", *did_something_at_all, l);

if (!(*did_something_at_all) && !dont_open_browser) {
  char *const orig_l = l;
  const char *error = NULL;
  if (check_calc(l, out, num_chars, &error)) {
    *did_something_at_all = 1;
    goto end_;
  }
  if (error == ONLY_SPACES) {
    goto end_;
  }
  while (isspace(*l)) {
    ++l;
  }
  size_t len = strlen(l) - 1;
  while (len > 0 && isspace(l[len])) {
    l[len] = 0;
    len--;
  }
  ++len;

  if (len == 5 && !memcmp(l, "clear", 5)) {
    clear_screen();
#if GUI
    append_text("<b>Screen cleared</b>\\n");
#endif

  end_:
    free(orig_l);
    return out;
  }

#if !GUI
  entry = l;
  puts(l);
#endif

  open_browser();
  dont_open_browser = true;
}

free(l);
good_for_eval = true;
}

return out;
}
EOF
end

abort HASH if HASH.keys.uniq != HASH.keys
lst = HASH.keys.sort;  # abort lst.to_s.gsub(",", "\n")
#File.write "temp", lst.inspect.gsub(",", ",\n")
func(lst, 1, +"")
puts <<~HERE_DOC


       #if LINUX && GUI
static void show_notification(const char *title, const char *message) {
NotifyNotification *notification = notify_notification_new(title, message, "dialog-information");
notify_notification_show(notification, NULL);
g_object_unref(notification);
}
#endif

#if GUI
static const char *copy_to_clipboard(const char *text) {

	GtkClipboard *clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);

	gtk_clipboard_set_text(clipboard, text, -1);

	gtk_clipboard_store(clipboard);

	char *const str = three_string_cat(
	"Copied '", text, "' to clipboard for ChatGPT.", 8, strlen(text), 27);
	#if LINUX
	show_notification("Copied", str);

	  ;

#else
  append_text(str);
#endif
  free(str);

  return text;
}


#endif

#if GUI

gboolean small_window(GtkWidget *window);

#endif

static void open_browser() {
#if GUI
gtk_window_present_with_time(GTK_WINDOW(window), GDK_CURRENT_TIME);
while (gtk_events_pending())
    gtk_main_iteration_do(false);
  
printf(\"SMALL\\n\");


    //	small_window(window);
  char *const site =
      strdup(copy_to_clipboard(gtk_entry_get_text(GTK_ENTRY(entry))));
#else
  char *const site = entry;
#endif

  size_t len = strlen(site);
  for (size_t i = 0; i < len; ++i) {
    if (site[i] == ' ') {
      site[i] = '+'; }
                    		else if (site[i] == '\\'') { site[i]='+'; }
                    		else if (site[i] == '"') {
      site[i] = '+'; }
                    		else if (site[i] == '&') {
      site[i] = '+'; }
                    		else if (site[i] == '(') {
      site[i] = '+'; }
                    		else if (site[i] == ')') {
      site[i] = '+'; }
                    		else if (site[i] == '\\n') {
      site[i] = '+'; }
  }
  for (size_t l = len - 1;;) {
    if (site[l] != '+')
      break;
    site[l] = '\\0';
    if (l == 0)
      break;
    --l;
  }

  void *chr;

  do {
#if !WINDOWS
#define DEVNULL " >/dev/null 2>/dev/null &"
#endif

#if LINUX

    if (!system(chr =
                    three_string_cat_nolen("google-chrome chat.openai.com/chat "
                                           "https://www.google.com/search?q=",
                                           site, DEVNULL)))
      break;
    free(chr);
#elif WINDOWS

    if (!system(chr = three_string_cat_nolen(
                    "start chrome.exe chat.openai.com/chat "
                    "https://www.google.com/search?q=",
                    site, "")))
      break;
    free(chr);
#endif

#if LINUX

    if (!system(
            chr = three_string_cat_nolen(
                "firefox chat.openai.com/chat https://www.google.com/search?q=",
                site, DEVNULL)))
      break;
    free(chr);

    if (!system(
            chr = three_string_cat_nolen(
                "xdg-open http://chat.openai.com/chat >/dev/null 2>/dev/null; "
                "xdg-open http://www.https://www.google.com/search?q=",
                site, DEVNULL)))
      break;
    free(chr);
#elif WINDOWS

    if (!system(chr = three_string_cat_nolen(
                    "start microsoft-edge:https://chat.openai.com/chat && "
                    "start microsoft-edge:https://www.google.com/search?q=",
                    site, "")))
      break;
    free(chr);

    if (!system(chr = three_string_cat_nolen(
                    "start iexplore.exe chat.openai.com/chat "
                    "https://www.google.com/search?q=",
                    site, "")))
      break;
    free(chr);

    if (!system(chr = three_string_cat_nolen(
                    "start firefox.exe    chat.openai.com/chat "
                    "https://www.google.com/search?q=",
                    site, "")))
      break;
    free(chr);
#else

    if (!system(chr = three_string_cat_nolen("open chrome chat.openai.com/chat "
                                             "https://www.google.com/search?q=",
                                             site, DEVNULL)))
      break;
    free(chr);

    if (!system(
            chr = three_string_cat_nolen("open firefox    chat.openai.com/chat "
                                         "https://www.google.com/search?q=",
                                         site, DEVNULL)))
      break;
#endif
  } while (false);
  free(chr);
#if GUI
  free(site);
#endif

  //      }
  //		{}
}

#if GUI
static void on_button_clicked(void *, GtkWindow *);
static void focus_loc_bar(void);

static bool callback_hidden_bar(void *_, GtkWidget *b) {
  switch (last_key) {
  case GDK_KEY_f: // puts("f"); break;
    break;
  case GDK_KEY_o:
#if LINUX
    {

      char* const str = three_string_cat_nolen(
          "google-chrome ", gtk_entry_get_text(GTK_ENTRY(bar)),         DEVNULL);
      if (system(str)) {
      }
      free(str);
    }

#endif
    break;

    // break;
  }

  return false;
}


static void on_button_clicked2(void *_, GtkWindow *window) {
  open_browser();
  on_button_clicked(0, window);
}

static void on_button_clicked3(void *_, GtkWindow *window) {
  append_text(HR #{HELP_MSG} NEWLINE_HR);
  gtk_widget_grab_focus(entry);
}


static void on_button_clicked(void *_, GtkWindow *const window) {
  const char *const text = gtk_entry_get_text(GTK_ENTRY(entry));
  if (strcmp(text, DEFAULT_MESSAGE) == 0)
    return;

  const bool dont_open_browser = !_;
  bool did_something_at_all;
  c_str_Str *const txt =
      process_main(text, dont_open_browser, &did_something_at_all);

  char *const cat = did_something_at_all
                        ? three_string_cat(HR, txt->str, NEWLINE_HR, strlen(HR),
                                           strlen(txt->str), strlen(NEWLINE_HR))
                        : txt->str;
  append_text(cat);

  if (did_something_at_all) {
    free(cat);
  }

  c_str_free(txt);
}

static void make_bar(const char *text, const int lk) {
  do {
    if (lk == last_key && gtk_widget_get_visible(bar_parent)) {
      gtk_widget_hide(bar_parent);
      break;
    } // break; }#{" "}
    gtk_label_set_text(GTK_LABEL(label), text);
    gtk_widget_grab_focus(bar);
    gtk_widget_show(bar_parent);
  } while (false);
  
  last_key = lk;

}


gboolean resize_window(GtkWidget *window);



static bool on_key_press(GtkWidget *widget, GdkEventKey *event,
                             gpointer data) {
if (altering) {
	puts (\"Alter\");
	return false;
}
printf(\"Maxed %b\\n\", maxed);

  if ((event->state & GDK_CONTROL_MASK)) {
    switch (event->keyval) {
    case GDK_KEY_f:
      make_bar("   Search...", event->keyval);
      break;
    case GDK_KEY_o:
      make_bar("   Open URL in Chrome...", event->keyval);
      break;
    case GDK_KEY_w:
    case GDK_KEY_q:
      gtk_main_quit();
      break;
    case GDK_KEY_l:
      focus_loc_bar();
      break;
    }
  } else if (event->keyval == GDK_KEY_Escape) {
    if (gtk_widget_get_visible(bar_parent)) {
      gtk_widget_hide(bar_parent);
    } else {
      //gtk_main_quit();
      	if (maxed) {
            g_timeout_add(3, (GSourceFunc)small_window,window);
        }
    }
  }

  else if (event->keyval == GDK_KEY_F11) {
    static bool not_fs = true;
    if (not_fs)
      gtk_window_fullscreen(GTK_WINDOW(widget));
    else
      gtk_window_unfullscreen(GTK_WINDOW(widget));
    not_fs = !not_fs;
  } else if (!altering) {
          g_timeout_add(3, (GSourceFunc)resize_window, window);
  }
  

  return false;
}
static void focus_loc_bar(void) { gtk_widget_grab_focus(entry); }

static const char *const MENU_ITEMS[] = {
    "To help people",
    "Donate at gregorycohen877@gmail.com via PayPal or e-transfer",
    #{ABOUT.dump}, #{CYCLE_OF_ETHICAL_BEHAVIOR.dump}
};


#if 0
static void append_non_markup(const char* input_text) {
  GtkTextBuffer *const text_buffer =
      gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_view));
  GtkTextIter text_iter_end;
  gtk_text_buffer_get_end_iter(text_buffer, &text_iter_end);
  GtkTextMark *const text_mark_end =
      gtk_text_buffer_create_mark(text_buffer, NULL, &text_iter_end, false);

  gtk_text_buffer_get_end_iter(text_buffer, &text_iter_end);
  gtk_text_buffer_insert(text_buffer, &text_iter_end, input_text,
                                strlen(input_text));
  gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(text_view), text_mark_end, 0.,
                               FALSE, 0., 0.);
  while (gtk_events_pending())
    gtk_main_iteration_do(false);
  gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(text_view), text_mark_end, 0.,
                               FALSE, 0., 0.);
  while (gtk_events_pending())
    gtk_main_iteration_do(false);
}
#endif


static void append_text(const char *input_text) {
  GtkTextBuffer *const text_buffer =
      gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_view));
  GtkTextIter text_iter_end;
  gtk_text_buffer_get_end_iter(text_buffer, &text_iter_end);
  GtkTextMark *const text_mark_end =
      gtk_text_buffer_create_mark(text_buffer, NULL, &text_iter_end, false);

  gtk_text_buffer_get_end_iter(text_buffer, &text_iter_end);
  gtk_text_buffer_insert_markup(text_buffer, &text_iter_end, input_text,
                                strlen(input_text));
  gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(text_view), text_mark_end, 0.,
                               FALSE, 0., 0.);
  while (gtk_events_pending())
    gtk_main_iteration_do(false);
  gtk_text_view_scroll_to_mark(GTK_TEXT_VIEW(text_view), text_mark_end, 0.,
                               FALSE, 0., 0.);
  while (gtk_events_pending())
    gtk_main_iteration_do(false);
}

static inline void append_with_style(const char* const s) {
  char *const chr = three_string_cat_nolen(HR, s, NEWLINE_HR);
  append_text(chr);
  free(chr);
}


static void on_menu_item_activate(void *_, long data) {
  append_with_style(MENU_ITEMS[data]);
}


static void clear_screen(void) {
  GtkTextBuffer *const text_buffer =
      gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_view));

  gtk_text_buffer_set_text(text_buffer, "",
                                0);
}


#endif

#if !GUI
static void clear_screen(void) {
if (system("clear || cls")) {}

}
#endif
const int MIN = 200;

#if GUI

gboolean


small_window



(GtkWidget *window) {
    static GdkRectangle rect;
    
    maxed=false;
    puts(\"AA\");
    
	if (0) {
    while (gtk_events_pending())
        gtk_main_iteration_do(false);
     }

    if (current_step_shrink == -1) {
        // Initialize on the first run
        gtk_window_get_size(GTK_WINDOW(window), &rect.width, &rect.height);
        current_step_shrink = rect.height;
//        first_size = rect.height;
    }

    if (current_step_shrink >= 0) {
    	altering=true;
        int new_height = current_step_shrink ;
//        printf(\"%d\\n\", current_step_shrink);
        gtk_window_resize(GTK_WINDOW(window), rect.width, new_height);
        current_step_shrink--;
        if (current_step_shrink == -1) {
                    puts(\"Done\");
            altering=FALSE;shrunk=true;maxed=false;
    return G_SOURCE_REMOVE;
           }

           move();

        // Redraw the label
        gtk_widget_queue_draw(window);

        return G_SOURCE_CONTINUE;
    }


            altering=FALSE;shrunk=true;maxed=false;
    return G_SOURCE_REMOVE;
}

// Function to update the window size
gboolean resize_window(GtkWidget *window) {
    static int target_height;
    static GdkRectangle rect;
    
    if (maxed) return G_SOURCE_REMOVE;

	if (false) {
    while (gtk_events_pending())
        gtk_main_iteration_do(false);
      }
    

    if (current_step == -1) {
        // Initialize on the first run
        gtk_window_get_size(GTK_WINDOW(window), &rect.width, &rect.height);
        first_size = rect.height;
        target_height = 400;
        current_step = 0;
    }

    if (current_step <= 1000) {
    altering = TRUE;
        int new_height = (current_step * target_height) / 1000;
        if (new_height == 0) {
        	new_height = 1;
        }
        gtk_window_resize(GTK_WINDOW(window), rect.width, new_height+MIN);
        current_step++;
move();
        // Redraw the label
        gtk_widget_queue_draw(window);

        return G_SOURCE_CONTINUE;
    }

	puts(\"Maxed\");

	altering=FALSE;
	maxed = true;shrunk=false;

	current_step=-1;
    return G_SOURCE_REMOVE;
}

#endif

#{"  "}
int main(int argc, char** argv) {
(void)argc;
(void)argv;





#if GUI
#if UNIX
  if (fork())
    return 0;
#endif
#if WINDOWS
  _putenv("GTK_CSD=0");
#endif
  gtk_init(0, 0);
  g_object_set(gtk_settings_get_default(), "gtk-enable-animations", FALSE,
               NULL);
#{"          "}
#if LINUX
                                     notify_init("Ultimate Chat App"); // Initialize libnotify
#endif
  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title(GTK_WINDOW(window), "Ultimate Chat App");
  gtk_container_set_border_width(GTK_CONTAINER(window),0);
  g_signal_connect(window, "destroy", G_CALLBACK(gtk_main_quit), NULL);
  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
  gtk_container_add(GTK_CONTAINER(window), box);
  entry = gtk_entry_new();
  gtk_entry_set_text(GTK_ENTRY(entry), DEFAULT_MESSAGE);
  GtkWidget *_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
  GtkWidget *scrolled_window = gtk_scrolled_window_new(NULL, NULL);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window),
                                 GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  text_view = gtk_text_view_new();
#{"    "}
  gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(text_view), FALSE);

  gtk_text_view_set_editable(GTK_TEXT_VIEW(text_view), FALSE);
  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(text_view), GTK_WRAP_WORD);
  gtk_container_add(GTK_CONTAINER(scrolled_window), text_view);
  gtk_box_pack_end(GTK_BOX(box), scrolled_window, TRUE, TRUE, 0);

  bar = gtk_entry_new();
  g_signal_connect(bar, "activate", G_CALLBACK(callback_hidden_bar), entry);
  {
    bar_parent = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_box_pack_start(GTK_BOX(bar_parent), label = gtk_label_new(""), 0, 0, 0);
    gtk_box_pack_start(GTK_BOX(bar_parent), bar, 1, 1, 0);
    gtk_box_pack_start(GTK_BOX(box), bar_parent, 0, 0, 0);
  }
  GtkWidget *bbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 10);

  GtkWidget *button1 = gtk_button_new_with_label("Enter...");
  GtkWidget *button2 = gtk_button_new_with_label("Tri-Answer");
  GtkWidget *button3 = gtk_button_new_with_label("Help...");
  // puts("@");
  g_signal_connect(G_OBJECT(button1), "clicked", G_CALLBACK(on_button_clicked),
                   0);
  g_signal_connect(G_OBJECT(button2), "clicked", G_CALLBACK(on_button_clicked2),
                   0);
  g_signal_connect(G_OBJECT(button3), "clicked", G_CALLBACK(on_button_clicked3),
                   0);
#{"      "}
  gtk_box_pack_start(GTK_BOX(bbox), button1, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(bbox), button2, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(bbox), button3, TRUE, TRUE, 0);

  gtk_widget_set_halign(bbox, GTK_ALIGN_CENTER);
  gtk_widget_set_valign(bbox, GTK_ALIGN_CENTER);

  gtk_box_pack_end(GTK_BOX(box), bbox, FALSE, FALSE, 0);
  g_signal_connect(entry, "activate", G_CALLBACK(on_button_clicked), entry);
  GtkEntry *entry_widget = GTK_ENTRY(entry);
  gtk_entry_set_activates_default(entry_widget, TRUE);

  GtkWidget *menu_item_1 = gtk_menu_item_new_with_label("Philosophy");
  GtkWidget *menu_item_2 = gtk_menu_item_new_with_label("Donate");
  GtkWidget *menu_item_3 = gtk_menu_item_new_with_label("About");
  GtkWidget *menu_item_4 =
      gtk_menu_item_new_with_label(#{"How to operate".dump});
  GtkWidget *menu = gtk_menu_new();
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item_1);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item_2);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item_3);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item_4);
  GtkWidget *menu_button = gtk_menu_button_new();
  gtk_menu_button_set_popup(GTK_MENU_BUTTON(menu_button), menu);

#if !WINDOWS

  GtkWidget *menu_icon = gtk_image_new_from_icon_name(
      "open-menu-symbolic", GTK_ICON_SIZE_SMALL_TOOLBAR);
  gtk_button_set_image(GTK_BUTTON(menu_button), menu_icon);
  gtk_button_set_relief(GTK_BUTTON(menu_button), GTK_RELIEF_NONE);
#endif

  gtk_box_pack_start(GTK_BOX(box), _box, 0, 0, 0);
  gtk_box_pack_end(GTK_BOX(_box), menu_button, 0, 0, 0);
  gtk_box_pack_end(GTK_BOX(_box), entry, 1, 1, 0);

  GtkWidget *menu_items[] = {menu_item_1, menu_item_2, menu_item_3,
                             menu_item_4};
  for (size_t i = 0; i < 4; ++i) {
    g_signal_connect(G_OBJECT(menu_items[i]), "activate",
                     G_CALLBACK(on_menu_item_activate), (gpointer)i);
  }

  g_signal_connect(G_OBJECT(window), "key-press-event",
                   G_CALLBACK(on_key_press), NULL);
    // Remove window decorations and make it undecorated
    gtk_window_set_decorated(GTK_WINDOW(window), FALSE);

    // Make the window stay on top of other windows
//    gtk_window_set_keep_above(GTK_WINDOW(window), TRUE);

  {
    GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(text_view));
    GtkTextIter start;
    gtk_text_buffer_get_start_iter(buffer, &start);
    gtk_text_buffer_insert_markup(
        buffer, &start,
        "<span size=\\"x-large\\" color=\\"#00DD00\\">#{INTRO}#{"</span>" * 1}\\n\\nThis is intended to "
                                              "be the Ultimate Chat App "
                                              "(Non-AI), a truth generator of "
                                              "sorts, an app that inspires and "
                                              "motivates. It operates in 3 "
                                              "ways, it's local, it doesn't "
                                              "need the Internet. If it "
                                              "doesn't have a superior answer, "
                                              "then it uses other means "
                                              "(Google and ChatGPT).\\n\\nTry "
                                              "asking it questions about "
                                              "operation, physics, or health, "
                                              "as some "
                                              "examples.\\n\\n\\n<b>#{"It gives you what you want".upcase}</b>#{'\\n' * (4 - 1)}",
        -1);
    ;
  }

  const int num = 10;
  gtk_text_view_set_left_margin(GTK_TEXT_VIEW(text_view), num);
  gtk_text_view_set_right_margin(GTK_TEXT_VIEW(text_view), num);
  gtk_text_view_set_top_margin(GTK_TEXT_VIEW(text_view), num);
  gtk_text_view_set_bottom_margin(GTK_TEXT_VIEW(text_view), num);

  GtkCssProvider *provider = gtk_css_provider_new();
  GdkDisplay *display = gdk_display_get_default();
  GdkScreen *screen = gdk_display_get_default_screen(display);
  gtk_style_context_add_provider_for_screen(
      screen, GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_USER);
  gtk_css_provider_load_from_data(provider, #{CSS}, -1, NULL);

  /*GdkRectangle workarea = {0};
  gdk_monitor_get_workarea(
      gdk_display_get_primary_monitor(gdk_display_get_default()),
      &workarea);*/

//int screen_width = workarea.width;
//int screen_height=workarea.height;
      int screen_width = gdk_screen_get_width(screen);
      
      int screen_height = gdk_screen_get_height(screen);
printf(\"%d, %d\\n\", screen_height, screen_height);
    gtk_window_set_default_size(GTK_WINDOW(window), screen_width, screen_height * 0.5);
//      move();



  gtk_widget_grab_focus(entry);
  // gtk_widget_grab_focus(entry);
  gtk_widget_show_all(menu);
  gtk_widget_show_all(window);
  gtk_widget_hide(bar_parent);
  gtk_main();

  if (malloc_free_count == 0) {
  } else {
#if WINDOWS
    printf("mfc %llu\\n", malloc_free_count);
#else
    printf("mfc %lu\\n", malloc_free_count);
#endif
  }
#else
  const bool tty = isatty(1);
  
  for (;;) {
    if (tty) {
      printf(BGRN);
      printf("Ultimate chat app>> ");
      printf(COLOR_RESET);
    }
    bool did_something_at_all;
    c_str_Str *s = process_main(stdin, 0, &did_something_at_all);
    if (s) {
      if (*s->str) {
        puts(s->str);
      }
      c_str_free(s);
    } else {
      break;
    }
  }

#endif


#if LINUX && GUI

                                     notify_uninit(); // Uninitialize libnotify
#endif


  return 0;
}

     HERE_DOC

File.write "/tmp/out.c", OUT

return unless Dir.home == "/home/a" && ENV["RETURN"].nil?

require "os"
pkg = `pkg-config --libs --cflags #{(OS.linux? && "libnotify") || ""} gtk+-3.0`.strip

args = " -Wfatal-errors -Werror -Wno-deprecated-declarations -Wno-unused-parameter  -Wno-format -s -Wall -Wextra -fwhole-program -Wno-implicit-fallthrough   -Wno-unused-value -O2"

cmd = "
set -e
(gcc #{args} /tmp/out.c #{pkg}&&echo LIN_GUI) || exit 1 &
(/usr/lib/mxe/usr/bin/x86_64-w64-mingw32.static-gcc -mwindows #{args} /tmp/out.c -o q.exe `/usr/lib/mxe/usr/bin/x86_64-w64-mingw32.static-pkg-config --cflags --libs gtk+-3.0`&&echo WIN_GUI) || exit 1 &
(gcc   -DNOGUI -o UCA_cli #{args} /tmp/out.c && echo  LIN_CLI) || exit 1 &

wait
"


STDOUT.puts cmd

system cmd, exception: true
# return
system "cd /home/a; cp physics CYCLE_OF_HEALTH democracy --verbose"

["", "bin"].each do |i|
  require "fileutils"
  include FileUtils
  cp "/home/a/UCA_cli", "/home/a/democracy/#{i}/UCA_cli" rescue nil

  cp "/home/a/a.out", "/home/a/democracy/#{i}/ULTIMATE_CHAT_APPLICATION_(LINUX)" rescue nil
  cp "/home/a/q.exe", "/home/a/democracy/#{i}/ULTIMATE_CHAT_APPLICATION.exe" rescue nil
end
puts "Copy."

cp "/home/a/UCA_cli", Dir.glob("/home/a/foon/*/")[0] rescue nil
cp "/home/a/q.exe", Dir.glob("/home/a/foon/*/ULT*.exe")[0] rescue nil
cp "/home/a/a.out", Dir.glob("/home/a/foon/*/ULT*LINUX*")[0] rescue nil
system "cp /home/a/PP.rb /home/a/output_data /home/a/democracy  --verbose
cp /home/a/PP.rb /home/a/output_data /home/a/foon/*  --verbose
" rescue nil
cp "/home/a/q.exe", Dir.glob("/home/a/foon/*/bin/ULT*.exe")[0] rescue nil
cp "/home/a/a.out", Dir.glob("/home/a/foon/*/bin/ULT*LINUX*")[0] rescue nil

cp "/home/a/UCA_cli", Dir.glob("/home/a/foon/*/bin/")[0] rescue nil
puts "Done."
